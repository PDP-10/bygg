TITLE AUTCON DETERMINE HDWRE CNFIG WHEN A SYSTEM COMES UP  V044
	SUBTTL T.WACHS/TW/JMF		25 OCT 83

	SEARCH F,S,RH2PRM
	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1981,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>



; DATE		LOAD	EDIT #
; ----		----	------
;
;07-JUL-81	70165	002
;14-JUL-81	70166	003
;21-JUL-81	70167	004
;9827
;28-JUL-81	70170	005
;9839-
;04-AUG-81	70171	006
;11-AUG-81	70172	007
;9858-
;18-AUG-81	70173	010
;9872-
;22-SEP-81	70175	011
;9893-
;29-SEP-81	70176	012
;9905-
;13-OCT-81	70111	013
;9914-
;9925-
;27-OCT-81	70113	014
;9946-
;17-NOV-81	70116	015
;9969-
;08-DEC-81	70121	016
;10004
;15-DEC-81	70122	017
;10009-
;10016-
;22-DEC-81	70123	020
;9-FEB-82	70132	021
;10089
;23-FEB-82	70134	022
;10111
;02-MAR-82	70135	023
;10123
;09-MAR-82	70136	024
;10134
;16-MAR-82	70137	025
;10144
;23-MAR-82	70140	026
;10163
;11-MAY-82	70146	027
;3-AUG-82	70162	030
;23-NOV-82	70113	031
;10509
;11-JAN-83	70120	032
;3-MAY-83	70140	033
;31-MAY-83	70143	034
;19-JULY-83	70152	035
;10857
;30-AUG-83	70160	036
;06-SEP-83	70161	037
;13-SEPT-83	70162	040
;10947
;20-SEP-83	70163	041
;27-SEP-83	70164	042
;10970
;18-OCT-83	70167	043
;25-OCT-83	70170	044
;11015
;
	XP VAUTCN,044
	ENTRY	AUTCON

;MASBUS DEVICE TYPES

TY.RU==020			;RP04
TY.RP5==021			;RP05
TY.RP6==022			;RP06
TY.RM3==24			;RM03
TY.RP7==42			;RP07
TY.RS4==002			;RS04 DRIVE TYPE
TY.T2L==010			;LOWEST TM02 TYPE
TY.T2H==017			;HIGHEST TM02 TYPE
TY.T3L==050			;LOWEST TM03 TYPE
TY.T3H==057			;HIGHEST TM03 TYPE
TY.T77==014			;TU77
TY.DXA==060			;DX20A TYPE (FOR TUXX TAPES)
TY.DXB==061			;DX20B TYPE (FOR RP20 DISKS)
TY.T78==101			;TM78

;HERE FROM FUNCTION 6 OF THE RECON UUO TO FORCE RECONFIGURATION OF DEVICES
; ON THIS CPU

CPUATC::PUSHJ	P,SAVE4##	;SAVE VOLATILE ACS
	MOVE	T1,[POINT 12,.CPNUM##,23]
	LDB	T1,T1		;START RN NUMBER
	MOVEM	T1,NUMRNA##	;REQUIRED SINCE VALUE IS WHATEVER WAS SETUP BY LAST CPU
	MOVSI	R,CP.22B##	;INDICATE AN RH10
	MOVEI	P2,270/4	;FIRST RH10 DEVICE CODE
	PUSHJ	P,UCNFIG	;SEE IF THERE IS ANYTHING THERE
	MOVEI	P2,274/4	;2ND RH10 DEVICE CODE
	PUSHJ	P,UCNFIG	;DO IT
	MOVEI	P2,360/4	;3RD RH10
	PUSHJ	P,UCNFIG	;DO IT
	MOVEI	P2,540/4	;FIRST RH20 DEVICE CODE
	MOVSI	R,CP.RH2##	;INDICATE AN RH20
CPUAT1:	PUSHJ	P,UCNFIG	;SEE WHAT WE HAVE
	MOVEI	P2,1(P2)	;STEP TO NEXT RH
	CAIG	P2,574/4	;AT THE TOP?
	JRST	CPUAT1		;NO, DO THIS ONE
	MOVEI	P2,220/4	;FIRST DX10 DEVICE CODE
	MOVSI	R,CP.DX1##	;INDICATE A DX10
	PUSHJ	P,UCNFIG	;SEE IF WE HAVE ANY
	MOVEI	P2,224/4	;SECOND DX10
	PUSHJ	P,UCNFIG	;SEE IF IT EXISTS
	MOVEI	P2,034/4	;3RD DX10
	PUSHJ	P,UCNFIG	;SEE IF WE HAVE ONE
IFN FTNET,<
	MOVSI	T1,<.TYMTA/.TYEST> ;GET DEVICE TYPE
	HRR	T1,MTANUM	;GET NUMBER OF MAGTAPES CONFIGURED
	PUSHJ	P,NETDEV##	;STUFF COUNT IN OUR NDB
>
IFN FTMP,<
	PJRST	T1CINI		;MAKE SURE DX10 KDB STAY UNCACHED AND RETURN
>
IFE FTMP,<
	POPJ	P,
>
;SUBROUTINE TO CONFIGURE CDB, KDB, AND UDBS FOR DEVICE WITH DEVICE CODE IN P2
; RETURN IMMEDIATELY IF NO SUCH DEVICE
; BUILD CDB, KDB, AND UDBS IF NONE EXIST
; BUILD UDBS FOR NEW DRIVES IF CDB AND KDB ALREADY EXIST
;CHANNEL
UCNFIG:	PUSHJ	P,CKCHN		;CHANNEL EXIST?
	  POPJ	P,		;NO, RETURN IMMEDIATELY
;NOW, SEE IF A KDB AND THEREFORE A CDB ALREADY EXIST FOR THIS DEVICE CODE
;DISKS
	HLRZ	J,SYSKON##	;START OF KONTROLLER CHAIN
UCNFI1:	LDB	T1,[POINT 7,-4(J),9] ;GET DEVICE CODE FROM CONSO INSTRUCTION
IFN FTMP,<
	LDB	T2,KOYCPU##	;CPU THIS KONTROLLER IS ON
	CAMN	T2,.CPCPN##	;SAME AS THIS CPU?
>
	CAIE	T1,(P2)		;YES, SAME DEVICE CODE?
	JRST	UCNFI2		;NO
	HRRZ	P1,KONCHN##(J)	;YES, ADDRESS OF CHANNEL DATA BLOCK
	PUSHJ	P,HAVUNI	;ANY UNITS ON THE KDB?
	  JRST	UNILUP		;NO, CONFIGURE AS IF CREATING THE KDB
	TLO	P1,400000	;INDICATE FROM CPUATC
	JRST	UNILUP		;GO CONFIGURE UNITS
UCNFI2:	HLRZ	J,KONNXT##(J)	;NEXT KDB
	JUMPN	J,UCNFI1	;JUMP IF NOT LAST
;TAPES
	SKIPN	J,CNFMTK##	;ANY TAPES?
	JRST	CNFIG		;NO, GO CONFIGURE CDB, KDB, AND UDBS
UCNFI3:	LDB	T1,[POINT 7,TKBCIS##(J),9] ;GET DEVICE CODE FROM CONI
IFN FTMP,<
	LDB	T2,[POINT 3,TKBSTS##(J),2] ;CPU THAT THIS KONTROLLER IS ON
	CAMN	T2,.CPCPN##	;SAME CPU AS WE ARE ON?
>
	CAIE	T1,(P2)		;YES, ALREADY HAVE A KDB?
	JRST	UCNFI4		;NOT THIS ONE
	HRRZ	P1,TKBCDB##(J)	;YES, GET THE ADDRESS OF THE CDB
	TLO	P1,400000	;INDICATE FROM CPUATC
	MOVE	W,J		;TAPES WANT IT IN W TOO
	JRST	UNILUP		;AND GO ADD UNITS IF ANY NEW ONES
UCNFI4:	HRRZ	J,TKBKDB##(J)	;NEXT KDB
	JUMPN	J,UCNFI3	;AND LOOK AT NEXT IF NOT LAST
	JRST	CNFIG		;NO CDB OR KDB, GO CONFIGURE ALL

;SUBROUTINE TO SEE IF A DSK KDB HAS ANY UNITS, CPOPJ IF NO, CPOPJ1 IF IT DOES

HAVUNI:	MOVSI	T4,MKNMXU##	;-MAX UNITS/KONTROLLER
	HRRI	T4,KONTAB##(J)	;LOOK THROUGH KONTAB
	SKIPN	(T4)		;UNIT ALREADY KNOWN?
	AOBJN	T4,.-1		;NO, ANY UNIT WILL DO
	JUMPGE	T4,CPOPJ##	;JUMP IF NONE FOUND
	JRST	CPOPJ1##	;SKIP IF AT LEAST ONE WAS FOUND
AUTCON::SKIPN	.CPACD##	;BEEN HERE BEFORE?
	POPJ	P,
	PUSHJ	P,SAVE4##
	PUSH	P,.CPTOA##	;SAVE ONCE TYPEOUT ADDRESS
	MOVEI	P4,CTYWAT##	;SETUP NEW TYPEOUT ADDRESS
	MOVEM	P4,.CPTOA##	;FOR TYPEOUT DURING AUTCON
	SETZ	P4,		;INITIALIZE
	PUSH	P,R
	MOVE	T1,.CPCPN##	;ARE WE ON THE BOOT CPU?
	CAMN	T1,BOOTCP##
	JRST	AUTCN2		;YES, START IMMEDIATELY
	HRLZ	T1,.CPCPN##	;NO, SET TIMER SO WE'LL DO THIS IN STRICT
	ADD	T1,[3,,0]	; ORDER OF CPUS
AUTCN1:	SKIPL	T2,LASCNF##	;SOMEONE CONFIGURUNG NOW?
	CAME	T2,.CPCPN##	;NO, IS IT OUR TURN?
	JRST	AUTCN3		;NO, WAIT A WHILE
AUTCN2:	SETOM	LASCNF##	;TELL THE WORLD SOMEONE IS DOING THIS
	JRST	AUTCN4		;AND FIGURE OUT WHAT WE HAVE
AUTCN3:	SOJGE	T1,AUTCN1	;WAIT FOR A WHILE
				;TIMED OUT. START NOW ANYWAY
AUTCN4:	MOVE	T1,[POINT 12,.CPNUM##]
	ILDB	T2,T1		;GET START RP LETTER
	MOVEM	T2,NUMRPA##
	ILDB	T2,T1		;GET START RN NUMBER
	MOVEM	T2,NUMRNA##
	ILDB	T2,T1		;GET START TAPE NUMBER
	MOVEM	T2,NUMTAP##
	SETZM	NUMRNC##	;CLEAR PER-CPU COUNTERS
	SETZM	NUMRPC##
	MOVSI	R,CP.22B##	;INDICATE AN RH10
	MOVEI	P2,270/4	;FIRST RH10 DEVICE CODE
	PUSHJ	P,CNFIG		;SEE IF THERE IS ANYTHING THERE
	MOVEI	P2,274/4	;2ND RH10 DEVICE CODE
	PUSHJ	P,CNFIG		;DO IT
	MOVEI	P2,360/4	;3RD RH10
	PUSHJ	P,CNFIG		;DO IT
	MOVEI	P2,540/4	;FIRST RH20 DEVICE CODE
	MOVSI	R,CP.RH2##	;INDICATE AN RH20
AUTCN5:	PUSHJ	P,CNFIG		;SEE WHAT WE HAVE
	MOVEI	P2,1(P2)	;STEP TO NEXT RH
	CAIG	P2,574/4	;AT THE TOP?
	JRST	AUTCN5		;NO, DO THIS ONE
	MOVE	T1,CORLOC	;SAVE 1ST DX10 LOC
	MOVEM	T1,TAPDST##	; FOR UNCACHING DATA BASE
	MOVEI	P2,220/4	;FIRST DX10 DEVICE CODE
	MOVSI	R,CP.DX1##	;INDICATE A DX10
	PUSHJ	P,CNFIG		;SEE IF WE HAVE ANY
	MOVEI	P2,224/4	;SECOND DX10
	PUSHJ	P,CNFIG		;SEE IF IT EXISTS
	MOVEI	P2,034/4	;3RD DX10
	PUSHJ	P,CNFIG		;SEE IF WE HAVE ONE
	MOVE	T1,CORLOC	;SAVE LAST DX10 LOC
	MOVEM	T1,TAPDEN##	; FOR UNCACHING
IFN FTNET,<
	MOVSI	T1,<.TYMTA/.TYEST> ;GET DEVICE TYPE
	HRR	T1,MTANUM	;GET NUMBER OF MAGTAPES CONFIGURED
	PUSHJ	P,NETDEV##	;STUFF COUNT IN OUR NDB
>
	SETZM	.CPACD##	;INDICATE WE'VE BEEN HERE BEFORE
	POP	P,R
	SKIPN	T1,.CPCPN##	;CPU 0?
	AOJA	T1,AUTCN6	;YES, TELL CPU1 TO GO NEXT
	CAMN	T1,BOOTCP##	;NO, BOOT CP?
	TDZA	T1,T1		;YES, TELL CPU0 TO GO NEXT
	ADDI	T1,1		;NO, TELL NEXT CPU IN ORDER
AUTCN6:	MOVEM	T1,LASCNF##	;TELL THE WORLD WHO SHOULD GO NEXT
	POP	P,.CPTOA##	;RESTORE ONCE TYPEOUT ADDRESS
	POPJ	P,
;HERE WHEN A NEW DISK OR TAPE DRIVE COMES ON LINE
;CALL WITH T1=CONTENTS OF DRIVE TYPE REGISTER, T2=SLAVE NO, T3=TUBCNF BITS
NEWTAP::PUSHJ	P,SAVE4##
	HRRO	P1,TKBCDB##(W)	;SET P1=-1,,CHN
	MOVE	J,W
	MOVE	P3,T2		;UNIT (SLAVE)
	MOVS	T4,TKBNAM##(W)
	SUBI	T4,'MT0'-1
	MOVEM	T4,NUMTAP	;SET TO MAKE RIGHT DDB NAME
	JRST	NEWUNI
NEWDSK::CAIN	T1,TY.DXB	;DOESN'T WORK
	POPJ	P,
	PUSHJ	P,SAVE4##
	HRRO	P1,KONCHN##(J)	;SET P1=-1,,CHN
	PUSHJ	P,HAVUNI	;KDB WITH NO UNITS?
	  JRST	[LDB T4,[POINT 12,.CPNUM##,23] ;INITIALIZE KON NUMBER
		 MOVEM T4,NUMRNA;WHERE TO START
		 AOS NUMRNA##	;YES, COUNT A CONTROLLER
		 HRRZS P1	;CONFIGURE AS IF NO KDB
		 JRST .+1]	;CONTINUE
	MOVE	P2,T2		;UNIT IF RP04
	HLRZ	P3,T2		;UNIT GOES HERE IF RP20
NEWUNI:	ANDI	T1,777		;ISOLATE DRIVE TYPE
	JRST	NEWLUP		;GO MATCH DRIVE TYPE

CKCHN:	DPB	P2,[POINT 7,AUTCNO##,9]
	DPB	P2,[POINT 7,AUTCNI##,9]
	DPB	P2,[POINT 7,AUTDTO##,9]
	DPB	P2,[POINT 7,AUTDTI##,9]
	MOVEI	T1,7
	CONO	PI,PI.OFF	;DON'T ALLOW INTERRUPTS
	XCT	AUTCNO##	;TRY TO GIVE IT A PI
	XCT	AUTCNI##
	MOVE	T2,T1
	MOVEI	T1,0		;SET PIA BACK TO 0
	XCT	AUTCNO##
	CONO	PI,PI.ON
	TRNE	T2,7		;IS IT THERE?
	JRST	CPOPJ1##	;YES
	POPJ	P,		;NO
;HERE TO CONFIGURE A WHOLE CHANNEL
CNFIG:	PUSHJ	P,CKCHN		;ANYTHING THERE AT ALL?
	  POPJ	P,		;NO, TRY NEXT
	SETZB	P1,J		;P1=CDB ADDR, J=KDB ADR
UNILUP:	MOVE	T4,P4		;SAVE CURRENT UNIT TYPE IF NOT 1ST UNIT
	SETOB	P3,P4		;SUBUNIT 0, NO UNIT SEEN ON THIS CONTROLLER
	MOVEI	T1,CO.MBE
	XCT	AUTCNO##
	TLNE	R,CP.DX1##	;DX10?
	JRST	FNDDX1		;YES. WE NEED A KDB TO SEE IF UNITS EXIST
	HLL	T1,P2		;UNIT NUMBER
	TLO	T1,(.DIDTR)	;SET TO READ DRIVE TYPE
	XCT	AUTDTO##	;WHAT WE WANT TO DO
	IMULI	P,1		;STALL
	IMULI	P,1
	XCT	AUTDTI##	;WHAT IT TELLS US
	ANDI	T1,777		;GET IMPORTANT BITS
	JUMPE	T1,NEXTUN	;FORGET IT IF NO REAL ANSWER
NEWLUP:	MOVEI	P4,TABLEN	;LENGTH OF TABLE (=TM02 INDEX)
	CAIL	T1,TY.T3L	;IS IT A TM03
	CAILE	T1,TY.T3H
	CAIA
	JRST	FNDCHN		;YES, SET THINGS UP FOR IT
	CAIL	T1,TY.T2L	;NO, IS IT A TM02?
	CAILE	T1,TY.T2H
	SOSA	P4
	JRST	FNDCHN		;YES, SET UP
SCAN:	MOVE	T2,TYPTAB(P4)	;TRY TO MATCH TYPE WITH TABLE
	CAIN	T1,(T2)		;MATCH?
	JRST	FNDCHN		;YES, WE HAVE A UNIT
	SOJGE	P4,SCAN		;NO, TRY NEXT
	MOVE	P4,T4		;PRESERVE LAST UNIT-TYPE
	JRST	NEXTUN		;NO MATCH, TRY NEXT UNIT


FNDDX1:	MOVEI	P4,DX1IDX
FNDCHN:	JUMPN	P1,HAVCHN	;BEEN HERE FOR THIS CHAN BEFORE?
	MOVEI	T2,LENCCB##	;NO, BUILD A CHAN DATA BLOCK
	PUSHJ	P,GETCOR
	  POPJ	P,		;NONE AVAILABLE. CAN'T DO ANYTHING
	MOVE	P1,T1		;P1 = CHAN ADDRESS
	MOVEI	T1,SYSCHN##-.CHSYS##
CDB1:	SKIPN	T2,.CHSYS##(T1)	;LINK THIS CDB ONTO THE SYSCHN CHAIN (AT END)
	JRST	CDB2
	HLRZ	T1,T2
	JRST	CDB1
CDB2:	HRLM	P1,.CHSYS##(T1)	;SAVE CHAN ADDR
	SETOM	CHNBSY##(P1)	;INDICATE IDLE
	MOVSI	T1,(CP.CS0)	;SET UP THE FEW CHANNEL VARIABLES
	LSH	T1,@.CPCPN##
	TLO	T1,(CP.PXX)
	MOVEM	T1,.CHCSR##(P1)
	HRRI	R,CHVIFP##
	MOVEM	R,CHNIFP##(P1)
	MOVEI	T1,CHVIFT##
	MOVEM	T1,CHNIFT##(P1)
	MOVEI	T1,3		;INITIAL FAIRNESS FOR SWAPPING
	MOVEM	T1,CHNIFS##(P1)
	AOS	CNFCHN##	;ONE MORE CHANNEL
;	JRST	HAVCHN
HAVCHN:	JUMPE	J,KDB1		;BEEN HERE FOR THIS KDB BEFORE?
	SKIPGE	KDBTAB(P4)	;YES, MULTI-UNIT CONTROLLER?
	CAIGE	P4,TAPIDX	;YES, A TAPE?
	JRST	HAVKDB		;NO, J IS RIGHT
	HLRZ	T1,P2		;CURRENT UNIT NUMBER
	MOVE	T3,J		;CURRENT KDB
KDB0:	HLRZ	T2,TKBUNI##(J)	;UNIT NUMBER FROM THE KDB
	CAMN	T1,T2		;SAME AS CURRENT UNIT NUMBER?
	JRST	 [MOVE W,J	;TAPES WANT IT IN W TOO
		  TLO P1,400000	;YES, INDICATE IN CPUATC
		  JRST TAPUDB]	;AND CONFIGURE SLAVES ON CURRENT KDB
	HLRZ	J,TKBCDB##(J)	;NEXT KDB IN THE RING
	CAME	J,T3		;BEEN ALL THE WAY AROUND THE RING?
	JRST	KDB0		;NO, SEE IF THIS IS THE CORRECT UNIT
;	SETZ	J,		;YES, KDB DOESN'T EXIST SO MAKE ONE
	HRRZS	P1		;PRETEND NOT DOING CPUATC
KDB1:	LDB	T2,[POINT 9,KDBTAB(P4),17] ;NO. GET LENGTH OF THIS KDB
	PUSHJ	P,CORGRB	;GET THE CORE
	  POPJ	P,		;NONE AVAILABLE. FORGET IT
	MOVE	J,T1		;J = KDB ADDRESS
	MOVEI	W,4(J)		;IN CASE OF A MAGTAPE
	HRL	W,T2		; LH WILL BE ADDR OF FIRST UDB
	HRL	T1,KDBTAB(P4)	;COPY PROTOTYPE KDB
	BLT	T1,-1(T2)	; TO THE CORE WE JUST GOT
	MOVE	T1,.CPEPT##	;FIND JSR CH??
	CAIL	P4,TAPIDX
	TROA	T1,TAPCHN##*2+40-1
	TRO	T1,DSKCHN##*2+40-1
	MOVE	T1,1(T1)
	MOVE	T2,1+IFN FTKLP,<3>(T1)	;START OF CONSO CHAIN
	MOVE	T3,J		;POINT START OF CHAIN TO THIS KDB
	HRLI	T3,(JRST)
	MOVEM	T3,1+IFN FTKLP,<3>(T1)
	MOVEM	T2,1(J)		;MAKE THIS INTERRUPT LOC BE THE JEN
	MOVN	T1,KDBTAB(P4)	;GET LENGTH OF KDB
	TLO	T1,777000	;MAKE SURE IT'S NEGATIVE
	HRR	T1,J		;START OF KDB
KDB2:	LDB	T2,[POINT 10,(T1),9] ;GET AN INSTR IN THE KDB
	CAIN	T2,7650/4	;IS IT AN IO INSTRUCTION?
	DPB	P2,[POINT 7,(T1),9] ;YES, CHANGE IT TO THIS CHANNEL
	AOBJN	T1,KDB2		;AND LOOP
	TLNN	R,CP.22B##	;RH10?
	JRST	KDB3
	MOVE	T1,[JFCL 350]	;YES, FIX UP INTERRUPT LOCS
	HRRM	T1,(J)		; WHICH GOT ASSEMBLED FOR RH20
	CAIGE	P4,TAPIDX
	HLLZM	T1,2(J)
KDB3:	CAIL	P4,TAPIDX	;TAPE?
	JRST	KDB4		;YES
	ADDI	T3,1		;NO, FIX UP REST OF INTERRUPT INST'S
	MOVEM	T3,4(J)
	MOVE	T1,.CPSAV##	;DISK PI SAVE ROUTINE
	HRRM	T1,5(J)		;INTO THE JSR
	ADDI	J,7		;POINT J AT REAL KDB (PAST SKIP-CHAIN INSTRS)
KDB4:	TLNN	R,CP.22B##	;RH10?
	JRST	KDB5		;NO
	MOVEI	T1,LOCOCW##	;YES, ASSIGN 1 2-WORD LOW CORE ADDRESS
	SKIPE	(T1)		;FOR THE ICWA
	AOJA	T1,.-1
	DMOVEM	P1,(T1)		;MAKE SURE IT GETS NON-0 SO WONT BE REUSED
	JRST	KDB7
KDB5:	TLNN	R,CP.DX1##	;DX10?
	JRST	KDB6		;NO
	MOVEI	T1,LOCODW##	;YES, ASSIGN A 4-WORD BLOCK FOR ICWA
	SKIPE	(T1)
	AOJA	T1,.-1
	DMOVEM	P1,(T1)		;SET NON - 0 SO IT WONT BE REUSED
	DMOVEM	P1,2(T1)
	JRST	KDB7
KDB6:	MOVEI	T1,-540/4(P2)	;RH20 - COMPUTE RIGHT ICWA
	LSH	T1,2
	ADD	T1,.CPEPT##
KDB7:	CAIL	P4,TAPIDX	;TAPE?
	JRST	TAPKDB		;YES, FINISH UP
	MOVEM	T1,KONIOC##(J)	;DISK - STORE ICWA
	MOVEI	T1,DSKCHN##	;SET UP PI
	DPB	T1,KOYPI##	; IN KDB
	MOVEI	T1,SYSKON##-KONNXT##
KDB8:	HLRZ	T2,KONNXT##(T1)	;LINK THIS KDB INTO THE END OF THE CHAIN
	JUMPE	T2,KDB9
	MOVE	T1,T2
	JRST	KDB8
KDB9:	HRLM	J,KONNXT##(T1)
KDB10:	CAIN	P4,RNAIDX	;RP20?
	CAIA			;COUNT NUMBER OF CONTROLLERS (ONLY COUNT RP20S WITH UNITS)
	AOSA	T1,NUMRPA##	; OF THIS TYPE
	AOSA	NUMRNC##	;COUNT NUMBER OF CONTROLLERS
	AOS	NUMRPC##	;OF THIS TYPE , PER CPU
	AOS	NUMKON##	;COUNT A CONTROLLER
	SUBI	T1,1		;SET UP KONTROLLER NUMBER
	HLRZ	T2,SYSKON##	;STARTING AT 1ST KDB IN SYSTEM
KDB11:	CAIN	T2,(J)		;LOOK FOR A MATCH WITH THE NAMES
	JRST	KDB13		; WE'RE ABOUT TO BUILD
	LDB	T3,[POINT 6,KONRDS##(T2),9]
	CAIE	T3,(T1)		;MATCH?
	JRST	KDB12		;NOT ON THIS ONE, TRY NEXT
	MOVE	T3,KDBTAB(P4)	;MAYBE CHECK TO SEE IF SAME TYPE
	HRRZ	T3,KONRDS##+7(T3)
	HRRZ	T4,KONRDS##(T2)
	CAIN	T4,(T3)		;SAME TYPE?
	JRST	KDB10		;YES. BUMP LETTER AND TRY AGAIN
KDB12:	HLRZ	T2,KONNXT##(T2)	;NO MATCH. TRY NEXT KDB
	JRST	KDB11
KDB13:	DPB	T1,[POINT 6,KONRDS##(J),9] ;SAVE NUMBER IN THE KDB
	MOVE	T1,.CPCPN##	;SET CPU NUMBER IN KDB
	DPB	T1,[POINT 3,KONSTP##(J),2]
	HRRM	P1,KONCHN##(J)	;POINT KDB AT CDB
	MOVEI	T1,KONTAB##(J)	;SET UP KONPTR
	HRRM	T1,KONPTR##(J)
IFN FTKL10,<
	CAIE	P4,RNAIDX	;RP20?
	JRST	HAVKDB		;NO, GO SET UP UDB
	MOVEI	T1,CHNRSC##(P1)	;YES. SET UP SOME EXTRA STUFF
	MOVEM	T1,RNXRSC##(J)
	HLRE	T1,P3
	AOJE	T1,HAVKDB	;DON'T LOOK FOR LAFGE UNITS IF 1ST UNIT
	SOJE	T1,HAVKDB	;1ST TIME FOR 2ND UNITS (GTR THAN 10)?
	TLZ	P3,-1		;YES, GET ADDR OF 1ST KDB
IFN FTDUAL,<
	HRRZM	T1,RNXALT##(J)	;LINK THE 2 KDBS TOGETHER
	MOVEM	J,RNXALT##(T1)
>
	MOVEI	T1,RNPUNB##	;INDICATE LARGE UNIT NUMBERS
	MOVEM	T1,RNXFLG##(J)
>	;END IFN FTKL10
	JRST	HAVKDB
TAPKDB:	MOVE	T2,.CPSAV##	;GET PI SAVE LOCATION
	HLRM	T2,2(J)		;SAVE IN INTERRUPT LOC (EG JSR SAV4)
	ADDI	J,4		;POINT J AT "REAL" PART OF KDB
	MOVEM	T1,TKBICP##(J)	;SAVE ICWA IN KDB
	ADDI	T1,3		;POINT TO VECTORED INTERRUPT WORD
	HRLI	T1,744002	;ASSUME RH20 FLAVOR OF VECTOR
	TLNN	R,CP.DX1##+CP.RH2##
	HRLI	T1,444002	;RH10-STYLE VECTOR
	TLNN	R,CP.DX1##
	MOVEM	T1,TKBIVI##(J)
	MOVEI	T1,CNFMTK##-TKBKDB##
TKDB1:	SKIPN	T2,TKBKDB##(T1)	;LINK THIS KDB INTO CNFMTK/TKBKDB CHAIN
	JRST	TKDB2
	MOVE	T1,T2
	JRST	TKDB1
TKDB2:	MOVEM	J,TKBKDB##(T1)
	ADDM	J,TKBIUN##(J)	;POINT TKBIUN, TKBCUN AT RIGHT PART OF KDB
	ADDM	J,TKBCUN##(J)
	TLNE	R,CP.DX1##
	JRST	TKDB3		;IF NOT A DX10
	ADDM	J,TKBVIN##+1+IFN FTKLP,<4>(J) ; SET UP TKBVIN
IFE FTKLP,<
	ADDM	J,TKBVIN##+3(J)
>
	HRRZ	T1,J
	ADD	T1,TKBVIN##+4(J)	;WORRY ABOUT OVERFLOW IN VIN+4
	HRRM	T1,TKBVIN##+4(J)	; (STARTS AS JRST -2)
IFN FTKLP,<
	ADDM	J,TKBVIN##+3(J)
	ADDI	T1,1
	HRRM	T1,TKBVIN##+7(J)
>
TKDB3:	HRLZ	T1,.CPCPN##	;CPU NUMBER INTO KDB
	LSH	T1,^D15
	MOVEM	T1,TKBSTS##(J)
	MOVEM	P1,TKBCDB##(J)	;POINT KDB AT CDB
	MOVEI	T1,CNFMTK##-TKBKDB##
TKDB4:	SKIPE	T1,TKBKDB##(T1)	;FIND 1ST KDB ON THIS CHAN
	CAIN	J,(T1)
	JRST	TKDB7		;NO KDB WITH MATCHING CDB
	HRRZ	T3,TKBCDB##(T1)	;CHAN FOR THIS KDB
	CAIE	T3,(P1)		;SAME AS THE KDB WE'RE BUILDING?
	JRST	TKDB4		;NO, KEEP LOOKING
	MOVE	T3,T1		;NOW FIND LAST KDB ON CHAN
TKDB6:	HLRZ	T2,TKBCDB##(T3)
	CAIN	T2,(T1)
	JRST	TKDB8
	MOVE	T3,T2
	JRST	TKDB6
TKDB7:	SKIPA	T1,J		;1ST KDB IN SYSTEM. LINK TO ITSELF
TKDB8:	HRLM	J,TKBCDB##(T3)	;INSERT THIS KDB INTO RING
	HRLM	T1,TKBCDB##(J)
	HLLM	P2,TKBUNI##(J)	;SET UP TKBUNI
	MOVEI	T1,1
	HLRZ	T2,P2
	LSH	T1,(T2)
	HRRM	T1,TKBUNI##(J)
	SKIPL	KDBTAB(P4)	;MULTI UNIT
	HRROM	T1,TKBUNI##(J)	;NO. MAKE SURE IT IS NEGATIVE
HAVKDB:	CAIL	P4,TAPIDX	;TAPE?
	JRST	TAPUDB		;YES
	SKIPGE	KDBTAB(P4)	;MULTI-UNIT (RP20)?
	JUMPL	P3,UDB5		;YES, GO FIND FIRST UNIT ON KDB
	PUSHJ	P,GETUNN	;GET UNIT NUMBER
	ADDI	T4,KONTAB##(J)	;OFFSET INTO KONTAB
	SKIPE	(T4)		;UNIT ALREADY EXIST? - CPUATC
	JRST	NEXTUN		;YES, LOOK ONWARD
	HLRZ	T2,TYPTAB(P4)	;LENGTH OF UDB
	PUSHJ	P,GETCOR	;GET THE CORE WE NEED
	  POPJ	P,		;NONE AVAILABLE. FORGET IT
	MOVE	U,T1		;SAVE UDB ADDRESS
	PUSHJ	P,MAKNAM	;MAKE UP A NAME FOR THE UNIT
	MOVEM	T1,(U)		;SAVE IT IN UDB
	ADDI	T4,KONTAB##(J)	;POINT AT RIGHT KONTAB SLOT
	MOVEM	U,(T4)		;POINT KDB AT THIS UDB
	HRRZ	T1,J		;GO SEARCH FOR 1ST AND LAST UDBS IN SYSTEM
	PUSHJ	P,FSTLST	; ON THIS KDB
	MOVEM	J,UNIKON##(U)	;SET UP RH(UNIKON)
	SKIPGE	P1		;IF SYSTEM IS RUNNING
	HLL	T4,UNIKON##(T4)	; PRESERVE CURRENT LINKS
	HRLM	U,UNIKON##(T4)	;POINT PREVIOUS LAST AT THIS UDB
	JUMPGE	P1,UDB4		;IF A SINGLE UNIT
	SKIPE	T1		;IF ANY UNITS ON THE KDB
	HRRM	T4,LASUNI##	;LINK UNISYS AT END OF CURRENT KDB'S UNITS
UDB4:	HLLM	T4,UNIKON##(U)	;POINT THIS UDB AT 1ST
	HRRO	T1,P1		;SEARCH FOR 1ST AND LAST UDBS IN SYSTEM
	PUSHJ	P,FSTLST	; ON THIS CDB
	MOVEM	P1,UNICHN##(U)	;SET UP RH(UNICHN)
	SKIPGE	P1
	HLL	T4,UNICHN##(T4)
	HRLM	U,UNICHN##(T4)	;POINT PREVIOUS LAST AT THIS UDB
	HLLM	T4,UNICHN##(U)	;POINT THIS UDB AT LAST
	SKIPE	T1,LASUNI##	;GET FORMER LAST UNIT
	SKIPE	UNI2ND##(T1)	;(2ND PORT ISNT ON CHAIN)
	MOVEI	T1,SYSUNI##-UNISYS##
	MOVE	T2,UNISYS##(T1)	;GET ITS LINK (IN CASE SINGLE UNIT)
	HRLM	U,UNISYS##(T1)	;POINT AT US
	HLLM	T2,UNISYS##(U)	;LINK US TO FORMER NEXT
	MOVEM	U,LASUNI##	;SAVE LAST UDB CREATED
	LDB	T2,[POINT 6,(T4),17] ;GET CONTROLLER LETTER OF PREVIOUS
	SKIPGE	P1
	DPB	T2,[POINT 6,(U),17] ;AND SAVE AS THIS LETTER
	MOVSI	T1,777		;SET UP RANDOM UDB LOCS
	MOVEM	T1,UNICCT##(U)
	MOVE	T1,[LBNHOM##,,LB2HOM##]
	MOVEM	T1,UNIHOM##(U)
	SETOM	UNICYL##(U)
	MOVE	T1,NUMRNC##	;COMPUTE ALL THE GARBAGE FOR UNIDES
	ADD	T1,NUMRPC##	; (DOES ANYONE REALLY CARE?)
	SUBI	T1,1
	ANDI	T1,7
	LSH	T1,^D15
	CAIN	P4,RNAIDX
	TROA	T1,TYPRN##*1000
	TROA	T1,TYPRP##*1000
	SKIPA	T2,NUMRNC##
	MOVE	T2,NUMRPC##
	SUBI	T2,1
	DPB	T2,[POINT 3,T1,29]
	MOVEI	T2,FRSTRP##
	CAIE	P4,RP5IDX
	ADDI	T2,(P4)
	DPB	T2,[POINT 3,T1,32]
	SKIPGE	KDBTAB(P4)	;MULTI-UNIT (RP20)?
	SKIPA	T2,P3		;YES, IGNORE UNIT-SLOT, JUST USE SLAVE NUMBER
	HLRZ	T2,P2		;COMPUTE UNIT NUMER
	ADD	T1,T2
	TLO	T1,3000		;MARK DOWN (IN CASE NOT BOOT, SYSTEM ALREADY UP)
	MOVEM	T1,UNIDES##(U)	;SAVE ALL THE STUFF IN UNIDES
	SETZ	T1,
	CAIE	P4,RNAIDX	;NON-REMOVABLE DISK?
	CAIN	P4,RP7IDX
	MOVSI	T1,U2PNRM##	;YES, LIGHT A BIT
	MOVEM	T1,UNIDS2##(U)
	SETOM	UNIAJB##(U)
	TLNE	P1,377777	;A SINGLE UNIT?
	POPJ	P,		;YES, THEN DONE
	SKIPL	KDBTAB(P4)	;MULTIPLE "SLAVES" ON THIS UNIT (IE RP20)?
	JRST	NEXTUN		;NO, WE'RE DONE
;THIS WORKS ONLY FOR RP20S.
UDB5:	MOVE	T1,AUTRNX##	;LAST UNIT WE HAD
	HLRZ	T2,P2		;RH20 UNIT NUMBER
	PUSHJ	P,@KONCFG##(J)	;ASK DRIVER WHAT THE NEXT UNIT IS
	  JRST	UDB6		;NO MORE
	SKIPGE	P3		;IF FIRST TIME,
	AOS	NUMRNA##	;COUNT A KONTROLLER
	HRRZ	P3,T1		;UNIT
	TRZ	P3,10		;ENSURE SMALL UNIT NUMBERS
	EXCH	T1,AUTRNX##	;SAVE FOR NEXT CALL
	XOR	T1,AUTRNX##	;DID UNIT NUMBERS JUST GO ABOVE 10?
	TRNE	T1,10
	JUMPGE	T1,UDB7		;YES (IF AUTRNX DID NOT = -1)
	JRST	HAVKDB		;GO SET UP UDB
UDB6:	SETOM	AUTRNX##	;DONE RESET FOR NEXT TIME
	POPJ	P,		;ONLY 1 RP20 PER RH. WE'RE DONE
UDB7:	HRL	P3,J		;SET FLAG, SAVE OLD KDB ADDR
	AOS	NUMRNA##	;COUNT A KONTROLLER
	JRST	KDB1		;GO BUILD A NEW KDB, LINK THE 2 TOGETHER
TAPUDB:	TLNE	P1,377777	;CNFIG OR CPUATC?
	JRST	TUDB4		;NO, SINGLE UNIT
	JUMPL	P1,TUDB9	;GO IF KONTROLLER ALREADY HAS A NAME
TUDB1:	AOS	T1,NUMTAP##	;YES, COUNT A TAPE CONTROLLER
	SUBI	T1,1
	AOS	NUMKON##	;COUNT A CONTROLLER
	ADDI	T1,'MT0'
	MOVSS	T1		;MAKE NAME IN LH
	SKIPN	T2,CNFMTK##	;STARTING AT FIRST TAPE KDB IN SYSTEM,
	JRST	TUDB3		; LOOK FOR A MATCH WITH THE NAME WE'RE MAKING
TUDB2:	CAMN	T1,TKBNAM##(T2)	;MATCH?
	JRST	TUDB1		;YES, BUMP NAME AND TRY AGAIN
	SKIPE	T2,TKBKDB##(T2)	;NO, TRY NEXT KDB
	JRST	TUDB2
TUDB3:	MOVEM	T1,TKBNAM##(J)
	JRST	TUDB9		;FIND 1ST SLAVE IF 1ST TIME
TUDB4:	PUSHJ	P,GETUNN	;GET UNIT NUMBER
	ADD	T4,TKBIUN##(J)	;OFFSET INTO UNIT TABLE
	SKIPE	(T4)		;UNIT ALREADY EXIST? - CPUATC
	JRST	TUDB9		;YES, JUST LOOK AT NEXT UNIT
	HLRZ	T2,TYPTAB(P4)	;GET LENGTH OF UDB
	PUSHJ	P,GETCOR	;ALLOCATE THAT MUCH CORE
	  POPJ	P,		;NONE AVAILABLE. FORGET IT
	MOVE	U,T1		;UDB ADDR INTO U
	HRL	T1,TAPTAB-TAPIDX(P4) ;COPY THE RIGHT FLAVOR OF UDB
	BLT	T1,-1(T2)
	TRNE	T3,-1		;DID DRIVER DETERMINE POSSIBLE CNFIG CHANGE?
	HRRM	T3,TUBCNF##(U)	;YES, STORE NEW INFORMATION
	MOVEI	T3,TUCIRD##	;ALL UNITS INTERRUPT
	IORM	T3,TUBCNF##(U)	;UORV REW DONE
	PUSHJ	P,FNYNAM	;MAKE A NAME FOR THE UDB
	LDB	T2,[POINT 6,TKBNAM##(J),17] ;GET KONTROLLER NUMBER
	SKIPGE	P1		;IF SINGLE UNIT OR CPUATC,
	DPB	T2,[POINT 6,T1,23] ;STORE IT IN UNIT NAME
	MOVEM	T1,(U)
	MOVEM	T4,TUBADR##(U)	;SAVE UNIT NUMBER
	ADD	T4,TKBIUN##(J)	;POINT TO RIGHT KDB SLOT
	MOVEM	U,(T4)		;SAVE UDB IN KDB
	HRRZM	J,TUBKDB##(U)	;POINT UDB AT KDB
	MOVEI	T2,MT0DDS##	;GET CORE FOR A DDB
	PUSHJ	P,GETCOR
	  POPJ	P,		;NONE AVAILABLE. FORGET IT
	MOVE	F,T1		;SAVE DDB ADDRESS
	PUSHJ	P,MAKNAM	;MAKE UP A NAME
	SKIPE	CORLOC		;SYSTEM UP AND RUNNING?
	JRST	TUDB5		;NO, ONCE WILL DO ALL THE RIGHT STUFF
	HRRI	T1,'000'(T4)	;MAKE "MTA00n" AS NAME
IFN FTNET,<
	LDB	T2,[POINT 3,JBTLOC##,35]
	DPB	T2,[POINT 3,T1,29] ;SET LAST DIGIT OF STATION
	LDB	T2,[POINT 3,JBTLOC##,32]
	DPB	T2,[POINT 3,T1,23] ;SET 1ST DIGIT OF STATION
>
	HLRZ	T2,MT0DDB##+DEVSER ;WERE ANY MAGTAPES FOUND ON START UP?
	JUMPN	T2,TUDB5	;YES, LINK THIS TAPE TO THE END OF THOSE
	HRLM	F,MT0DDB##+DEVSER ;NO. POINT AT THIS DDB SO CNFMTA GETTAB WILL WORK
	MOVEI	T2,SWPDDB##	;LINK MAGTAPES INTO DEVICE CHAIN
	MOVEM	T2,TAPLNK##	; AT END OF SWAPPER
TUDB5:	LDB	T2,[POINT 6,TKBNAM##(J),17] ;KONTROLLER NUMBER
	ADDI	T2,"A"-"0"	;CHANGE INTO A LETTER
	SKIPGE	P1		;IF SINGLE UNIT OR CPUATC,
	DPB	T2,[POINT 6,T1,17] ;STORE LETTER IN NAME
	MOVEM	T1,(F)		;SAVE NAME IN DDB
	MOVE	T1,[<^D5*HUNGST>,,MTSIZ##]
	MOVEM	T1,DEVCHR(F)	;SET UP DEVCHR
	MOVEI	T1,TPMDSP##	;SET UP RH OF DEVSER
	MOVEM	T1,DEVSER(F)
	MOVE	T1,TAPLNK##
TUDB6:	HLRZ	T2,DEVSER(T1)	;FIND THE END OF THE MAGTAPES
	JUMPE	T2,TUDB7	;HAVE END
	HRRZ	T3,DEVSER(T2)	;IF SYSTEM IS ALREADY RUNNING (THIS ISNT BOOT CPU)
	CAIE	T3,TPMDSP##	;IS THE NEXT DDB NOT A TAPE?
	JRST	TUDB7		;NOT A TAPE - INSERT NEW DDB HERE
	MOVE	T1,T2
	JRST	TUDB6
TUDB7:	HRLM	F,DEVSER(T1)	;LINK PREVIOUS DDB TO THIS ONE
	HRLM	T2,DEVSER(F)	;PRESERVE THE LINK OF WHAT WE'RE INSERTING
	HLRZ	T4,W		;IS THIS THE 1ST UNIT ON THE KDB?
	SUBI	T4,(U)
	JUMPN	T4,TUDB8
	MOVE	T1,NUMTAP##	;YES, POINT GENTAB AT THIS DDB
	CAIG	T1,TAPN##
	HRRM	F,GENTAB##-1(T1)
	MOVEM	F,TKBERB##(W)	;POINT TKBERB AT 1ST DDB ON CONTROL
TUDB8:	MOVE	T1,[1023,,154403+<1_BYTMOD>]
	MOVEM	T1,DEVMOD(F)	;SET UP DEVMOD
	MOVE	T1,[.TYMTA!DEPLEN,,DEPEVM]
IFN FTNET,<
	TDO	T1,JBTLOC##	;(NON-0 IF SYSTEM ALREADY UP)
>
	MOVEM	T1,DEVSTA(F)	;SAVE DEVSTA
	LDB	T1,[POINT 3,TUBADR##(U),35] ;ONLY LOW-ORDER PART OF NAME SO DDBFIX
	DPB	T1,PUNIT##	; WILL DO THE RIGHT THING
IFN FTMP,<
	HRLZ	T1,.CPCPN##
	LSH	T1,^D15		;SET UP DEVCPU
	TLO	T1,2000
	HRR	T1,.CPTIL##	;TAPE INTERLOCK WORD FOR THIS CPU
	MOVEM	T1,DEVCPU(F)
>
	HRLM	U,TDVKDB##(F)	;POINT DDB AT UDB
	HRRM	W,TDVKDB##(F)	;POINT DDB AT KDB
	HRLM	U,TDVUDB##(F)	;COUPLE DDB,TUB
	HRRZM	F,TUBDDB##(U)
	PUSHJ	P,TAPACT	;ACCOUNT FOR THE DRIVE, TELL QUASAR
	TLNE	P1,377777	;CNFIG OR CPUATC?
	POPJ	P,		;NO, SINGLE UNIT SO ALL DONE
TUDB9:	MOVE	T1,TKBDSP##(W)	;ASK THE DRIVER WHAT THE NEXT UNIT IS
	MOVE	T2,CORLOC	;FOR TX1KON
	PUSHJ	P,TPKCFG##(T1)
	JUMPL	P3,NEXTUN	;GO IF NO MORE SLAVES ON UNIT
	MOVNI	T1,1(P3)	;ANOTHER UNIT
	HRLM	T1,TKBIUN##(W)	;SET UP TKBIUN, TKBCUN
	MOVE	T1,TKBIUN##(W)
	MOVEM	T1,TKBCUN##(W)
	JRST	TUDB4		;GO SET UP UDB FOR THIS SLAVE
TUDB10:	MOVSI	T1,1(P3)	;SET T1=-DRIVE NUMBER,,00
	MOVNS	T1
	CAML	T1,TKBIUN##(W)	;LARGER THAN CURRENT?
	POPJ	P,
	HLLM	T1,TKBIUN##(W)	;YES. RESET LH ACCORDINGLY
	HLLM	T1,TKBCUN##(W)
	POPJ	P,		;RETURN


; HERE TO ACCOUNT FOR THE DRIVE, TELL QUASAR, ETC.
TAPACT:
IFN FTNET,<AOS MTANUM>		;COUNT MAGTAPES FOR NETSER
IFE FTMDA,<POPJ P,>		;RETURN IF NO MDA
IFN FTMDA,<
	SKIPE	CORLOC		;ARE WE IN ONCE ONLY CODE?
	POPJ	P,		;YES, SIMPLY RETURN.
	PUSHJ	P,SAVT##	;IPCSER SMASHES T1-T4
	PJRST	MTAMPA##	;TELL MDA ABOUT THE NEW TAPE DRIVE
> ;END IFN FTMDA
NEXTUN:	MOVEI	T1,CO.RAE+CO.MBE;CLEAR POSSIBLE RAE
	XCT	AUTCNO##
	HLRZ	T2,P2
	ADDI	T2,1		;STEP TO NEXT UNIT
	TLNN	R,CP.DX1##
	CAILE	T2,7		;IS THERE ONE?
	POPJ	P,		;NO, WE'RE DONE WITH THIS RH
	HRLM	T2,P2		;YES, PUSH ON
	JUMPL	P4,UNILUP	;GO IF NO UNIT SEEN ON THIS KON YET (CPUATC)
	SKIPL	KDBTAB(P4)	;MULTI UNIT
	JRST	UNILUP		;GO SEE IF ANOTHER UNIT EXISTS
	CAIGE	P4,TAPIDX	;HAVCHN WILL FIND THE NEXT KDB
	SETZ	J,		;CNFIG, SET TO BUILD A NEW KDB FOR NEW UNIT
	JRST	UNILUP

;ROUTINE TO MAKE SURE DX10 KDBS ARE NEVER CACHED
IFN FTMP,<
T1CINI::SKIPN	W,CNFMTK##	;ANY MAGTAPES?
	POPJ	P,		;NO, NOTHING TO DO
T1CIN1:	PUSHJ	P,TX1TCF##	;IF A DX10, MAKE SURE KDBS ARE NEVER CACHED
	HRRZ	W,TKBKDB##(W)	;NEXT KDB
	JUMPN	W,T1CIN1	;IF NEXT, TRY IT
	POPJ	P,		;AND RETURN
>

;PRESERVES T3
GETCOR:	PUSH	P,T3
	PUSHJ	P,CORGRB	;GET SOME CORE
	  JRST	T3POPJ##
	POP	P,T3
	MOVEI	T4,1(T1)
	HRLI	T4,(T1)
	SETZM	-1(T4)
	BLT	T4,-1(T2)
	JRST	CPOPJ1##	;SUCCESS


CORGRB:	SKIPN	T1,CORLOC	;ALLOCATING FROM ONCE ONLY CORE?
	JRST	CORGR1		;NO, GET CORE FROM MONITOR FREE CORE
	ADDB	T2,CORLOC	;GET TOP, BUMP FOR NEXT TIME
	CAMGE	T2,MONVFF##	;ABOVE FIRST FREE LOC?
	JRST	CORGRA		;NO, JUST MAKE SURE THE MAP IS RIGHT AND RETURN
	PUSHJ	P,SAVT##	;SAVE SOME ACS
	SUB	T2,MONVFF##	;NUMBER OF WORDS TO GET
	SKIPN	T2		;GET AT LEAST 1
	AOSA	T1,T2		;ONCMAP WANTS IT IN T1
	MOVE	T1,T2		; ...
IFE FTKLP,<
	MOVEI	T2,PM.ACC+PM.WRT+PM.SWB ;MAP BITS
>
IFN FTKLP,<
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.SWB)
>
	PUSHJ	P,ONCMAP##	;GET THE SPACE
CORGRA:
IFN FTMP,<
	PUSHJ	P,RDMAP		;COPY BOOTS MAP IF NOT THE BOOT CPU
>
	JRST	CPOPJ1##	;WIN RETURN

IFN FTMP,<
RDMAP:	PUSHJ	P,SAVT##	;ONLY REASON THIS IS A SUBROUTINE
	MOVE	T1,.CPCPN##	;OUR CPU NUMBER
	CAMN	T1,BOOTCP	;ARE WE THE BOOT?
	POPJ	P,		;YES, NOTHING TO DO
	PJRST	MAPINI##	;COPY BOOTS MAP SINCE MAY HAVE CHANGED
>

;HERE IF THE SYSTEM IS UP AND RUNNING
CORGR1:	TRZE	T2,3		;INTEGRAL NUMBER OF 4-WD BLOCKS?
	ADDI	T2,4		;NO, ROUND UP
	PUSH	P,T2		;SAVE NO OF WORDS TO GET
	PUSHJ	P,GETWDS##	;ASK FOR THE CORE
	  JRST	TPOPJ##		;CANT GET IT
	POP	P,T2		;GOT IT. RESTORE AMOUNT REQUESTED
	ADD	T2,T1		;PLUS START ADDR = END ADDR
	JRST	CPOPJ1##	;GIVE GOOD RETURN
;ROUTINE TO FIND FIRST AND LAST UDBS OF A CERTAIN TYPE IN SYSTEM
;CALL T1=0,,KDB  OR T1=-1,,CDB
;RETURNS T4=1ST,,LAST	(COULD BE THE SAME. IF NONE YET RETURNS T4=UDB,,UDB)
;RETURNS T1=0 IF FIRST SUCH UDB
FSTLST:	PUSHJ	P,SAVE1##
	MOVE	P1,T1		;SAVE ARGUMENT
	PUSHJ	P,FSTMAT	;FIND A MATCH
	  JRST	FSTLS2		;FOUND IT
FSTLS1:	MOVE	T4,U		;NO MATCH. 1ST=LAST=US
	HRL	T4,U
	POPJ	P,
FSTLS2:	HRL	T4,T3		;SAVE 1ST FOUND IN LH(T4)
FSTLS3:	HRR	T4,T3		;SAVE THIS AS LAST
	PUSHJ	P,FSTMA3	;NEXT UDB A MATCH?
	  JRST	FSTLS3		;YES, SAVE UDB ADDR
	POPJ	P,		;NO MORE MATCHES. DONE

;ROUTINE TO SEE IF WE HAVE A MATCH
;RETURNS CPOPJ IF YES, CPOPJ1 IF NO
FSTMAT:	HLRZ	T1,SYSKON##	;START AT FIRST KDB IN SYSTEM
FSTMA1:	MOVE	F,T1		;SAVE LOC OF KDB
	HRLI	T1,-10		;10 UNITS PER KDB
FSTMA2:	SKIPN	T3,(T1)		;UDB THERE?
FSTMA3:	AOBJN	T1,.-1		;NO, TRY NEXT
	JUMPE	T3,FSTMA4	;FIND A UDB? NOT IF 0
	JUMPL	P1,[HRRZ T2,UNICHN##(T3)
		    JRST .+2]	;LOOKING FOR UNICHN IF NEGATIVE
	HRRZ	T2,UNIKON##(T3)	;POSITIVE - LOOKING FOR UNIKON
	CAIN	T2,(P1)		;MATCH?
	POPJ	P,		;YES, RETURN
	JUMPN	T2,FSTMA4	;NO. FOUND THIS UNIT?
	AOBJN	T1,FSTMA2	;YES. KEEP GOING IF NOT UNIT 7
FSTMA4:	HLRZ	T1,KONNXT##(F)	;STEP TO NEXT KDB
	JUMPN	T1,FSTMA1	;LOOK FOR UNIT MATCH IF IT EXISTS
	JRST	CPOPJ1##	;NO MATCH. SKIP
;RETURNS T4=UNIT NUMBER, T2=CONTROLLER "NUMBER"
FNYNAM:	PUSHJ	P,SETNAM	;SET UP T2=KDB NO, T4=UNIT NO
	TDC	T1,[61,,2000]	;CONVERT xxA0 TO xx000
	DPB	T3,[POINT 3,T1,17] ;3RD CHAR IS CDB NO
FNYNM1:	SUBI	T2,1
	DPB	T2,[POINT 3,T1,23] ;FINISH UP NAME
	DPB	T4,[POINT 3,T1,29]
	POPJ	P,		;AND RETURN

;SUBROUTINE TO MAKE UP A UNIT NAME
;RETURNS T4=UNIT NUMBER, T2=CONTROLLER "NUMBER"
MAKNAM:	PUSHJ	P,SETNAM	;SET ACS
	DPB	T2,[POINT 5,T1,17] ;STORE THE CONTROLLER LETTER
	DPB	T4,[POINT 3,T1,23] ;STORE THE UNIT NUMBER
	POPJ	P,		;AND RETURN

SETNAM:	CAIL	P4,TAPIDX	;TAPE?
	JRST	[MOVE T1,[SIXBIT /MTA0/]
		 MOVE T2,NUMTAP## ;SET UP T1, T2 FOR TAPE
		 JRST SETNM1]
	CAIN	P4,RNAIDX	;SET UP T1 FOR RNA OR RPA
	SKIPA	T1,[SIXBIT /RNA0/]
	SKIPA	T1,[SIXBIT /RPA0/]
	SKIPA	T2,NUMRNA##	;SET UP T2 FOR CONTROLLER LETTER
	MOVE	T2,NUMRPA##
SETNM1:	MOVE	T3,.CPCPN	;RETURN T3= CPU NUMBER
;SUBROUTINE TO RETURN CURRENT UNIT NUMBER
GETUNN:	HLRZ	T4,P2		;T4 = UNIT NUMBER
	SKIPGE	KDBTAB(P4)	;MULTI-UNIT?
	HRRZ	T4,P3		;YES. USE SLAVE NUMBER
	POPJ	P,		;AND EXIT
TYPTAB:	RPULEN##,,TY.RU
	RPULEN##,,TY.RP6
	RPULEN##,,TY.RP5
RP5IDX==.-TYPTAB-1
	RPULEN##,,TY.RP7
RP7IDX==.-TYPTAB-1
	RNULEN##,,TY.DXB
RNAIDX==.-TYPTAB-1
TAPIDX==.-TYPTAB
	TXULEN##,,TY.DXA
	DXULEN##,,1
DX1IDX==.-TYPTAB-1
	T8ULEN##,,TY.T78
T78IDX==.-TYPTAB-1
	T2ULEN##,,TY.T2L		;MUST BE LAST IN TYPTAB
TABLEN==.-TYPTAB-1

MULUNI==400000
KDBTAB:	RPKLEN##,,RPXKDB##
	RPKLEN##,,RPXKDB##
	RPKLEN##,,RPXKDB##
	RPKLEN##,,RPXKDB##
	MULUNI+RNKLEN##,,RNXKDB##
	MULUNI+TXKLEN##,,TX2KDB##
	DXKLEN##,,DX1KDB##
	MULUNI+T8KLEN##,,T78KDB##
	MULUNI+T2KLEN##,,TM2KDB##

TAPTAB:	TX2UDB##
	DX1UDB##
	T78UDB##
	TM2UDB##

$LOW
CORLOC::0
IFN FTNET,<
MTANUM:	BLOCK	1		;COUNT OF MAGTAPES CONFIGURED
>

$HIGH
	END
