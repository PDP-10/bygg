TITLE	DX2COM -- COMMON CODE FOR ALL DEVICES DRIVEN THROUGH DX20'S V004
SUBTTL	G.M. UHLER/GMU	17 NOV 81
	SEARCH	F,S
	$RELOC
	$HIGH



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1981,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>


; DATE		LOAD	EDIT #
; ----		----	------
;
;24-MAR-81	70146	001
;27-OCT-81	70113	002
;02-NOV-81	70114	003
;17-NOV-81	70116	004
;

XP VDX2CM,004
SALL


;ASSEMBLY INSTRUCTIONS:
;	.R MACRO
;	*DX2COM,DX2COM/C=DX2COM

DX2COM::ENTRY	DX2COM


;TECHNICAL INFORMATION AND TECHNIQUES FOR PROGRAMMING THE
;RH20/DX20 ARE AVAILABLE IN THE FOLLOWING DOCUMENTS:
;
;  DX20 PROGRAMMED DEVICE ADAPTER TECHNICAL MANUAL,
;	DOCUMENT NUMBER EK-0DX20-TM-001, FEB 78
;  RH20 MASSBUS CONTROLLER UNIT DESCRIPTION,
;	DOCUMENT NUMBER EK-RH20-UD-001, AUG 76
	SUBTTL	MACRO DEFINITIONS


;MACRO TO COMPUTE THE WIDTH OF A MASK
;	"WID" RETURNS THE LENGTH OF THE LEFTMOST STRING OF
;	CONSECUTIVE ONES IN THE WORD.

DEFINE	WID(MASK),<<^L<-<<MASK>_<^L<MASK>>>-1>>>

;MACRO TO COMPUTE THE POSITION OF A MASK

DEFINE	POS(MASK),<<^L<MASK>+^L<-<<MASK>_<^L<MASK>>>-1>-1>>

;MACRO TO BUILD A POINTER TO A MASKED QUANTITY
;	POINTR	LOCATION,MASK

DEFINE	POINTR(LOC,MASK),<<POINT WID(MASK),LOC,POS(MASK)>>

;MACRO TO INSERT A VALUE IN A MASKED FIELD
;	INSVL.(VALUE,MASK)

DEFINE INSVL.(VALUE,MASK),<<<<VALUE>B<POS(<MASK>)>>&<MASK>>>
	SUBTTL	DX20 DEVICE DEPENDENT REGISTER/BIT DEFINITIONS


.DXMTR==03B5			;MAINTENANCE REGISTER
	MR.SCY==1B31		;MICROPROCESSOR SINGLE CYCLE
	MR.STR==1B33		;MICROPROCESSOR START
	MR.RES==1B34		;MICROPROCESSOR RESET

.DXMIR==30B5			;MICROCONTROLLER INSTRUCTION REGISTER

.DXPCR==31B5			;MICROPROCESSOR PC REGISTER
	PC.IRE==1B20		;INSTRUCTION REGISTER ENABLE
	PC.MSE==1B21		;MICROSTORE ENABLE
	PC.PCE==1B22		;PC ENABLE
	PC.PCI==1B23		;PC AUTO INCREMENT
	PC.MPC==7777B35		;MICROPROCESSOR PC

.DXIBR==36B5			;DIAGNOSTIC REGISTER 7
	DX.IBR==377		;CONTENTS OF THE BR REGISTER

.DXIPE==37B5			;DIAGNOSTIC REGISTER 7
	DX.IPE==1B22		;INSTRUCTION REGISTER PARITY ERROR

.CRM10==10			;LOCATION IN THE CRAM CONTAINING A CODE
				;  CHECKED BY THE DRIVERS TO SEE IF THE
				;  MICROCODE IS VALID

.DXSAD==1			;FULL START ADDRESS FOR ALL VERSIONS
				;  OF THE DX20 MICROCODE
	SUBTTL	FUNCTION TABLE DEFINITIONS FOR THE DX20 LOAD SUBROUTINES


;THE DX20 LOAD SUBROUTINE (DXLOAD) IS CALLED WITH THE ADDRESS OF A FUNCTION
;TABLE GIVING THE ADDRESSES OF THE DEVICE SPECIFIC ROUTINES TO CALL TO
;PERFORM FUNCTIONS.  IT THEN BLT'S THE EXTERNAL FUNCTION ADDRESSES
;HERE SO THAT IT CAN USE THEM IN BOTH THE LOAD AND VERIFY STEPS.
;NOTE THAT THE PROTOTYPE TABLE IS ALSO THE LOAD FUNCTION TABLE.
;THE FORMAT OF THE TABLE IS AS FOLLOWS:

	$LOW

DXLTAB:				;START OF THE TABLE USED TO LOAD THE
				;  MICROCODE

	PHASE	0

.FNUCA:! BLOCK	1		;ADDRESS OF MEMORY LOCATION CONTAINING THE
				;  PHYSICAL ADDRESS OF THE START OF THE
				;  MICROCODE
.FNUCS:! BLOCK	1		;ADDRESS OF MEMORY LOCATION CONTAINING THE
				;  SIZE OF THE MICROCODE IN THE FOLLOWING
				;  FORMAT:  XWD # PAGES,# BYTES
.FNDTO:! BLOCK	1		;ADDRESS OF THE ROUTINE TO DO DATAO OPERATIONS
				;  TO REGISTERS IN THE DX20.  THIS ROUTINE
				;  TAKES THE DATAO ARGUMENT IN T2 AND ONLY
				;  DESTROYS T2 AND T3
.FNDTI:! BLOCK	1		;ADDRESS OF THE ROUTINE TO DO DATAI OPERATIONS
				;  FROM REGISTERS IN THE DX20.  THIS ROUTINE
				;  TAKES A DATAO ARGUMENT TO LOAD INTO THE
				;  PREPARATION REGISTER IN T2 AND RETURNS THE
				;  CONTENTS OF THE REGISTER IN BITS  20-35
				;  OF T2.  BITS 0-29 MUST BE RETURNED AS 0.
.FNCHK:! BLOCK	1		;ADDRESS OF THE ROUTINE TO CHECK THE DEVICE
				;  SPECIFIC MICROSTORE LOCATIONS AFTER THE
				;  MICROCODE HAS BEEN LOADED.  THIS ROUTINE
				;  RETURNS NON-SKIP IF THE CHECK FAILS AND
				;  SKIP IF THE CHECK SUCCEEDS.  IT MUST
				;  NOT START THE MICROPROCESSOR.
.FNRES:! BLOCK	1		;ADDRESS OF THE ROUTINE TO RESET THE DX20
				;  MICROPROCESSOR.
.FNCFG:! BLOCK	1		;ADDRESS OF ROUTINE TO RETURN THE
				;  RH20 DEVICE CODE AND THE DX20 NUMBER
				;  OF THE DX20 BEING LOADED.  THIS
				;  ROUTINE RETURNS THE (FULL 9 BIT) RH20
				;  DEVICE CODE IN T1 AND THE DX20 NUMBER
				;  IN T2 AND RETURNS NON-SKIP ALWAYS
.FNMFL:!			;LENGTH OF EXTERNAL FUNCTION TABLE


				;CONTINUED ON THE NEXT PAGE
				;CONTINUED FROM THE PREVIOUS PAGE


;THE FOLLOWING ENTRIES IN THE FUNCTION TABLE ARE DEFINED INTERNALLY TO THIS
;ROUTINE AND ARE NEVER CHANGED BY THE CALLER.

.FNMSS:! EXP	.DXPCR!PC.MSE!PC.PCE ;.DXPCR REGISTER BITS THAT, WHEN OR'ED WITH
				;  THE ADDRESS OF THE CRAM LOCATION TO
				;  BE READ/WRITTEN, RESULT IN THAT LOCATION
				;  BEING READ INTO THE IR OR WRITTEN FROM THE
				;  IR.
.FNCRF:! EXP	LDCRAM		;ADDRESS OF THE ROUTINE TO LOAD/VERIFY THE
				;  CRAM.  THIS ROUTINE NON-SKIPS IF AN ERROR
				;  IS DETECTED AND SKIPS IF NO ERROR IS
				;  DETECTED
.FNWMF:! EXP	LDWM		;ADDRESS OF THE ROUTINE TO LOAD/VERIFY THE
				;  WORKING MEMORY.  THIS ROUTINE NON-SKIPS IF
				;  AN ERROR IS DETECTED AND SKIPS IF NO ERROR
				;  IS DETECTED.

	DEPHASE



;FUNCTION TABLE USED TO VERIFY THE MICROCODE THAT HAS JUST BEEN LOADED.

DXVTAB:	BLOCK	.FNMFL		;RESERVE SPACE FOR THE EXTERNAL FUNCTIONS
	.DXPCR!PC.IRE!PC.PCE	;BITS TO READ CRAM LOCATION
	EXP	VFCRAM		;ADDRESS OF ROUTINE TO VERIFY THE CRAM
	EXP	VFWM		;ADDRESS OF ROUTINE TO VERIFY WORKING MEMORY

	$HIGH
	SUBTTL	DX20 MICROCODE LOADING SUBROUTINES


;ROUTINE TO CLEAR, LOAD, AND VERIFY, AND START THE MICROCODE FOR A DX20.
;CALL:
;	T1/ADDRESS OF DEVICE SPECIFIC FUNCTION TABLE (SEE ABOVE)
;	PUSHJ	P,DXLOAD
;RETURN CPOPJ IF UNSUCCESSFUL
;	CPOPJ1 WITH MICROCODE LOADED BUT NOT STARTED

DXLOAD::SKIPE	.CPNLD##	;PROHIBITED FROM DOING THIS?
	POPJ	P,		;YES, JUST RETURN
	PUSHJ	P,SAVE1##	;SAVE P1
	HRLZS	T1		;PUT ADDRESS OF FUNCTION TABLE IN LH
	HRRI	T1,DXLTAB	;GET ADDRESS TO COPY IT TO
	BLT	T1,DXLTAB+.FNMFL-1 ;COPY THE PART SPECIFIED BY THE USER
	MOVE	T1,[DXLTAB,,DXVTAB] ;NEED TO DUPLICATE IT FOR THE VERIFY TABLE
	BLT	T1,DXVTAB+.FNMFL-1 ;DO SO
	MOVEI	P1,DXLTAB	;GET ADDRESS OF THE LOAD TABLE IN P1
	PUSHJ	P,@.FNRES(P1)	;RESET THE MICROPROCESSOR
	PUSHJ	P,DXCLR		;CLEAR THE CRAM AND WORKING MEMORY
	PUSHJ	P,DXFUNC	;LOAD THE MICROCODE
	  JRST	DXLOA1		;FAILED
	MOVEI	P1,DXVTAB	;GET ADDRESS OF THE VERIFY TABLE IN P1
	PUSHJ	P,DXFUNC	;VERIFY THE MICROCODE THAT WE JUST LOADED
	  JRST	DXLOA1		;FAILED
	PUSHJ	P,@.FNCHK(P1)	;DO A FINAL CHECK ON THE MICROSTORE
	  POPJ	P,		;FAILED
	PUSHJ	P,RDCRM0	;READ THE VERSION NUMBER FROM CRAM LOC 0
	PUSH	P,T2		;SAVE THE VERSION NUMBER
	PUSHJ	P,DXSTRT	;START THE DX20
	POP	P,T1		;GET THE MICROCODE VERSION NUMBER BACK
	PUSHJ	P,DXVERS	;PRINT THE VERSION INFORMATION
	JRST	CPOPJ1##	;GIVE SKIP RETURN
DXLOA1:	MOVEI	T2,.CRM10	;WRITE A 0 INTO CRAM LOCATION 10
	MOVEI	T3,0		;  SO THAT ATTEMPTS TO START THIS DX20
	PJRST	WRCRAM		;  WILL FAIL


;It might occur to someone to call DXVERS before DXSTRT to save the
;PUSH and POP of the microcode version number.  It is done that way
;to waste enough KL CPU time to give the DX20 microprocessor enough
;time to get through its full initialization and get to the idle
;loop before a massbus init or a call to the reset routine stops
;it again.  If the DX20 doesn't finish its initialization, the
;restart of the microprocessor (at a different start address than
;that used by DXSTRT) will cause strange things to happen.
;ROUTINE TO LOAD OR VERIFY THE MICROCODE IN A DX20.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,DXFUNC
;RETURN CPOPJ IF ERROR
;	CPOPJ1 WITH FUNCTION PERFORMED SUCCESSFULLY

DXFUNC:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	HRRZ	P3,@.FNUCS(P1)	;GET SIZE (IN BYTES) OF THE MICROCODE
	JUMPE	P3,CPOPJ##	;DON'T HAVE ANY, CAN'T LOAD IT
	SKIPN	@.FNUCA(P1)	;MAKE SURE WE HAVE AN ADDRESS
	POPJ	P,		;DON'T HAVE ONE, DON'T LOAD IT
	MOVSI	P2,(POINT 7,0)	;GET A BYTE POINTER TO THE MICROCODE
	PUSH	P,F		;NEED ANOTHER AC, USE F
DXFUN1:	PUSHJ	P,ADXHDR	;CRACK THE HEADER OF THE NEXT LINE
	  JRST	FPOPJ##		;RESTORE F AND GIVE ERROR RETURN
	MOVNI	P4,(T2)		;GET WORD COUNT OF LOAD LINE
	JUMPE	P4,FPOPJ1##	;DONE WITH WORD COUNT=0
	HRLZS	P4		;PUT -VE WORD COUNT IN LH OF P4
	HRR	P4,T1		;PUT LOAD ADDRESS IN RH
	HRRZ	F,T2		;INITIALIZE LINE CHECKSUM WITH WORDCOUNT
	ADD	F,T1		;INCLUDE ADDRESS IN WORDCOUNT
	HLL	P1,T2		;USE SIGN BIT OF P1 AS FLAG FOR CRAM/WM
	JUMPGE	P1,DXFUN2	;GO IF LOADING CRAM LINE
	PUSHJ	P,RDCRM0	;READ THE CONTENTS OF CRAM LOCATION 0
	HRL	F,T2		;SAVE CRAM LOCATION 0 IN LH(F)
	HRRZ	T2,P4		;GET THE BASE ADDRESS OF THE LINE
	PUSHJ	P,LDMAR		;SET MAR/MARX TO THAT VALUE
DXFUN2:	PUSHJ	P,ADXWRD	;GET NEXT WORD OF DATA FROM THE LINE
	  JRST	FPOPJ##		;ERROR, GIVE NON-SKIP RETURN
	ADD	F,T1		;INCLUDE IT IN THE CHECKSUM
	JUMPL	P1,DXFUN3	;GO IF DOING WORKING MEMORY
	HRRZ	T2,P4		;GET BASE ADDRESS OF LINE
	IOR	T2,.FNMSS(P1)	;INCLUDE DATAO BITS TO READ/WRITE CRAM
	PUSHJ	P,@.FNDTO(P1)	;INITIALIZE ADDRESS OF CRAM LOCATIONS
	PUSHJ	P,@.FNCRF(P1)	;DISPATCH TO CRAM FUNCTION ROUTINE
	  JRST	FPOPJ##		;ERROR, GIVE NON-SKIP RETURN
	JRST	DXFUN4		;JOIN COMMON CODE
DXFUN3:	ANDI	T1,377		;KEEP ONLY 8 BITS OF WM DATA
	PUSHJ	P,@.FNWMF(P1)	;DISPATCH TO WORKING MEMORY FUNCTION ROUTINE
	  JRST	FPOPJ##		;ERROR, GIVE NON-SKIP RETURN
DXFUN4:	AOBJN	P4,DXFUN2	;LOOP FOR ALL WORDS ON LINE
	JUMPGE	P1,DXFUN5	;GO IF DOING WORKING MEMORY LOAD LINE
	MOVEI	T2,0		;RESTORE THE VALUE THAT WAS IN CRAM LOCATION
	HLRZ	T3,F		;  0 BEFORE WE STARTED
	PUSHJ	P,WRCRAM	;  LOADING WORKING MEMORY
DXFUN5:	PUSHJ	P,ADXWRD	;GET THE LAST WORD (CHECKSUM) ON THE LINE
	  CAIA			;MUST HAVE END-OF-LINE HERE
	JRST	FPOPJ##		;ELSE ERROR
	ADD	F,T1		;INCLUDE THAT IN THE CHECKSUM
	TRNE	F,177777	;MUST COME OUT TO 16 BITS OF 0
	JRST	FPOPJ##		;ELSE, ERROR
	JRST	DXFUN1		;DO THE NEXT LINE
;ROUTINE TO CLEAR THE CRAM AND WORKING MEMORY OF A DX20.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,DXCLR
;RETURN CPOPJ ALWAYS

DXCLR:	PUSH	P,F		;SAVE F
	MOVSI	F,-4000		;4000 LOCATIONS TO CLEAR IN THE CRAM
DXCLR1:	HRRZ	T2,F		;GET THE ADDRESS TO WRITE
	MOVEI	T3,0		;PUT A ZERO IN IT
	PUSHJ	P,WRCRAM	;WRITE THE CRAM LOCATION
	AOBJN	F,DXCLR1	;WRITE THEM ALL

	MOVEI	T2,0		;SET THE MAR/MAR EXTENSION
	PUSHJ	P,LDMAR		;  TO 0
	MOVEI	F,2000		;2000 LOCATIONS IN THE WORKING MEMORY
DXCLR2:	MOVEI	T2,11400	;LDMEM 0,I MICROINSTRUCTION
	PUSHJ	P,DXXCT		;CLEAR NEXT LOCATION IN WORKING MEMORY
	SOJG	F,DXCLR2	;DO THEM ALL
	JRST	FPOPJ##		;RESTORE F AND RETURN


;ROUTINE TO START THE DX20 MICROPROCESSOR AT THE FULL START ENTRY
;POINT.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,DXSTRT
;RETURN CPOPJ ALWAYS

DXSTRT:	PUSHJ	P,@.FNRES(P1)	;MAKE SURE THE PROCESSOR IS RESET
	MOVE	T2,[.DXPCR!PC.IRE!PC.PCE!PC.PCI!INSVL.(.DXSAD,PC.MPC)]
	PUSHJ	P,@.FNDTO(P1)	;SET THE PC TO THE FULL START ADDRESS
	MOVE	T2,[.DXMTR!MR.STR] ;MAINTENANCE REGISTER+START BIT
	PJRST	@.FNDTO(P1)	;START THE MICROPROCESSOR AND RETURN
;ROUTINE TO READ THE CONTENTS OF CRAM LOCATION 0.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,RDCRM0
;RETURN CPOPJ ALWAYS WITH:
;	T2/CONTENTS OF CRAM LOCATION 0

RDCRM0:	MOVE	T2,[.DXPCR!PC.IRE!PC.PCE!INSVL.(0,PC.MPC)] ;SET TO READ
	PUSHJ	P,@.FNDTO(P1)	;  CRAM LOCATION 0
	MOVSI	T2,(.DXMIR)	;READING THIS REGISTER RETURNS THE VALUE
	PJRST	@.FNDTI(P1)	;  THAT IS ADDRESSED BY THE PC REGISTER


;ROUTINE TO WRITE A WORD INTO A DX20 CRAM LOCATION.
;CALL:
;	T2/ADDRESS OF LOCATION TO WRITE
;	T3/DATA TO BE WRITTEN
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,WRCRAM
;RETURN CPOPJ ALWAYS

WRCRAM:	PUSH	P,T3		;SAVE THE DATA TO BE WRITTEN
	TDO	T2,[.DXPCR!PC.MSE!PC.PCE] ;PC REGISTER+BITS TO ENABLE
	PUSHJ	P,@.FNDTO(P1)	;  MICROSTORE AND PC WRITES
	POP	P,T2		;RESTORE THE DATA TO BE WRITTEN
	HRLI	T2,(.DXMIR)	;WRITES INTO THE IR GO INTO THE CRAM LOCATION
	PJRST	@.FNDTO(P1)	;  ADDRESSED BY THE PC REGISTER


;ROUTINE TO LOAD THE DX20 MEMORY ADDRESS AND ADDRESS EXTENSION REGISTERS
;(MAR AND MARX) WITH A VALUE.
;CALL:
;	T2/ADDRESS TO LOAD
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,LDMAR
;RETURN CPOPJ ALWAYS

LDMAR:	PUSH	P,T2		;SAVE THE ADDRESS TO LOAD
	ANDI	T2,377		;KEEP LOW 8 BITS
	TRO	T2,1000		;ADD A LDMAR MICROINSTRUCTION
	PUSHJ	P,DXXCT		;EXECUTE IT
	POP	P,T2		;RESTORE THE ADDRESS TO LOAD
	LSH	T2,-^D8		;GET 2 HIGH ORDER BITS
	TRO	T2,400		;ADD A LDMARX MICROINSTRUCTION
	PJRST	DXXCT		;EXECUTE THAT AND RETURN
;ROUTINE TO CAUSE THE DX20 TO EXECUTE AN INSTRUCTION.
;CALL:
;	T2/MICROINSTRUCTION TO EXECUTE
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,DXXCT
;RETURN CPOPJ ALWAYS

DXXCT:	PUSH	P,T2		;SAVE THE INSTRUCTION TO EXECUTE
	MOVE	T2,[.DXMTR!MR.SCY] ;GET MAINTENANCE REGISTER AND SINGLE CYLCLE
	PUSHJ	P,@.FNDTO(P1)	;FORCE THE DX20 INTO SINGLE CYCLE MODE
	MOVEI	T2,0		;STORE THE INSTRUCTIN TO EXECTUTE IN CRAM LOC 0
	POP	P,T3		;RESTORE THE INSTRUCTION TO EXECUTE
	PUSHJ	P,WRCRAM	;WRITE IT INTO THE CRAM
	MOVE	T2,[.DXPCR!PC.IRE!PC.PCI] ;PC REG+IR ENABLE+PC AUTO INCR
	PUSHJ	P,@.FNDTO(P1)	;SETUP TO EXECUTE THE INSTRUCTION
	MOVE	T2,[.DXMTR!MR.SCY!MR.STR] ;MAINT REG+SINGLE CYCLE+START
	PUSHJ	P,@.FNDTO(P1)	;EXECUTE THE INSTRUCTION
	MOVSI	T2,(.DXMTR)	;CLEAR SINGLE CYCLE AND LEAVE START OFF
	PJRST	@.FNDTO(P1)	;CLEAR START AND RETURN
;ROUTINE TO LOAD DATA INTO A CRAM LOCATION.
;CALL:
;	T1/16 BITS OF DATA TO WRITE
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,LDCRAM
;RETURN CPOPJ1 ALWAYS

LDCRAM:	HRRZ	T2,T1		;MOVE DATA TO THE RIGHT AC
	HRLI	T2,(.DXMIR)	;ADD THE REGISTER THAT WE WANT
	PUSHJ	P,@.FNDTO(P1)	;DO THE DATAO THAT CAUSES THE WRITE
	JRST	CPOPJ1##	;GIVE SKIP RETURN


;ROUTINE TO LOAD DATA INTO A WORKING MEMORY LOCATION.
;CALL:
;	T1/8 BITS OF DATA TO WRITE
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,LDWM
;RETURN CPOPJ1 ALWAYS

LDWM:	HRRZ	T2,T1		;GET DATA INTO THE WRITE AC
	TRO	T2,11400	;ADD A LDMEM N,I MICROINSTRUCTION
	PUSHJ	P,DXXCT		;EXECUTE THE INSTRUCTION
	JRST	CPOPJ1##	;GIVE SKIP RETURN
;ROUTINE TO VERIFY THE DATA IN A CRAM LOCATION.
;CALL:
;	T1/16 BITS OF CRAM DATA
;	P1/ADDRESS OF THE FUNCTION TABLE
;	PUSHJ	P,VFCRAM
;RETURN CPOPJ IF NO MATCH
;	CPOPJ1 IF MATCH

VFCRAM:	MOVSI	T2,(.DXMIR)	;READ THIS REGISTER TO GET THE DATA
	PUSHJ	P,@.FNDTI(P1)	;READ THE DATA
	CAIE	T2,(T1)		;MATCH WITH WHAT IT SHOULD BE?
	POPJ	P,		;NO, GIVE NO SKIP RETURN
	JRST	CPOPJ1##	;GIVE SKIP RETURN


;ROUTINE TO VERIFY THE DATA IN A WORKING MEMORY LOCATION
;CALL:
;	T1/8 BITS OF DATA
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,VFWM
;RETURN CPOPJ IF NO MATCH
;	CPOPJ1 IF MATCH

VFWM:	MOVEI	T2,043411	;GET A MOVMEM BR,I MICROINSTRUCTION
	PUSHJ	P,DXXCT		;EXECUTE IT
	MOVSI	T2,(.DXIBR)	;REGISTER TO READ THE BR
	PUSHJ	P,@.FNDTI(P1)	;READ THE REGISTER
	ANDI	T2,DX.IBR	;KEEP ONLY THE BR OUTPUT
	CAIE	T2,(T1)		;MATCH?
	POPJ	P,		;NO
	JRST	CPOPJ1##	;YES, GIVE SKIP RETURN
;ROUTINE TO SEND A MESSAGE TO THE CTY TELLING THE OPERATOR THAT
;WE'VE LOADED THE DX20 MICROCODE.
;CALL:
;	T1/DX20 MICROCODE VERSION AND EDIT NUMBERS
;	P1/ADDRESS OF FUNCTION TABLE
;	PUSHJ	P,DXVERS
;RETURN CPOPJ ALWAYS

DXVERS:	PUSHJ	P,SAVE2##	;SAVE P1-P2
	PUSH	P,U		;  AND U
	HRRZ	U,CTYLDB##	;GET LDB ADDRESS OF CTY
	MOVE	P2,T1		;SAVE THE MICROCODE VERSION NUMBER
	PUSHJ	P,INLMES##	;START THE MESSAGE
	ASCIZ/[DX20 microcode v/
	LDB	T1,[POINT 6,P2,25] ;GET THE VERSION NUMBER
	PUSHJ	P,PRTDI8##	;PRINT IT
	PUSHJ	P,INLMES##	;MORE TEXT
	ASCIZ/(/
	LDB	T1,[POINT 10,P2,35] ;GET THE EDIT NUMBER
	PUSHJ	P,PRTDI8##	;PRINT IT
	PUSHJ	P,INLMES##	;MORE TEXT
	ASCIZ/) loaded on /
	MOVE	T2,.CPLOG##	;GET THE NAME OF THE CPU THAT WE'RE ON
	PUSHJ	P,PRNAME##	;PRINT IT
	PUSHJ	P,INLMES##	;MORE TEXT
	ASCIZ/, RH20 /
	PUSHJ	P,@.FNCFG(P1)	;GET THE RH20/DX20 NUMBERS
	PUSH	P,T2		;SAVE THE DX20 NUMBER
	PUSHJ	P,PRTDI8##	;PRINT THE RH20 NUMBER
	PUSHJ	P,INLMES##	;MORE TEXT
	ASCIZ/, DX20 /
	POP	P,T1		;RESTORE THE DX20 NUMBER
	PUSHJ	P,PRTDI8##	;PRINT IT
	SKIPE	DINITF##	;IN ONCE ONLY?
	JRST	DXVER1		;YES, DON'T HAVE THE DATE/TIME YET
	PUSHJ	P,INLMES##	;MORE TEXT
	ASCIZ/ on /
	PUSHJ	P,DATIME##	;TYPE DATE AND TIME
DXVER1:	PUSHJ	P,INLMES##	;MORE TEXT
	ASCIZ/]
/
	JRST	UPOPJ##		;RESTORE U AND RETURN
;ROUTINE TO READ AND PROCESS THE HEADER PORTION OF A LINE FROM AN .ADX FILE.
;THE HEADER CONTAINS THE TYPE OF LINE (COMMENT, CRAM LOAD LINE, OR WORKING
;MEMORY LOAD LINE), THE BASE ADDRESS OF THE LOAD LINE, AND THE WORD COUNT
;OF THE LOAD LINE.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	P2/BYTE POINTER TO .ADX DATA
;	P3/BYTE COUNT TO .ADX DATA
;	PUSHJ	P,ADXHDR
;RETURN CPOPJ IF ERROR
;RETURN CPOPJ1 IF LEGAL HEADER WITH:
;	T1/BASE ADDRESS OF LOAD LINE
;	T2/FLAG,,WORD COUNT OF LOAD LINE WHERE
;		FLAG=1B0=0 IF CRAM LOAD LINE,
;		        =1 IF WORKING MEMORY LOAD LINE

ADXHDR:	PUSH	P,F		;SAVE F
	SETZM	F		;ZERO THE AC
ADXHD1:	PUSHJ	P,ADXCHR	;GET FIRST CHARACTER FROM LINE
	CAIN	T1,";"		;IS THIS THE START OF A COMMENT LINE?
	JRST	ADXHD3		;YES, SKIP IT
	CAIN	T1,"C"		;START OF A CRAM LOAD LINE?
	JRST	ADXHD2		;YES, PROCESS IT
	CAIE	T1,"W"		;START OF A WORKING MEMORY LOAD LINE?
	JRST	FPOPJ##		;NO, ERROR IN THE FILE
	TLO	F,(1B0)		;SET FLAG FOR WORKING MEMORY LOAD LINE
ADXHD2:	PUSHJ	P,ADXCHR	;GET NEXT CHARACTER FROM LOAD LINE
	CAIE	T1," "		;MUST BE A SPACE
	JRST	FPOPJ##		;ERROR IN THE FILE
	PUSHJ	P,ADXWRD	;GET THE WORD COUNT FOR THE LOAD LINE
	  JRST	FPOPJ##		;CAN'T HAVE END-OF-LINE HERE
	HRR	F,T1		;SAVE IT IN P1
	PUSHJ	P,ADXWRD	;GET THE BASE ADDRESS FOR THE LOAD LINE
	  JRST	FPOPJ##		;CAN'T HAVE END-OF-LINE HERE
	MOVE	T2,F		;PUT FLAG,,WORD COUNT IN T2
	JRST	FPOPJ1##	;GIVE SKIP RETURN TO CALLER
ADXHD3:	PUSHJ	P,ADXCHR	;GET NEXT CHARACTER FROM LINE
	JUMPL	T1,FPOPJ##	;GIVE UP IF ERROR
	JUMPN	T1,ADXHD3	;LOOP IF MORE DATA TO FLUSH
	JRST	ADXHD1		;TRY NEXT LINE AFTER FLUSHING THIS ONE

;ROUTINE TO READ ONE "WORD" FROM AN .ADX FILE LOAD LINE.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	P2/BYTE POINTER TO .ADX DATA
;	P3/BYTE COUNT TO .ADX DATA
;	PUSHJ	P,ADXWRD
;RETURN CPOPJ IF DATA IS TERMINATED BY A CRLF
;	CPOPJ1 IF DATA IS TERMINATED BY A COMMA WITH:
;	T1/DATA WORD

ADXWRD:	PUSH	P,F		;SAVE F
	SETZM	F		;INITIALIZE ACCUMULATION REGISTER
ADXWR1:	PUSHJ	P,ADXCHR	;GET NEXT CHARACTER FROM LOAD LINE
	JUMPL	T1,ADXWR2	;GO IF ERROR DETECTED
	CAIN	T1,","		;TERMINATOR FOUND?
	JRST	ADXWR3		;YES
	JUMPE	T1,ADXWR4	;END-OF-LINE FOUND?
	LSH	F,6		;NO, MAKE ROOM FOR THE CHARACTER
	CAIE	T1," "		;WAS IT A SPACE?
	DPB	T1,[POINT 6,F,35] ;NO, STORE RIGHT 6 BITS IN WORD
	JRST	ADXWR1		;LOOP FOR NEXT CHARACTER
ADXWR2:	TDZA	F,F		;ZERO F ON AN ERROR
ADXWR3:	AOS	-1(P)		;GIVE SKIP RETURN IF TERMINATOR WAS A COMMA
ADXWR4:	MOVE	T1,F		;RETURN ACCUMULATED WORD IN T1
	ANDI	T1,177777	;KEEP ONLY 16 BITS OF DATA
	JRST	FPOPJ##		;RESTORE F AND RETURN

;ROUTINE TO READ ONE CHARACTER FROM THE .ADX FILE.  SURPRESSES NULLS AND
;CARRIAGE RETURNS.
;CALL:
;	P1/ADDRESS OF FUNCTION TABLE
;	P2/BYTE POINTER TO .ADX FILE DATA
;	P3/BYTE COUNT FOR .ADX FILE DATA
;	PUSHJ	P,ADXCHR
;RETURN CPOPJ ALWAYS WITH:
;	T1/CHARACTER, -1 IF ERROR, 0 IF END-OF LINE

ADXCHR:	PUSH	P,U		;SAVE U (INPUT ARGUMENT TO REFMEM)
ADXCH1:	SOJL	P3,ADXCH2	;GO IF BYTE COUNT EXHAUSTED
	IBP	P2		;INCREMENT THE BYTE POINTER IN P1
	MOVE	U,@.FNUCA(P1)	;GET PHYSICAL ADDRESS OF START OF UCODE
	ADDI	U,(P2)		;ADD IN OFFSET OF WORD WE WANT
	PUSHJ	P,REFMEM##	;GET THE WORD FROM PHYSICAL MEMORY
	HLLZ	U,P2		;GET THE LEFT HALF OF THE BYTE POINTER
	HRRI	U,T1		;MAKE IT POINT TO T1
	LDB	T1,U		;GET THE BYTE WE WANT FROM THE WORD
	JUMPE	T1,ADXCH1	;IGNORE IT IF NULL
	CAIN	T1,15		;CARRIAGE RETURN?
	JRST	ADXCH1		;YES, IGNORE IT
	CAIN	T1,12		;LINE FEED?
	MOVEI	T1,0		;YES, TURN THAT INTO A NULL
	JRST	UPOPJ##		;RESTORE U AND RETURN
ADXCH2:	SETOM	T1		;RETURN T1=-1 IF ERROR
	JRST	UPOPJ##		;RESTORE U AND RETURN


	END
