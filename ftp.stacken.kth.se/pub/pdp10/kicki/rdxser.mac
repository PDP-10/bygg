TITLE RDXSER -REMOTE DATA ENTRY SERVICE ROUTINE TO SUPPORT MCS10 - V052
SUBTTL	D. TODD/WEM   26 JUL 83
	SEARCH	F,S,NETPRM
	$RELOC
	$HIGH



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1978,1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>
;
;
; DATE		LOAD	EDIT #
; ----		----	------
;
;04-NOV-80	70125	043
;27-APR-82	70144	044
;9972
;25-MAY-82	70150	045
;08-JUN-82	70152	046
;22-JUNE-82	70154	047
;31-MAY-83	70143	050
;28-JUN-83	70150	051
;26-JUL-83	70153	052
;
;XP VRDXSER,052	;PUT VERSION NUMBER IN GLOB AND LOADER MAP

NETRDX::ENTRY	NETRDX


;RDX ONLY DEVICE STATUS BITS

	IOSDRP==IOSFFB		;INDICATES THAT THIS IS A MULTIDROP RDX
SUBTTL 1.0      UUOCON INTERFACE.

	JRST	NTDONL##	;(-5) ONLINE CHECK
	JRST	CPOPJ##		;(-4) SPECIAL ERROR STATUS
	JRST	REGSIZ##	;(-3) LENGTH CAN BE GOTTEN FROM DDB
	JRST	CPOPJ##		;(-2) INITIALIZE
	JRST	CPOPJ##		;(-1) HUNG DEVICE
NDEVRD::JRST	NTDREL##	;(0)  RELEASE
	JRST	NTDCLO##	;(1)  CLOSE OUTPUT
	JRST	R.OUT		;(2)  OUTPUT
	JRST	R.IN		;(3)  INPUT
	JRST	CPOPJ##		;(4)  ENTER
	JRST	CPOPJ##		;(5)  LOOKUP
	JRST	NTDILI##	;(6)  DUMP MODE INPUT
	JRST	NTDILO##	;(7)  DUMP MODE OUTPUT
	JRST	CPOPJ##		;(10) USETO
	JRST	CPOPJ##		;(11) USETI
	JRST	CPOPJ##		;(12) GETF UUO
	JRST	CPOPJ##		;(13) RENAME UUO
	JRST	CPOPJ##		;(14) CLOSE INPUT
	JRST	CPOPJ##		;(15) UTPCLR
	JRST	CPOPJ##		;(16) MTAPE UUO
SUBTTL 1.1        DDB SEARCH LOGIC INTERFACE (TSTRDX)

;TSTRDX	ROUTINE TO SEE IF A RDX DDB SHOULD BE CREATED.  CALLED FROM
; UUOCON'S DDB SEARCH LOGIC ROUTINE.
;CALL	MOVEI	P1,FLAGS	;(ONLY MATCH IF LOOKING FOR PHYSICAL DEVICE)
;	MOVE	T1,[SIXBIT /RD?NNX/] ;DEVICE NAME
;	PUSHJ	P,TSTRDX
;RETURN	CPOPJ			;NOT AN RDX DEVICE
;	CPOPJ1			;IS AN RDX DEVICE. F := RDX DDB.
;
TSTRDX::HLRZ	T2,T1		;GET JUST THE NAME
	XORI	T2,'RDA'	;"COMPARE" IT WITH SIXBIT /RDA/
	TRNN	T2,777700	;MAKE SURE IT'S OF THE FORM RD?
	TRNE	P1,DD%LOG##	;MAKE SURE IT'S A PHYSICAL DEVICE SEARCH
	POPJ	P,		;EITHER NOT RD?, OR LOGICAL DEVICE
	NETDBJ			;BETTER INTERLOCK FROM HERE ON OUT.
	PUSHJ	P,SAVJW##	;WE CLOBBER W RIGHT AWAY, AND J IF WE CONNECT.
	PUSHJ	P,SAVE4##	;NETSER CLOBBERS MOST OF THESE
	PUSH	P,T1		;SAVE THE DEVICE NAME
	PUSHJ	P,DVSCVT##	;GET THE NODE NUMBER FROM THE NAME
	  PJRST	TPOPJ##		;NOT A NETWORK NAME.
	MOVEI	T1,(T2)		;COPY THE NODE NUMBER
	PUSHJ	P,SRCNDB##	;GET A NDB POINTER
	  PJRST	TPOPJ##		;NO NODE MEANS NO RDX
	MOVEI	P1,(W)		;COPY THE NDB POINTER FOR MAKDDB
	MOVEI	T1,'RDA'	;GET GENERIC DEVICE NAME IN RH(T1)
	PUSHJ	P,SRCNDT##	;SEE IF THE NODE SUPPORTS RDA'S
	  PJRST	TPOPJ##		;IF NOT, THEN DEVICE DOESN'T EXIST
	LDB	T1,[POINT 6,(P),17] ;POINT TO "CONTROLLER" CHARACTER
	CAIL	T1,'A'		;MAKE SURE THAT IT'S IN THE
	CAILE	T1,'H'		; RANGE A-H (= 0-7)
	PJRST	TPOPJ##		;NOT AN RDX DEVICE IF NOT IN RANGE
	SUBI	T1,'A'		;CONVERT TO A CONTROLLER NUMBER
	LDB	T2,[POINT 6,(P),35] ;GET THE UNIT DIGIT (NUMERIC)
	CAIL	T2,'0'		;MAKE SURE THAT IT'S IN THE
	CAILE	T2,'7'		; RANGE 0-7
	PJRST	TPOPJ##		;NOT A VALID DIGIT.
	SUBI	T2,'0'		;CONVERT NUMERIC TO NUMBER
	LSH	T1,3		;CONTROLLER BECOMES TOP HALF OF "PUNIT"
	IORI	T1,(T2)		;T1 := FULL UNIT SPECIFICATION
	PUSH	P,T1		;SAVE "PUNIT" VALUE UNTIL WE SEND THE CONNECT.

	MOVE	P2,-1(P)	;GET THE FULL NAME BACK
	SETZ	P3,		;THERE IS NO LOGICAL NAME
	PUSHJ	P,MAKDDB##	;MAKE A DDB (NDB POINTER IN P1)
	  JRST	[POP P,T1	;NO CORE. FLUSH THE UNIT NUMBER
		 JRST TPOPJ##]	;AND GIVE THE ERROR RETURN
	POP	P,T1		;GET THE UNIT NUMBER BACK
	DPB	T1,PUNIT##	;STORE THE UNIT NUMBER IN THE DDB
	MOVEI	W,(P1)		;SET UP THE NDB POINTER AGAIN
	PUSHJ	P,NTDCNT##	;ATTEMPT TO CONNECT THE DEVICE
	  JRST	[PUSHJ P,UNLDDB## ;CONNECT FAILED. FREE THE DDB
		 JRST TPOPJ##]	;AND GIVE UUOCON THE ERROR RETURN
	PUSHJ	P,LNKDDB##	;IT CONNECTED. PUT THE DDB IN THE CHAIN
	LDB	T1,NETDVT##	;GET THE ATTRIBUTES
	TRNN	T1,DRX.MD	;IS THIS A MULTIDROP LINE?
	TDZA	T2,T2		;NO, LEAVE DEVSTS 0
	MOVEI	T2,1		;YES, LEAVE A 1 IN DEVSTS
	MOVEM	T2,DEVSTS(F)	;SET DEVSTS FOR USERS TO LOOK AT
	LSH	T2,<^D35-^L<IOSDRP>>+^D18  ;POSITION IOSDRP
	IORB	T2,DEVIOS(F)	;AND SET INTERNAL MULTI-DROP LINE FLAG
	PJRST	TPOPJ1##	;ALL DONE. GOOD RETURN, F := DDB POINTER.
SUBTTL 1.2        OUTPUT UUO.

R.OUT:	PUSHJ	P,SAVE4##	;NETSER LIKES ITS P'S.
	MOVSI	S,IOSUSO	;CLEAR "UUOCON STOPPED OUTPUT" SINCE
	ANDCAB	S,DEVIOS(F)	;  IT'S TRYING TO START IT NOW

ROLOOP:	PUSHJ	P,NTDSET##	;SET UP "W" ETC.
	MOVSI	S,IO		;MARK DIRECTION AS OUTPUT
	IORB	S,DEVIOS(F)	;SO THAT "WAIT" WORKS RIGHT
	PUSHJ	P,NTDONL##	;MAKE SURE WE ARE STILL CONNECTED
	  JRST	R.DERR		;NOT THERE?? RETURN IODERR
	LDB	T2,PIOMOD##	;GET THE DEVICE MODE
	MOVEI	T1,7		;ASSUME THAT IT'S ASCII (7 BIT BYTES)
	CAIN	T2,BYTMOD	;BUT CHANGE OUR MINDS IF IT'S BYTE MODE
	MOVEI	T1,^D8		;(8 BIT BYTES)
	PUSHJ	P,NTDSOB##	;SET UP THE OUTPUT BUFFER
	  POPJ	P,		;NO MORE OUTPUT DATA.  RETURN TO UUOCON.
	SKIPN	DEVAXO+1(F)	;MAKE SURE WE DON'T TRY TO SEND
	JRST	ROLOO2		; A ZERO LENGTH BUFFER
	PUSHJ	P,NTDCDQ##	;CHECK FOR AVAILABLE DATA REQUESTS
	  JRST	ROWAIT		;IF NONE, THEN WE MUST WAIT
	TLNE	S,IOSDRP	;IS THIS A MULTIDROP LINE?
	JRST	R.MXMT		;IF MULTIDROP, THEN USE SPECIAL ROUTINE
	MOVEI	T1,PCV.NC	;NO CONVERSION AT FEK TIME
	MOVEI	T2,DC.DAR	;DATA WITH END OF RECORD
	PUSHJ	P,NTDXMT##	;SEND A PCB'S WORTH OF DATA
	  PUSHJ	P,[JUMPN T1,NTDSTP## ;WE SHOULD NEVER GET AN IO-ERROR
		   POP P,(P)	;CLEAN OFF THE RETURN ADDRESS (UGLY)
		   PUSHJ P,NETSLP## ;PAUSE FOR FREECORE
		   JRST ROLOOP]	; AND TRY AGAIN
	PUSHJ	P,NTDDDQ##	;UPDATE THE DATA REQUEST COUNT
ROLOO1:	SKIPE	DEVAXO+1(F)	;DID THAT FINISH OFF THE BUFFER?
	JRST	ROLOOP		;IF NOT, THEN  GO TRY TO SEND SOME MORE
ROLOO2:	SETZM	DEVAXO+1(F)	;INDICATE THAT THE BUFFER IS ALL GONE
	PUSHJ	P,NTDAOB##	;ADVANCE THE OUTPUT BUFFER
	JRST	ROLOOP		;GO TRY TO SEND MORE


ROWAIT:	PUSHJ	P,NTDWTO##	;WAIT FOR A DATA REQUEST
	  POPJ	P,		;  IF NON-BLOCKING, RETURN TO UUOCON.
	JRST	ROLOOP		;GO TRY TO SEND MORE NOW.
;MULTIDROP RDX OUTPUT CODE.

R.MXMT:	SETZ	T1,		;WE WILL ACCUMULATE THE DROP NUMBER HERE
	MOVEI	T2,5		;THERE ARE 5 CHARACTERS IN THE DROP NUMBER

R.MXM1:	SOSGE	DEVAXO+1(F)	;COUNT OFF ONE MORE BYTE
	JRST	R.IMPM		;BUFFER DIDN'T CONTAIN A DROP NUMBER??
	EXCTUX	<ILDB T3,DEVAXO(F)> ;GET THE NEXT CHARACTER FROM THE BUFFER
	CAIN	T3," "		;IF IT'S A SPACE,
	MOVEI	T3,"0"		; THEN TREAT IT AS A ZERO
	CAIL	T3,"0"		;MAKE SURE THAT IT'S IN THE RANGE
	CAILE	T3,"9"		; 0-9 (DECIMAL)
	JRST	R.IMPM		;BAD DROP NUMBER. SET IOIMPM
	SUBI	T3,"0"		;CONVERT NUMERIC TO A NUMBER
	IMULI	T1,^D10		;MULTIPLY THE PARTIAL NUMBER BY THE RADIX
	ADDI	T1,(T3)		;ADD IN THE NEXT DIGIT
	SOJG	T2,R.MXM1	;LOOP OVER ALL FIVE DIGITS.

	PUSH	P,T1		;SAVE THE DROP NUMBER
	JFFO	T1,.+2		;GET 36-LOG(T1)
	MOVEI	T2,^D35		;ASSUME "0" IS ONE BIT LONG
	SUBI	T2,^D36+6	;THESE TWO INSTRUCTIONS FIND THE NUMBER OF
	MOVN	T2,T2		; SIGNIFICANT BITS IN THE DROP NUMBER (ROUND UP)
	IDIVI	T2,7		;NOW GET NUMBER OF "EXTENSIBLE" BYTES
	PUSH	P,T2		;SAVE THE DROP NUMBER'S LENGTH

	MOVEI	T1,^D32		;GET A 32 WORD LONG PCB
	PUSHJ	P,NTDHDR##	; AND FILL IN THE HEADER UP TO THE "DLA"
	  JRST	[SUB P,[2,,2]	;CAN'T GET THE CORE.  CLEAN UP THE STACK
		POPJ P,]	; AND RETURN TO UUOCON.
	MOVE	T2,PCBOCT(U)	;GET XWD PCB'S SIZE,BYTES ALREADY WRITTEN
	HLRZ	T4,T2		;GET THE SIZE OF THE PCB (WORDS)
	LSH	T4,2		;GET THE SIZE OF THE PCB (BYTES)
	SUBI	T4,(T2)		;ACCOUNT FOR THE BYTES IN THE HEADER
	POP	P,T2		;GET THE LENGTH OF THE DROP NUMBER
	SUBI	T4,3(T2)	;ACCOUNT FOR "CNT" AND "TYP" GET BYTES LEFT
	MOVEI	T3,DC.DAR	;ASSUME DATA WITH EOR
	CAML	T4,DEVAXO+1(F)	;SEE IF THE DATA WILL FIT IN THE PCB
	SKIPA	T4,DEVAXO+1(F)	;YES. ADJUST THE "CNT" TO BE BYTES LEFT
	MOVEI	T3,DC.DAT	;NO. THIS WILL BE DATA W/O E-O-R
;CNT
	MOVEI	T1,1(T4)	;ALLOW FOR THE "TYP" BYTE
	XMT	T1		;SEND THE "COUNT" FIELD
;TYP
	XMT	T3		;SEND THE "TYP"
;DROP
	POP	P,T1		;GET THE DROP NUMBER
	XMT	T1		;AND SEND THAT
;DATA
R.MXM2:	SOSGE	DEVAXO+1(F)	;COUNT OFF THE NEXT BYTE
	PUSHJ	P,NTDSTP##	;++ MY ARITHMETIC SUCKS
	EXCTUX	<ILDB T1,DEVAXO(F)> ;GET ANOTHER BYTE FROM THE USER'S BUFFER
	XMT1	T1		;SEND THE BYTE
	SOJG	T4,R.MXM2	;LOOP UNTIL WE'VE SENT IT ALL

	ADDB	P3,PCBOCT(U)	;UPDATE THE PCB'S LENGTH
	MOVEI	T1,PCV.NC	;THIS IS TO BE SENT UN-ADULTERATED
	PUSHJ	P,NTDWRT##	;SEND THE MESSAGE ON IT'S CONTORTED WAY
	PUSHJ	P,NTDDDQ##	;ACCOUNT FOR DATA REQUEST THAT JUST GOT USED
	JRST	ROLOO1		;GO SEE IF THE USER'S BUFFER WANTS ADVANCING
SUBTTL 1.3        INPUT UUO.

R.IN:	PUSHJ	P,SAVE4##	;WE CLOBBER MOST EVERYTHING
	MOVSI	S,IOSUSI	;CLEAR "UUOCON STOPED INPUT" SINCE IT'S
	ANDCAB	S,DEVIOS(F)	;  TRYING TO START IT NOW.

RILOOP:	PUSHJ	P,NTDSET##	;SET UP "W" ETC.
	MOVSI	S,IOBEG!IO	;CLEAR "FIRST TIME" AND TELL
	ANDCAB	S,DEVIOS(F)	; "WAITX" THAT WE'RE DOING INPUT
	PUSHJ	P,NTDIBA##	;IS THERE AN INPUT BUFFER AVAILABLE TO FILL?
	  POPJ	P,		; IF NOT, THEN GO BACK TO UUOCON
	HRRZ	T1,DEVPCB(F)	;IS THERE A PCB AVAILABLE?
	JUMPE	T1,RIWAIT	;IF NOT, WE MUST WAIT FOR ONE
	PUSHJ	P,NTDDID##	;IF THERE IS A PCB, THEN DECODE IT.
	JRST	RILOOP		;KEEP IT UP TILL SOME ONE GETS BORED.

RIWAIT:	PUSHJ	P,NTDONL##	;ARE WE STILL ONLINE?
	  JRST	R.DERR		;IF NOT, THEN SET IODERR AND RETURN
	PUSHJ	P,NTDXDQ##	;MAKE SURE WE'VE SENT ENOUGH DATA REQUESTS
	PUSHJ	P,NTDWTI##	;WAIT FOR DATA.
	  POPJ	P,		;NO DATA, BUT NON-BLOCKING. RETURN TO UUOCON
	JRST	RILOOP		;GO SEE IF IT WAS DATA THAT WOKE US UP.
SUBTTL 2.0      NETSER INTERFACE.

;RDXSER'S NDP DISPATCH VECTOR (HERE ON MESSAGES FROM NETSER)

	JRST	NTDNWD##	;NODE WENT DOWN
	JRST	NTDDSC##	;DISCONNECT MESSAGE (INIT/CONFIRM)
	JRST	NTDCNC##	;CONNECT CONFIRM MESSAGE
	JRST	NTDSTP##	;CONNECT INITIATE MESSAGE (CAN'T HAPPEN)
	JRST	NTDRDQ##	;RECIEVED DATA REQUEST
RDANDP::JRST	NTDQIP##	;QUEUE INCOMING PCB'S TO UUO LEVEL
	JRST	R.DATA		;DATA WITH OUT E-O-R
	JRST	R.DATA		;DATA WITH E-O-R
	JRST	CPOPJ##		;STATUS ??
	JRST	CPOPJ##		;CONTROL ??
	JRST	CPOPJ##		;UNIT ID ??
	JRST	CPOPJ##		;FILE SPEC ??



;DUMMY CONNECT INIT PROCESSOR

	NRDACI==:NJNKCI##	;JUNK CI PROCESSOR
SUBTTL 2.1        DAP INPUT DATA MESSAGE.

R.DATA:	LDB	T2,PIOMOD##	;GET THE DATA MODE
	MOVEI	T4,7		;ASSUME THAT IT'S ASCII (7 BIT BYTES)
	CAIN	T2,BYTMOD	;BUT IF IT'S BYTE MODE, CHANGE OUT MIND
	MOVEI	T4,^D8		; (8 BIT BYTES)
	PUSHJ	P,NTDSIB##	;SET UP THE INPUT BUFFER
	  PUSHJ	P,NTDSTP##	;++ BUT WE CHECKED??
	TLNN	S,IOSDRP	;IS THIS IS MULTI DRIP LINE?
	JRST	R.DAT1		;IF NOT, SKIP READING THE DROP NUMBER

	PUSHJ	P,EBI2BI##	;GET THE DROP NUMBER
	SETZB	T2,T3		;CLEAR THESE (WE ACCUMULATE THE NUMBER HERE)
	MOVEI	T4,5		;WE WANT A 5 DIGIT NUMBER

R.RDR1:	IDIVI	T1,^D10		;GET THE REMAINDER (NEXT DIGIT)
	ADDI	T2,"0"		;ASCIIZ IT
	LSHC	T2,-7		;SAVE IT IN T3 (DON'T USE THE STACK)
	SOJG	T4,R.RDR1	;LOOP OVER ALL 5 CHARS

	MOVEI	T4,5		;NOW STORE ALL 5 CHARS
R.RDR2:	SOSGE	DEVAXI+1(F)	;COUNT DOWN ANOTHER BYTE
	JRST	R.BKTL		;?? USER GAVE US AN AWFULLY TINY BUFFER
	LSHC	T2,7		;GET THE NEXT BYTE BACK
	EXCTUU	<IDPB T2,DEVAXI(F)> ;STORE THE DIGIT
	SOJG	T4,R.RDR2	;LOOP OVER ALL 5 DIGITS

R.DAT1:	SOJL	P4,NTDA1B##	;COUNT OFF THE NEXT DATA CHARACTER
	ILDB	T2,P1		;GET THE NEXT DATA CHARACTER
	SOSGE	DEVAXI+1(F)	;COUNT DOWN THE USERS FREE BUF CNT
	JRST	R.BKTL		;IOBKTL IF HE DIDN'T GIVE A BIG BUFFER
	EXCTUU	<IDPB T2,DEVAXI(F)> ;STORE THE BYTE
	JRST	R.DAT1		;LOOP OVER ALL THE DATA
SUBTTL 3.0      UTILITY SUBROUTINES.

;R.BKTL	ROUTINE TO SET IOBKTL IF THE USER GAVE US AN INPUT BUFFER THAT
; WAS TOO SMALL.  IT ALSO ADVANCES THE INPUT PCB WHEN DONE.
;
R.BKTL:	MOVEI	S,IOBKTL	;GET THE ERROR BIT
	IORB	S,DEVIOS(F)	;SET IT WHERE UUOCON WILL NOTICE
	PJRST	NTDA1B##	;ADVANCE THE USERS BUFFER AND SKIP RETURN

;R.DERR, R,IMPM ROUTINES TO SET IODERR AND IOIMPM
;
R.DERR:	MOVE	S,[XWD IOSERR,IODERR] ;TWO ERROR BITS TO SET
	CAIA
R.IMPM:	MOVEI	S,IOIMPM	;ERROR BIT TO SET
	IORB	S,DEVIOS(F)	;SET THE BIT
	POPJ	P,		;AND RETURN





	XLIST			;DON'T LIST LITERALS
	$LIT
	LIST
RDXEND::END
