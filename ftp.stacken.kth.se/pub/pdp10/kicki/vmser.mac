TITLE	VMSER - VIRTUAL MEMORY SERVICE ROUTINE  V4517
SUBTTL	J. FLEMMING, T. WACHS 3 JAN 84
	SEARCH	F,S
	SALL
	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>



;DATE		LOAD	EDIT #
;----		----	------

;26-AUG-80	70113	372
;9370 MCO
;16-SEP-80	70116	373
;94005-9406-9407
;30-SEP-80	70120	374
;9417-
;07-OCT-80	70121	375
;9425-
;14-OCT-80	70122	376
;9434-
;04-NOV-80	70125	377
;9458
;25-NOV-80	70126	400
;9459,9460,9457A
;16-DEC-80	70131	401
;9507-
;20-JAN-81	70135	402
;27-JAN-81	70136	403
;9545-
;03-FEB-81	70137	404
;9555-
;10-FEB-81	70140	405
;9571
;17-FEB-81	70141	406
;9582
;17-MAR-81	70145	407
;7-APR-81	70150	410
;28-APR-81	70153	411
;9701,9709
;12-MAY-81	70155	412
;9720-
;19-MAY-81	70156	413
;9728-
;02-JUN-81	70160	414
;9744
;09-JUN-81	70161	415
;9749-
;23-JUN-81	70163	416
;8791-
;30-JUN-81	70164	417
;07-JUL-81	70165	420
;9808-
;22-SEP-81	70175	421
;20-OCT-81	70112	422
;27-OCT-81	70113	423
;01-DEC-81	70120	424
;10001
;08-DEC-81	70121	425
;10005-
;15-DEC-81	70122	426
;MCO 10013
;12-JAN-82	70126	427
;19-JAN-82	70127	430
;26-JAN-82	70130	431
;10059-10060
;02-FEB-82	70131	432
;10069-10072
;9-FEB-82	70132	433
;10096
;16-FEB-82	70133	434
;10102
;23-FEB-82	70134	435
;10119
;02-MAR-82	70135	436
;10123
;16-MAR-82	70137	437
;10146
;23-MAR-82	70140	440
;10170
;30-MAR-82	70141	441
;10176
;13-APR-82	70142	442
;10199-10200
;27-APR-82	70144	443
;10213
;4-MAY-82	70145	444
;10234
;01-JUN-82	70151	445
;10272
;22-JUN-82	70154	446
;20-JUL-82	70160	447
;10328
;3-AUG-82	70162	450
;10339-10343
;10-AUG-82	70163	451
;17-AUG-82	70164	452
;10354-10357
;24-AUG-82	70165	453
;10369	
;31-AUG-82	70166	454
;10392
;14-SEP-82	70170	455
;10403
;28-SEP-82	70172	456
;10423
;5-OCT-82	70173	457
;10436
;19-OCT-82	70175	460
;10450
;26-OCT-82	70176	461
;10463-10464
;02-NOV-82	70177	462
;10470
;9-NOV-82	70111	463
;10483-10483
;16-NOV-82	70112	464
;10490-10497
;21-DEC-82	70116	465
;04-JAN-83	70117	466
;11-JAN-83	70120	467
;18-JAN-83	70121	470
;10573-10576
;25-JAN-83	70122	471
;10585
;08-FEB-83	70124	472
;10593-10596-10602
;22-FEB-83	70126	473
;10611
;29-MAR-83	70133	474
;10669
;12-APR-83	70135	475
;26-APR-83	70137	476
;10695
;3-MAY-83	70140	477
;10753
;7-JUN-83	70144	500
;10788
;14-JUN-83	70145	501
;10799
;21-JUN-83	70146	502
;10807
;12-JULY-83	70153	503
;26-JUL-83	70153	504
;10883
;2-AUG-83	70154	505
;9-AUG-83	70155	506
;10897
;19-AUG-83	70156	507
;23-AUG-83	70157	510
;30-AUG-83	70160	511
;10933
;13-SEP-83	70162	512
;10950
;27-SEP-83	70164	513
;10970
;11-OCT-83	70166	514
;11000
;13-DEC-83	70172	516
;3-JAN-84	70173	517
;
XP VVMSER,517	;ASSEMBLY INSTRUCTIONS: VMSER,VMSER/C=F,S,VMSER
	ENTRY	VMSER
VMSER::


OPDEF	PAGE.	[CALLI	145]
OPDEF	MERGE.	[CALLI	173]

SUBTTL FILIO  INTERFACE WITH FILSER

;SUBROUTINE TO SCAN FOR THINGS TO DO FOR THE SWAPPER
;OPTIMIZES ALL SEEK REQUESTS, TRANSFER REQUESTS, STARTS SEEKS GOING
;STARTS DATA TRANSFER GOING IF ON UUO (CHAN 7) LEVEL
SWPSCN::
IFN FTMP,<
	SYSPIF
	SKIPL	T1,SCNOWN##	;IF NO CPU "OWNS" SCNCNT
	CAMN	T1,.CPCPN##	; OR IF THIS CPU "OWNS" IT
>
	AOSE	SCNCNT##	;SOMEONE ALREADY DOING THIS?
IFE FTMP,<
	PJRST	DOPOPJ##	;YES, GO AWAY (AT INTERRUPT LEVEL,
				; SWPSCN IS RUNNING AT UUO LEVEL)
>
IFN FTMP,<
	JRST	[SYSPIN
		 PJRST DOPOPJ##]
	MOVE	T1,.CPCPN##
	MOVEM	T1,SCNOWN##
	SYSPIN
>
	DSKON
	PUSHJ	P,SAVE3##	;NO, NOW WE ARE
	JUMPE	J,SWPSC1	;GO IF UUO LEVEL
	SOS	P3,CHNCFS##(P1)	;UPDATE CHANNEL FAIRNESS COUNT FOR SWAPPING
	HRR	P3,CHNQUE##(P1)	;RH NON-0 IF FILE TRANSFER WAITING
SWPSC1:	PUSH	P,J		;SAVE J
	PUSH	P,U		;SAVE U
SWPSC2:	SETZB	P1,T2		;INDICATE FIRST CALL TO NEXT
	HRLOI	T1,377777	;SET ALL UNITS IN A.S.L. TO HUGE
				; TIMES TO BLOCK OR TIMES TO CYLINDER
	MOVEI	T4,TWCOD##
SWPSC3:	SKIPN	T3,SWPTAB##(T2)	;UNIT IN ASL?
	JRST	SWPS3A
	CAME	T1,UNISWD##(T3)	;TIME ALREADY INFINITY?
	CAME	T4,UNISTS##(T3)	;NO, IS UNIT IN TRANSFER WAIT?
	SKIPA	U,T1		;NO, MAKE TIME = INFINITY
	MOVEI	U,-1		;YES, INSURE SWPPIK WILL FIND IT EVEN IF SWPSCN DOESN'T
	MOVEM	U,UNISWD##(T3)	;SAVE LARGE TIME-TO-BLOCK OR CYLINDER
IFN FTDUAL,<
	SKIPE	T3,UNI2ND##(T3)	;IN 2ND PORT TOO
	MOVEM	U,UNISWD##(T3)
>
SWPS3A:	CAIGE	T2,SWPMAX##	;END OF THE ACTIVE SWAPPING LIST?
	AOJA	T2,SWPSC3	;NO, LOOK AT ALL UNITS IN THE ASL
	DSKOFF
SWPSC4:	PUSHJ	P,NEXT		;GET NEXT REQUEST FROM SWPLST
	  JRST	SWPS10		;DONE
	HRRZ	T2,UNICDA##(U)	;DDB UNIT IS ATTACHED TO
	CAIE	T2,SWPDDB##	;IF NOT THE SWAPPER
	JUMPN	T2,SWPSC4	;LET FILE IO HAPPEN
	HRR	J,UNIKON##(U)	;SET UP J POINTING TO  KONTROLLER
IFN FTDUAL,<
	CAME	J,-1(P)		;IGNORE BUSY IF INT ON THIS KON
	SKIPL	KONTAB##(J)	;KON BUSY?
	JRST	SWPS80		;IDLE, USE PRIME PORT
	SKIPN	T3,UNI2ND##(U)	;BUSY, DUAL-PORTED DRIVE?
	JRST	SWPS80		;NO, WAIT FOR PRIME PORT
	HRR	J,UNIKON##(T3)	;YES, GET 2ND KON
	CAME	J,-1(P)		;IGNORE BUSY IF INT ON THIS KON
	SKIPL	KONTAB##(J)	;KON BUSY?
	HRRZ	U,UNI2ND##(U)	;IDLE, USE 2ND PORT
	HRR	J,UNIKON##(U)	;GET (NEW) KON
SWPS80:
IFN FTMP,<
	PUSHJ	P,SWPCP		;SET U IF OTHER CPU
	  JFCL
>
>
	CAMN	J,-1(P)		;IF NOT ON INTERRUPT LEVEL FOR THIS CHAN,
	JRST	SWPSC5
IFN FTDHIA,<
	HRRZ	T2,KONCHN##(J)
	SKIPE	DIADSK##
	CAME	T2,DIACHN##	;IGNORE REQUEST IF SHUTTING DOWN CHAN
>
	SKIPGE	KONTAB##(J)	;IS KONTROLLER IDLE?
	JRST	SWPSC4		;NO, TRY NEXT SWPLST ENTRY
	JRST	SWPSC6		;YES, THIS REQUEST IS OK
SWPSC5:	JUMPGE	P3,SWPSC6	;GO UNLESS BEING FAIR
IFN FTDUAL,<
	SKIPE	T4,UNI2ND##(U)	;POSITIONS WAITING ON SECOND PORT?
	SKIPN	UNIQUE##(T4)
>
	SKIPE	UNIQUE##(U)	;OR PRIME PORT?
	JRST	SWPSC4		;YES, DON'T DO THIS REQUEST
SWPSC6:	SKIPG	KONPOS##(J)	;CAN DO THINGS FOR THIS REQUEST
	JRST	SWPSC8		;UNIT DOESNT POSITION
	MOVE	T4,T1		;POSITIONING UNIT - SAVE BLOCK NUMBER
	PUSHJ	P,@KONCCM##(J)	;COMPUTE DISTANCE TO BLOCK
	JUMPE	T1,SWPSC7	;GO IF UNIT ON CYLINDER
	MOVMS	T1		;NOT ON CYL, GET + DISTANCE
	SKIPE	T2,UNISTS##(U)	;IS UNIT IDLE
	CAIN	T2,O2COD##	; OR OFF-LINE (NEED THIS TO GET TO BADUNI)
	JRST	SWPS6A		;YES, SAVE THIS REQUEST
	CAIN	T2,PWCOD##	;NO, IN POSITION WAIT?
	CAML	T1,UNISWD##(U)	;YES, IS THIS DISTANCE SHORTER?
	JRST	SWPSC4		;NO, TRY NEXT REQUEST
SWPS6A:	MOVEI	T2,PWCOD##	;MAKE SURE UNIT IS IN POSITION WAIT
	PUSHJ	P,SETUDB	;SET UNISWA, ETC.
	JRST	SWPSC4		;AND TEST NEXT SWPLST ENTRY
;HERE AFTER NUS STOPCD

SWPS6B:	PUSHJ	P,SWPCD1	;GIVE SWAP READ ERROR
	JRST	SWPSC4		;AND PUSH ON
;HERE IF UNIT ON-CYLINDER
SWPSC7:	MOVE	T1,T4		;RESTORE BLOCK NUMBER

;HERE IF UNIT DOESN'T POSITION OR ON CYLINDER
SWPSC8:	CAMN	J,-1(P)		;INTERRUPT LEVEL FOR THIS KON?
	JRST	SWPS8A		;YES
	SKIPL	KONTAB##(J)	;NO, IS KON BUSY?
	JRST	SWPS8B		;NO, KON IDLE
	JRST	SWPSC4		;YES, KON BUSY
SWPS8A:	TRNE	P3,-1		;TRANSFERS WAITING?
	JUMPL	P3,SWPSC4	;YES, IGNORE IF BEING FAIR
SWPS8B:
IFN FTDUAL,<
	HRRZ	T2,UNICHN##(U)	;FILE TRANSFERS WAITING ON THIS CHAN?
	SKIPE	CHNQUE##(T2)
	SKIPN	T2,UNI2ND##(U)	;AND DUAL PORTED?
	JRST	SWPS8Z		;NO, OK LET IT HAPPEN
	HRR	J,UNIKON##(T2)	;YES, IS OTHER KON BUSY?
	CAME	J,-1(P)
	SKIPL	KONTAB##(J)
	JRST	SWPS8Y		;IDLE, LET SWAP HAPPEN
	HRRZ	T2,KONCUA##(J)	;BUSY, IS IT DOING A SWAP?
	MOVE	T3,UNISTS##(T2)
	HRRZ	T4,UNICDA##(T2)
	CAIN	T3,TCOD##
	CAIE	T4,SWPDDB##
	JRST	SWPS8Y		;NOT A SWAP
	JRST	SWPSC4		;DON'T TIE UP BOTH CHANNELS DOING SWAPS
				;LEAVE ONE CHANNEL OPEN FOR FILE I/O
SWPS8Y:	HRR	J,UNIKON##(U)	;GET KON BACK
SWPS8Z:>
IFN FTMP,<
	LDB	T2,KOYCPU##
	CAMN	T2,.CPCPN##
>
	PUSHJ	P,@KONLTM##(J)	;COMPUTE TIME TO BLOCK
	  MOVEI	T1,0		;UNIT OFF-LINE
	SKIPE	T2,UNISTS##(U)	;IS UNIT IDLE
	CAIN	T2,PWCOD##	; OR POSITION WAIT?
	JRST	SWPSC9		;YES, THIS IS THE BEST TIME TO BLOCK
	CAIN	T2,TWCOD##	;NO, TRANSFER WAIT?
	CAMLE	T1,UNISWD##(U)	;YES, IS THIS BEST?
	JRST	SWPS9A		;NO, TEST NEXT ENTRY
SWPSC9:	MOVEI	T2,TWCOD##	;SET UNIT TO TRANSFER WAIT
	PUSHJ	P,SETUDB	;SET UNISWA, ETC.
SWPS9A:	JRST	SWPSC4		;AND TEST NEXT
IFN FTMP,<
SWPS98: SETOM	.C0SWP##(T4)	;COME BACK AT DSKTIC
>
SWPS99:	PUSHJ	P,IDLEPW##	;SET IDLE OR PW
	JRST	SWPS14


;HERE WHEN ALL OF SWPLST HAS BEEN SCANNED. START SEEKS GOING
SWPS10:	MOVEI	P2,0		;START AT 1ST UNIT IN ASL
SWPS11:	SKIPN	U,SWPTAB##(P2)	;GET UNIT
	JRST	SWPS14		;NOT THERE, TRY NEXT
	DSKOFF			;NO DISK INTERRUPTS HERE
	MOVE	T1,UNISTS##(U)	;STATE OF UNIT
	MOVE	T2,UNISWD##(U)	;DISTANCE OR TIME OF BEST
	CAME	T2,[377777,,-1];IS ANYTHING THERE?
	CAIE	T1,PWCOD##	;YES, POSITION WAIT?
	JRST	SWPS14		;NO
	HRR	J,UNIKON##(U)	;KONTROLLER
IFN FTDUAL,<
	CAME	J,-1(P)		;IGNORE BUSY IF INT ON THIS KON
	SKIPL	KONTAB##(J)	;KON BUSY?
	JRST	SWPS79		;IDLE, USE PRIME PORT
	SKIPN	T3,UNI2ND##(U)	;BUSY, DUAL-PORTED DRIVE?
	JRST	SWPS79		;NO, WAIT FOR PRIME PORT
	HRR	J,UNIKON##(T3)	;YES, GET 2ND KON
	CAME	J,-1(P)		;IGNORE BUSY IF INT ON THIS KON
	SKIPL	KONTAB##(J)	;KON BUSY?
	HRRZ	U,UNI2ND##(U)	;IDLE, USE 2ND PORT
	HRR	J,UNIKON##(U)	;GET (NEW) KON
SWPS79:>
	MOVE	P1,UNISWA##(U)	;GET SWPLST ENTRY
IFN FTMP,<
	PUSHJ	P,SWPCD		;UNIT ON THIS CPU?
	  JRST	SWPS98		;NO,COME BACK AT DSKTIC
>
	CAMN	J,-1(P)		;ON INTERRUPT LEVEL?
	JRST	SWPS12		;YES, KONTROLLER ISNT REALLY BUSY
	MOVSI	T2,KOPPWX##
	AND	T2,KONPOS##(J)	;T2 NON-0 IF KON CAN START SEEKS WHILE BUSY
IFN	FTDHIA,<
	SKIPE	DIADSK##	;IF DIAG IS GOING
	SETZ	T2,		;REQUIRE KDB TO BE IDLE
>
	SKIPGE	KONTAB##(J)	;IS KONTROLLER NOW BUSY?
	JUMPE	T2,SWPS99	;YES, TOUGH LUCK
SWPS12:
IFN FTDUAL,<
	HRL	P1,U		;SAVE U (2ND PORT OF DUAL-PORTED DRIVE)
>
	PUSHJ	P,THSBLK	;NO, GET BLOCK AND UNIT AGAIN
	  JRST	SWPS14		;MEMTAB IS MESSED UP
IFN FTDUAL,<
	HLRZ	U,P1		;RESTORE U
>
	MOVEM	T1,DEVBLK##(F)	;SAVE BLOCK IN SWPDDB FOR UNIPOS
	MOVEM	U,DEVUNI##(F)	;SAVE UNIT IN SWPDDB
	MOVE	P1,KONCHN##(J)	;IN CASE STRPOS CALLS STRTIO
IFN FTDUAL,<
	SKIPE	T1,UNI2ND##(U)	;TO DETECT SPURIOUS INTERRUPTS
	SETZM	UNICDA##(T1)
	SETOM	UNICDA##(U)	;SAVE F IN ACTIVE UDB
>
	PUSHJ	P,STRPOS##	;GO START THE SEEK
SWPS14:	CAIGE	P2,SWPMAX##	;AT END OF SWPTAB?
	AOJA	P2,SWPS11	;NO, TEST NEXT UNIT IN ASL

;HERE WHEN ALL UNITS HAVE BEEN STARTED SEEKING
	DSKON
	SKIPN	-1(P)		;INTERRUPT LEVEL?
	JRST	SWPPI1		;NO, START IO IF A UNIT IN TW
	PJRST	SWPPI5

;ROUTINE TO SAVE STUFF IN UDB
;ENTER T1=UNISWD, T2=UNISTS, P1=UNISWA
SETUDB:	MOVEM	T1,UNISWD##(U)	;SAVE TIME
	MOVEM	P1,UNISWA##(U)	;SAVE SWPLST POSITION
	MOVEM	T2,UNISTS##(U)	;SAVE PW/TW
IFN FTDUAL,<
	SKIPN	T3,UNI2ND##(U)	;IS THERE A SECOND PORT?
	POPJ	P,		;NO
	MOVEM	T1,UNISWD##(T3)	;YES, SET UP THAT UDB TOO
	MOVEM	P1,UNISWA##(T3)
	MOVEM	T2,UNISTS##(T3)
>
	POPJ	P,
;SUBROUTINE TO SCAN ALL UNITS IN A.S.L., START TRANSFER ON BEST
SWPPIK::
IFN FTMP,<
	SKIPL	T1,SCNOWN##
	CAMN	T1,.CPCPN##	;IF THIS CPU "OWNS" SCNCNT
>
	SKIPE	SCNCNT##	;SOMEONE ALREADY HERE?
	POPJ	P,		;YES, WAIT A WHILE
	PUSHJ	P,SAVE2##	;SAVE P1,P2
	PUSH	P,J		;SAVE J
	PUSH	P,U
	HRRZ	P2,P1		;SAVE LOC OF CHAN DB
	MOVSI	T1,400000	;SET EVERYTHING IDLE SO FILIO WILL DO SOMETHING
	ANDCAM	T1,KONTAB##(J)	; (THEY REALLY ARE, HAVEN'T YET BEEN MARKED)
SWPPI1:	SETZB	T1,P1		;INITIALIZE
	HRLOI	T2,377777	;INITIALIZE BEST-SO-FAR
	DSKOFF
SWPPI2:	SKIPN	U,SWPTAB##(T1)	;GET ASL ENTRY
	JRST	SWPPI3
	HRR	J,UNIKON##(U)	;SET KONTROLLER
IFN FTDUAL,<
	CAIE	P2,@KONCHN##(J)	;IGNORE BUSY IF INT ON THIS CHAN
	SKIPGE	@KONCHN##(J)	;CHAN BUSY?
	JRST	SWPI2B		;IDLE, USE PRIME PORT
	SKIPN	T3,UNI2ND##(U)	;BUSY, DUAL-PORTED DRIVE?
	JRST	SWPI2B		;NO, WAIT FOR PRIME PORT
	HRR	J,UNIKON##(T3)	;YES, GET 2ND KON
	CAIE	P2,@KONCHN##(J)	;IGNORE BUSY IF INT ON THIS CHAN
	SKIPGE	@KONCHN##(J)	;CHAN BUSY?
	HRRZ	U,UNI2ND##(U)	;IDLE, USE 2ND PORT
	HRR	J,UNIKON##(U)	;GET (NEW) KON
SWPI2B:>
IFN FTMP,<
	PUSHJ	P,SWPCP		;ON THIS CPU?
	  JRST	[SKIPLE .C0SWP##(T4) ;NO, ALREADY QUEUED AN IO ON OTHER CPU?
		 JRST SWPPI3	 ;YES, IGNORE THIS UNIT
		 JRST .+1]	 ;NO, GET 1 TO START ON OTHER CPU
>
IFE FTMP&FTDUAL,<
	MOVE	T3,UNISTS##(U)	;STATE OF UNIT
>
IFN FTMP&FTDUAL,<
	MOVE	T3,SWPTAB##(T1)	;GET UNISTS FROM THE UNIT WHICH IS IN
	MOVE	T3,UNISTS##(T3)	; SWPTAB (MIGHT HAVE CHANGED U TO 2ND PORT)
>
	CAIE	P2,@KONCHN##(J)
	SKIPGE	@KONCHN##(J)	;IS CHANNEL IDLE?
	CAIE	T3,TWCOD##	;YES, UNIT IN TRANSFER WAIT?
	JRST	SWPPI3		;NO, TEST NEXT UNIT
	CAMLE	T2,UNISWD##(U)	;YES, IS THIS BEST SO FAR?
	PUSHJ	P,SWPCH		;YES, CAN WE DO THIS IO (FRAG'D LIST)?
	  JRST	SWPPI3		;NO, TRY NEXT
	MOVE	T2,UNISWD##(U)	;YES, SAVE TIME
	MOVE	P1,UNISWA##(U)	;SAVE SWPLST POSITION
IFN FTDUAL,<
	HRL	P1,U		;SAVE ACTUAL UNIT
>
SWPPI3:	CAIGE	T1,SWPMAX##	;END OF ASL?
	AOJA	T1,SWPPI2	;NO, TRY NEXT UNIT
	JUMPE	P1,SWPPI4	;RETURN IF NOTHING TO DO

;HERE WHEN BEST TRANSFER HAS BEEN FOUND FOR SOME CHANNEL
	PUSHJ	P,THSBLK	;GET BLOCK NUMBER
	  JRST	[SETZM (P1)	;MEMTAB MESSED UP
		 JRST SWPPI4]
IFN FTDUAL,<
	HLRZ	U,P1		;GET ACTUAL UNIT BACK
>
	HRR	J,UNIKON##(U)	;SET UP KONTROLLER
IFN FTMP,<
	PUSHJ	P,SWPCD		;ON THIS CPU?
	  JRST	SWPI6A		;NO, SET SO DSKTIC WILL FIND IT
>
	MOVEM	T1,DEVBLK##(F)	;SAVE IN SWPDDB
	MOVEM	U,DEVUNI##(F)	;SAVE U IN DDB
	MOVE	P1,KONCHN##(J)	;AND CHAN LOC
	SKIPGE	KONTAB##(J)	;IS KONTROLLER BUSY?
	JRST	SWPPI6		;YES, CANT USE IT NOW
	SETZM	(P1)		;CHAN IS BUSY
IFN FTDUAL,<
	SKIPE	T1,UNI2ND##(U)
	SETZM	UNICDA##(T1)
	SETOM	UNICDA##(U)
>
	PUSHJ	P,STRTIO##	;GO CRANK UP THE IO
	CAIN	P2,@KONCHN##(J)	;YES, INT ON THIS CHAN?
	TLO	P2,-1		;YES, FLAG THAT CHAN IS NOW BUSY
	JRST	SWPPI1		;LOOK FOR OTHER CHAN
;HERE WHEN THROUGH
SWPPI4:	DSKON
	SOSL	SCNCNT##	;DECREMENT SCNCNT. DID INTERRUPT LEVEL TRY?
	JUMPGE	P2,SWPSC2	;YES, SCAN AGAIN (UNIT IN ASL MAY HAVE CHANGED STATE)
				;DON'T RETRY IF STARTED XFER. COULDN'T TELL
				;IF KON WAS REALLY BUSY.
	SKIPGE	P2		;STARTED XFER ON THIS CHAN?
	AOS	-2(P)		;YES, TELL FILSER SOMETHING HAPPENED
IFN FTMP,<
	SETOM	SCNOWN##
>
	MOVE	J,-1(P)		;RESTORE J
	JUMPE	J,SWPPI5	;IF ON INTERRUPT LEVEL,
	MOVE	P1,KONCHN##(J)	;GET CHAN LOC
	SKIPGE	T1,CHNCFS##(P1);RESTORE CHNCFT IF IT COUNTED
	MOVE	T1,CHNIFS##(P1); BELOW 0
	MOVEM	T1,CHNCFS##(P1)

SWPPI5:	POP	P,U		;RESTORE U
	PJRST	JPOPJ##		;AND EXIT

IFN FTMP,<
SWPI6A:	HRRZM	J,.C0SWP##(T4)	;.CPSWP GREATER THAN 0
>
SWPPI6:	DSKON
	JRST	SWPPI1

;SUBROUTINE TO SEE IF A SWAP REQUEST MAY BE STARTED
;CALLED AT INTERRUPT LEVEL BY FILIO ON A POSITION-DONE INTERRUPT AND BY SWPPIK
;NON-SKIP RETURN IF CAN'T START IT NOW (FRAGMENTED, ANOTHER FRAGMENT IN PROGRESS)
;SKIP RETURN IF IO CAN BE STARTED
;PRESERVES T1,T2
SWPCH:
SWPCHK::HLRZ	T3,UNISWA##(U)	;FRAGMENTED?
	JUMPE	T3,CPOPJ1##	;NO, OK TO START
	HRL	T3,(T3)
	MOVSS	T3		;YES, GET START OF CHAIN
SWPCH1:	SKIPN	T4,(T3)		;GET FRAGMENT POINTER
	PJRST	CPOPJ1##	;DONE - OK TO START
	JUMPL	T4,[HRR T3,T4
		    JRST SWPCH1]
	TLNE	T4,(SL.IOP)	;IN PROGRESS?
	CAMN	T3,UNISWA##(U)	;YES, IS IT THE ONE WE WANT TO START?
	AOJA	T3,SWPCH1	;THIS ONE IS OK, CHECK NEXT
	POPJ	P,		;IO ALREADY HAPPENING - QUEUE THIS TILL LATER



IFN FTMP,<
;RETURNS CPOPJ IF ON OTHER CPU, CAUSES SWAP READ ERROR IF OTHER CPU IS DEAD
; RETURN CPOPJ1 IF ON THIS CPU
;PRESERVES T1,T2
SWPCD:	PUSHJ	P,SWPCP		;ON THIS CPU?
	  CAIA			;NO
	JRST	CPOPJ1##	;YES, ON THIS CPU RETURN
	MOVSI	T3,(CR.DET)	;CPU IS DETACHED BIT
	TDNN	T3,.C0RUN##(T4)	;CPU DETACHED?
	POPJ	P,
>
SWPCD1:	PUSHJ	P,SAVT##	;PRESERVE T1,T2 - SAVE T4
	PUSHJ	P,SW2LC		;INDEX INTO SW2LST
	MOVE	T4,SW2LST##(T1)	;ORIGINAL SWPLST ENTRY
	TLO	T4,(SL.ERR+SL.IOP) ;ERROR + I/O IN PROGRESS
	PJRST	DONE9		;SET IT DONE
IFN FTMP,<
;RETURNS CPOPJ IF ON OTHER CPU, CPOPJ1 IF ON THIS
;PRESERVES T1,T2
SWPCP:	LDB	T4,KOYCPU##	;CPU THAT THIS KONTROLLER IS ON
	CAMN	T4,.CPCPN##	;THIS CPU?
	JRST	CPOPJ1##	;YES, DO THE I/O NOW
IFN FTDUAL,<
	SKIPN	T3,UNI2ND##(U)	;SECOND PORT
	JRST	SWPCP1
	MOVE	T3,UNIKON##(T3)
	LDB	T4,KOZCPU##	;CPU KONTROLLER FOR SECOND PORT IS ON
	CAME	T4,.CPCPN##	;;THIS CPU?
	JRST	SWPCP1		;NO
	HRRZ	U,UNI2ND##(U)	;SWITCH TO OTHER PORT
	HRR	J,UNIKON##(U)	;KONTROLLER FOR SECOND PORT
	JRST	CPOPJ1##	;DO I/O NOW RETURN
SWPCP1:	LDB	T4,KOYCPU##	;CPU NUMBER KONTROLLER IS ON
>
	LSH	T4,.CPSOF##	;OFFSET FROM BEGINNING OF CDB'S TO THIS CPU'S CDB
	POPJ	P,		;NOT ON THIS CPU SO CAN'T START I/O NOW RETURN
> ;END IFN FTMP

;SUBROUTINE TO GET THE NEXT ENTRY FROM SWPLST
;CALL WITH P1=0 ON FIRST ENTRY
;SUBSEQUENTLY CALL WITH P1,P2=NUMBERS RETURNED FROM THE LAST CALL
;RETURNS CPOPJ IF NO MORE ENTRIES
;RETURNS CPOPJ1 WITH P1 POINTING AT NEXT ENTRY,
; U=LOC OF UNIT DATA BLOCK, T1=PHYSICAL DSK BLOCK NUMBER
NEXT:	JUMPN	P1,NEXT1	;FIRST CALL?
	PUSHJ	P,UUOLVL##	;IF AT UUO LEVEL
	  JRST	NEXT0		;AVOID CHANGING THE UBR
	HRRZ	P1,.USSLX	;BY FINDING ONLY THE ENTRY FOR THIS JOB
	MOVE	T1,SWPLST##(P1)
	TLNE	T1,(SL.IOP!SL.IOD) ;ALREADY STARTED?
	POPJ	P,		;YES, GO AWAY
	MOVEI	P2,1
	MOVEI	P1,SWPLST##-1(P1)
	JUMPL	T1,NEXT6	;IF FRAGMENTED
	JRST	NEXT5
NEXT0:	MOVEI	P1,SWPLST##-1	;YES, INITIALIZE P1
	SKIPN	P2,SPRCNT##	;ONLY LOOK AT SWAPS IF THERE ARE ANY
	SKIPA	P2,SLECNT##	;P2=NUMBER OF ENTRIES IN SWPLST
	ADD	P2,SWPCNT##
NEXT1:	JUMPE	P2,CPOPJ##	;NON-SKIP RETURN IF NO MORE ENTRIES
NEXT2:	SKIPA	T2,[TLNN T1,(SL.IOP)]	;ASSUME NOT A FRAGMENTED ENTRY
NEXT3:	MOVE	T2,[TLNE T1,(SL.IOP)]	;IF IT IS A FRAGMENTED ENTRY
NEXT4:	SKIPN	T1,1(P1)	;IS THERE ANOTHER ENTRY IN SWPLST?
	JRST	NEXT8		;MAYBE (IF WE'RE IN A FRAGMENT CHAIN)
	SKIPE	SPRCNT##	;IF ANY SWAPS WAITING,
	TLNE	T1,(SL.SIO)	;IF THIS IS A SWAP REQUEST
	SKIPA	T4,SINCNT##	; TEST IT
	JRST	NEXT8		;PAGE REQUEST - IGNORE FOR NOW
	JUMPL	T1,NEXT6	;SWAP, IS IT A FRAGMENT POINTER?
	JUMPE	P2,NEXT4A	;IGNORE SINCNT IF FRAGMENT IN PROGRESS
	TLNE	T1,(SL.DIO)	;NO, IF AN OUTPUT REQUEST
	JUMPG	T4,NEXT8	; IGNORE IT IF ANY INPUT REQUESTS WAITING
NEXT4A:	XCT	T2		;IS IT USABLE?(SL.IOP=0 IF NOT IN A FRAGMENT CHAIN
				; , SL.IOP=1 IF IN A FRAGMENT CHAIN)
	TLNE	T1,(SL.IOD)	; AND SL.IOD=0
	AOJA	P1,NEXT9	;NO, TRY NEXT
	TLZN	P1,400000	;FIRST TIME FOR THIS ENTRY?
	TLNN	P1,-1		;NO, IN A FRAGMENT?
	JRST	NEXT5		;NO, USE THIS ENTRY
	TLNE	T1,(SL.DIO)	;YES, SWAPPING OUT?
	SKIPE	2(P1)		;YES, LAST ENTRY IN THE FRAGMENT?
	JRST	NEXT5		;NO, USE IT
	JRST	NEXT8		;YES, CANT USE IT (CANT WRITE UPMP TILL ALL
				; DSK ADDRESSES ARE FILLED IN)
NEXT5:
IFN FTMP&FTKL10,<
	TLNE	T1,(SL.DIO)	;IF PAGING OUT
	TLNE	T1,(SL.SIO)	;(NOT SWAPPING)
	JRST	NEXT5A
	PUSHJ	P,SW2LC
	TLNE	P1,-1
	SUBI	T1,1
	HRR	J,SW3LST##+1(T1) ;GET JOB NUMBER
	PUSHJ	P,CHKCSH##	;IS IT RIGHT WRT CACHE?
	  SKIPA	T1,1(P1)	;YES, DO IT
	JRST	NEXT8		;NO, TRY SOMEONE ELSE
>
NEXT5A:	PUSHJ	P,SWPMEM	;YES, GET DSK ADR, UNIT
	  JRST	NEXT8		;SWPLST IS ZERO!
	TLNN	P1,-1		;A MAIN ENTRY?
	SUBI	P2,1		;YES, DECREMENT NO OF ENTRIES LEFT
	AOJA	P1,CPOPJ1##	;AND SKIP-RETURN
;HERE ON A POINTER TO A FRAGMENT
NEXT6:	HLRZ	T3,P1		;T3 NON-0 IF NOT FIRST LINK (FATHER NOT SWPLST ENTRY)
	JUMPN	T3,NEXT7	;IF FIRST TIME IN THIS FRAGMENT,
	TLNE	T1,(SL.IOD)	;IF SL.IOD=1
	AOJA	P1,NEXT9	; EITHER ALL DONE OR ERROR
	MOVE	T4,T1		;SAVE THIS PIECE
	PUSHJ	P,SW2LC		;WE THINK WE FOUND A USABLE ENTRY
	SKIPE	SW2LST##+1(T1)	; BUT IF 1 PIECE IS ALREADY  GOING (DIFFERENT DF)
	TLNE	T4,(SL.IOP)	; THEN WE CANT START THIS ONE
	SKIPA	T1,1(P1)	;OK - RESTORE SWPLST ENTRY TO T1
	AOJA	P1,NEXT9	;CANT USE IT
	MOVSI	P1,400001(P1)	;SAVE POINT IN SWPLST WHERE WE TURNED DOWN
	SOJL	P2,CPOPJ##	;COUNT THE ENTRY
NEXT7:	HRRI	P1,-1(T1)	;SET RH(P1) FOR 1ST THING IN CHAIN
	JUMPN	T3,NEXT4	;T2 SET UP RIGHT IF NOT 1ST LINK
	TLNN	T1,(SL.IOP)
	JRST	NEXT2		;AND TEST IT
	SETZ	P2,		;MAKE SURE THIS ENTRY IS PICKED
	JRST	NEXT3


;HERE WHEN AT END OF CHAIN
NEXT8:	JUMPLE	P2,CPOPJ##	;RETURN IF ALL ITEMS IN SWPLST SCANNED
	TLNN	P1,-1		;NOT END, IN A FRAGMENT?
	AOJA	P1,NEXT8A	;NO, TRY NEXT SWPLST ENTRY
	HLRZS	P1		;RESTORE MAIN LOC IN SWPLST IF FRAGMENT
	TRZ	P1,400000	;BIT IS ON IF FOUND NOTHING
NEXT8A:	CAIL	P1,SW2LST##	;REACHED END?
	POPJ	P,		;YES (DUAL CPU, OTHER CPU IN ZERSLE)
	JRST	NEXT2

NEXT9:	TLNE	P1,-1		;FRAGMENT?
	JRST	NEXT4		;YES, P2 ALREADY DECREMENTED
	SOJG	P2,NEXT4	;NO, DECR P2 AND TRY NEXT
	POPJ	P,		;ALL DONE - RETURN


;SUBROUTINE TO GET THE BLOCK NUMBER FOR THIS SWPLST ENTRY
;CALL P1= LOC OF ENTRY
;RETURNS CPOPJ1 WITH U SET UP, T1= BLOCK NUMBER
;RETURNS CPOPJ IF THINGS ARE MESSED UP
THSBLK:	SKIPN	T1,(P1)		;GET SWPLST ENTRY
	STOPCD	CPOPJ##,DEBUG,NSE,	;++NO SWPLST ENTRY
;	PJRST	SWPMEM		;FALL INTO SWPMEM

;SUBROUTINE TO OBTAIN THE DISK ADDRESS FROM MEMTAB
;ENTER WITH T1=SWPLST ENTRY
;RETURN CPOPJ1 WITH U, T1 SET TO DISK ADDRESS
;RETURNS CPOPJ IF THINGS ARE MESSED UP
SWPMEM:	SE1ENT			;MUST BE IN SECTION 1 TO REFERENCE MEMTAB
	LDB	T1,[POINT 13,T1,26]  ;GET PHYSICAL PAGE NUMBER
	SSX	T1,MDSEC2	;MEMTAB SECTION
	SKIPN	T1,MEMTAB(T1)	;GET DSK ADDRESS
	STOPCD	CPOPJ##,DEBUG,MIZ,	;++MEMTAB IS ZERO
SWPADR::
	LDB	U,UNZCFS##	;GET SWAP UNIT
	SKIPE	U,SWPTAB##(U)

	SKIPG	UNISLB##(U)
	STOPCD	.,STOP,SBZ,	;++SWAP BLOCK ZERO
	LDB	T1,UNZFKS##	;1ST LOGICAL K
	ROT	T1,BLKSPP##	;CONVERT TO BLOCKS
	ADD	T1,UNISLB##(U)	;PLUS STARTING BLOCK NUMBER
	JRST	CPOPJ1##	;RETURN
;SUBROUTINE TO BE CALLED WHEN IO IS FINISHED. ENTERED AT INTERRUPT LEVEL FROM FILIO
;CALLED WITH P1=LOC OF SWPLST ENTRY, T1= NUMBER OF BLOCKS TRANSFERRED, P2=ERROR BITS
DONE::	MOVE	T2,(P1)		;SWPLST ENTRY
	MOVEI	T3,UNIICT##(U)	;SET CORRECT UNIT WORD TO
	TLNN	T2,(SL.SIO)	; COUNT THE IO (SWAP OR PAGE, IN OR OUT)
	MOVEI	T3,UNIPCI##(U)
	TLNE	S,IO
	ADDI	T3,1
	ADDM	T1,(T3)
	PUSHJ	P,SW2LC		;GET INDEX INTO 2ND TABLE
	MOVE	T4,SW2LST##(T1)	;ORIGINAL SWPLST ENTRY
	TRNE	S,IODERR+IODTER+IOIMPM	;IO ERROR?
	TLO	T4,(SL.ERR)	;YES, SET BIT
	TRNE	P2,IOCHMP+IOCHNX ;CHAN-DETECTED ERROR?
	TLO	T4,(SL.CHN)	;YES
DONE9:	HLRZ	T3,P1		;ORIGINAL SWPLST ENTRY IF A FRAGMENT
	LDB	T2,[POINT 9,(P1),35] ;NUMBER OF PAGES LEFT IN ENTRY
	TLNN	T4,(SL.ERR+SL.CHN) ;ABORT IF ERROR
	JUMPN	T2,DONE6
	JUMPE	T3,DONE1	;NO, GO IF NOT IN A FRAGMENT
	MOVSI	T2,(SL.IOP)	;IN A FRAGMENT - CLEAR THE IOP BIT
	ANDCAM	T2,(T3)		; IN THE SWPLST ENTRY ITSELF
DONE1:	TLZE	T4,(SL.IOP)	;CLEAR IN-PROGRESS BIT
	TLOE	T4,(SL.IOD+SL.DFM) ;SET DONE BIT
	STOPCD	.+1,DEBUG,SBW,	;++SWPLST BITS WRONG
	SETZM	SW2LST##(T1)
	MOVEM	T4,(P1)		;SAVE UPDATED SWPLST ENTRY
	TLNE	T4,(SL.CHN+SL.ERR)
	HRRZM	U,SWPEUJ##	;SAVE ADR OF UNIT
	JUMPE	T3,DONE5	;FINISHED IF NONE
	TLNE	T4,(SL.ERR+SL.CHN)  ;IF AN ERROR,
	JRST	DONE4		; DONT WASTE TIME BY CONTINUING
	SKIPL	T1,(T3)		;GET ADR OF START OF CHAIN
	STOPCD	DONE4,DEBUG,NRF,	;++SWPLST NOT REALLY FRAGMENTED
DONE2:	SKIPN	T2,(T1)		;LOOK AT NEXT ENTRY IN FRAGMENT CHAIN
	JRST	DONE4		;WHOLE CHAIN DONE IF AT END
	JUMPGE	T2,DONE3	;CHECK IT IF NOT ANOTHER POINTER
	MOVE	T1,T2		;GO TO NEXT PART OF CHAIN
	JRST	DONE2
DONE3:	TLNN	T2,(SL.IOD)	;THIS FRAGMENT DONE?
	POPJ	P,		;NO, DONT WAKE UP SWAPPER
	AOJA	T1,DONE2	;YES, TEST NEXT ENTRY OF FRAGMENT CHAIN
;HERE IF THE ENTIRE SWPLST FRAGMENT CHAIN IS FINISHED
DONE4:	HLLZS	T4		;INDICATE DONE, ERROR BIT IF ON
	IORB	T4,(T3)
	HLRZS	P1		;POINT TO SWPLST
DONE5:	HRLOI	T1,377777	;SET UNISWD HUGE
IFN FTDUAL,<
	SKIPE	T2,UNI2ND##(U)
	MOVEM	T1,UNISWD##(T2)
>
	MOVEM	T1,UNISWD##(U)
	TLNE	T4,(SL.IPC)	;IF IPC PAGING
	TLNN	T4,(SL.DIO)	; OUT
	JRST	SWPINT##
	AOS	IPCCNT##	;BUMP A COUNT
	PJRST	SWPINT##	;KICK THE SWAPPER
;HERE IF THE SWPLST ENTRY WASN'T ENTIRELY PROCESSED
DONE6:	JUMPN	T3,CPOPJ##	;LEAVE SL.IOP ON IF IN A FRAGMENT
	MOVSI	T1,(SL.IOP)	;CLEAR THE IO IN PROGRESS BIT
	ANDCAM	T1,(P1)		; SO NEXT WILL CONSIDER THIS ENTRY AGAIN
	POPJ	P,		;AND RETURN

IFE FTKS10,<
;SUBROUTINE TO SET UP AN IOLIST FOR A SWAP/PAGE OPERATION
;ENTER P1=LOC OF SWPLST ENTRY, T3= MAX NUMBER OF BLOCKS TO DO
;EXIT P3=LOC OF 1ST IOWD, T1= NUMBER OF BLOCKS IN LIST
THIS::	PUSHJ	P,GETSWJ	;GET JOB NUMBER
	  PUSHJ	P,SVEUB##	;MAKE JOB ADDRESSABLE
	PUSHJ	P,SAVE4##	;SAVE P'S
	LSH	T3,-2		;CONVERT BLOCKS TO PAGES
	MOVE	P4,(P1)		;GET SWPLST ENTRY
	LDB	P2,[POINT 9,P4,35] ;NUMBER OF PAGES REQUIRED
	MOVE	T2,P2
	CAMLE	P2,T3		;NEED MORE THAN WE CAN DO?
	MOVE	P2,T3		;YES, SETTLE FOR LESSER AMOUNT
	SUB	T2,P2		;AMOUNT LEFT AFTER THIS OPERATION FINISHED
	PUSH	P,T2
	TLO	P4,(SL.IOP)	;INDICATE IO IN PROGRESS
	PUSHJ	P,SW2LC
	SKIPN	SW2LST##(T1)	;IF THE FIRST TIME,
	MOVEM	P4,SW2LST##(T1)	; SAVE THE SWPLST ENTRY IN DUPLICATE TABLE
	DPB	T2,[POINT 9,P4,35] ;UPDATE SWPLST ENTRY WITH NEW COUNT
	MOVEM	P4,(P1)
	MOVE	T2,P2		;NUMBER OF PAGES WE'LL DO
	LSH	T2,2		;CONVERT TO BLOCKS
	EXCH	T2,(P)
	PUSH	P,T2		;SAVE (RETURN NUMBER TO FILIO)
	DSKOFF			;PROTECT AGAINST S BEING CHANGED AT
				; INTERRUPT LEVEL
	TLNE	P4,(SL.DIO)	;INPUT OR OUTPUT?
	TLOA	S,IO		;OUTPUT
	TLZ	S,IO		;INPUT
	TRZ	S,IODTER+IODERR+IOIMPM
	MOVEM	S,DEVIOS(F)	;SAVE UPDATED S
	SETZ	P1,		;WE NEED AN IOWD
	PUSHJ	P,GCH4WD##	;GET A LOW-CORE BLOCK FOR THE IOLIST
	  JRST	THIS10		;CANT GET ONE!
	MOVE	P1,T1		;ADR IN P1
	HRLI	P1,-3		;CAN SAVE 3 IOWD'S WITH NO HASSLE
	MOVEM	T1,-5(P)	;RETURN INITIAL IOWD LOC IN P2

;STILL IN IFE FTKS10
	PUSH	P,U		;SAVE U
	MOVEI	U,0		;U=0 FOR 18-BIT CHAN
	SKIPGE	T2,CHB22B##(P3)
	MOVEI	U,1		;22-BIT CHAN
IFN FTKL10,<
	TLNE	T2,CP.RH2##	;RH20?
	MOVEI	U,2		;YES
>

IFN FTIPCF,<
	TLNN	P4,(SL.IPC)	;IPCF PAGE?
>
	CAILE	J,JOBMAX##	;HIGH SEG?
	TLOA	U,400000	;INDICATE BY U NEGATIVE
	SKIPA	T1,.USLPS	;NO GET SAVE PNTR IF IT EXISTS
	MOVE	T1,[POINT 13,JBTUPM##(J),21]	;HIGH SEG - JBTUPM SAVES WHERE WE LEFT OFF
	LDB	P4,[POINT 13,P4,26]	;PHYSICAL PAGE TO START IO AT
	HRRZ	T2,JBTUPM##(J)	;SWAPPING THE UPMP?
	CAIN	T2,(P4)
	TLO	U,400000	;YES, NO NEXT PAGE
	JUMPGE	U,THIS1		;GO IF NOT HIGH SEG OR UPMP
	CAIG	J,JOBMAX##	;HI SEG?
	JRST	THIS3		;NO, UPMP OR IPCF PAGE
	LDB	T1,T1		;GET SAVED LAST PNTR
	TRZ	T1,740000	;CLEAR EXTRANEOUS BITS
	SKIPE	T1		;IS THERE ONE?
	MOVE	P4,T1		;YES, POINT P4 AT 1ST PAGE TO START SWAPPING
	SETO	P3,0		;MAKE SURE P3 IS NON-ZERO FOR TEST AT THIS8B
	JRST	THIS3		;AND CONTINUE

;STILL IN IFE FTKS10
;HERE WITH P4=PAGE NUMBER OF THE BEGINNING PAGE OF THE IO
THIS1:	SKIPN	P3,T1		;HAVE A SAVED UPMP POINTER?
	JRST	THIS2		;NO
	LDB	P4,P3		;YES, GET MAP ENTRY
	ANDI	P4,17777	;CLEAR UNWANTED BITS
	JRST	THIS3		;AND CONTINUE
THIS2:	TLNN	S,IO		;OUTPUT?
	JRST	THIS3		;NO, DONT NEED POINTER TO LAST SLOT
IFE FTKLP,<
	MOVE	P3,[POINT 18,.UPMP,17] ;YES, ASSUME START AT PAGE 0
>
IFN FTKLP,<
	MOVE	P3,[POINT 36,.UPMAP,35]
>
	LDB	T1,P3		;PHYSICAL PAGE NUMBER FROM UPMP
IFE FTKLP,<
	ANDI	T1,417777	;CLEAR ACCESS BITS
	TRZE	T1,400000
>
IFN FTKLP,<
	AND	T1,[<PM.ACD>B2+17777]
	TLZE	T1,(<PM.DCD>B2)
>
	CAIE	T1,(P4)		;SAME AS STARTING PHYSICAL PAGE?
	PUSHJ	P,MAPSLT	;NO, GET A POINTER TO STARTING PAGE
THIS3:	MOVE	T1,P4		;STARTING PAGE
	MOVE	T2,[400000+T1,,1] ;SET TO COUNT CONTIGUOUS PAGES
IFN FTKLP,<
	XJRST	 [MCSEC1+.+1]	;ENTER SECTION 1 FOR PAGTAB/MEMTAB REFERENCES
>
THIS4:	SSX	P4,MDSEC2	;SET SECTION INDEX FOR PAGTAB/MEMTAB
	SKIPGE	MEMTAB(P4)	;IS THIS LAST PAGE IN FRAGMENT?
	SOJN	P2,@[0,,THIS7]	;YES, SOMEONE IS CONFUSED IF NOT LAST PAGE
	JUMPL	U,THIS5		;GO IF HI-SEG
	LDB	T4,[POINT 17,MEMTAB(P4),35] ;DSK ADR OF THIS PAGE
	TLNE	S,IO		;IF SWAPPING OUT,
IFN FTKLP,<
	TLZE	U,200000	;PAGE MAP SLOT?
	CAIA
>
	DPB	T4,P3		; SAVE ADR IN UPMP
	JUMPE	P2,THIS6	;GO IF LAST PAGE
	LDB	T4,[POINT 13,MEMTAB(P4),17] ;POINTER TO NEXT VIRTUAL PAGE
	JUMPE	T4,@[0,,THIS7]	;ERROR IF 0
	CAIN	T4,.UPMVP/PAGSIZ## ;UPMP?
	TLO	U,400000	;YES, DONT WIPE OUT SLOT IN MAP
	TLNN	S,IO		;INPUT?
	TLZ	U,400000	;YES, STOP ON COUNT EXHAUSTED
IFN FTKLP,<
	CAIN	T4,<.UPMVP-PAGSIZ##>/PAGSIZ## ;DON'T CLOBBER SLOT (MAPBAR)
	TLO	U,200000
>
	PUSHJ	P,GMPTR		;GET A POINTER TO THE MAP
	LDB	P4,T4		;CONTENTS OF THE MAP
	ANDI	P4,17777	;CLEAR ACCESS BITS
	SKIPA	P3,T4		;POINTER FOR NEXT DEPOSIT
THIS5:	HRRZ	P4,PAGTAB(P4)	;HI-SEG GETS NEXT PAGE FROM PAGTAB
	HRRZ	T4,U		;LEFT HALF = 0 FOR INDEXING
	CAIN	P4,@T2		;PAGES CONTIGUOUS?
	CAML	T2,MAXCNT(T4)	;YES, BELOW MAX SIZE OF AN IOWD?
	SOJA	P2,THIS6	;NO, MAKE THE IOWD
IFN FTKL10,<
	CAMN	T2,[400000+T1,,27] ;DON'T BUILD AN IOWD
	SOJA	P2,THIS6	; THAT LOOKS LIKE AN RH20 GOTO WORD
>
	SOJLE	P2,THIS6	;MAKE THE IOWD IF DONE
	AOJA	T2,THIS4	;PAGE IN IOWD - COUNT AND TRY NEXT PAGE

;STILL IN IFE FTKS10
;HERE TO FINISH THE IOWD
THIS6:
IFN FTKLP,<
	JRST	@[0,,.+1]	;REYURN TO SECTION 0
>
	IMULI	T2,-1000	;COMPUTE WORDCOUNT
	LSH	T1,P2WLSH##	;CONVERT BEGINNING PAGE NUMBER TO ADDRESS
IFE FTKL10,<
	SUBI	T1,1		;MAKE AN IOWD
>
IFN FTKL10,<
	TRNN	U,2		;IF NOT AN RH20,
	SOJA	T1,THIS6A	; ADDR-1
	MOVNS	T2		;RH20 - ADDR RATHER THAN ADR-1
	TRO	T2,RH2TRX##	; +WDCNT, TRA BIT
THIS6A:>
	DPB	T2,PNTCNT(U)

	MOVEM	T1,(P1)		;SAVE IOWD IN LOCORE BLOCK
	ADDI	T1,1		;ADDRESS OF 1ST WORD TO TRANSFER
	AND	T1,MSK22B##(U)	;GET ADDRESS
IFE FTKL10!FTKS10,<		;ONE-TO-ONE NOT GUARANTEED ON KL/KS

	CAMGE	T1,SYSSIZ##	;TOO LOW?
	STOPCD	.,STOP,P2L,	;++PAGE TOO LOW
>
	JUMPLE	P2,THIS8	;DONE IF P2=0
	AOBJN	P1,THIS3	;MORE TO DO, GET NEXT CHUNK
IFN FTKL10,<
	TRNE	U,2		;IF AN RH20
	TRO	U,4		; TELL KLSER
>
	PUSHJ	P,GETMOR##	;NEED ANOTHER 4-WORD BLOCK
	  JRST	THIS9		;NONE AVAILABLE
IFN FTKL10,<
	TRZ	U,4		;CLEAR KLSER'S RH20-BIT
>
	JRST	THIS3		;GOT IT, DO NEXT CHUNK

THIS7:	STOPCD	THIS8,DEBUG,IPM, ;++ILLEGAL POINTER IN MEMTAB

;STILL IN IFE FTKS10
;HERE WHEN ALL REQUIRED IOWDS HAVE BEEN BUILT
THIS8:	SETZM	1(P1)		;TERMINATE THE LIST
	AOS	T3,P1		;POINT AT TERMINATION WORD
IFN FTKL10,<
	TRNN	U,2		;RH20?
	JRST	THIS8A		;NO
	MOVSI	T1,RH2LST##	;YES, INDICATE LAST IOWD
	IORB	T1,-1(P1)
	LDB	T2,[POINT 11,T1,13]	;WORDCOUNT
	TLZ	T1,077760	;CLEAR WDCNT FIELD
	ADD	T1,T2		;ADDR + N
	JRST	THIS8B		;STORE IN CHNTCW AND CONTINUE
THIS8A:>
	HLRO	T1,-1(P1)	;WORD COUNT OF LAST IOWD
	LDB	T2,ADRPT2##(U)	;WHERE DATA ASSOCIATED WITH LAST IOWD
	ASH	T1,@ASH22B##(U)	; WILL START

	SUBM	T2,T1		;WHERE LAST DATA ITEM WILL GO
	DPB	P1,ADRPT4##(U)	;WHERE TERMINATION WORD WILL BE FETCHED FROM

THIS8B:	MOVE	T2,-5(P)	;ADDRESS OF THE CHANNEL DATA BLOCK
	MOVEM	T1,CHNTCW##(T2)	;STORE WHAT CHANNEL TERMINATION WORD SHOUL LOOK LIKE
	POP	P,U		;RESTORE U
	POP	P,T1
	SKIPN	T1		;WILL THIS BE THE LAST IO?
	SETZB	P3,P4		;YES
	CAIG	J,JOBMAX##
	MOVEM	P3,.USLPS	;SAVE POINTER TO NEXT PART IN UPMP
	CAILE	J,JOBMAX##
	DPB	P4,[POINT 13,JBTUPM##(J),21]
	JUMPE	P3,THIS8C	;GO IF NO MORE TO DO
	MOVE	P1,-5(P)
	DPB	P4,[POINT 13,(P1),26]
	HLRZS	P1		;SWPLST ENTRY FOR MAIN WORD
	JUMPE	P1,THIS8C	;GO IF NOT IN A FRAGMENT
	MOVSI	T1,(SL.IOP)
	IORM	T1,(P1)		;INDICATE IN A FRAGMENT FOR NEXT
				; (SO WILL ONLY PICK THIS PIECE)
THIS8C:	POP	P,T1		;NO OF BLOCKS TO TRANSFER
	SKIPE	DINITF##
	POPJ	P,
	TLNN	S,IO
	ADDM	T1,.CPSBI##	;COUNT TOTAL SWAPPING BLOCKS
	TLNE	S,IO
	ADDM	T1,.CPSBO##
	POPJ	P,		;AND RETURN
;STILL IN IFE FTKS10
;HERE IF WE RAN OUT OF LOWER CORE BLOCKS
THIS9:	HRRZ	T1,-7(P)
	ADDM	P2,(T1)		;INCREASE # PAGES LEFT TO DO
	LSH	P2,2
	ADDM	P2,-1(P)	;UPDATE # BLOCKS LEFT AFTER THIS IO
	MOVNS	P2
	ADDM	P2,-2(P)	;UPDATE # BLOCKS DONE THIS OPERATION
	SOJA	P1,THIS8	;FINISH UP, START THE IO

;HERE IF THERE WASNT A LOWER-CORE BLOCK TO START AT
THIS10:	ADD	P4,P2		;MAKE P4 THE SWPLST ENTRY AGAIN
	TLZ	P4,(SL.IOP)
	HRRZ	P1,-6(P)	;RESET P1
	MOVEM	P4,(P1)		;SAVE BACK IN SWPLST
	POP	P,(P)		;CLEAR GARBAGE OFF LIST
	SETZB	T1,-4(P)	;INDICATE 0 BLOCKS TRANSFERRED
	PJRST	T2POPJ##	;RETURN TO FILIO
>;END IFE FTKS10

IFN FTKS10,<
;SUBROUTINE TO SET UP UNIBUS ADAPTER MAPPING REGISTERS FOR A SWAP/PAGE OPERATION
;ENTER P1=LOC OF SWPLST ENTRY, T3= MAX NUMBER OF BLOCKS TO DO
;EXIT P3=LOC OF 1ST IOWD, T1= NUMBER OF BLOCKS IN LIST
THIS::	PUSHJ	P,GETSWJ	;GET JOB NUMBER
	  PUSHJ	P,SVEUB##	;MAKE JOB ADDRESSABLE
	PUSHJ	P,SAVE4##	;SAVE P'S
	LSH	T3,-2		;CONVERT BLOCKS TO PAGES
	MOVE	P4,(P1)		;GET SWPLST ENTRY
	LDB	P2,[POINT 9,P4,35] ;NUMBER OF PAGES REQUIRED
	MOVE	T2,P2
	CAMLE	P2,T3		;NEED MORE THAN WE CAN DO?
	MOVE	P2,T3		;YES, SETTLE FOR LESSER AMOUNT
	SUB	T2,P2		;AMOUNT LEFT AFTER THIS OPERATION FINISHED
	PUSH	P,T2
	TLO	P4,(SL.IOP)	;INDICATE IO IN PROGRESS
	PUSHJ	P,SW2LC
	SKIPN	SW2LST##(T1)	;IF THE FIRST TIME,
	MOVEM	P4,SW2LST##(T1)	; SAVE THE SWPLST ENTRY IN DUPLICATE TABLE
	DPB	T2,[POINT 9,P4,35] ;UPDATE SWPLST ENTRY WITH NEW COUNT
	MOVEM	P4,(P1)
;STILL IN IFN FTKS10
	MOVE	T2,P2		;NUMBER OF PAGES WE'LL DO
	LSH	T2,2		;CONVERT TO BLOCKS
	EXCH	T2,(P)
	PUSH	P,T2		;SAVE (RETURN NUMBER TO FILIO)
	DSKOFF			;PROTECT AGAINST S BEING CHANGED AT
				; INTERRUPT LEVEL
	TLNE	P4,(SL.DIO)	;INPUT OR OUTPUT?
	TLOA	S,IO		;OUTPUT
	TLZ	S,IO		;INPUT
	TRZ	S,IODTER+IODERR+IOIMPM
	MOVEM	S,DEVIOS(F)	;SAVE UPDATED S
	MOVE	P1,CHNIMR##(P3)	;GET ADDRESS OF INITIAL MAPPING REGISTER
	MOVEI	T4,UBAEXP	;GET INITIAL MAPPING REGISTER ADDRESS
	SUBM	P1,T4		;DISPLACEMENT OF THIS DEVICES FIRST
	IMULI	T4,UBAMUL	;MAKE INTO AN ELEVEN STYLE ADDRESS
	MOVEM	T4,CHNIEA##(P3)	;AND SAVE AS INITIAL ELEVEN ADDRESS
	MOVE	T4,CHNUBA##(P3)	;GET UNIBUS ADAPTER NUMBER (36 BIT)
	MOVE	T3,CHNMRC##(P3)	;GET COUNT OF AVAILABLE MAPPING REGISTERS
	PUSH	P,U		;SAVE U
	MOVEI	U,0		;U=0 FOR 18-BIT CHAN
IFN FTIPCF,<
	TLNN	P4,(SL.IPC)	;IPCF PAGE?
>
	CAILE	J,JOBMAX	;HIGH SEG?
	TLOA	U,400000	;INDICATE BY U NEGATIVE
	SKIPA	T1,.USLPS;NO GET SAVE PNTR IF IT EXISTS
	MOVE	T1,[POINT 13,JBTUPM(J),21] ;HIGH SEG - JBTUPM SAVES WHERE WE LEFT OFF
	LDB	P4,[POINT 13,P4,26] ;PHYSICAL PAGE TO START IO AT
	HRRZ	T2,JBTUPM##(J)	;SWAPPING THE UPMP?
	CAIN	T2,(P4)
	TLO	U,400000	;YES, NO NEXT PAGE
	JUMPGE	U,THIS1		;GO IF NOT HIGH SEG OR UPMP
	CAIG	J,JOBMAX##	;HI SEG?
	JRST	THIS3		;NO, UPMP OR IPCF PAGE
	LDB	T1,T1		;GET SAVED LAST PNTR
	TRZ	T1,740000	;CLEAR EXTRANEOUS BITS
	SKIPE	T1		;IS THERE ONE?
	MOVE	P4,T1		;YES, POINT P4 AT 1ST PAGE TO START SWAPPING
	JRST	THIS3		;AND CONTINUE

;STILL IN IFN FTKS10
;HERE WITH P4=PAGE NUMBER OF THE BEGINNING PAGE OF THE IO

THIS1:	SKIPN	P3,T1		;HAVE A SAVED UPMP POINTER?
	JRST	THIS2		;NO
	LDB	P4,P3		;YES, GET MAP ENTRY
	TRZ	P4,760000	;CLEAR UNWANTED BITS
	JRST	THIS3		;AND CONTINUE
THIS2:	TLNN	S,IO		;OUTPUT?
	JRST	THIS3		;NO, DONT NEED POINTER TO LAST SLOT
	MOVE	P3,[POINT 18,.UPMP,17] ;YES, ASSUME START AT PAGE 0
	LDB	T1,P3		;PHYSICAL PAGE NUMBER FROM UPMP
	ANDI	T1,417777	;CLEAR ACCESS BITS
	PUSH	P,T3		;SAVE T3 AROUND MAPLST CALL
	PUSH	P,T4		;SAVE T4 AROUND MAPLST CALL
	TRZE	T1,400000
	CAIE	T1,(P4)		;SAME AS STARTING PHYSICAL PAGE?
	PUSHJ	P,MAPSLT	;NO, GET A POINTER TO STARTING PAGE
	POP	P,T4		;RESTORE T4
	POP	P,T3		;RESTORE T3
THIS3:	MOVE	T1,P4		;STARTING PAGE
	SKIPGE	MEMTAB(P4)	;IS THIS LAST PAGE IN FRAGMENT?
	SOJN	P2,THIS7	;YES, SOMEONE IS CONFUSED IF NOT LAST PAGE
	JUMPL	U,THIS5		;GO IF HI-SEG
	LDB	T2,[POINT 17,MEMTAB(P4),35] ;DSK ADR OF THIS PAGE
	TLNE	S,IO		;IF SWAPPING OUT,
	DPB	T2,P3		; SAVE ADR IN UPMP
	JUMPE	P2,THIS6	;GO IF LAST PAGE
	LDB	P3,[POINT 13,MEMTAB(P4),17] ;POINTER TO NEXT VIRTUAL PAGE
	JUMPE	P3,THIS7	;ERROR IF 0
	CAIN	P3,.UPMVP/PAGSIZ## ;UPMP?
	TLO	U,400000	;YES, DONT WIPE OUT SLOT IN MAP
	ROT	P3,-1		;COMPUTE A POINTER TO SLOT IN UPMP
	TLZE	P3,400000	; IN ORDER TO GET NEXT PHYSICAL PAGE NO
	TDOA	P3,[POINT 13,.UPMP,35]
	TDO	P3,[POINT 13,.UPMP,17]
	LDB	P4,P3		;NEXT PHYSICAL PAGE
	TLCA	P3,003700	;CONVERT POINTER TO 18 BITS FOR DEPOSIT
THIS5:	HRRZ	P4,PAGTAB(P4)	;HI-SEG GETS NEXT PAGE FROM PAGTAB

;HERE TO LOAD THE MAPPING REGISTER, PAGE NUMBER IN T1

THIS6:	TRO	T1,UNB36B!UNBVBT ;SET 36 BIT MODE AND VALID BIT
	HRR	T4,P1		;MAKE 36 BIT REGISTER ADDRESS
	WRIO	T1,(T4)		;LOAD THE MAPPING REGISTER
	REPEAT	0,<		;1 TO 1 NOT GUARANTEED
	TRZ	T1,UNB36B!UNBVBT ;CLEAR THE BITS
	LSH	T1,P2WLSH##	;MAKE IT AN ADDRESS
	CAMGE	T1,SYSSIZ##	;TOO LOW?
	STOPCD	.,STOP,P2L,	;++PAGE TOO LOW
>
	ADDI	P1,1		;POINT TO NEXT MAPPING REGISTER
	SOJLE	P2,THIS8	;DONE IF P2=0
	SOJG	T3,THIS3	;IF THERE IS ONE AVAILABLE
	JRST	THIS9		;NONE LEFT, CLEAN UP FOR PARTIAL TRANSFER

THIS7:	STOPCD	THIS8,DEBUG,IPM, ;++ILLEGAL POINTER IN MEMTAB
;HERE WHEN ALL MAPPING REGISTERS HAVE BEEN LOADED

THIS8:	MOVE	T2,-5(P)	;ADDRESS OF THE CHANNEL DATA BLOCK
	SUB	P1,CHNIMR##(T2)	;GET NUMBER OF MAPPING REGISTERS USED
	LSH	P1,P2WLSH##+2	;MAKE INTO WORDS, 11 STYLE
	MOVEM	P1,CHNTCW##(T2)	;STORE ADDRESS OF LAST WORD TO BE TRANSFERRED
	SUB	P1,CHNIEA##(T2)	;COMPUTE TOTAL NUMBER OF BYTES IN TRANSFER
	MOVEM	P1,CHNBTC##(T2)	; AND PUT IT HERE
	POP	P,U		;RESTORE U
	POP	P,T1
	SKIPN	T1		;WILL THIS BE THE LAST IO?
	SETZB	P3,P4		;YES
	CAIG	J,JOBMAX##
	MOVEM	P3,.USLPS;SAVE POINTER TO NEXT PART IN UPMP
	CAILE	J,JOBMAX##
	DPB	P4,[POINT 13,JBTUPM(J),21]
	JUMPE	P3,THIS8C	;GO IF NO MORE TO DO
	MOVE	P1,-5(P)
	DPB	P4,[POINT 13,(P1),26]
	HLRZS	P1		;SWPLST ENTRY FOR MAIN WORD
	JUMPE	P1,THIS8C	;GO IF NOT IN A FRAGMENT
	MOVSI	T1,(SL.IOP)
	IORM	T1,(P1)		;INDICATE IN A FRAGMENT FOR NEXT
				; (SO WILL ONLY PICK THIS PIECE)
THIS8C:	POP	P,T1		;NO. OF BLOCK TO TRANSFER
	SKIPE	DINITF##
	POPJ	P,
	TLNN	S,IO
	ADDM	T1,.CPSBI##	;COUNT TOTAL SWAPPING BLOCKS
	TLNE	S,IO
	ADDM	T1,.CPSBO##
	POPJ	P,		;AND RETURN

;HERE IF WE RAN OUT OF MAPPING REGISTERS

THIS9:	MOVE	T2,-7(P)
	ADDM	P2,(T2)		;INCREASE # PAGES LEFT TO DO
	LSH	P2,2
	ADDM	P2,-1(P)	;UPDATE # BLOCKS LEFT AFTER THIS IO
	MOVNS	P2
	ADDM	P2,-2(P)	;UPDATE # BLOCKS DONE THIS OPERATION
	SOJA	P1,THIS8	;FINISH UP, START THE IO


>;END IFN FTKS10
;SUBROUTINE TO SET UP J FROM SWPLST ENTRY
;ENTER P1 POINTING TO SWPLST
;EXIT CPOPJ IF A LOW SEG, CPOPJ1 IF HIGH
GETSWJ:	PUSHJ	P,SW2LC		;GET INDEX OF SWPLST ENTRY
	HRRZ	J,SW3LST##(T1)	;GET JOB NUMBER
	CAILE	J,JOBMAX##	;HIGH SEG?
	AOS	(P)		;YES
	POPJ	P,		;AND RETURN


;SUBROUTINE TO COMPUTE INDEX INTO SW2LST TABLE
;ENTER P1=ADDRESS IN SWPLST (OR FRAGMENT, ADR IN LH)
;EXIT T1=INDEX
;PRESERVES T2-T4
SW2LC:	TLNN	P1,-1		;POINTER TO A FRAGMENT?
	SKIPA	T1,P1		;NO, USE MAIN ADDRESS
	HLRZ	T1,P1		;YES, GET SWPLST LOCATION
	TRZ	T1,400000	;SIGN BIT OF P1 MIGHT BE ON
	SUBI	T1,SWPLST##	;MAKE INTO AN INDEX
	POPJ	P,		;AND RETURN


;SUBROUTINE  TO COMPUTE POINTER TO CURRENT SLOT
;ENTER P4=PHYSICAL PAGE TO START IO ON (MEMTAB POINTS TO NEXT VIRTUAL PAGE)
;EXIT P3=POINTER TO UPMP ENTRY FOR THIS VIRTUAL PAGE
MAPSLT:	SE1ENT			;ENTER SECTION 1
	SSX	P4,MDSEC2	;MAKE MEMTAB ADDRESSABLE
	SKIPA	T3,MEMTAB(P4)	;GET POINTER TO NEXT SLOT
MAPSL1:	MOVE	T3,MEMTAB(T2)	;PNTR TO NEXT
	LDB	T1,[POINT 13,T3,17] ;GET NEXT VIRTUAL PAGE NUMBER
	PUSHJ	P,GTPME		;GET MAP ENTRY FOR THAT PAGE
	ANDI	T2,17777	;CLEAR EXTRANEOUS BITS
	SSX	T2,MDSEC2	;SETUP SECTION NUMBER FOR MAPSL1
	JUMPG	T3,MAPSL1	;LOOK AT NEXT IF NOT LAST PAGE IN CHAIN
	CAME	T2,P4		;LAST PAGE, IS IT POINTING AT RIGHT PAGE?
	STOPCD	MAPSL2,DEBUG,NFS,	;++NO FIRST SLOT
	SKIPA	P3,T4		;YES, GET POINTER IN P3
MAPSL2:	MOVEI	P3,0		;BUG - RETURN PNTR =0
	POPJ	P,
SUBTTL SWPSER INTERFACE WITH THE SWAPPER

;SUBROUTINE TO SETUP SWPLST FOR SWAP OUT
BOSLST::PUSHJ	P,SAVE3##	;SAVE ACS
	CAILE	J,JOBMAX##	;HI SEG?
	JRST	BOSLS5		;YES, DO IT DIFFERENTLY
	PUSHJ	P,SVEUB##	;LOW SEG, MAKE JOB ADDRESSABLE
	MOVE	T1,JBTADR##(J)	;SAVE JBTADR
	HLLM	T1,.USREL	; FOR SWAP-IN
	MOVE	T2,JBTSTS##(J)
	TLNE	T2,JXPN
	MOVEM	T1,.JDAT+JOBDPG##
IFN FTDHIA,<
	MOVE	T1,.JDAT+.JBPFH## ;GET JOBPFH
	MOVEM	T1,.USPFH	;AND SAVE IN UPMP FOR BISLST (MIGRATING JOB)
>
	SKIPGE	T1,JBTSWP##(J)	;FRAGMENTED?
	JRST	BOSLS1		;YES
	LDB	T2,IMGOUT##	;NO, GET SIZE TO SWAP OUT
	LDB	U,NFYPGS##	;ADD 1 PAGE FOR UPMP
	ADD	T2,U
	MOVN	U,T2
	HLL	U,T1		;STARTING DSK ADDRESS
	MOVSS	U		;-N,,ADR
	PUSHJ	P,SETOMT	;SETOMT WILL SET UP MEMTAB
	LDB	T1,JBYLSA##	;STARTING PAGE
	LSH	T1,11		;POSITION IT
	LDB	T2,IMGOUT##	;NUMBER OF PAGES
	LDB	T3,NFYPGS##	;PLUS 1 FOR UPMP
	ADD	T2,T3
	DPB	T2,[POINT 9,T1,35]	;IN T1
	JRST	BOSLS4		;SET LH BITS AND STORE T1 IN SWPLST

;HERE IF LOW SEG SWAP OUT AND DISK SPACE IS FRAGMENTED
BOSLS1:	HLRZ	P1,JBTSWP##(J)	;POINT P1 AT FRAGMENT TABLE
	TRZ	P1,FRGSEG	;CLEAR THE EXTRA BIT
	MOVSI	P2,(SL.DIO+SL.SIO)	;SWPLST DESCRIPTORS
	PUSHJ	P,NXTFRG	;SET UP U FOR THIS FRAGMENT
	  STOPCD	.+1,DEBUG,O1F,	;++ONLY 1 FRAGMENT
	PUSHJ	P,SETOMT	;SET UP MEMTAB
BOSLS2:	DPB	P3,[POINT 13,P2,26]	;STORE 1ST PAGE NUMBER OF FRAG
	MOVEM	P2,-1(P1)	;STORE THE SWPLST FRAGMENT IN TABLE
	PUSHJ	P,NXTFRG	;GET U FOR NEXT FRAG
	  JRST	BOSLS3		;LAST FRAGMENT
	MOVEI	P3,0		;P3=0 0N CALL TO SETOMT
	PUSHJ	P,[SE1ENT	;DO THIS IN SECTION 1
		JRST SETOM2]	;SET UP MEMTAB FOR THIS FRAG
	JRST	BOSLS2		;AND TRY NEXT
BOSLS3:	PUSHJ	P,[SE1ENT	;DO THIS IN SECTION 1
		SSX F,MDSEC2	;MAKE A REAL POINTER TO MEMTAB
		HRRZ U,MEMTAB(F)
		POPJ P,]
	HLRZ	T1,JBTSWP##(J)	;ADR OF FRAGMENT/SWPLST TABLE
	TDC	T1,[FRGSEG,,FRGSEG]	;INDICATE FRAGMENTED
;HERE WHEN DONE, T1=SWPLST ENTRY, U=DSK ADR OF UPMP
BOSLS4:	HRRZS	M		;IS THE UPMP THE LAST PAGE?
	CAIE	M,.UPMVP/PAGSIZ##
	STOPCD	.+1,DEBUG,UNL,	;++UPMP NOT LAST
	HRLM	U,JBTSWP##(J)	;SAVE UPMP ADR IN JBTSWP
	TLO	T1,(SL.DIO+SL.SIO) ;INDICATE SWAP OUT
	MOVSI	T2,(UP.PGB)	;INDICATE PAGES WILL BE GIVEN BACK
	ANDCAM	T2,.USBTS
	PJRST	MAKSLE		;STORE IN SWPLST AND RETURN

;HERE IF HIGH SEG SWAP OUT
BOSLS5:	LDB	P1,IMGOUT##	;SIZE OF OUTPUT IMAGE (NO PAGES TO SWAP)
	HRLI	P1,(SL.SIO+SL.DIO) ;SWPLST DESCRIPTORS
	PJRST	BHSLST		;GO DO IT
;SUBROUTINE TO SETUP SWPLST FOR SWAP IN OF UPMP
BUSLST::SE1ENT			;ENTER SECTION 1
	CAILE	J,JOBMAX##	;HI SEG?
	JRST	BISLS7		;YES, DO DIFFERENTLY
	PUSHJ	P,SVEUB##	;MAKE THE JOB ADDRESSABLE
	HLRZ	U,JBTSWP##(J)	;NO, GET DSK ADR OF UPMP
	HRRZ	T1,JBTUPM##(J)	;PAGE NUMBER OF UPMP
	TLO	U,(MT.LEF)	;INDICATE ONLY 1 PAGE
	SSX	T1,MDSEC2	;MAKE MEMTAB ADDRESSABLE
	MOVEM	U,MEMTAB(T1)	;MEMTAB FOR UPMP
IFE FTKLP,<
	LSH	T1,11		;POSITION PAGE FOR SWPLST
	ADDI	T1,1		;1 PAGE
>
IFN FTKLP,<
	SOS	U		;***THIS DEPENDS ON CONTIGUOUS ALLOCATION (SEE SWPSER)
	TLC	U,<<.UPMVP/PAGSIZ##>+<(MT.LEF)>>
	HRR	T1,PAGTAB(T1)
	MOVEM	U,MEMTAB(T1)
	HRRZS	T1		;CLEAR SECTION NUMBER FROM LEFT HALF
	LSH	T1,11
	ADDI	T1,2
>
	TLO	T1,(SL.SIO)	;SWAPPING UPMP IO (PREVENT FNDSLE FROM FINDING IT)
	LDB	T2,JBYLSA##	;NUMBER OF 1ST PAGE FOR JOB
	HRLM	T2,JBTSWP##(J)	;SAVE IN JBTSWP
	JRST	MAKSLE		;SET UP SWPLST AND RETURN
;SUBROUTINE TO SET UP SWPLST FOR SWAP IN OF JOB
BISLST::PUSHJ	P,SAVE4##	;SAVE SOME ACS
IFN FTDHIA,<
	SKIPE	.USVRT	;JOB VIRTUAL?
	CAME	J,MIGRAT##	;YES, BEING MIGRATED OFF A BAD UNIT?
	JRST	NOWSRS		;NO
	MOVE	P1,[NXWSC2,,NXWSC]	;YES, SET UP TO FIND W-S PAGES
	PUSHJ	P,TSTOFF	;ANY WS PAGES ON THE BAD UNIT?
	  JRST	NOWSRS		;YES, GET THEM OFF FIRST
	HLRZ	R,.USREL	;NO, SET UP JBTADR
	HRLM	R,JBTADR##(J)
	PUSHJ	P,PGOFFA	;ANY NON-WS PAGES ON BAD UNIT?
	  CAIA			;YES, HAVE TO GET THEM OFF
	JRST	BISLS0		;NO, WE'RE ALL DONE
;STILL IN FTDHIA CONDITIONAL
;SOME PAGES ARE ON THE BAD UNIT, ALL WS PAGES ARENT, SO SWITCH
; SOME BITS AROUND, PULLING IN THE PAGES OFF THE BAD UNIT
	MOVEI	T2,LOK		;SEE IF LOK IS SET
	MOVSI	T1,(UP.MIP)	;MIGRATE IN PROGRESS
	TDZN	T2,JBTSTS##(J)	;ALREADY SET?
	IORM	T1,.USBTS	;SET TO UNDO LOK
	IORM	T2,JBTSTS##(J)	;SET LOCK IF NOT
	LDB	T1,IMGIN	;BE SURE THAT IT'S NOT CHANGING SIZE
	LDB	T2,IMGOUT
	CAIE	T1,(T2)
	  JRST	NOWSRS		;IT IS, LET IT CHANGE SIZE FIRST THEN FIDDLE WITH IT
	HRRZ	T1,.USBTS	;DID WE ALREADY SAVE WSBTAB?
	JUMPN	T1,NOWSSV	;YES
	MOVEI	T2,WSBTBL	;HOW MUCH CORE TO SAVE WSBTAB
	PUSHJ	P,GETWDS##	;GET IT
	  JRST	NOWSRS
	HRRM	T1,.USBTS	;SAVE IT
	HRLI	T1,WSBTAB	;SAVE OLD WORKING SET
	MOVEI	T2,WSBTBL-1(T1)
	BLT	T1,(T2)		;AND MOVE IT IN
NOWSSV:
IFN FTPI,<
	PUSH	P,T1		;ALLOCATE STACK WORD
	PUSHJ	P,PSIIVR##	;GET LAST,,FIRST PAGE OF PSI VECTOR
	PUSH	P,T1
	HRRZS	(P)		;SAVE 1ST PAGE
	HLRZS	T1
	PUSH	P,T1		;SAVE LAST PAGE
>
	PUSHJ	P,NXTWSB	;INITIALIZE NXTWS, DONT WANT TO FLIP PAGE 0
	PUSHJ	P,EXCHT		;SAVE INITIAL STATE
	PUSHJ	P,NXTNWS	;GET 1ST NON-WS PAGE
	HRRZ	F,.USPFH	;MAKE SURE WE DONT FLIP
	HLRZ	R,.USPFH	; BITS FOR PFH (EFFECTIVELY
	LSH	F,W2PLSH##	; PAGING IT OUT)
	LSH	R,W2PLSH##
	CAIA
BITSW1:	PUSHJ	P,NXTNW2	;GET NEXT NON-WS BIT
	JUMPE	T4,BITSW3	;DONE IF 0
	PUSHJ	P,TSTUN		;PAGE ON BAD UNIT?
	  CAIA
	JRST	BITSW1		;NO, TEST NEXT PAGE
	PUSHJ	P,EXCHT		;YES, SAVE STATE, SET FOR NXTWSB
BITSW2:	PUSHJ	P,NXTWS2	;GET A WS PAGE
	CAIG	F,(M)		;IS IT IN PFH?
	CAIGE	R,(M)
	CAIA
	JRST	BITSW2		;YES, HAVE TO KEEP IT IN WS
IFN FTPI,<
	MOVEM	T4,-2(P)	;SAVE T4
	HRRZI	T4,(M)		;ONLY RIGHT HALF
	CAMG	T4,(P)		;ABOVE TOP OF PSI VECTOR?
	CAMGE	T4,-1(P)	;ABOVE BOTTOM
	SKIPA	T4,-2(P)
	JRST	BITSW2		;INTERRUPT VECTOR IS IN PAGE-SKIP IT
>
	TRNE	M,777000	;NO, DONE?
	JRST	BITSW3		;NOT ENOUGH WS PAGES TO FLIP ALL NON-WS PAGES
	LDB	T4,T4		;NO, GET MAP CONTENTS
	PUSHJ	P,TSTUN		;PAGE ON BAD UNIT?
	  JRST	BITSW2		;YES (WE ALREADY FLIPPED IT)
	PUSHJ	P,BTCOM		;NO, CLEAR WSBTAB BIT
	TLO	M,200000	;FOUND AT LEAST 1 PAGE TO SWITCH
	PUSHJ	P,EXCHT		;GET NON-WS ACS BACK
	PUSHJ	P,BTCOM		;SET WSBTAB BIT FOR THE PAGE
	JRST	BITSW1		;AND LOOK FOR MORE NON-WS PAGES
BITSW3:
IFN FTPI,<
	POP	P,(P)
	POP	P,(P)		;REMOVE JUNK FROM STACK
	POP	P,(P)
>
	TLNN	M,200000	;DID WE DO ANYTHING?
	TLNE	P4,200000
	JRST	BITSW4		;YES, FINISH UP
	MOVSI	T1,(UP.DDW)
	SKIPGE	JBTSTS##(J)	;IGNORE UP.DDW IF AT MONITOR
	TDNN	T1,.USBTS	;DON'T DO ANYTHING IF CAN'T
IFN FTMP,<
	PUSHJ	P,SCDMM##
	  JRST	BISLS0		;CAN'T DO IT NOW IF CAN'T GET THE MM
>
	SKIPN	CORTAL##	;NO, ANY FREE CORE RIGHT NOW?
	JRST	BISLS0		;CANT DO ANYTHING THIS PASS
	PUSHJ	P,SCPAGS##	;YES, ADD 1 PAGE TO JOB
	MOVEI	T2,1
	PUSHJ	P,ADPAGS##
IFN FTMP,<
	PUSHJ	P,GIVMM##	;GIVE UP THE MM
>
	PUSHJ	P,NXTNWS	;FIND FIRST NON-WS PAGE
	PUSHJ	P,TSTUN
	  JRST	BTSW3C		;FOUND PAGE
BTSW3A:	PUSHJ	P,NXTNW2	;FIND NEXT
	JUMPE	T4,BTSW3B	;IF NONE
	PUSHJ	P,TSTUN
	  JRST	BTSW3C
	JRST	BTSW3A		;EXCHANGE A USEFUL PAGE
BTSW3B:	PUSHJ	P,NXTNWS	;IF CAN'T FIND ANY (SHOULD NEVER BE)
BTSW3C:	TLO	T1,400000	;TELL BTCOM TO FIXED THE SAVED SET TOO
	PUSHJ	P,BTCOM		;AND LIGHT WSBTAB FOR IT
	AOS	JBTSWP##(J)	;HOUSEKEEP
BITSW4:	MOVSI	T1,(UP.WHC!UP.WSS) ;WORKING SET HAS CHANGED, BEEN SCRAMBLED
	IORM	T1,.USBTS
	TLNN	M,200000	;IF DIDN'T DO ANYTHING
	TLNE	P4,200000	;LET JOB PASS
	  JRST	NOWSRS
BISLS0:	HRLZ	T1,.USBTS
	JUMPE	T1,NOWSRS
	HRRI	T1,WSBTAB
	BLT	T1,WSBTAB+WSBTBL-1
	HRRZ	T2,.USBTS
	MOVEI	T1,WSBTBL
	HLLZS	.USBTS
	PUSHJ	P,GIVWDS##
	MOVSI	T2,(UP.MIP)	;MIGRATE IN PROGRESS
	MOVEI	T1,LOK
	TDNE	T2,.USBTS	;SHOULD WE CLEAR LOK?
	ANDCAM	T1,JBTSTS##(J)
	ANDCAM	T2,.USBTS	;CLEAR THIS TOO
NOWSRS:> ;END FTDHIA
	SETZB	P1,P3		;P1,P3=0 ON FIRST CALL TO SETIMT
	MOVEI	U,SETIMT	;WHERE TO GO
	SKIPL	JBTSWP##(J)	;IF NOT FRAGMENTED,
	JRST	BISLS1		;GO DIRECTLY TO SETIMT
	MOVSI	T1,400000	;FRAG'D
	ANDCAM	T1,JBTSWP##(J)	;CLEAR BIT IN JBTSWP
	DMOVE	T1,.USHSE
	LSH	T1,W2PLSH##
	LSH	T2,W2PLSH##
	EXCH	T1,.USTMP
	EXCH	T2,.USTMP+1
	DMOVE	T3,.USTMP+2	; TO SETIMT
	MOVE	M,.USTMP+4
	MOVE	F,.USTMP+5
	MOVEI	U,SETIMX	;WE'LL CALL SETIMX THIS TIME
BISLS1:	PUSHJ	P,(U)		;SET UP UPMP FOR THIS FRAG, OR WHOLE JOB
BISLS2:	  SKIPA	T1,P1		;DONE - GET 1ST VIRT,,1ST PHYS
	JRST	BISLS3		;ANOTHER FRAG TO DO
	TLZ	T1,-1		;1ST PHYSICAL PAGE
	LSH	T1,11		;POSITION IT
	TLO	T1,(SL.SIO)	;SWAPPING IO
	DPB	P3,[POINT 9,T1,35]	;NUMBER OF PAGES TO DO
	JRST	BISLS6		;SET UP JBTADR AND CALL MAKSLE
;HERE WHEN FRAGMENTED
BISLS3:	MOVEI	P4,0		;INDICATE 1ST CALL
	PUSHJ	P,GT4MR		;GET A 4-WORD BLOCK
	  JRST	BISLS8		;CANT GET ONE
	HRRZ	P2,P4		;SAVE 1ST ADR OF 4-WD BLOCKS
BISLS4:	HRLI	P3,(SL.SIO)	;SWAPPING IO
	DPB	P1,[POINT 13,P3,26]	;1ST PHY PAGE
	MOVEM	P3,(P4)		;SAVE SWPLST ENTRY IN 4-WD BLOCK
	JUMPL	P2,BISLS5	;GO IF LAST FRAG
	SETZB	P1,P3		;NOT LAST, SETIMX WANTS P1,P3=0
	PUSHJ	P,SETIMX	;SET UP UPMP FOR THIS FRAG
	  TLO	P2,400000	;LAST FRAGMENT - P2 NEGATIVE
	AOBJN	P4,BISLS4	;GO DO NEXT IF 4-WD BLOCK NOT EXHAUSTED
	PUSHJ	P,GT4MR		;GET ANOTHER BLOCK
	  JRST	BISLS8		;NONE AVAILABLE
	JRST	BISLS4		;GET ONE - CONTINUE

;HERE WHEN LAST FRAGMENT DONE
BISLS5:	SETZM	1(P4)		;TERMINATE LIST
	HRRZ	T1,P2		;ADR OF START OF 4-WD BLOCKS
	TLO	T1,FRGSEG(SL.SIO)	;FRAGMENTED SWAP
;HERE AT END OF FRAG (OR WHOLE JOB)
BISLS6:	HLRZ	M,.USREL	;LH (JBTADR) ON SWAP-OUT
	HRRZS	.USREL	;CLEAR LH (.UPREL)
	HRLM	M,JBTADR##(J)
	MOVE	R,JBTADR##(J)	;MAKE SURE R IS RIGHT
	LSH	M,W2PLSH##
	DPB	M,JBYLSS##	;SAVE AS LOW SEG SIZE
	SKIPLE	T2,JBTSGN##(J)	;IS THERE A NON-SHARABLE HI-SEG?
	TLNE	T2,SHRSEG
	JRST	MAKSLE		;NO, GO MAKE THE SWPLST ENTRY
IFN FTKLP,<
	HRRZS	T2		;CLEAR JUNK
>
	LDB	T3,[POINT 9,JBTADR##(T2),8]	;YES
	SKIPE	JBTADR##(T2)	;HIGHEST ADR IN HIGH SEG
	ADDI	T3,1
	DPB	T3,JBYHSS##	;SAVE AS HI SEG SIZE
	LDB	T4,[POINT 9,JBTUPM##(T2),8]	;HI-SEG OFFSET
	PUSHJ	P,MAPHI
	JRST	MAKSLE		;SET SWPLST AND RETURN

;HERE FOR HI SEG
BISLS7:	PUSHJ	P,SAVE2##	;SAVE ACS
	LDB	P1,IMGOUT##	;NO OF PAGES TO SWAP IN
	HRLI	P1,(SL.SIO)	;SWAPPING IO
	PJRST	BHSLST		;SET UP SWPLST FOR HI SEG

;HERE WHEN NOT ENOUGH 4-WD BLOCKS ARE AVAILABLE
BISLS8:	DMOVEM	T1,.USTMP	;SAVE WORKING ACS IN  UPMP
	DMOVEM	T3,.USTMP+2
	MOVEM	M,.USTMP+4
	MOVEM	F,.USTMP+5
	MOVSI	T1,400000	;INDICATE HAVE DONE A PART OF WHAT WE NEED
	IORM	T1,JBTSWP##(J)
	JUMPN	P4,BISLS5	;FINISH UP THIS PART AND CALL MAKSLE
	JRST	BISLS2
;SUBROUTINE TO SETUP SWPLST FOR HIGH SEGMENT SWAP IN OR OUT
;CALLING SEQUENCE:
;
;	MOVE	P1,HIGH SEGMENT SIZE
;	HRLI	P1,SWPLST ATTRIBUTES (I.E. DIRECTION OF I/O)
;	PUSHJ	P,BHSLST
;ALWAYS RETURNS CPOPJ

BHSLST:	LDB	T2,JBYHSA##	;1ST PAGE
	SKIPGE	T1,JBTSWP##(J)	;DSK ADR OF 1ST PAGE
	JRST	BHSLS1		;FRAGMENTED
	HLRZS	T1		;NOT FRAG'D - DSK ADR IN RH
	HRRZ	T3,P1		;SIZE
	PUSHJ	P,SETHMT	;SET UP FOR SWAP
	LDB	T1,JBYHSA##	;1ST PAGE
	LSH	T1,11		;POSITION IT FOR SWPLST
	IOR	T1,P1		;ADD ATTRIBUTES, SIZE
	JRST	MAKSLE		;SET UP SWPLST AND RETURN
;HERE IF HIGH SEG SWAP AND DISK SPACE IS FRAGMENTED
BHSLS1:	PUSHJ	P,SAVE4##	;SAVE ACS
	MOVE	P2,P1		;ATTRIBUTES,,SIZE
	MOVEI	P4,0		;1ST CALL
	PUSHJ	P,GT4MR		;GET A 4-WORD BLOCK
	  JRST	BHSLS5		;NONE AVAILABLE
	PUSH	P,P4		;SAVE LOC OF BLOCK
	HLRZ	P1,JBTSWP##(J)	;LOC OF FRAG TABLE
	TRZ	P1,FRGSEG	;CLEAR EXTRANEOUS BIT
BHSLS2:	DPB	T2,[POINT 13,P2,26]	;SAVE PAGE NUMBER IN P2
	PUSHJ	P,NXTFRG	;SET U FOR THIS FRAGMENT
	  JRST	BHSLS3		;DONE
	MOVEM	P2,(P4)		;SAVE SWPLST ENTRY
	LDB	T3,[POINT 9,P2,35]	;SIZE
	HRRZ	T1,U		;1ST DSK ADR
	PUSHJ	P,SETHMT	;SET UP FOR THIS FRAG
	AOBJN	P4,BHSLS2	;AND DO NEXT
	HLRZ	U,(P1)		;NEXT ENTRY IN FRAG TABLE
	JUMPE	U,BHSLS2	;DON'T GET ANOTHER BLOCK IF LAST
	PUSHJ	P,GT4MR		;OOPS, NEED ANOTHER 4-WD BLOCK
	  JRST	BHSLS4		;NOT THERE!
	JRST	BHSLS2		;OK, DO NEXT FRAG
BHSLS3:	SETZM	(P4)		;TERMINATE LIST
	POP	P,T1		;RESTORE 1ST ADR OF 4-WD BLOCKS
	HLL	T1,P2		;PLUS ATTRIBUTES
	TLO	T1,FRGSEG	;INDICATE FRAGMENTED
	JRST	MAKSLE		;CALL MAKSLE AND RETURN
BHSLS4:	POP	P,T1
BHSLS5:	HALT	.

;SUBROUTINE TO SET UP FOR SWAP OF HI SEG
;CALL WITH T1=1ST DSK ADR, T2=1ST PAGE NUMBER, T3 = NUMBER OF PAGES
;ALWAYS RETURNS CPOPJ
SETHMT:	SE1ENT			;ENTER SECTION 1
SETHM1:	SSX	T2,MDSEC2	;SECTION NUMBER FOR PAGTAB/MEMTAB
	HRRZM	T1,MEMTAB(T2)	;SAVE DSK ADR IN MEMTAB
	MOVE	T4,T2		;GET NEXT PAGE OF SEGMENT
	TRNE	T4,-1		;LEGAL PREDESESSOR?
	SKIPGE	T2,PAGTAB(T2)
	STOPCD	.,STOP,PFC,	;++PAGE ON FREE CORE LIST
	ADDI	T1,1		;INCR. DSK ADR BY 1
	SOJG	T3,SETHM1	;GO DO NEXT PAGE
	MOVEI	T1,(MT.LEF)	;DONE - INDICATE LAST PAGE
	HRLM	T1,MEMTAB(T4)	; IN MEMTAB
	POPJ	P,		;AND RETURN
;SUBROUTINE TO MAKE AN ENTRY IN SWPLST
;CALLING SEQUENCE:
;
;	MOVE	T1,SWPLST ENTRY
;	PUSHJ	P,MAKSLE
;ALWAYS RETURNS CPOPJ

MAKSLE::MOVSI	T2,MJBTMX##	;MAX NUMBER OF SWPLST ENTRIES
	DSKOFF
IFN FTMP,<
	SYSPIF
>
MAKSL1:	SKIPE	SWPLST##(T2)	;THIS SLOT AVAILABLE?
	AOBJN	T2,MAKSL1	;NO
	JUMPL	T2,MAKSL2	;FOUND A SLOT IF T2 NEG
	STOPCD	CPOPJ##,DEBUG,SLF,	;++SWPLST FULL
MAKSL2:	MOVEM	J,SW3LST##(T2)	;SAVE J
	MOVEM	T1,SWPLST##(T2)	;SAVE SWPLST ENTRY
	MOVE	T1,SWPOUT##	;SWPOUT (SCHED1) HAS TO BE SAVED
	HRLM	T1,SW3LST##(T2)	; IN CASE OF MULTIPLE SWAP-OUTS
	AOS	SLECNT##	;INCREMENT SWAP-LIST-ENTRY COUNT
MAKSL3:
IFN FTMP,<
	SYSPIN
>
	POPJ	P,		;AND RETURN

;SUBROUTINE TO FIND A SWPLST ENTRY
;RETURNS CPOPJ IF NO ENTRIES (EVERYTHING IN SWPLST IS FOR PAGING)
;RETURNS CPOPJ1 IF FOUND, P1=INDEX , J=JOB NUMBER, T1=1ST PAGE, P2=ENTRY
FNDSLE::
IFN FTMP,<
	SYSPIF			;MAKE SURE SOME OTHER CPU DOESN'T MAKE A SWPLST ENTRY
				; AT INTERRUPT LEVEL
>
	SKIPN	P3,SLECNT##	;GET COUNT OF SWPLST ENTRIES
	STOPCD	MAKSL3,DEBUG,SLZ,	;++SLECNT IS ZERO
	MOVEI	P1,0		;START AT 1ST THING IN SWPLST
FNDSL1:	SKIPN	P2,SWPLST##(P1);GET THE ENTRY
FNDSL2:	AOJA	P1,FNDSL1	;NOT HERE - TRY NEXT
	TLNE	P2,(SL.DFM)	;DON'T FIND A UPMP ENTRY
	JRST	FNDSL3		;IT WILL BE HANDLED AT INTERRUPT LEVEL
	TLNE	P2,(SL.SIO)	;SWAPPER ENTRY?
	TLNN	P2,(SL.IOD)	;YES, DONE?
FNDSL3:	SOJG	P3,FNDSL2	;NO, TRY NEXT
	JUMPE	P3,ONPOPJ##	;DIDNT FIND ONE IF T1=0
	MOVE	T1,SW3LST##(P1)	;SWPOUT,,JOB NUMBER
	TLNE	P2,(SL.DIO)	;DON'T CHANGE SWPOUT IF INPUT
	HLRZM	T1,SWPOUT##	;RESTORE SWPOUT FOR SCHED1
	HRRZ	J,T1		;SET UP J
	LDB	T1,[POINT 13,P2,26]	;1ST PHYSICAL PAGE
IFN FTMP,<
	SYSPIN			;SLECNT AND SWPLST ARE CONSISTANT
>
	PJRST	CPOPJ1##	;TAKE SKIP-RETURN
;SUBROUTINE TO DELETE THE SWPLST ENTRY
;ENTER WITH P1=INDEX
;ALWAYS RETURNS CPOPJ
DLTSLX::
IFN FTMP,<
	PUSH	P,F		;PROBABLY NOT NECESSARY
	MOVEI	F,SWPDDB##	;FOR PIOFF
	PIOFF			;GUARD AGAINST INTERPROCESSOR RACE
	PUSHJ	P,DLTSLE	;DELETE SWPLST ENTRY AND DECREMENT SLECNT
	PION
	JRST	FPOPJ##		;RESTORE F AND RETURN
>
DLTSLE::SKIPN	T1,SWPLST##(P1)	;GET ENTRY
	STOPCD	CPOPJ##,DEBUG,SIE, ;++SWPLST IS EMPTY
	TLNE	T1,(SL.IOD)	;IO DONE FOR THIS ENTRY?
	TLNN	T1,(SL.SIO)	;SWAPPER?
	JRST	DLTSL1		;PAGER - LEAVE SWPCNT ALONE
	SOSGE	SWPCNT##	;DECREMENT SWPCNT
	STOPCD	DLTSL2,DEBUG,SIN, ;++SWPCNT IS NEGATIVE
DLTSL1:	SOS	SLECNT##	;DECREMENT NUMBER OF ITEMS IN SWPLST
	SETZM	SWPLST##(P1)	;CLEAR OUT THE OLD ENTRY
	JUMPGE	T1,CPOPJ##	;DONE IF NOT FRAGMENTED
					;FALL INTO RTNBLK

;SUBROUTINE TO RETURN 4-WORD CORE BLOCKS USED IN SWPLST
;ENTER WITH T1=SWPLST ENTRY
RTNBLK:	PUSHJ	P,SAVE1##	;SAVE AC
	MOVE	P1,T1		;ORIGINAL ENTRY
RTNBL1:	HRRZ	T2,P1		;ADR OF 4-WD BLOCK
	SKIPG	T1,3(P1)	;NEXT BLOCK CONTIGUOUS WITH THIS?
	SKIPA	P1,T1		;NO, SAVE ITS ADR
	ADDI	P1,4		;YES
	MOVEI	T1,1		;DELETE 1 BLOCK
	PUSHJ	P,GIV4WD##
	JUMPE	P1,CPOPJ##	;DONE IF LINK=0
	JRST	RTNBL1		;NOT DONE, RETURN NEXT BLOCK


DLTSL2:	SETZM	SWPCNT##	;ZERO SWPCNT SO WONT KEEP GETTING HERE
	POPJ	P,		;AND RETURN
;SUBROUTINE TO GET 4 WORDS OF MONITOR FREE CORE
;ENTER P4=0 1ST TIME, P4=PREVIOUS P4 ON FOLLOWING CALLS
;RETURNS CPOPJ IF NO BLOCKS AVAILABLE
;RETURNS CPOPJ1 IF GOT ONE, P4=AOBJN WORD FOR BLOCK
GT4MR:	PUSHJ	P,SAVT##	;SAVE A BUNCH OF ACS
	MOVEI	T2,1		;GET 1 BLOCK
	PUSHJ	P,GET4WD##
	  POPJ	P,SETOMT	;CANT GET IT - POPJ
	SETZM	3(T1)		;GOT IT, ZERO THE LINK
	JUMPE	P4,GT4M3	;IF NOT 1ST CALL,
	CAIE	T1,1(P4)	;BLOCK CONTIGUOUS WITH PREVIOUS?
	JRST	GT4M2		;NO
	HRLI	P4,-4		;YES, CAN USE 4 WDS
	JRST	CPOPJ1##	; (LINK OF LAST, FIRST 3 OF THIS)
GT4M2:	HRROM	T1,(P4)		;POINT LAST WD OF PREVIOUS BLOCK AT THIS
GT4M3:	MOVE	P4,T1		;ADR OF THIS BLOCK
	HRLI	P4,-3		;CAN USE 3 WORDS
	JRST	CPOPJ1##	;TAKE GOOD RETURN

;SUBROUTINE TO SET UP BITS IN S FROM SWPLST
GETIOS::MOVEI	S,0
	TLNE	P2,(SL.ERR)	;ERROR?
	TRO	S,IODERR	;YES
	TLNE	P2,(SL.CHN)	;CHAN ERROR?
	TRO	S,IOCHMP	;YES
	TLNE	P2,(SL.CHK)	;CHECKSUM ERRORS
	TRO	S,IOIMPM	;YES
	TLNE	P2,(SL.DIO)	;OUTPUT?
	TLO	S,IO		;YES
	POPJ	P,		;RETURN
;ROUTINE TO RETURN NEXT PAGE
;RETURNS RH(M)=VIRT PAGE, T4=POINTER TO MAP SLOT
;PRESERVE T1-T3,M ACCROSS CALLS (AFTER FIRST, CALL NXTSW2)
NXTWSB::SETZB	M,T2
NXTWS1:	MOVEI	T1,^D36		;36 BITS PER WORD
	SKIPE	T3,WSBTAB(T2)	;GET THE WSBTAB ENTRY
NXTWS2::JFFO	T3,NXTWS3	;FIND FIRST BIT
	ADDI	M,(T1)		;REST OF WORD 0 - COUNT VIRT PAGE IN M
	AOJA	T2,NXTWS1	;AND TRY NEXT WSBTAB WORD
NXTWS3:	LSH	T3,1(T4)	;SHIFT OUT BITS THROUGH BIT JUST FOUND
	SUBI	T1,1(T4)	;ACCOUNT FOR NO OF BITS SCANNED
	ADDI	M,1(T4)		;INCR VIRTUAL PAGE
	TLON	M,400000	;1ST TIME?
	SUBI	M,1		;YES, WE'RE 1 TOO HIGH
	HRRZ	T4,M		;GET VIRTUAL PAGE IN T4
				;FALL INTO GTMPTR
;SUBROUTINE TO SETUP A BYTE POINTER TO A HALF WORD IN THE MAP
;ENTER WITH T4=VIRTUAL PAGE NUMBER FOR WHICH THE BYTE PNTR IS TO BE COMPUTED
;PRESERVES T1-T3
GMPTR::
IFE FTKLP,<
	ROT	T4,-1		;2 PAGES PER MAP SLOT
	TLZN	T4,400000	;GET POINTER TO RIGHT HALF WORD
	TDOA	T4,[POINT 18,.UPMP,17]
	TDO	T4,[POINT 18,.UPMP,35]
>
IFN FTKLP,<
	CAIGE	T4,1000
	JRST	[TDO T4,[POINT 36,.UPMAP,35]
		 POPJ P,]
	ADDI	T4,.UPMP-1000+340
	HRLI	T4,(POINT 36,0,35)
>
	POPJ	P,		;AND RETURN
;SUBROUTINE TO SETUP MEMTAB FOR A SWAP OUT FROM THE WORKING SET TABLE
; AND THE UPMP
;CALLING SEQUENCE:
;
;	MOVSI	U,-NUMBER OF PAGES ALLOCATED CONTIGUOUSLY ON THE DISK
;	HRRI	U,STARTING PAGE NUMBER ON THE DISK
;	PUSHJ	P,SETOMT	;FIRST CALL
;	PUSHJ	P,SETOM2	;ALL SUBSEQUENT CALLS
;ALWAYS RETURNS CPOPJ, T1-T3,M,F MUST BE PRESERVED FOR SUBSEQUENT CALLS
;RETURNS WITH U POINTING AT LAST PAGE DONE

SETOMT:	SE1ENT			;MUST BE IN SECTION 1 TO ADDRESS PAGTAB/MEMTAB
	PUSHJ	P,NXTWSB	;GET 1ST PAGE OF WORKING SET
	LDB	F,T4		;GET MAP ENTRY
	ANDI	F,17777		;CLEAR OUT ACCESS-BITS
	HRLI	P3,<(MT.LEF)>(M) ;1ST VIRTUAL PAGE (+LEF FOR MEMTAB)
	HRR	P3,F		;P3=1ST VIRT,,1ST PHYS
SETOM1:	SSX	F,MDSEC2	;SET SECTION NUMBER
	HRRZM	U,MEMTAB(F)	;SAVE DSK ADR IN MEMTAB
	AOBJP	U,SETOM6	;GO IF LAST PAGE
SETOM2:	PUSHJ	P,NXTWS2	;NOT LAST, GET NEXT WS BIT
	LDB	T4,T4		;PHYSICAL PAGE
IFE FTKLP,<
	ANDI	T4,417777	;PM.ACC + PHYS PAGE
>
	JUMPE	T4,SETOM2	;IF PAGE EXISTS,
IFE FTKLP,<
	TRZN	T4,PM.ACC	;PM.ACC ON?
>
IFN FTKLP,<
	TLZN	T4,(<PM.DCD>B2)
>
	JRST	SETOM5		;NO
SETOM3:	JUMPN	P3,SETOM4	;IF 1ST TIME,
	HRLI	P3,<(MT.LEF)>(M) ;SAVE VIRT PAGE
	TROA	P3,(T4)		; AND PHYS PAGE IN P3
SETOM4:	HRLM	M,MEMTAB(F)	;NOT 1ST TIME - SAVE VIRT PAGE IN LH(MEMTAB)
	MOVE	F,T4		;F=PHYS PAGE
	JRST	SETOM1		;AND CONTINUE

;HERE IF PM.ACC OFF - EITHER EXPANDING (INSDSK) OR IT REALLY SHOULD BE OFF
SETOM5:	PUSHJ	P,TSAAT		;PAGE IN AABTAB?
	  JRST	SETOM3		;REALLY OFF
	JRST	SETOM2		;EXPANDING, THE PAGE IS PAGED OUT - IGNORE IT

SETOM6:	HLLM	P3,MEMTAB(F)	;DONE - SAVE PNTR TO 1ST PAGE IN MEMTAB FOR LAST
	SOJA	U,CPOPJ##	;READJUST U AND RETURN
;SUBROUTINE TO SETUP THE UPMP WITH PHYSICAL CORE ADDRESSES FROM PAGTAB,
; THE UPMP, THE WORKING SET TABLE, AND THE ACCESS ALLOWED TABLE AND SETUP
; MEMTAB FOR A SWAP IN
;CALLING SEQUENCE:
;
;	PUSHJ	P,SETIMT	;FIRST CALL
;	PUSHJ	P,SETIMX	;ALL SUBSEQUENT CALLS
;RETURNS CPOPJ1 WHEN A NON-CONTIGUOUS DISK ADDRESS IS FOUND. RETURNS
; CPOPJ WHEN THE ENTIRE UPMP HAS BEEN PROCESSED.
;RETURNS P3=# OF PAGES, P1=1ST VIRT,,1ST PHYS
;PRESERVE T1-T4,M,F OVER CALLS TO SETIMX

SETIMT:	SE1ENT			;ENTER SECTION 1
	PUSH	P,J		;SAVE J
	PUSHJ	P,HSVAD##
	LSHC	T1,W2PLSH##
	HRRZM	T1,.USTMP
	HRRZM	T2,.USTMP+1
	LDB	F,JBYLSA##	;FIRST PHYSICAL ADDRESS
	PUSHJ	P,NXTWSB	;GET 1ST PAGE IN WORKING SET
	HRLI	P1,<(MT.LEF)>(M)	;1ST VIRTUAL PAGE
	HRR	P1,F		;1ST VIRTUAL,,1ST PHYSICAL
SETIM1:	LDB	U,T4		;GET DSK ADR
	ANDI	U,377777	;MAKE SURE EXTRANEOUS BITS ARE 0
SETIM2:	PUSHJ	P,TSAAT		;PAGE IN AABTAB?
	  TDZA	J,J		;NO
IFE FTKLP,<
	MOVEI	J,PM.ACC	;YES
IFN FTKL10!FTKS10,<
	TDO	J,[PM.CSH]	;ASSUME A CACHED PAGE
	TRNE	M,777000	;A USER PAGE?
	TRNE	J,PM.ACC	;NO, SHOULD IT BE CACHED
	CAIA			;YES, CACHE THE PAGE
	TRC	J,PM.ACC+PM.CSH	;NO, ALLOW ACCESS, DON'T CACHE
>
	ADDI	J,PM.WRT+PM.PUB(F)
>
IFN FTKLP,<
	MOVSI	J,(<PM.DCD>B2)
	TLO	J,(PM.CSH)
	TRNE	M,777000
	TLNE	J,(<PM.DCD>B2)
	CAIA
	TLC	J,(<PM.DCD>B2+PM.CSH)
	ADD	J,[PM.WRT+PM.PUB]
	ADDI	J,(F)
>
	PUSH	P,T4		;SAVE BYTE POINTER
	MOVE	T4,F
	SSX	T4,MDSEC2	;SET SECTION NUMBER FOR MEMTAB
	TLNN	F,-1		;THIS PAGE HAVE A DISK ADDRESS?
	MOVEM	U,MEMTAB(T4)	;YES, SAVE IN MEMTAB
	HRRZ	T4,M
	CAML	T4,.USTMP+1
	CAMLE	T4,.USTMP
	CAIA
	TDZA	J,[PM.WRT]
	HRLI	M,400000(M)	;SAVE (HIGHEST) VIRT PAGE IN LH(M)
	POP	P,T4		;RESTORE THE BYTE POINTER
	DPB	J,T4		;SAVE IN MAP
	PUSHJ	P,NXTWS2	;GET NEXT PAGE, M=VIRT, T4=MAP POINTER
	JUMPN	P1,SETIM3	;IF 1ST CALL,
	HRLI	P1,<(MT.LEF)>(M) ;P1=1ST VIRT
	HRR	P1,F		; ,,1ST PHYS
SETIM3:	LDB	J,T4		;DISK ADR OF NEXT PAGE
	ANDI	J,377777
	JUMPE	J,SETIM4	;GO IF NO DISK ADDR
	SUBI	U,-1(J)		;U=0 IF PAGES CONTIGUOUS
	HLRZ	J,F		;PAGE NUMBER OF LAST PAGE WITH A DSK ADR
	TLZN	F,-1		;IF IT WAS LAST PAGE,
	MOVE	J,F		;GET IT FROM F
	HRRZ	R,M
IFE FTKLP,<
	CAIN	R,.UPMVP/PAGSIZ##
>
IFN FTKLP,<
	CAIN	R,<.UPMVP-PAGSIZ##>/PAGSIZ##
>
	JRST	SETIM6		;NEXT=UPMP
	JUMPN	U,SETIM7	;GO IF NOT CONTIGUOUS
	CAIL	P3,776		;CAN ONLY STORE NINE BITS
	  JRST	SETIM7		;FRAGMENT
	MOVE	R,J		;FOR INDEXING INTO PAGTAB/MEMTAB
	SSX	R,MDSEC2	;MAKE MEMTAB/PAGTAB ADDRESSABLE
	HRLM	M,MEMTAB(R)	;NEXT VIRT PAGE IN MEMTAB FOR LAST PAGE W/ DSK ADR
	HRR	R,F		;FOR INDEXING INTO PAGTAB
	HRR	F,PAGTAB(R)	;NEXT PHYSICAL PAGE
	AOJA	P3,SETIM1	;COUNT THE PAGE, TEST NEXT
;HERE IF NEXT PAGE HAS NO DISK ADDRESS
SETIM4:	PUSH	P,T2		;SAVE T2 FOR NXTWSB
	MOVE	T2,F		;FOR INDEXING INTO PAGTAB
	SSX	T2,MDSEC2	;SET SECTION NUMBER
	HRRZ	T2,PAGTAB(T2)	;THIS PHYSICAL PAGE
	PUSHJ	P,ZPAGE		;ZERO THE PAGE
	POP	P,T2		;RESTORE T2
	TLNN	F,-1		;FIRST SUCH PAGE?
	HRLS	F		;YES, SAVE IN LH(F)
SETIM5:	MOVE	R,F		;TO GET PAGTAB ENTRY
	SSX	R,MDSEC2	;SET SECTION
	HRR	F,PAGTAB(R)	;STEP TO NEXT PHYSICAL PAGE
	JUMPN	P1,SETIM2	;CONTINUE, U=DSK ADR IF NOT 1ST CALL TO SETIMX
	JRST	SETIM1		;1ST CALL TO SETIMX - GET U FROM BYTE PNTR

;HERE FOR UPMP
SETIM6:	SOS	-1(P)		;RETURN CPOPJ
	PUSHJ	P,SETHSA	;UPDATE JBTHSA IF NECESSARY

;HERE AT END OF THIS FRAGMENT
SETIM7:	MOVE	R,J		;FOR INDEX
	SSX	R,MDSEC2	;SET SECTION
	HLLM	P1,MEMTAB(R)	;SAVE 1ST VIRT PAGE IN LH(MEMTAB)
	AOJA	P3,JPOPJ1##	;COUNT THE PAGE AND RETURN

;HERE FOR SUBSEQUENT CALLS
SETIMX:	SE1ENT			;ENTER SECTION 1
	PUSH	P,J		;SAVE J
	JRST	SETIM5		;AND START AT NEXT PAGE
;SUBROUTINE TO SETUP AN AOBJN POINTER TO BE USED TO SETUP MEMTAB -
; I.E. XWD -NUMBER OF CONTIGUOUS PAGES ON THE DISK, STARTING
; PAGE ON THE DISK, FROM THE FRAGMENT TABLE POINTED TO BY JBTSWP.
; IT ALSO SETS UP THE JOB NUMBER AND NUMBER OF PAGES
; ENTRIES IN THE SWPLST ENTRY WHICH IS BEING BUILT.
;CALLING SEQUENCE:
;
;	MOVE	P1,POINTER TO THE FRAGMENT TABLE (1ST CALL)
;	MOVE	J,JOB NUMBER OR 0 IF A HIGH SEGMENT
;	MOVEI	P2,SWPLST DESCRIPTORS
;	PUSHJ	P,NXTFRG
;RETURNS CPOPJ IF THIS IS THE LAST ENTRY IN THE FRAGMENT TABLE, CPOPJ1
; IF NOT, P1 POINTS TO THE NEXT ENTRY

NXTFR1:	HRRZ	P1,(P1)		;GET NEXT FRAG TABLE ENTRY
NXTFRG:	HLRE	U,(P1)		;GET NO OF DSK PAGES
	JUMPE	U,CPOPJ##	;DONE IF 0
	JUMPL	U,NXTFR1	;POINTER TO ANOTHER ADR IF NEG
	DPB	U,[POINT 9,P2,35]	;SAVE NUMBER OF PAGES
	MOVNS	U		;-N
	HRLS	U		;-N,,0
	HRR	U,(P1)		;-N,,START
	AOJA	P1,CPOPJ1##	;GOOD RETURN
;SUBROUTINE TO FIX THINGS UP AFTER A SWAP-WRITE ERROR
MAPBAK::CAILE	J,JOBMAX##
	JRST	MAPBK5
	PUSHJ	P,SVEUB##	;MAKE JOB ADDRESSABLE
	PUSHJ	P,SAVE4##	;SAVE ACS
	SETZM	.USLPS		;START BACK AT TOP OF UPMP
	SE1ENT			;MUST BE IN SECTION 1
	PUSHJ	P,NXTWSB	;GET 1ST PAGE IN WORKING SET
MAPBK1:	LDB	P2,T4		;GET DSK ADR
	TRZE	P2,400000	;IS IT A DISK ADR?
	JRST	MAPBK3		;NO, LOOK AT NEXT PAGE
	LDB	P3,JBYLSA##	;YES, SET TO SCAN MEMTAB CHAIN
MAPBK2:	SSX	P3,MDSEC2	;MAKE GLOBAL INDEX
	MOVE	P4,MEMTAB(P3)	;MEMTAB FOR THIS PAGE
	CAIE	P2,(P4)		;DSK ADR THE SAME?
	JRST	MAPBK4		;NO
IFE FTKLP,<
	TRO	P3,PM.WRT+PM.PUB+PM.ACC	;YES, MAKE IT A MAP ENTRY AGAIN
>
IFN FTKLP,<
	HRLI	P3,(<PM.DCD>B2+PM.WRT+PM.PUB)
>
	PUSHJ	P,TSAAT
IFE FTKLP,<
	  TRZ	P3,PM.ACC
>
IFN FTKLP,<
	  TLZ	P3,(<PM.DCD>B2)
>
	DPB	P3,T4		;SAVE MAP ENTRY IN UPMP
MAPBK3:	PUSHJ	P,NXTWS2	;GET NEXT PAGE IN WORKING SET
	HRRZ	P4,M		;UPMP?
	CAIN	P4,.UPMVP/PAGSIZ##
	S0JRST	DLTSLX		;YES, DELETE SWPLST ENTRY AND RETURN
	JRST	MAPBK1		;NO, CONVERT THIS DSK ADR TO PAGE NUMBER
MAPBK4:	HRRZ	P3,PAGTAB(P3)	;STEP TO NEXT PAGE OF JOB
	JUMPN	P3,MAPBK2	;CHECK MEMTAB FOR ITS DSK ADR
	JRST	MAPBK3		;NO MATCH - IT WASNT A DSK ADR, TRY NEXT
MAPBK5: MOVEI	T1,0	;START OVER
	DPB	T1,[POINT 13, JBTUPM##(J),21]
	PJRST	DLTSLX

;SUBROUTINE TO SET/CLEAR IO IN S FOR SWAPPER
;CALLED IN ERROR RECOVERY SINCE DEVIOS CAN CHANGE IN SWPDDB
;CALL WITH U SET UP

SWPINS::MOVE	T1,UNISWA##(U)	;POINTER TO SWPLST
	MOVE	T1,(T1)		;GET SWPLST ENTRY
	TLNN	T1,(SL.DIO)	;INPUT?
	TLZA	S,IO		;YES
	TLO	S,IO		;NO
	POPJ	P,


IFN FTDHIA,<
;SUBROUTINE TO TEST IF ALL NON-WORKING SET PAGES OF A JOB ARE OFF A SWAPPING UNIT
; WHICH IS BEING TAKEN DOWN FOR DIAGNOSTIC PURPOSES
;CALL J=JOB NUMBER
;NON-SKIP RETURN IF STILL SOME PAGES ON A "BAD" UNIT, M=1ST VIRT PAGE ON UNIT
;SKIP RETURN IF NO PAGES ON THE UNIT
;CALL PGOFFA IF JOB IS ALREADY ADDRESSABLE
;PRESERVES T1
PGOFF::	PUSHJ	P,SVEUB##	;MAKE JOB ADDRESSABLE
PGOFFA:	SKIPN	.USVRT		;JOB VIRTUAL?
	JRST	CPOPJ1##	;NO, CANT HAVE NON-WS PAGES
	PUSHJ	P,SAVE1##	;YES, SAVE AN AC
	PUSH	P,T1
	MOVE	P1,[NXTNW2,,NXTNWS] ;ROUTINE TO GET NEXT NON-WS PAGE
	PUSHJ	P,TSTOFF	;ANY NON-WS PAGE ON BAD UNIT?
	  SOS	-1(P)		;YES, NON-SKIP
	JRST	TPOPJ1##	;RETURN SKIP OR NON-SKIP


;SUBROUTINE TO TEST WHETHER A SET OF PAGES IS ON A "BAD" SWAPPING UNIT
;ENTER P1=ALL-BUT FIRST,,FIRST  ROUTINE TO CALL
;EXIT CPOPJ IF SOME PAGE IS ON A BAD UNIT, RH(M)=FIRST BAD PAGE
;EXIT CPOPJ1IF NO PAGES ON BAD UNIT
TSTOFF:	HLRZ	R,JBTADR##(J)	;HIGHEST PAGE TO TEST
	LSH	R,W2PLSH##
	PUSHJ	P,(P1)		;GET 1ST PAGE
	MOVSS	P1		;SET FOR SUBSEQUENT CALLS
TSTOF1:	CAIGE	R,(M)		;PAST TOP?
	JRST	CPOPJ1##	;YES, GOOD RETURN
	PUSHJ	P,TSTUN		;NO, SWAPPED ON A "BAD" UNIT?
	  POPJ	P,		;YES, NON-SKIP
	PUSHJ	P,(P1)		;NO, GET NEXT PAGE
	JRST	TSTOF1		;AND TEST IT

;STILL IN FTDHIA&FT2SP CONDITIONAL
;SUBROUTINE TO RETURN THE NEXT PAGE NOT IN THE WORKING SET
;RETURNS CPOPJ, WITH RH(M)=VIRT PAGE, T4=CONTENTS OF MAP SLOT
;ZERO PAGES AND PM.ZER PAGES ARE IGNORED
;PRESERVE T1-T3, M ACROSS CALLS (CALL NXTNW2 AFTER FIRST CALL)
NXTNWS:	SETZB	M,T2		;START AT THE BEGINNING
NXTNW1:	MOVEI	T1,^D36		;36 BITS IN A WORD
	SETCM	T3,WSBTAB(T2)	;BITS FOR EVERY NON-WS PAGE
NXTNW2:	JFFO	T3,NXTNW3	;FIND A 1-BIT
	ADDI	M,(T1)		;REST OF WORD 0, STEP TO NEXT
	AOJA	T2,NXTNW1
NXTNW3:	LSH	T3,1(T4)	;CLEAR THE BIT
	SUBI	T1,1(T4)	;COUNT THE BIT
	ADDI	M,1(T4)		;...
	TLON	M,400000	;FIRST TIME?
	SUBI	M,1		;YES, WE'RE 1 TOO HIGH
	HRRZ	T4,M		;VIRTUAL PAGE NUMBER
	CAIGE	T4,.UPMVP/PAGSIZ## ;AT END?
	JRST	NXTNW4		;NO
	MOVEI	T4,0		;YES, RETURN 0
	POPJ	P,
NXTNW4:	PUSHJ	P,GTPM4		;GET MAP CONTENTS
	CAIE	T4,PM.ZER	;IF NOT ALLOCATED BUT 0,
	PUSHJ	P,NXTHS		;SEE IF 0 OR HIGH SEG PAGE
	  JRST	NXTNW2		;0 OR PM.ZER, TRY NEXT
	POPJ	P,		;"REAL" PAGE, RETURN IT

;SUBROUTINE TO SEE IF MAP CONTENTS IS 0 OR IN A HIGH SEG
;PRESERVES ALL ACS
NXTHS:	JUMPE	T4,CPOPJ##	;IF MAP IS NON-0
	PUSHJ	P,SAVT##	;SAVE ALL ACS
	HRRZ	T1,M		;PAGE TO TEST
	PJRST	TPSHS		;GO SEE IF IT IS IN A HIGH SEG

;SUBROUTINE TO CALL NXTWSB/NXTWS2 BUT RETURN MAP CONTENTS IN
;T4 INSTEAD OF MAP POINTER (FOR TSTOFF)

NXWSC:	PUSHJ	P,NXTWSB
	LDB	T4,T4
	POPJ	P,

NXWSC2:	PUSHJ	P,NXTWS2		;FOR AFTER THE FIRST TIME
	LDB	T4,T4
	POPJ	P,
;SUBROUTINE TO EXCHANGE T1-T3,M WITH P1-P4
EXCHT:	EXCH	P1,T1
	EXCH	P2,T2
	EXCH	P3,T3
	EXCH	P4,M
	POPJ	P,

;SUBROUTINE TO TEST IF A DISK ADDRESS IS ON A UNIT BEING REMOVED
;ENTER T4=C(MAP SLOT)  -  DSK ADR
;EXIT CPOPJ IF UNIT GOING DOWN, CPOPJ1 IF NOT
;PRESERVES T1-T3
TSTUN::	LDB	T4,UNXCFS##	;GET SWAP UNIT
	MOVE	T4,SWPTAB##(T4)	;UNIT DATA BLOCK LOC
	MOVE	T4,UNIUST##(T4)	;STATUS
	TLNN	T4,UNPNNA##+UNPRSS## ;UNIT GOING DOWN?
	AOS	(P)		;NO, SKIP RETURN
	POPJ	P,		;RETURN

;SUBROUTINE TO COMPLEMENT A BIT IN WSBTAB
;ENTER RH(M) = VIRTUAL PAGE NUMBER
;ENTER ALSO WITH SIGN BIT OF T1 SET IF TO TURN ON CORRESPONDING WS BIT
;IN THE "SAVED" COPY OF WSBTAB POINTED TO BY .USBTS
;PRESERVES T1-T3 (EXCEPT SIGN BIT OF T1 ALWAYS CLEARED)
BTCOM:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;AND T2
	HRRZ	T1,M		;VIRTUAL PAGE
	PUSHJ	P,TSWST		;COMPUTE WSBTAB BIT, POSITION
	  JFCL
	XORM	T2,WSBTAB(T4)	;FLIP THE BIT IN WSBTAB
	MOVE	T1,-1(P)	;GET T1 BACK
	TLZN	T1,400000	;UPDATE SAVED COPY?
	  JRST	TTPOPJ##	;NO
	MOVEM	T1,-1(P)	;CLEAR THE BIT
	HRRZ	T1,.USBTS
	ADDI	T1,(T4)
	IORM	T2,(T1)
	JRST	TTPOPJ##	;RESTORE ACS AND RETURN
>	;END FTDHIA
;SUBROUTINE TO ALLOCATE MONITOR PAGES
;CALLING SEQUENCE:
;	MOVE	T1,FIRST PAGE TO ALLOCATE
;	MOVE	T2,NUMBER OF PAGES TO ALLOCATE
;	MOVE	T3,SIGN BIT=FLAG 0=CACHED,NON-ZERO=UNCACHED (KL ONLY)
;	PUSHJ	P,CREMPG
;	  RETURNS HERE IF NO VIRTUAL CORE
;	RETURNS HERE WHEN THE PAGES HAVE BEEN ALLOCATED
;STOPS IF THE PAGES ALREADY EXIST, CALLERS RESPONSIBILITY TO
; CHECK TO SEE THAT THE PROGRAM ISN'T GETTING TO BIG

CREMPG:	PUSHJ	P,SAVE3##	;SAVE P1-P3
IFN FTKL10,<
	MOVE	P3,T3		;SAVE CACHED/UNCACHED FLAG
>
IFN FTMP,<
	PUSHJ	P,UPMM##	;GET THE MEMORY MANAGEMENT RESOURCE
>
	CAMLE	T2,VIRTAL##	;MAKE SURE THERE'S ENOUGH SPACE
IFN FTMP,<
	PJRST	DWNMM##		;RETURN MM AND FAIL
>
IFE FTMP,<
	POPJ	P,		;FAIL
>
	DMOVEM	T1,P1		;SAVE STARTING PAGE NUMBER, NUMBER OF PAGES
	MOVN	T3,T2		;MINUS THE NUMBER OF PAGES OF INCREASE
	ADDM	T3,VIRTAL##	;DECREMENT TOTAL SYSTEM VIRTUAL MEMORY AVAILABLE
CREMP0:	MOVE	T3,P2		;NUMBER OF PAGES TO ALLOCATE
	PUSHJ	P,FRDCR##	;ENOUGH CORE IN CORE TO SATISFY REQUEST?
	  JRST	CREMP4		;NO, ALLOCATE CORE ON THE DISK
	SE1ENT			;ENTER SECTION 1 TO ADDRESS PAGTAB
	PUSH	P,J		;SAVE J, COULD POINT AT A KDB
	MOVE	J,.CPJOB##	;CURRENT JOB
	MOVE	T3,[MCPCNT]	;ONE IN COUNT OF FUNNY PAGES BYTE
	IMULI	T3,(P2)		;TIMES THE NUMBER OF FUNNY PAGES TO ALLOCATE
	ADDM	T3,JBTPDB##(J)	;UPDATE NUMBER OF FUNNY PAGES OWNED BY THIS JOB
	MOVEI	T2,^D511+NWMCP/PAGSIZ## ;HIGHEST PAGE AVAILABLE IN FUNNY SPACE
	PUSHJ	P,SNPAGS##	;FIND THE LAST PAGE ALLOCATED TO THIS JOB
	MOVE	T2,P2		;NUMBER OF PAGES REQUESTED
	PUSHJ	P,ADPAGS##	;ALLOCATE THAT NUMBER
	EXCH	P1,T1		;P1 = FIRST PHYSICAL PAGE ALLOCATED, T1 = VIRTUAL PAGE
IFN FTLOCK,<
	LDB	T2,JBYLSA##	;PAGE 0
	SSX	T2,MDSEC2	;PAGTAB SECTION NUMBER
	HLR	P3,PAGTAB(T2)	;LOCK BITS
>
	SSX	P1,MDSEC2	;PAGTAB SECTION
	JRST	CREMP2		;GO ADD THE PAGES TO THE JOB'S MAP
CREMP1:	SSX	P1,MDSEC2	;SET PAGTAB SECTION NUMBER
	HRRZ	P1,PAGTAB(P1)	;NEXT PHYSICAL PAGE
CREMP2:
IFN FTLOCK,<
	HRLM	P3,PAGTAB(P1)	;LOCK BITS
>
IFN FTKL10,<
	JUMPGE	P3,CREMP3	;JUMP IF CACHED PAGE
	PUSHJ	P,WSBIT		;SETUP FOR CALL TO INSMPU
IFE FTKLP,<
	MOVEI	T3,PM.ACC+PM.WRT+PM.PUB(P1) ;UNCACHED
>
IFN FTKLP,<
	MOVE	T3,P1
	HRLI	T3,(<PM.DCD>B2+PM.WRT+PM.PUB)
>
	PUSHJ	P,INSMPU	;PUST THE PAGE IN THE JOB'S MAP
	CAIA			;SKIP
CREMP3:>
	PUSHJ	P,INSMPC	;INSERT THE PAGE IN THE JOB'S MAP CACHED
	ADDI	T1,1		;NEXT VIRTUAL PAGE
	SOJG	P2,CREMP1	;LOOP OVER ALL PAGES ALLOCATED
	CLRPGT	(0)		;CLEAR MEMORY OF PREVIOUS MAP
IFN FTMP,<
	PUSHJ	P,DWNMM##	;RETURN THE MEMORY MANAGEMENT RESOURCE
>
	JRST	JPOPJ1##	;RESTORE J AND RETURN
CREMP4:	PUSH	P,J		;SAVE J, COULD POINT AT A KDB
	MOVE	J,.CPJOB##	;CURRENT JOB
IFN FTLOCK,<
	MOVSI	T2,NSHF!NSWP	;JOB IS LOCKED BITS
	TDNN	T2,JBTSTS##(J)	;IS THE JOB LOCKED?
	JRST	CREMP5		;NO
IFN FTMP,<
	PUSHJ	P,DWNMM##	;RETURN THE MEMORY MANAGEMENT RESOURCE
>
	PUSH	P,T1		;YES, SAVE STARTING PAGE NUMBER
	MOVEI	T1,1		;SLEEP 1 SECOND SINCE CANNOT SWAP OUT JOB TO ALLOCATE CORE
	PUSHJ	P,SLEEPF##	;ZZZZZZ
	POP	P,T1		;RESTORE STARTING PAGE NUMBER
IFN FTMP,<
	PUSHJ	P,UPMM##	;RE-GET THE MM RESOURCE
>
	POP	P,J
	JRST	CREMP0		;AND START OVER FROM SCRATCH
>
IFE FTLOCK,<
	SETZ	T2,		;FOR CALL TO IOWAT BELOW
>
CREMP5:	PUSH	P,S		;SAVE S (FILSER IS PARTICULAR ABOUT THAT)
	PUSH	P,F		;AND F
	PUSHJ	P,IOWAT		;WAIT FOR ALL I/O TO STOP SINCE JOB WILL BE SWAPPED
	POP	P,F		;RESTORE F
	POP	P,S		;AND S
	LDB	T2,NFYPGS##	;NUMBER OF FUNNY PAGES CURRENTLY ALLOCATED TO THE JOB
	ADD	T2,P2		;PLUS NUMBER OF PAGES OF INCREASE
	DPB	T2,IFYPGS##	;NUMBER OF PAGES REQUIRED WHEN SWAPPED BACK IN
CREMP6:
IFN FTKL10,<
	PUSHJ	P,WSBIT		;SET POINTERS TO AABTAB
	SKIPL	P3		;CACHED PAGE?
	IORM	T2,AABTAB(T4)	;YES, REMEMBER THAT
	PUSHJ	P,INSMPD	;INSERT THE PAGE (ON THE DISK)
>
IFN FTKI10!FTKS10,<
	PUSHJ	P,INSDSK	;INSERT PAGE (NEEDN'T WORRY ABOUT CACHE)
>
	ADDI	T1,1		;NEXT VIRTUAL PAGE
	SOJG	P2,CREMP6	;NEXT PAGE
	PUSHJ	P,XPANDH##	;MARK JOB AS EXPANDING
	POP	P,J		;RESTORE J
IFN FTMP,<
	PUSHJ	P,DWNMM##	;GIVE UP MM NOW THAT XJOB AND JXPN AGREE
>
	AOS	(P)		;EVERYTHING IS OK
	PJRST	WSCHED##	;AND WAIT UNTIL THE JOB IS BACK IN CORE
;SUBROUTINE TO ALLOCATE AND MAKE ADDRESSABLE PAGES IN A NON-ZERO SECTION
;CALLING SEQUENCE:
;	MOVEI	R,SECTION NUMBER PAGES ARE TO BE ALLOCATED IN
;		  IF (R) = 0, ALLOCATE IN FUNNY SPACE
;	MOVEI	T2,NUMBER OF PAGES TO BE ALLOCATED
;	PUSHJ	P,CREMNS
;	  ...			;RETURNS HERE IF NOT POSSIBLE TO ALLOCATE PAGES
;	...			;RETURNS HERE WITH T1 = VIRTUAL ADDRESS OF PAGES ALLOCATED
;MUST BE CALLED IN SECTION 1 IF ALLOCATING NZS SPACE

CREMNS::
IFN FTKLP,<
	JUMPE	R,CREFSP	;IF (R) = 0, ALLOCATE A PAGE OF FUNNY SPACE
	PUSHJ	P,SAVE4##	;SAVE WORKING ACS
	MOVE	P1,T2		;SAVE NUMBER OF PAGES REQUESTED
;VERIFY THAT ALLOCATING A PHYSICAL PAGE WON'T PREVENT ANY JOB FROM BEING SWAPPED
; IN AND ADJUST CORMAX IF NEED BE TO KEEP ANY JOB FROM GETTING TO BIG AFTER A PAGE
; IS ALLOCATED. ACCOUNT FOR SECTION MAP IF IT MUST BE ALLOCATED.
;	INSERT CODE HERE
	MOVE	T1,R		;SECTION TO ALLOCATE FROM
	ADD	T1,.CPEPT##	;ADDRESS OF THE EPT
	SKIPE	T2,SECTAB(T1)	;SECTION ALREADY EXIST?
	JRST	CREMN1		;YES, JUST FIND THE FREE PAGES
;HERE WHEN A PAGE MUST BE ALLOCATED FOR A SECTION MAP
	MOVEI	T3,1		;ALLOCATE 1 PAGE
	PUSHJ	P,GETPHP	;GET A PAGE OF PHYSICAL MEMORY
	MOVE	T2,T1		;PAGE NUMBER
	HLRZ	T1,R		;SECTION NUMBER
	ADDI	T1,SECTAB	;WHERE TO STORE
	PUSHJ	P,STMAPS	;STORE PAGE NUMBER IN THE SECTION MAP
CREMN1:	HRLI	T2,(<PM.DCD>B2+PM.WRT+PM.CSH)
	MOVEM	T2,.UPMP+<.TEMP/PAGSIZ##>
	CLRPGT	(0)
	PUSH	P,T2		;SAVE FOR LATER
	MOVEI	T1,0		;START AT FIRST SLOT IN THE MAP
CREMN2:	MOVE	P2,T1		;FIRST FREE SLOT SEEN
	MOVEI	T3,0		;NUMBER OF CONTIGUOUS FREE SLOTS SEEN SO FAR
CREMN3:	CAIL	T3,(P1)		;FOUND ENOUGH FREE SLOTS YET?
	JRST	CREMN4		;YES
	AOS	T1		;NEXT SLOT TO LOOK AT
	CAILE	T1,^D512	;LOOPED OVER THE ENTIRE SECTION MAP?
	JRST	TPOPJ		;YES, CANNOT ALLOCATE PAGES IN THIS SECTION
	SKIPE	.TEMP-1(T1)	;NEXT SLOT FREE?
	JRST	CREMN2		;NO, LOOK HIGHER UP
	AOJA	T3,CREMN3	;YES, SEE IF ENOUGH SLOTS HAVE BEEN FOUND
CREMN4:	MOVE	T3,P1		;NUMBER OF PAGES TO ALLOCATE
	PUSHJ	P,GETPHP	;GET THE PAGES
	POP	P,.UPMP+<.TEMP/PAGSIZ##> ;MAKE THE SECTION MAP ADDRESSABLE
	CLRPGT	(0)		;FLUSH PAGING MEMORY
	MOVE	P3,P2		;STARTING MAP SLOT (NEEDED FOR VIRTUAL ADDRESS)
	MOVE	P4,T1		;FIRST PHYSICAL PAGE ALLOCATED
CREMN5:	MOVE	T2,P4		;PAGE NUMBER TO T2
	MOVEI	T1,.TEMP(P2)	;WHERE TO STORE IN THE SECTION MAP
	PUSHJ	P,STMAPE	;MAKE THE MAP ENTRY
	SSX	P4,MDSEC2	;PAGTAB SECTION
	HRRZ	P4,PAGTAB(P4)	;NEXT PAGTAB ENTRY
	TRNE	P4,-1		;LAST PAGE?
	AOJA	P2,CREMN5	;NO, LOOP MAKING ENTRIES FOR EVERY PAGE ALLOCATED
	MOVE	T1,P3		;FIRST SLOT ALLOCATED
	LSH	T1,P2WLSH##	;ADDRESS WITHIN THE SECTION
	SSXE	T1,(R)		;FULL VIRTUAL ADDRESS OF CORE ALLOCATED
	JRST	CPOPJ1##	;GIVE WON RETURN
> ;END IFN FTKLP

;ROUTINE TO CREATE A PAGE IN FUNNY SPACE
; CALL WITH T1=BITS,,HEADER
;RETURNS CPOPJ IF NONE AVAILABLE, CPOPJ1 IF AVAILABLE, T1 = VIRTUAL ADDRESS OF PAGE

CREFSP:	PUSH	P,T1		;SAVE BITS,,HEADER
	MOVEI	T1,.MCFV/PAGSIZ## ;VIRTUAL PAGE NUMBER OF FIRST FUNNY PAGE
CREFS1:	PUSHJ	P,TSWST		;DOES IT EXIST
	  JRST	[MOVE T2,-1(P)	;NO, CHECK IF RESTRICTED PAGE
		 CAIN T1,<<.MCFV+NWMCP>/PAGSIZ##>-1 ;THE NEXT TO THE LAST FUNNY PAGE
		 TLNE T2,200000	;YES, ARE WE ALLOWED TO GIVE IT OUT
		 JRST CREFS2	;OK TO CREATE THIS PAGE
		 AOJA T1,.+1]	;CANNOT GIVE IT OUT, STOP LOOP
	CAIGE	T1,<.MCFV+NWMCP>/PAGSIZ## ;OFF THE END OF FUNNY SPACE
	AOJA	T1,CREFS1	;LOOK FOR A NON-EXISTANT PAGE
	JRST	TPOPJ##		;NONE AVAILABLE
CREFS2:	MOVEI	T2,1		;NUMBER OF PAGES TO CREATE
	PUSH	P,T1		;SAVE VIRTUAL PAGE NUMBER
IFN FTKL10,<
	MOVE	T3,-1(P)	;GET SIGN BIT FOR UNCACHED
>
	PUSHJ	P,CREMPG	;CREATE THE PAGE
	  JRST	TTPOPJ##	;FAIL IF NO VIRTUAL SPACE
	POP	P,T1		;RESTORE VIRTUAL PAGE NUMBER
	SUBI	T1,<.MCFV-.FPMC>/PAGSIZ## ;CONVERT TO PER-PROCESS ADDRESS
	LSH	T1,P2WLSH##	;...
	JRST	T2POJ1##	;POP OFF JUNK AND GIVE GOTIT RETURN

;SUBROUTINE TO GET PHYSICAL PAGES OF MEMORY
; CALL WITH T3 = NUMBER OF PAGES TO ALLOCATE
; CALLERS RESPONSABILITY TO CHECK TO SEE IF ALLOCATING PAGES REQUESTED WILL
; LEAVE ENOUGH ROOM FOR THE BIGGEST JOB TO SWAP IN
; RETURNS WITH T1 = FIRST PAGE ALLOCATED
; MUST OWN THE MM BEFORE CALL

GETPHP::PUSHJ	P,FRDCR##	;MAKE ROOM IF POSSIBLE
	  CAIA			;DIDN'T MAKE IT, WAIT A WHILE
	JRST	GETPH1		;PAGES ARE AVAILABLE, ALLOCATE THEM
IFN FTMP,<
	PUSHJ	P,DWNMM##	;RETURN MM BEFORE SLEEPING
>
	PUSH	P,T3		;SAVE NUMBER OF PAGES REQUESTED
	MOVEI	T1,1		;SLEEP A TIC
	PUSHJ	P,SLEEPF##	;ZZZZZZ
IFN FTMP,<
	PUSHJ	P,UPMM##	;GET THE MM BACK
>
	POP	P,T3		;RESTORE SIZE OF REQUEST
	JRST	GETPHP		;AND TRY AGAIN
GETPH1:	SE1ENT			;ENTER SECTION 1
	MOVE	T2,T3		;NUMBER OF PAGES TO GET
	LSH	T3,P2WLSH##	;NUMBER OF WORDS BEING ALLOCATED
	MOVNS	T3		;MAKE NEGATIVE
	ADDB	T3,MAXMAX##	;DECREASE MAX CORMAX
	CAMGE	T3,CORMAX##	;LOWER THAN CORMAX?
	MOVEM	T3,CORMAX##	;YES, DECREASE CORMAX AS WELL
	PUSHJ	P,GTPAGS##	;GET THE NEEDED PAGES
	MOVE	T3,T1		;RETURN FIRST PAGE ALLOCATED IN T1
GETPH2:	MOVE	T2,T3		;PAGE NUMBER OF PAGE TO BE ZEROED
	PUSHJ	P,ZPAGE		;ZERO THE PAGE
	SSX	T3,MDSEC2	;PAGTAB SECTION
	MOVSI	T2,MONTRB+TNCSHB;MARK THIS PAGE AS A MONITOR PAGE
	IORB	T2,PAGTAB(T3)	;LITE THE BIT AND GET NEXT PAGE NUMBER
	TRNN	T2,-1		;LAST PAGE ALLOCATED?
	POPJ	P,		;YES, RETURN
	HRRZ	T3,T2		;NO, NEXT PAGE NUMBER
	JRST	GETPH2		;LOOP TO MARK AND ZERO ALL PAGES ALLOCATED
;SUBROUTINE TO STORE A PAGE NUMBER IN A MAP (CAUSES ALL CPUS TO SEE NEW MAPPING)
; ENTER AT STMAPS TO STORE IN SECTION TABLE, STMAPE TO STORE IN SECTION MAP
;CALL WITH T1= MAP OFFSET, T2 = NEW PHYSICAL PAGE # (OR ZERO IF
;CLEARING)

IFN FTKL10!FTKS10,<
IFN FTKLP,<
STMAPS:	TLOA	T1,400000	;REMEMBER ENTRY POINT
STMAPE:	TLZ	T1,400000	;REMEMBER ENTRY POINT
	PUSHJ	P,SAVE4##	;SAVE ACS
	SKIPGE	T1		;STORING SECTION POINTER?
	SKIPA	P2,[<POINT 36,(P4),35>] ;YES, BYTE POINTER TO EPT INDEXED BY .CPEPT
	MOVSI	P2,(POINT 36,0,35) ;BYTE POINTER TO STORE IN SECTION MAP
	SKIPE	P3,T2		;IF ZERO, STORE A ZERO
	HRLI	P3,(<PM.DCD>B2+PM.WRT+PM.CSH) ;ACCESSIBLE, WRITABLE, CACHED
>
IFE FTKLP,<
STMAPE:	PUSHJ	P,SAVE4##	;SAVE ACS
	TRNN	T1,1		;ODD OR EVEN PAGE?
	SKIPA	P2,[POINT 18,(P4),17]
	MOVSI	P2,(POINT 18,(P4),35)
	LSH	T1,-1		;CONVERT TO OFFSET
	SKIPE	P3,T2		;IF ZERO, STORE ZERO
	MOVEI	P3,PM.WRT!PM.CSH(P3)
>
	HRRI	P2,(T1)		;OFFSET INTO SECTION TABLE OR MAP
IFN FTMP,<
	JUMPL	T1,STMAP1	;SECTION POINTERS ALWAYS HAVE CACHE BIT ON
	PUSHJ	P,MLSCSH##	;MONITOR LOW SEGMENT CACHED?
	  TLZ	P3,(PM.CSH)	;NO, CACHE MUST BE OFF
STMAP1:>
	MOVEI	T1,STMPEC##	;ROUTINE TO STORE ENTRY IN ALL CPU'S MAPS
IFN FTMP,<
	PUSHJ	P,DIFMM##	;GIVE UP THE MM IF OWNED SINCE STMPEC MAY SLEEP
>
	S0PSHJ	CPUAPP##	; AND INSURE THAT ALL CPUS SEE THE NEW MAPPING
				; DO IT
IFN FTMP,<
	PJRST	UIFMM##		;RESTORE THE MM IF OWNED UPON ENTRY
>
IFE FTMP,<
	POPJ	P,		;RETURN
>
>
;SUBROUTINE TO ALLOCATE FUNNY SPACE IN WORDS RATHER THAT CHUNKS
;	T2/ NUMBER OF WORDS DESIRED
;	PUSHJ	P,GTFWDC	;GET FUNNY WORDS, CACHED
;	  -OR-
;	PUSHJ	P,GTFWDU	;GET FUNNY WORDS, UNCACHED
;RETURN CPOPJ IF SPACE IS NOT AVAILABLE
;	CPOPJ1 IF IT IS, T1 = ADDRESS

GFWDCH::HRRZS	.USFCU		;CLEAR LARGEST HOLE
	PUSHJ	P,GTFWDC	;GET THE SPACE
	  CAIA			;NOT AVAILABLE
	JRST	CPOPJ1##	;GOT IT
	HLRZ	T2,.USFCU	;GET SIZE OF BIGGEST HOLE
	POPJ	P,		; AND FAIL

IFN FTKL10,<
GFWDUD::SKIPA	T1,[GTFWDU]	;TRY REGULAR ENTRY POINTS FIRST
GFWDCD::MOVEI	T1,GTFWDC	;...
	PUSHJ	P,(T1)		;CALL CORRECT ROUTINE
>
IFE FTKL10,<
GFWDUD::
GFWDCD::PUSHJ	P,GTFWDC	;ALL THE SAME ON KI/KS
>
	  CAIA			;NO FUNNY SPACE AVAILABLE
	JRST	CPOPJ1##	;GIVE GOOD RETURN
	MOVE	T1,[600000,,.USFCD] ;TRY RESTRICTED SPACE
	JRST	GTFWD9		;AND HOPE THAT THERE IS SOME

GTFWDU::
IFN FTKL10,<
	SKIPE	[CPUN##-1]	;ALL SPACE IS CACHED IF ONLY 1
	SKIPA	T1,[400000,,.USFCU] ;ELSE GET UNCACHED HEADER
>
GTFWDC::MOVEI	T1,.USFCC	;POINT TO CACHED LIST HEAD
GTFWD9:
	PUSHJ	P,SAVR##	;SAVE R
IFE FTKLP,<
	SETZ	R,
>
IFN FTKLP,<
	MOVEI	R,(MDSEC0)	;SECTION 0 SPACE (REALLY FUNNY SPACE)
	JRST	GTFWD1		;JOIN COMMON CODE
GFWNZ2::
	SKIPA	T1,[400000,,(MDSEC1)]	;SECTION 2 CORE
GFWNZS::
	MOVE	T1,[400000,,(MDSEC2)]	;GENERAL NZS SPACE
	SE1ENT			;MUST BE IN SECTION 1 TO ALLOCATE NZS SPACE
IFN FTMP,<
	PUSHJ	P,MMOWN##	;WE OWN MM ALREADY?
	  PUSHJ	P,GGVMM##	;NO--MUST HAVE THE MM TO LINK THROUGH FREE CORE CHAINS
>
	PUSHJ	P,SAVR##	;SAVE R
	MOVE	R,T1		;COPY SECTION # TO R
	MOVE	T1,NZSFCH##(R)	;HEADER FOR SPACE (ALWAYS UNCACHED)
>
GTFWD1:	PUSH	P,T1		;SAVE HEAD (FLAG ACTUALLY)
GTFWD2:
IFE	FTKLP,<
	MOVEI	T3,(T1)		;REMEMBER LINK
>
IFN FTKLP,<
	MOVE	T3,T1		;REMEMBER LINK
	SKIPE	R		;SECTION ZERO ALWAYS STORES SECTION
	CAME	T3,NZSFCH##(R)	;IF NOT THE FIRST TIME IN NON-ZERO SECTION
	SSXE	T1,(R)		; SET SECTION INDEX TO FUNNY SPACE SECTION
	HLL	T3,T1		;SET PREDECESSOR SECTION
	JUMPE	R,GTFW2A	;NON-ZERO SECTION HAS END POINTER
	CAMN	T1,NZSFCE##(R)	;THIS LAST BLOCK?
	  JRST	GTFWD3		;YES
	HRRZ	T1,(T1)		;POINT TO NEXT BLOCK
	JRST	GTFW2B
GTFW2A:>
	HRRZ	T1,0(T1)	;T1 = CURRENT CHUNK ADDRESS
	JUMPE	T1,GTFWD3	;IF 0, NO HOLE AVAILABLE, GET SOME MORE
GTFW2B:	SSXE	T1,(R)		;ADDRESS CORRECT SECTION
	HLRZ	T4,0(T1)	;SIZE OF THIS HOLE
	CAIGE	T4,(T2)		;LARGE ENOUGH FOR REQUEST
	JRST	[IFN FTKLP,<JUMPN R,GTFWD2> ;NO BIGGEST HOLE IN NZS SPACE
		 HRLZ T4,T4	;NO, MOVE SIZE OF THIS HOLE
		 CAMLE T4,.USFCU ;BIGGEST YET
		 HLLM T4,.USFCU ;YES, REMEMBER FOR TMPCOR
		 JRST	GTFWD2]	; AND LOOK AT THE NEXT
	MOVEM	T1,(P)		;SAVE CHUNK ADDRESS
	CAIN	T4,(T2)		;AN EXACT SIZE MATCH
	JRST	[HRR T4,0(T1)	;YES, GET POINTER TO NEXT
		 HRRM T4,0(T3)	;RE-LINK PREVIOUS
IFN FTKLP,<
		 JUMPE	R,TPOPJ1##
		 JRST	GTFW2F]	;CHECK IF THIS WAS LAST
>
IFE FTKLP,<
		 JRST	TPOPJ1##]
>
	HRL	T4,0(T1)	;GET LINK TO NEXT CHUNK
	ADDI	T1,(T2)		;ADDRESS OF REMAINDER THIS CHUNK
	HRRM	T1,0(T3)	;STORE LINK TO REMAINDER
	SUBI	T4,(T2)		;SIZE OF REMAINDER
	MOVSM	T4,0(T1)	;STORE NEW LENGTH,OLD LINK IN REMAINDER
IFN FTKLP,<
	JUMPE	R,TPOPJ1##	;SECTION ZERO, WE ARE DONE
	MOVE	T3,T1		;NEW LAST BLOCK
GTFW2F:	POP	P,T1		;RESTORE ADDRESS
	CAMN	T1,NZSFCE##(R)	;JUST ALLOCATE LAST BLOCK?
	  MOVEM	T3,NZSFCE##(R)	;STORE IT
	JRST	CPOPJ1##	;DONE
>
IFE FTKLP,<
	JRST	TPOPJ1##
>
GTFWD3:	PUSH	P,T2		;SAVE AMOUNT REQUESTED
	MOVE	T1,-1(P)	;BITS,,HEADER
	MOVEI	T2,1		;ALWAYS CREATE ONLY 1 PAGE
	PUSH	P,R		;SAVE R
	PUSHJ	P,CREMNS	;CREATE A PAGE IN FUNNY SPACE OR NON-ZERO SECTION
	  JRST	GTFW3A
	POP	P,R
	JRST	GTFWD4		;A WINNER
GTFW3A:	POP	P,R
IFN FTKL10,<
	POP	P,T2		;RESTORE AMOUNT REQUESTED
	POP	P,T1		;RESTORE HEADER USED
	SKIPE	[CPUN##-1]	;ONLY ONE TRY IF ALL IS CACHED
	JUMPGE	T1,GTFWDU	;TRY FOR UNCACHED SPACE IF NO CACHED
	POPJ	P,		;ELSE OUT OF FUNNY SPACE
>
IFE FTKL10,<JRST TTPOPJ##>	;ONLY 1 TRY ON KI/KS
GTFWD4:	POP	P,T4		;RESTORE AMOUNT REQUESTED
	POP	P,T3		;RESTORE FREE SPACE HEADER AND FLAG
	MOVEI	T2,PAGSIZ##	;AMOUNT JUST ACQUIRED
	CAILE	T4,PAGSIZ##	;REQUESTING MORE THAN 1 PAGE
	JRST	GTFWD5		;YES, MERGE THIS PAGE AND TRY AGAIN
	SUB	T2,T4		;AMOUNT LEFT OVER AFTER SATISFYING REQUEST
	JUMPE	T2,CPOPJ1##	;EXACT AMOUNT, RETURN NOW
	PUSH	P,T1		;SAVE ADDRESS OF NEWLY ACQUIRED CHUNK
	ADD	T1,T4		;ADDRESS OF RESIDUE
	EXCH	T1,T2		;WANT ARGS IN OTHER ORDER
	PUSHJ	P,GVFWD2	;GIVE IT BACK (T3 ALREADY SET UP)
	JRST	TPOPJ1##	;AND GIVE GOOD RETURN TO CALLER
GTFWD5:	PUSH	P,T3		;SAVE HEADER AND FLAGS
	PUSH	P,T4		;SAVE ORIGINAL AMOUNT REQUESTED
	TLO	T3,100000	;LIGHT BIT SAYING NOT TO RETURN FULL PAGES
	EXCH	T1,T2		;WANT LENGTH AND ADDRESS IN THE OTHER ORDER
	PUSHJ	P,GVFWD2	;RETURN FULL PAGE TO THE FREE LIST
	POP	P,T2		;RESTORE ORIGINAL WORDS REQUESTED
	POP	P,T1		;RESTORE FREE SPACE HEADER AND FLAGS
	JRST	GTFWD1		;AND TRY TO SATISFY THE REQUEST NOW
;SUBROUTINE TO RETURN WORDS ACQUIRED BY GTFWDC, GTFWDU, OR GFWNZS
;CALL:	T1/ WORDS TO RETURN
;	T2/ ADDRESS
;	PUSHJ	P,GVFWDS

GVFWDS::
	PUSHJ	P,SAVR##	;SAVE TEMP USED FOR SECTION INDEX
GVFWD0:
IFN FTKLP,<
	MOVEI	R,(MDSEC0)	;ASSUME WE ARE TALKING ABOUT SECTION 0 SPACE
	HLRZ	T4,T2		;SECTION NUMBER
>
IFE FTKLP,<
	SETZB	R,T4		;ONCE ONLY OR FUNNY SPACE IS SECTION 0
>
	CAML	T2,LOCORE##	;ONCE-ONLY CORE?
IFN FTKLP,<
	TLZE	T2,-1		;NZS SPACE?
	TRNA			;ONCE ONLY OR NZS
>
	JRST	GVFWD1		;NO, SECTION ZERO FUNNY SPACE
	CAIGE	T4,NZSFCL##	;KNOW ABOUT THIS SECTION?
	SKIPN	T3,NZSFCH##(T4)	;?
	STOPCD	CPOPJ##,DEBUG,RWS, ;++RETURNING SPACE TO WRONG SECTION
IFN FTKLP,<
	SKIPE	R,T4		;GET SECTION #
	SE1ENT			;IF RETURNING NZS CORE
	TLO	R,400000	;FLAG NOT FUNNY SPACE
>
IFE FTKLP,<
	MOVSI	R,400000	;FLAG NOT FUNNY SPACE BUT STILL SECTION ZERO
>
IFN FTMP,<
	PUSHJ	P,MMOWN##	;WE OWN MM ALREADY?
	  PUSHJ	P,GGVMM##	;NO--MUST INTERLOCK CHAIN CHASING
>
	MOVE	T3,NZSFCH##(R)	;GET PROPER HEADER
	JRST	GVFWD2		;JOIN COMMON CODE
GVFWD1:
	MOVE	T4,T2		;COPY ADDRESS OF PIECE
	LSH	T4,W2PLSH##	;CONVERT TO PAGE NUMBER
	CAIGE	T4,.LPMC/PAGSIZ## ;RANGE CHECK IT
	CAIGE	T4,.FPMC/PAGSIZ## ;...
	STOPCD	CPOPJ##,DEBUG,PFR, ;++PIECE OUT OF FREE RANGE
	CAIN	T4,<.LPMC/PAGSIZ##>-1 ;IS THIS THE RESTRICTED PAGE
	JRST	[MOVE T3,[600000,,.USFCD] ;YES, USE THIS HEADER
		 JRST GVFWD2]	;ENTER COMMON CODE
	ADDI	T4,<.MCFV-.FPMC>/PAGSIZ## ;CONVERT TO VIRTUAL ADDRESS
	PUSHJ	P,GTPM4		;GET PAGE MAP ENTRY
	SKIPN	T4
	STOPCD	CPOPJ##,DEBUG,FPE, ;++FUNNY PAGE MUST EXIST
IFN FTKL10,<
	TDNN	T4,[PM.CSH]	;A CACHED PAGE
	SKIPA	T3,[400000,,.USFCU] ;GET UNCACHED LIST HEADER
>
	MOVEI	T3,.USFCC	;GET CACHED LIST HEADER
GVFWD2:	SPUSH	T3		;PUSH LEFT HALF
	TLZ	T3,100000	;CLEAR POSSIBLE FLAG.
	TLNE	R,400000	;FUNNY SPACE?
	CAME	T3,NZSFCH##(R)	;IF NOT THE FIRST TIME
	SSXE	T3,(R)		; RELOCATE TO DATA SECTION
	JUMPE	R,GVFW2A	;ZERO TERMINATION FOR SECTION ZERO
	CAMN	T3,NZSFCE##(R)	;ELSE IS THIS LAST?
	  JRST	[SPOP	T3
		 JRST	GVFWD3]	;YES
GVFW2A:
	HRRZ	T4,0(T3)	;GET FIRST CHUNK IN FREE LIST
	SPOP	T3		;RESTORE LEFT HALF
	TLNN	R,400000	;FUNNY SPACE?
	  JUMPE	T4,GVFWD3	;SECTION ZERO IS ZERO TERMINATED
	CAIN	T4,(T2)		;ALREADY IN FREE LIST
	STOPCD	CPOPJ##,DEBUG,PFL	;++PIECE ON FREE LIST
	CAIL	T4,(T2)		;KEEP CHUNKS IN ADDRESS ORDER
	JRST	GVFWD3		;IT GOES HERE
	HRR	T3,T4		;REMEMBER LINK
	JRST	GVFWD2		;AND LOOK AT THE NEXT
GVFWD3:	PUSH	P,T3		;SAVE PREVIOUS (AND FLAGS)
	MOVEI	T4,(T3)		;ADDRESS OF PREVIOUS
	JUMPL	R,GVFW3A	;ALWAYS COMBINE NZS
	CAIE	T4,.USFCD	;RESTRICTED SPACE HEADER
	CAIN	T4,.USFCC	;OR CACHED HEADER THE PREVIOUS?
	JRST	GVFWD4		;YES, CANNOT COMBINE (LH OF HDR IS NOT A LENGTH)
	JUMPE	R,GVFW3B	;SKIP SOME IF FUNNY SPACE
GVFW3A:	HLL	T4,NZSFCH##(R)	;COMPARE WITH NZS HEADER FOR RIGHT SECTION
IFN FTKL10,<
	CAME	T4,NZSFCH##(R)
	TLZA	T4,-1		;CLEAR LEFT HALF, PRESERVE NON-SKIP
	TLZA	T4,-1		;CLEAR LEFT HALF PRESERVE SKIP
GVFW3B:	CAIN	T4,.USFCU	;UNCACHED HEADER
>
IFE FTKL10,<
	CAMN	T4,NZSFCH##(R)
	TLZA	T4,-1		;CLEAR LEFT HALF, PRESERVE NON-SKIP
	TLZA	T4,-1		;CLEAR LEFT HALF PRESERVE SKIP
>
	JRST	GVFWD4		;IF NZS HEADER, CANNOT COMBINE
IFE FTKLP,<
IFE FTKL10,<
GVFW3B:
>
	TLZ	T3,-1		;CLEAR JUNK
>
	SSXE	T3,(R)		;PROPER SECTION FOR REFERENCES BELOW
	HLRZ	T4,0(T3)	;LENGTH OF PREVIOUS PIECE
	ADDI	T4,(T3)		;FIRST WORD NOT IN PREVIOUS CHUNK
	CAILE	T4,(T2)		;BETTER BE
	STOPCD	TPOPJ##,DEBUG,FOP, ;++FUNNY ADDRESS OVERLAPS PREVIOUS
	CAIE	T4,(T2)		;PIECES CONTIGUOUS
	JRST	GVFWD4		;NO, CANNOT COMBINE
	MOVEI	T2,(T3)		;YES, ADDRESS OF LARGER CHUNK
	HLRZ	T4,0(T3)	;SIZE OF PREVIOUS
	ADD	T1,T4		;SIZE OF COMBINED PIECES
GVFWD4:	SSXE	T2,(R)		;SET FOR PROPER SECTION ADDRESSING
	HRLM	T1,0(T2)	;SIZE OF THIS CHUNK
	HRRZ	T4,0(T3)	;PREVIOUS LINK TO NEXT
	HRRM	T4,0(T2)	;LINK THIS TO NEXT
	CAME	T2,T3		;PREV=THIS (CONCATENATION)
	HRRM	T2,0(T3)	;NO, LINK PREV TO THIS
	JUMPE	R,GVFW4A
	CAMN	T3,NZSFCE##(R)	;LAST?
	  MOVEM	T2,NZSFCE##(R)	;WE ARE NOW LAST
GVFW4A:
	HRRZ	T3,T2		;ADDRESS OF CURRENT
	ADD	T3,T1		;+SIZE OF CURRENT
	SKIPN	T4		;WAS LAST ADDRESS ZERO?
	  JUMPE	R,GVFWD5	;YES, END OF LIST IF SECTION ZERO
	CAMN	T2,NZSFCE##(R)	;ARE WE NOW LAST?
	  JRST	GVFWD5		;YES, THERE IS NO NEXT
	CAILE	T3,(T4)		;BETTER  BE
	STOPCD	.,JOB,FON,	;++FUNNY ADDRESS OVERLAPS NEXT
	CAIE	T3,(T4)		;BUTT UP AGAINST NEXT ONE
	JRST	GVFWD5		;NO, CANNOT COMBINE THAT SIDE
	HRLZS	T1		;SIZE OF CURRENT,,0
	SSXE	T4,(R)		;PROPER SECTION
	ADD	T1,0(T4)	;COMBINED SIZE,,NEXT'S LINK
	MOVEM	T1,0(T2)	;STORE NEW INFO
	HLRZS	T1		;ISOLATE SIZE OF NEW, LARGER PIECE
	JUMPE	R,GVFWD5	;NOTHING MORE IF SECTION 0
	CAMN	T4,NZSFCE##(R)	;WAS THIS LAST?
	  MOVEM	T2,NZSFCE##(R)	;WE ARE LAST NOW
GVFWD5:	POP	P,T3		;RESTORE ORIGINAL PREVIOUS (AND FLAGS)
	TLNE	T3,100000	;SUPRESS RECLAMATION OF FULL PAGES
	POPJ	P,		;YES, ALL DONE NOW
IFE FTKL10!FTKS10,<		;RECLAIM UNLESS KI
	TLCE	R,400000	;FUNNY SPACE?
	JUMPE	R,CPOPJ		;NO, CAN'T RECLAIM ONCE-ONLY CORE
	TLC	R,400000	;PUT BIT BACK RIGHT
>
	PUSHJ	P,INTLVL##	;ONLY RECLAIM AT UUO LEVEL
	  CAIGE	T1,PAGSIZ##	;CAN WE RECLAIM A FULL CHUNK
	POPJ	P,		;NO, RETURN NOW
	PUSHJ	P,SAVE4##	;YES, SAVE SOME REGS
	DMOVE	P1,T1		;SAVE LENGTH, ADDRESS OF PIECE
	TRZ	T1,PAGSIZ##-1	;MAX WORDS THAT CAN BE RETURNED
	ADDI	T2,PAGSIZ##-1	;AND ROUND ADDRESS TO CHUNK BOUNDRY
	TRZ	T2,PAGSIZ##-1	;...
	MOVE	P4,P2		;ORIGINAL ADDRESS
	ADD	P4,P1		;P4 = FIRST WORD NOT IN PIECE
	MOVE	T4,T2		;START OF CHUNK THAT CAN BE RETURNED
	ADD	T4,T1		;T4 = FIRST WORD THAT WON'T BE RETURNED
GVFWD6:	CAMGE	P4,T4		;RETURNABLE SPACE COMPLETELY CONTAINED
	JRST	[SUBI T1,PAGSIZ## ;NO, LESS WORDS TO RETURN
		 JUMPE T1,CPOPJ## ;"AND THEN THERE WERE NONE"
		 SUBI T4,PAGSIZ## ;ADJUST ENDING ADDRESS ( +1 )
		 JRST GVFWD6]	;AND LOOK AT THE SMALLER PIECE
	MOVEI	P3,(P2)		;GET RIGHT HALF
	CAIE	P3,(T3)		;CURRENT = PREVIOUS (CONCATENTATION)
	JRST	[JUMPE	R,GVFWD9	;GO IF FUNNY SPACE
		 CAME	T3,NZSFCH##(R)	;AT BEGINNING?
		 SSXE	T3,(R)		;NO, RELOCATE
		 JRST	GVFWD9]		;AND UNLINK PIECE
	JUMPE	R,GVFW6A	;SECTION ZERO
	HRR	T3,NZSFCH##(R)	;ASSUME NZS CORE BEING RETURNED
	JRST	GVFWD8		;NON-ZERO SECTION
GVFW6A:	HRRI	T3,.USFCC	;YES, MUST FIND NEW PREVIOUS
IFN FTKL10,<
	SKIPGE	T3		;CACHED OR UNCACHED HEADER NEEDED
	HRRI	T3,.USFCU	;UNCACHED
>
	TLNE	T3,200000	;RESTRICTED SPACE
	HRRI	T3,.USFCD	;YES
GVFWD7:	SSXE	T3,(R)		;SET TO ADDRESS PROPER SECTION
GVFWD8:	HRRZ	P3,0(T3)	;GET LINK TO NEXT
	CAIN	P3,(P2)		;POINT TO THIS ONE
	JRST	GVFWD9		;YES, T3 = NEW PREVIOUS
	HRR	T3,P3		;COPY PREVIOUS
	JRST	GVFWD7		;AND GO LOOK AGAIN
GVFWD9:	SPUSH	P2		;SAVE LEFT HALF
	SSXE	P2,(R)		;SET PROPER SECTION
	HRRZ	P3,0(P2)	;GET ADDRESS OF NEXT CHUNK
	JUMPE	R,GVFW9A	;SECTION ZERO
	CAMN	P2,NZSFCE##(R)	;WERE WE THE LAST?
	  MOVEM	T3,NZSFCE##(R)	;PREDECESSOR NOW IS
GVFW9A:	SPOP	P2		;RESTORE LEFT HALF
	HRRM	P3,0(T3)	;DE-LINK THE LARGER PIECE
	MOVE	P1,T2		;START OF REMOVED PIECE
	SUB	P1,P2		;COMPUTE LENGTH OF L.H. EXCESS
	MOVE	P3,P4		;1ST WORD NOT IN THE PIECE
	SUB	P3,T4		;COMPUTE LENGTH OF R.H. EXCESS
	MOVE	P4,T4		;AND WHERE IT STARTS
	PUSH	P,P1		;SAVE REMAINDER INFORMATION
	PUSH	P,P2		;...
	DMOVE	P1,T1		;COPY AMOUNT TO RETURN
	LSHC	P1,W2PLSH##	;P1 = NUMBER TO RETURN, P2 = PAGE NUMBER OF FIRST
GVFW10:	MOVE	J,.USJOB	;GET JOB NUMBER WHO OWNS THESE PAGES
	PUSHJ	P,DLTMPG	;DELTETE THIS PAGE
	AOS	P2		;STEP TO NEXT PAGE TO RETURN
	SOJG	P1,GVFW10	;GET THEM ALL
	CLRPGT	(0)		;WE HAVE CHANGED THE MAP
	POP	P,T2		;RESTORE LEFT HAND REMAINDER INFORMATION
	POP	P,T1		;...
	SKIPE	T1		;WAS THERE ANY
	PUSHJ	P,GVFWD0	;YES, GIVE IT BACK
	JUMPE	P3,CPOPJ##	;DONE IF NO RIGHT HAND REMAINDER
	DMOVE	T1,P3		;GET LENGTH AND ADDRESS OF IT
	JRST	GVFWD0		;GIVE IT BACK AND RETURN
;SUBROUTINE TO RETURN A FUNNY PAGE, MUST BE A SUBROUTINE SO THAT
; IT CAN CALL THE COROUTINE GGVMM
; CALL WITH P2 = VIRTUAL PAGE NUMBER

DLTMPG:
IFN FTKL10!FTKS10,<
	MOVE	T1,P2		;IN CASE A NZS PAGE
	PJUMPN	R,DNZSPG	;JUMP IF A NZS PAGE
>
IFN FTMP,<
	PUSHJ	P,GGVMM##	;GET MM RESOURCE SINCE DIDDLING CORE ALLOCATION TABLES
				; WILL BE RETURNED UPON EXIT
>
	MOVN	T1,[MCPCNT]	;DECREMENT COUNT OF FUNNY PAGES OWNED
	ADDM	T1,JBTPDB##(J)	;...
	MOVEI	T1,<.MCFV-.FPMC>/PAGSIZ##(P2) ;CONVERT TO VIRTUAL PAGE NUMBER
	PUSHJ	P,TSWST		;GET BIT FOR WSBTAB
	  STOPCD .+1,DEBUG,PNW,	;++PAGE NOT IN WORKING SET
	ANDCAM	T2,WSBTAB(T4)	;NO LONGER IN WORKING SET
	ANDCAM	T2,AABTAB(T4)	;AND NO LONGER CACHED
	PUSHJ	P,GTPME		;GET PAGE MAP ENTRY FOR IT
	SETZ	T3,		;AND GET A ZERO
	DPB	T3,T4		;ZAP THE PAGE MAP ENTRY
	ANDI	T2,17777	;DOWN TO PHYSICAL PAGE NUMBER
	PUSHJ	P,LKPSP		;FIX UP PAGTAB
	PJRST	DLTPGC		;AND DELETE THE PAGE,
				; RETURN MM RESOURCE AND RETURN TO CALLER

;SUBROUTINE TO RETURN A PAGE IN A NON-ZERO SECTION TO FREE CORE OR ONCE-ONLY CORE
; CALL WITH T1 = VIRTUAL PAGE NUMBER (MUST OWN THE MM RESOURCE)

IFN FTKL10!FTKS10,<
DNZSPG:
IFN FTKLP,<
	LSHC	T1,-^D9		;ISOLATE SECTION NUMBER
	LSH	T2,-^D27	;RIGHT JUSTIFY PAGE NUMBER
	ADD	T1,.CPEPT##	;ADDRESS OF EPT + SECTION NUMBER
	SKIPN	T3,SECTAB(T1)	;GET ENTRY FROM SECTION MAP
	STOPCD	CPOPJ##,DEBUG,NXS, ;++NON-EXISTANT SECTION
	MOVEM	T3,.UPMP+<.TEMP/PAGSIZ##> ;MAKE THE SECTION MAP ADDRESSABLE
	CLRPGT	(0)		;MAKE NEW MAPPING VISABLE
	MOVEI	T1,.TEMP(T2)	;ADDRESS OF THE POINTER SLOT (FOR STMAPE)
	SKIPN	T2,.TEMP(T2)	;GET PAGE POINTER
	STOPCD	CPOPJ##,DEBUG,RNP, ;++RETURNING NON-EXISTANT PAGE
>
IFE FTKLP,<
	TRNN	T1,1		;ODD OR EVEN PAGE?
	SKIPA	T2,[POINT 18,.EPLM##(T1),17]
	MOVE	T2,[POINT 18,.EPLM##(T1),35]
	ADD	T2,.CPEPT##
	ROT	T1,-1
	LDB	T2,T2
	ROT	T1,1		;PUT BACK
>
	ANDI	T2,17777	;ISOLATE PHYSICAL PAGE NUMBER
	PUSH	P,T1		;SAVE MAP OFFSET
	PUSHJ	P,DLTPGC	;RETURN THE PAGE TO FREE CORE
	MOVEI	T1,PAGSIZ##	;NUMBER OF WORDS BEING FREED
	ADDM	T1,MAXMAX##	;UPDATE MAXMAX TO REFLECT THAT
	POP	P,T1		;RESTORE PAGE OFFSET
	MOVEI	T2,0		;SET TO ZERO THE MAP SLOT
	PJRST	STMAPE		;ZERO THE MAP SLOT AND RETURN
>
	SUBTTL	COMCON	INTERFACE WITH COMMAND DECODER

;PRIVILEGED COMMAND/UUO TO SET THE SYSTEM-WIDE VM LIMIT
SETVMX::PUSHJ	P,CORLGL##	;GET CORE ARGUMENT
	ADDI	T2,1
	LSH	T2,W2PLSH##	;CONVERT TO PAGES
SETVM1::CAMLE	T2,VIRTAL##	;BIGGER THAN VIRTAL?
	MOVE	T2,VIRTAL##	;YES, USE VIRTAL
	CAMGE	T2,VMTOTL##	;BIGGER THAN TOTAL VM NOW IN USE?
	MOVE	T2,VMTOTL##	;YES, USE CURRENT AMOUNT IN USE
	MOVEM	T2,VMCMAX##	;SAVE SYSTEM WIDE VM LIMIT
	PJRST	CPOPJ1##	;AND RETURN

REPEAT	0,<
;PRIVILEGED UUO/COMMAND TO SET THE SYSTEM-WIDE MAXIMUM PAGING RATE

SETVMR::PUSHJ	P,SAVE1##	;SAVE P1
	PUSHJ	P,CTEXT##	;GET NEXT ARG TYPED BY USER
	JUMPE	T2,NOTENF##
	MOVE	T1,[-2,,SYSORJ];"SYSTEM" OR "JOB"?
	PUSHJ	P,FNDNAM##
	  JRST	COMERA##	;NO - ERROR
	MOVE	P1,T1		;YES, SAVE INDEX
	PUSHJ	P,DECLGL##	;GET NUMBER
SETVR2:	MOVE	T1,@RTPNTR(P1)
	IDIVI	T1,(T2)		;COMPUTE INTERVAL
	MOVEM	T1,@JORSYS(P1)	;SAVE AS PER-JOB OR SYSTEM INTERVAL
	PJRST	CPOPJ1##	;AND TAKE GOOD RETURN

SETVR1::PUSHJ	P,SAVE1##	;SAVE P1
	HRR	M,T2
	PUSHJ	P,GETWDU##
	TLZN	T1,-1		;SYSTEM?
	TDZA	P1,P1		;YES
	MOVEI	P1,1		;NO, JOB
	MOVE	T2,T1
	JRST	SETVR2		;FLOAT, SAVE, AND RETURN

SYSORJ:	SIXBIT	/SYSTEM/
	SIXBIT	/JOB/
JORSYS:	EXP	VMRMAX##
	EXP	JBRMAX##
RTPNTR:	EXP	TICSEC##
	EXP	[RTUPS##]
>	;END OF REPEAT 0
;PRIVILEGED UUO TO SET THE ABSOLUTE PER-USER MAXIMA
SETUVL::HRR	M,T2		;LOC OF ARGUMENT
	PUSHJ	P,FLTSX		;MAKE SURE WONT FAULT
	  JRST	ECOD0##		;PAGE-FAULT AT NON-UUO LEVEL????!!??
	PUSHJ	P,GETWDU##	;GET ARG
	PUSHJ	P,CHKLIM	;MAKE SURE VALUES ARE OK
	  JRST	ECOD0##		;NOT - NON SKIP
SETVLM::DPB	T1,[POINT 28,.PDMVL##(W),35]	;MVPL,,MPPL
	SKIPN	.PDCVL##(W)	;IF NOT ALREADY SET,
	JRST	SETUV2		;SAVE AS CURRENT LIMITS TOO
	PJRST	CPOPJ1##	;AND GOOD RETURN

;NON-PRIVILEGED UUO TO SET INTERVAL FOR VIRTUAL-TIME INTERRUPT
SETVTM::IMUL	T2,TICSEC##	;CONVERT TO TICS-PER-INTERRUPT
	IDIVI	T2,^D1000
	HRRZM	T2,.USTMC;SAVE IN UPMP
	MOVEM	T2,.USTMI
	PJRST	CPOPJ1##	;AND RETURN

;SUBROUTINE TO CHECK CORE LIMITS
;ENTER T1=LIMITS
;EXIT CPOPJ IF TOO BIG, CPOPJ1 IF OK
;RETURNS T3=RH(T1) WITHOUT GUIDELINE BIT
CHKLIM:	HLRZ	T2,T1
	HRRZ	T3,T1
	TRZ	T3,400000	;CLEAR LIMIT BIT
	CAIG	T2,1000		;OK?
	CAILE	T3,1000
	POPJ	P,		;NO, NON-SKIP
	PJRST	CPOPJ1##	;YES, SKIP
;NON-PRIVILEGED COMMAND TO SET CURRENT PER-USER LIMITS
SETUVC::SKIPA	T1,[POINT 10,.PDMVL##(W),17]
SETUPC::MOVE	T1,[POINT 18,.PDMVL##(W),35]
	PUSHJ	P,SAVE2##	;SAVE AN AC
	MOVE	P1,T1		;SAVE POINTER TO MAX VALUE FOR THIS ARG
	PUSHJ	P,FNDPDB##	;GET PDB LOC
	  POPJ	P,		;NONE-RETURN
	MOVE	T1,[-2,,[SIXBIT /GUIDEL/
			 SIXBIT /LIMIT/]]
	PUSHJ	P,TXTARG##
	  TDZA	P2,P2
	MOVE	P2,T1
	PUSHJ	P,CORARG##	;GET THE CORE ARGUMENT
	  PJRST	NOTENF##
	ADDI	T1,1		;CONVERT TO PAGES
	LSH	T1,W2PLSH##
	PUSHJ	P,CHKLIM	;LEGAL?
	  PJRST	COMERA##
	LDB	T2,P1		;YES, GET MAX VALUE FOR THIS ARG
	CAILE	T1,(T2)		;TRYING TO SET IT TOO HIGH?
	JRST	COMERA##	;YES
	HRRI	P1,.PDCVL##	;NO, SET TO STORE NEW VALUE
	DPB	T1,P1		;SAVE CURRENT LIMIT
	TRNN	T1,-1		;SETTING LIMIT/GUIDELINE TO ZERO?
	MOVEI	P2,0		;YES, CLEAR LIMIT BIT
	TLNN	P1,770000	;PHYSICAL?
	DPB	P2,[POINT 1,.PDCVL##(W),18]
	PJRST	CPOPJ1##	;AND TAKE GOOD RETURN


;NON-PRIVILEGED UUO TO SET PER-USER CURRENT LIMITS
SETUV1::HRR	M,T2		;ADR OF ARGUMENT
	PUSHJ	P,FLTSX
	  POPJ	P,		;PAGE-FAULT AT NON-UUO LEVEL???!!!
	PUSHJ	P,GETWDU##	;GET ARGUMENT
	PUSHJ	P,CHKLIM	;LEGAL?
	  POPJ	P,		;NO, RETURN
	MOVE	T2,.PDMVL##(W)	;YES, GET MAX LIMIT
	HRRZ	T4,T2		;MAKE SURE ARGUMENTS ARE BELOW MAX LIMITS
	TLZ	T2,776000
	TRO	T2,-1		;PUT LARGE NUMBER IN IRRELEVANT RIGHT-HALF
	CAMG	T1,T2
	CAMLE	T3,T4
	POPJ	P,		;TRYING TO SET THEM TOO BIG
SETUV2:	TLNE	T1,-1		;OK, SAVE WHAT HE ASKED FOR
	.HLLM	T1,.PDCVL##(W)	;CVPL
	TRNE	T1,-1
	.HRRM	T1,.PDCVL##(W)	;CPPL
	SKIPN	T1		;IF WHOLE THING ZERO,
	.MOVEM	T1,.PDCVL##(W)	;  DO IT ANYWAY
	PJRST	CPOPJ1##
;ROUTINE TO DETERMINE IF A PAGE EXISTS AND IF SO IF REFERENCING IT
; WILL CAUSE A PAGE FAULT. ENTER T2 = VIRTUAL ADDRESS
; EXIT CPOPJ IF PAGE DOESN'T EXIST
; CPOPJ1 IF PAGE EXISTS BUT IS PAGED OUT OR HAS ACCESS ALLOWED OFF,
; CPOPJ2 IF PAGE EXISTS AND IS IN CORE,  OR IS ALLOCATED BUT ZERO
;RETURNS MAP CONTENTS FOR THE ADR IN T4
;PRESERVES T2.

FLTTC::	HRRZ	T4,T2		;GET ADR
	LSH	T4,W2PLSH##	;PAGE NUMBER
	PUSHJ	P,GTPM4		;GET CONTENTS OF MAP
	JUMPE	T4,CPOPJ##	;NON-SKIP IF NOT ALLOCATED
	CAIE	T4,PM.ZER	;CPOPJ2 IF ALL. BUT ZERO
IFE FTKLP,<
	TRNE	T4,PM.ACC	;ELSE CPOPJ1 IF AA OFF
>
IFN FTKLP,<
	TLNE	T4,(<PM.ACD>B2)
>
	AOS	(P)		;CPOPJ2 IS ACCESS ALLOWED ON
	JRST	CPOPJ1##
;HERE TO DEPOSIT IN AN ALLOCATED BUT ZERO PAGE
; S = WHAT TO DEPOSIT, JOBEXM = WHERE
CREPAG::PUSHJ	P,CLRASA##	;CLEAR JS.ASA IN CASE OF ERROR AND SO USER'S
				; ACS WILL GET RESTORED WHEN MONITOR JOB IS STARTED
	JUMPL	P4,CREPA2	;IF RUNNING, REQUIRE A CONTROL C
	JSP	T2,SAVCTX##
;RETURN HERE AT UUO LEVEL
	MOVEM	S,.JDAT+JOBFDV##	;SAVE WHAT TO DEPOSIT
	HRRZ	T2,.JDAT+JOBEXM##	;WHERE TO DEPOSIT
	MOVEI	T3,1		;NUMBER OF PAGES TO CREATE FOR THE DEPOSIT
	PUSHJ	P,MAKPGS	;CREATE THE PAGE FOR THE DEPOSIT
	  JRST	CREPA1		;LOST, PHYSICAL LIMIT IS SET TOO LOW
	MOVE	T1,.JDAT+JOBFDV##	;WHAT
	HRRZ	T2,.JDAT+JOBEXM##	;WHERE
	EXCTXU	<MOVEM T1,(T2)>	;STORE IT AWAY FOR HIM
	POPJ	P,
CREPA1:	PUSHJ	P,TTYFUW##	;FIND HIS TTY AND RESTORE J
	PUSHJ	P,PRQM##	;"?"
	MOVEI	T1,OUTBMS##	;"OUT OF BOUNDS"
	PJRST	CONMES##	;PRINT THAT
CREPA2:	HRRM	T2,.JDAT+JOBEXM## ;STORE WHAT USER TYPED SINCE CAN'T DO IT NOW
	MOVEI	T1,RUNERR##	;"PLEASE TYPE CONTROL C FIRST"
	PJRST	ERRMES##	;PRINT THAT AND RETURN TO COMCON
;SUBROUTINE TO RETURN # OF VIRTUAL PAGES ALLOCATED TO A USER'S JOB
;CALL WITH:
;	UBR SETUP TO USER PAGE MAP PAGE
;	MOVEI	J,JOB #
;	PUSHJ	P,VMSIZE
;	RETURNS HERE WITH LOWSEG SIZE IN T1 AND HISEG SIZE IN T2
;
;	JOB'S UPMP IS IN CORE WHEN VMSIZE IS CALLED. LOWSEG SIZE
;	  INCLUDES THE JOB'S PAGE MAP PAGE.
;
VMSIZE::SETZB	T1,T2		;ASSUME USER DID CORE 0
	SKIPN	JBTADR##(J)	;ANY CORE ASSIGNED?
	POPJ	P,		;NO, RETURN ZEROS
	PUSHJ	P,LOSIZ		;GET THE LOW SEG SIZE
	MOVEI	T1,UPMPSZ##(T3)	; +1 FOR UPMP
	ADD	T1,.USMEM	; + NO OF NON-CONTIGUOUS PAGES
	SKIPLE	T3,JBTSGN##(J)	;HAVE A HI SEG?
	 TLOA	T3,(1B0)	;MAKE A USABLE INDEX OUT OF COPY OF JBTSGN
	  TRNA			;NO HISEG
	 HLRZ	T2,JBTADR##(T3)	;YES, GET ITS SIZE
	ADDI	T2,1
	LSH	T2,W2PLSH##	;CONVERT TO PAGES
	POPJ	P,		;AND RETURN
;SUBROUTINE TO COMPUTE THE LOW SEG SIZE
;ENTER J=JOB NUMBER
;EXIT T3= LOW SEG SIZE IN PAGES
;PRESERVES ALL ACS (EXCEPT T3)

;CALL HISIZ TO COMPUTE HI SEG SIZE, ALWAYS RETURNS CPOPJ1
HISIZ:	AOSA	(P)		;SKIP RETURN, GET JBTADR
LOSIZ:	SKIPN	T3,.USREL	;VIRTUAL?
	HLRZ	T3,JBTADR##(J)	;NO, USE JBTADR
	ADDI	T3,1
	LSH	T3,W2PLSH##	;CONVERT TO PAGES
	POPJ	P,		;AND RETURN
	SUBTTL	ERRCON	ERROR HANDLING MODULE

;SUBROUTINE TO COMPUTE A VIRTUAL PAGE NUMBER WITHIN A JOB'S
; ADDRESS SPACE BASED ON AN ABSOLUTE PAGE NUMBER KNOWN TO BE IN THE
; JOB'S MAP
;CALLING SEQUENCE:
;	MOVE	J,JOB NUMBER
;	MOVE	T3,PHYSICAL PAGE NUMBER TO BE USED IN VIRTUAL PAGE CALCULATION
;	MAKE THE JOB'S MAP ADDRESSABLE
;	PUSHJ	P,PHYPVP	;CONVERT PHYSICAL PAGE NUMBER TO VIRTUAL PAGE NUMBER
;ALWAYS RETURNS POPJ,T1=VIRTUAL PAGE NUMBER WITHIN THE
; LOW SEGMENT OR RELATIVE PAGE NUMBER WITHIN HIGH SEGMENT

PHYPVP::SETZB	T1,T4		;START AT VIRTUAL PAGE 0
	PUSHJ	P,GMPTR		;GET A BYTE POINTER TO THE MAP
PHYPV1:	LDB	T2,T4		;MAP CONTENTS
	IBP	T4		;BUMP BYTE POINTER TO THE NEXT SLOT
	TRZ	T2,760000	;CLEAR ACCESS BITS
	CAIE	T3,(T2)		;IS THIS THE ABSOLUTE PAGE IN QUESTION?
	AOJA	T1,PHYPV1	;NO, LOOK AT THE NEXT PAGE IN THE MAP
	PUSHJ	P,TPAHS		;YES, IS THIS PAGE IN THE HIGH SEGMENT?
	  SKIPA	J,JBTSGN##(J)	;YES, GET HIGH SEGMENT NUMBER
	POPJ	P,		;NO, RETURN
	LDB	T1,JBYHSO##	;GET ORIGIN PAGE OF THE HIGH SEGMENT
	SUBI	T1,(T2)		;COMPUTE RELATIVE PAGE WITHIN HIGH SEGMENT
	POPJ	P,		; AND RETURN
	SUBTTL	CORE1	INTERFACE WITH THE CORE ROUTINES

;SUBROUTINE TO TURN ON BITS IN WSBTAB WHEN A JOB IS EXPANDING
;ENTER T1=HIGHEST RELATIVE PAGE DESIRED
;PRESERVES T1
CLRWS::	PUSHJ	P,SAVE1##	;SAVE P1
	MOVSI	P1,(ANDCAM T1,(T4))	;SET ARGUMENT FOR ADJWS1
	JRST	ADJWS1		;CLEAR BITS IN WSBTAB

ADJWS::	PUSHJ	P,SAVE1##	;SAVE P1
	MOVSI	P1,(IORM T1,(T4)) ;SET ARG  FOR ADJWS1
	MOVEI	T3,10+IFN FTKLP,<20> ;MAKE SURE UPMP BIT ON IN WSBTAB
	IORM	T3,WSBTAB+16
ADJWS1:	MOVE	T3,T1		;HIGHEST PAGE
	MOVEI	T4,WSBTAB	;SET BITS IN WSBTAB
	PUSHJ	P,DOBIT
	MOVEI	T4,AABTAB	;SET BITS IN AABTAB
DOBIT:	PUSHJ	P,SAVT##
	MOVEI	T1,^D36		;SET UP FIRST PART OF MASK
	PUSHJ	P,BITMSK##
DOBIT1:	XCT	P1		;SET OR CLEAR BITS
	JUMPLE	T3,CPOPJ##	;GO IF THROUGH
	PUSHJ	P,BITMS2##	;SET MASK FOR NEXT PART
	JRST	DOBIT1		;AND CONTINUE


;SUBROUTINE TO COMPUTE THE TOTAL VIRTUAL SIZE OF A JOB
;ENTER WITH JOB ADDRESSABLE
;EXIT T2= JOB SIZE IN PAGES (EXCLUDES UPMP SIZE)
;PRESERVES ALL ACS BUT T2
VRTSZ:	PUSH	P,T1		;SAVE T1
	MOVE	T1,.USJOB	;JOB NUMBER
	SKIPN	T2,.USREL	;NON-CONTIGUOUS?
	HLRZ	T2,JBTADR##(T1)	;NO, GET JBTADR
	SKIPLE	T1,JBTSGN##(T1)	;IS THERE A NON-SHARABLE HI-SEG?
	TLNE	T1,SHRSEG
	TDZA	T1,T1		;NO
	HLRZ	T1,JBTADR##(T1)	;YES, GET ITS SIZE
	ADD	T2,T1		;LOW+HIGH SIZES
	LSH	T2,W2PLSH##
	ADD	T2,.USMEM	;+NO OF NON-CONTIG PAGES
	AOJA	T2,TPOPJ##	;AND RETURN
;SUBROUTINE CALLED BY CORE1 ON A CORE UUO/COMMAND
;ALLOCATES SPACE (ALLOCATED BUT ZERO) IF A JOB IS ALREADY VIRTUAL
; OR IS GOING VIRTUAL BY THIS CORE OPERATION
;ENTER T3=AMOUNT OF INCREASE -1 ; T1=NEW HIGHEST ADDRESS
;EXIT CPOPJ IF ASKING FOR TOO MUCH
;EXIT CPOPJ1 IF ALLOCATED ON DSK
;EXIT CPOPJ2 OTHERWISE, T1=HIGHEST ADR, T3=AMOUNT OF INCREASE-1
VIRCHK::CAIG	J,JOBMAX##	;LOW SEGS MUST CALL KISER TO
	JUMPE	R,CPOPJ2##	; GET INITIAL CORE (GETMIN)
	TLNE	J,SHRSEG	;A SHARABLE HIGH SEGMENT?
	JRST	CPOPJ2##	;YES, LET KISER HANDLE CORE ALLOCATION
	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	SKIPN	T2,.USREL	;NO, HIGHEST CONTIGUOUS ADDRESS IN THE LOW SEGMENT
	HLRZ	T2,R		;HIGHEST ADDRESS IN THE SEGMENT
	MOVE	T4,T1		;HIGHEST ADDRESS REQUESTED
	SUB	T4,T2		;MINUS CURRENT HIGHEST ADDRESS
	JUMPLE	T4,VIRC13	;JUMP IF DECREASING IN SIZE
	LSH	T4,W2PLSH##	;CONVERT TO NUMBER OF PAGES OF INCREASE
	DMOVEM	T1,.USTMP	;SAVE REQUESTED SIZE, CURRENT SIZE
	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	JRST	VIRCH1		;NO
	SKIPN	R		;CREATING A HIGH SEGMENT?
	SETZM	JBTSWP##(J)	;YES, ZERO JUNK
	EXCH	J,.USJOB	;JOB NUMBER
	PUSHJ	P,HSVAD##	;COMPUTE THE EXTENT OF THE HIGH SEGMENT
	EXCH	J,.USJOB	;RESTORE HIGH SEGMENT NUMBER
	MOVE	T1,T2		;UVA OF HIGH SEGMENT
	ADD	T1,.USTMP	;CURRENT HIGEST ADDRESS IN THE HIGH SEGMENT
	ADD	T2,.USTMP+1
VIRCH1:	CAMG	T4,VIRTAL##	;IS ENOUGH SWAPPING SPACE AVAILABLE?
	PUSHJ	P,CKNZW		; AND ARE ALL PAGES REQUESTED NOT IN-USE?
	  POPJ	P,		;NO, ERROR RETURN
	MOVE	T1,.USTMP	;RESTORE THE HIGEST ADDRESS REQUESTED
	MOVEM	T4,.USTMP	;SAVE THE NUMBER OF PAGES OF INCREASE
	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	PUSHJ	P,FNDPDS##	;NO, FIND THE PDB FOR THIS JOB
	PUSHJ	P,GSIZT		;DOES IT FIT (PHSYCIALLY, VIRTUALY, NOT AT ALL)?
	  JRST	VIRCH2		;MAYBE VIRTUALLY
	  SKIPGE P1		;VIRTUALLY IF NOT PHYSICAL ONLY
	JRST	VIRCH3		;PHYSICALLY
;HERE IF JOB ALREADY VIRTUAL OR HAS TO GO VIRTUAL
VIRCH2:	JUMPL	P1,CPOPJ##	;PHYSICAL-ONLY IF P1 NEGATIVE
	HLRZ	T3,.PDCVL##(W)	;CURRENT VIRTUAL LIMIT
	JUMPE	T3,CPOPJ##	;CANNOT GO VIRTUAL IF NONE
	ADD	T4,.USTMP	;NEW VIRTUAL SIZE
	SKIPL	T2,.USVRT	;ALREADY VIRTUAL?
	TRNE	T2,777000	; OR ARE ALL PAGES IN CORE, SOME WITH A.A. OFF?
	TDZA	T2,T2		;THERE ARE SOME DISK ADDRESSES IN THE MAP
	PUSHJ	P,VRTSZ		;COMPUTE THE VIRTUAL SIZE OF THE JOB
	ADD	T2,.USTMP	;VIRTUAL MEMORY REQUIRED TO SATISFY THIS REQUEST
	CAIL	T3,-1(T4)	;TRYING TO EXCEED THIS USER'S VIRTUAL LIMIT?
	CAMLE	T2,VMCMAX##	; OR THE TOTAL AMOUNT OF SWAPPING SPACE AVAILABLE
				; TO VIRTUAL USER'S?
	POPJ	P,		;YES, ERROR RETURN
	ADDM	T2,VMTOTL##	;UPDATE THE TOTAL AMOUNT OF VM IN USE
	MOVNS	T2		;MINUS THE INCREASE IN VM IN USE
	ADDM	T2,VMCMAX##	;UPDATE THE AMOUNT OF VM LEFT FOR VM USERS
	MOVN	T2,.USTMP	;NUMBER OF PAGES OF SWAPPING SPACE REQUIRED
				; TO SATISFY THIS REQUEST
	ADDM	T2,VIRTAL##	;UPDATE THE NUMBER OF PAGES OF SWAPPING SPACE AVAILABLE
	JRST	VIRCH7		;GO ALLOCATE THE PAGES TO THE JOB
;HERE IF CAN GET PHYSICAL CORE
VIRCH3:	ADD	T4,.USTMP	;TOTAL NUMBER OF PAGES REQUESTED
	HLRZ	T2,.PDCVL##(W)	;USER'S CURRENT VIRTUAL LIMIT
	JUMPE	T2,VIRCH4	;IGNORE IF NONE SINCE PAGES CAN BE ALLOCATED PHYSICALLY
	CAILE	T4,(T2)		;TRYING TO EXCEED THE CVL?
	POPJ	P,		;YES, ERROR RETURN
VIRCH4:	PUSH	P,T1		;SAVE THE ARGUMENT TO THE CORE UUO
	CAILE	J,JOBMAX##	;A HIGH SEGMENT?
	JRST	VIRCH5		;YES, DO THINGS DIFFRENTLY

;HERE IF JOB HAS A NON-VIRTUAL HI SEG
	SKIPN	T2,.USREL	;CURRENT CONTIGUOSLY HIGHEST ADDRESS IN LOW SEG
	HLRZ	T2,R		;UPREL = 0 MEANS (R) REFLECTS THAT
	SUB	T1,T2		;AMOUNT OF INCREASE IN WORDS
	LSHC	T1,W2PLSH##	;INCREASE, CURRENT ALLOCATATION - 1, IN PAGES
	AOJA	T2,VIRCH6	;CURRENT NUMBER OF CONTIGUOUS PAGES
;HERE TO ALLOCATE CORE TO A NON-SHARABLE HI SEG
VIRCH5:	PUSH	P,J		;SAVE HIGH SEGMENT NUMBER
	MOVE	T3,T1		;CORE REQUESTED
	MOVE	J,.CPJOB##	;REQUESTING JOB JOB'S NUMBER
	DMOVE	T1,.USHSE	;COMPUTE CURRENT EXTENT OF THE HIGH SEGMENT
	ADDI	T3,1(T2)	;NEW HIGHEST ADDRESS IN THE HIGH SEGMENT
	POP	P,J		;RESTORE HIGH SEGMENT NUMBER
	LSHC	T1,W2PLSH##	;T1 = HIGHEST PAGE -1 IN CURRENT HIGH SEGMENT
				; T2 = UVA OF HIGH SEGMENT
	DPB	T2,JBYHSO##	;STORE PAGE NUMBER OF THE STARTING PAGE OF HIGH SEG
	SKIPE	T1		;CREATING A HIGH SEGMENT?
	AOSA	T2,T1		;NO, T2 = FIRST PAGE BEING ADDED TO HIGH SEGMENT
	MOVE	T1,T2		;YES, FIRST PAGE TO BE CREATED = HIGH SEGMENT ORIGIN
	LSH	T3,W2PLSH##	;NEW HIGHEST PAGE IN THE HIGH SEGMENT
	SUBM	T3,T1		;NUMBER OF PAGES OF INCREASE
	HRLZ	T3,T1		;NEW SIZE OR INCREASE IN SIZE OF THE HIGH SEG
	ADDM	T3,JBTSWP##(J)	;UPDATE THE NUMBER OF PAGES ALLOCATED TO THE HIGH SEG
VIRCH6:	SKIPE	T3,.USREL	;NUMBER OF PAGES ALLOCATED CONTIGUOUSLY TO THE LOW SEG
	MOVE	T3,(P)		;IF NON-ZERO, 
	CAIG	J,JOBMAX##	;DON'T CHANGE .UPREL IF ALLOCATING TO A HI SEG
	MOVEM	T3,.USREL	;STORE PREVIOUS VALUE OF UPREL
	SKIPE	.USVRT	;VIRTUAL?
	CAMG	T1,VMCMAX##	;YES, TRYING TO EXCEED MAX AMOUNT OF VM AVAILABLE
				; TO VM USERS?
	CAIA			;NO
	JRST	TPOPJ##		;YES, ERROR RETURN
	SKIPN	R		;CREATING A HIGH SEGMENT?
	MOVE	R,[PG.BDY##,,.VJDT]
	PUSHJ	P,PHYCRZ	;ALLOCATE PHYSICAL CORE
	MOVE	T1,(P)		;RESTORE ARGUMENT TO THE CORE UUO
	MOVEI	T3,-1		;AVOID SCAN OF MAP INSERTING PM.ZER
	MOVSI	T2,(UP.WHC)	;INDICATE WORKING SET HAS CHANGED
	IORM	T2,.USBTS	; ..
	JRST	VIRCH8		;CONTINUE
;HERE TO GIVE THE JOB EXTRA SPACE ON DSK (ALLOCATED BUT ZERO)
VIRCH7:	PUSH	P,T1		;SAVE ARGUMENT TO CORE UUO
	CAILE	J,JOBMAX##	;A HIGH SEGMENT?
	PUSHJ	P,HISIZ		;YES, COMPUTE CURRENT SIZE OF THE HIGH SEGMENT
				; AND SKIP THE NEXT INSTRUCTION
	PUSHJ	P,LOSIZ		;NO, COMPUTE THE CURRENT SIZE OF THE LOW SEGMENT
VIRCH8:	LSH	T1,W2PLSH##	;CONVERT HIGHEST ADR. REQUESTED TO HIGHEST
				; PAGE REQUESTED - 1
	LDB	T2,PCORSZ##	;CURRENT HIGHEST PAGE NUMBER
	CAILE	T1,(T2)		;INCREASING HIGHEST PAGE NUMBER?
	MOVE	T2,T1		;YES, NEW HIGHEST PAGE NUMBER
	SKIPN	R		;CREATING A HIGH SEGMENT?
	MOVE	R,[PG.BDY##,,.VJDT]
	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	DPB	T2,JBYLSS##	;NO, STORE NEW LOW SEGMENT SIZE - 1
	DPB	T2,[POINT 9,R,8];HIGHEST VIRTUAL ADDRESS IN THIS SEGMENT
	MOVEM	R,JBTADR##(J)	;STORE NEW HIGHEST VIRTUAL ADDRESS
	MOVEI	T2,PM.ZER	;INDICATE ALLOCATED BUT ZERO PAGES
	SUBI	T1,(T3)		;NUMBER OF PAGES OF INCREASE
	MOVEM	T1,.USTMP	;SAVE THAT
	JUMPL	T1,VIRC10	;JUMP IF CORE HAS ALREADY BEEN ALLOCATED
	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	TDZA	T4,T4		;NO, SEGMENT ORIGIN = 0
	LDB	T4,JBYHSO##	;YES, GET HIGH SEGMENT ORIGIN
	ADDI	T4,-1(T3)	;PAGE WHERE ALLOCATION STARTS
	HRRZS	T4		;CLEAR POSSIBLE -1 IN LEFT HALF
	PUSHJ	P,GMPTR		;GET A BYTE POINTER TO THE MAP
VIRCH9:	IDPB	T2,T4		;PM.ZER IN THE MAP
	SOJGE	T1,VIRCH9	;LOOP OVER ALL PAGES IN THE REQUEST
VIRC10:	PUSHJ	P,STVSIZ	;STORE NEW VIRTUAL SIZE FOR SYSDPY
	POP	P,T1		;RESTORE ARGUMENT
	CAILE	J,JOBMAX##	;A HIGH SEGMENT?
	JRST	VIRC12		;YES
	HLRZM	R,.USHVA	;FOR ADDRESS CHECKING AT INTERRUPT LEVEL
	CAME	J,.CPJOB##	;THE CURRENT JOB (A CORE UUO?)
	JRST	VIRC11		;NO
	MOVEM	R,.CPADR##	;YES, UPDATE SOFTWARE RELOCATION INFORMATION
	HLRZM	R,.CPREL##	; ..
VIRC11:	SKIPL	.USTMP		;ANY VIRTUAL PAGES ADDED TO THIS JOBS ADDRESSING SPACE?
	HLLOS	.USVRT		;YES, INDICATE THAT THE JOB IS VIRTUAL
	MOVEM	T1,.JDAT+JOBREL##	;STORE UPDATED JOBREL
	SKIPN	.USREL		;LOW SEGMENT NOW CONTIGUOUS?
	PJRST	FIXMJ1		;YES, CLEAR THE A.M. AND RETURN TO THE USER
	MOVEI	T2,MPGSIZ##(T1)	;SET TO FAKE OUT ICUPR
	MOVEM	T2,.USREL	; ..
	PUSHJ	P,ICUPRW	;CALCULATE THE NEW HIGHEST CONTIGUOUS
				; ADDRESS IN THE LOW SEGMENT
	PJRST	FIXMJ1		;CLEAR THE A.M. AND RETURN TO THE USER
VIRC12:	LDB	T4,JBYHSO##	;HIGH SEGMENT ORIGIN
	LSH	T4,P2WLSH##	;CONVERT TO ADDRESS
	ADD	T4,T1		;NEW HIGHEST ADDRESS IN THE HIGH SEGMENT
	HRRM	T4,JOBHRL##+.JDAT
	LDB	T4,JBYHSO##	;HIGH SEGMENT ORIGIN
	PUSHJ	P,MAPHI		;MAKE THE VESTIGUAL JOB DATA ADDRESSABLE
	PUSH	P,J		;SAVE THE HIGH SEGMENT NUMBER
	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER
	LSH	T1,W2PLSH##	;CONVERT HIGHEST ADDRESS TO HIGHEST PAGE - 1
	ADDI	T1,1		;HIGHEST PAGE
	DPB	T1,JBYHSS##	;STORE HIGHEST PAGE IN THE HIGH SEGMENT
	DPB	T1,[POINT 9,JBTVRT##(J),26] ;STORE HI-SEG SIZE FOR CONTROL T
	SKIPL	.USTMP		;WERE ALLOCATED BUT ZERO PAGES ADDED TO THIS SEG?
	HRROS	.USVRT		;YES, INDICATE THAT THE HIGH SEGMENT IS VIRTUAL
	CLRPGT	(0)		;CLEAR THE A.M. SO NEW MAPPING WILL BE IN AFFECT
	JRST	JPOPJ1##	;RESTORE HIGH SEGMENT NUMBER AND GIVE OK RETURN
;HERE TO DEALLOCATE STORAGE
VIRC13:	ADDI	T1,1		;HIGHEST ADDRESS REQUESTED + 1
	AOS	(P)		;DEALLOCATING CORE ALWAYS WINS
	TRNN	T1,-1		;IF 256K, REQUESTING 256K WIN
	POPJ	P,		;SKIP RETURN
	LSH	T1,W2PLSH##	;CONVERT TO HIGHEST PAGE REQUESTED
	PUSHJ	P,SAVE4##	;SAVE P1-P4
	LDB	P1,PCORSZ##	;HIGHEST PAGE IN SEGMENT RELATIVE TO SEGMENT ORIGIN
	SOS	P2,T1		;HIGHEST PAGE REQUESTED - 1
	LSH	T1,P2WLSH##	;HIGHEST ADDRESS - PAGSIZ
	HRLI	R,PG.BDY##(T1)	;NEW HIGHEST ADDRESS - 1
	ASH	T1,W2PLSH##	;HIGHEST PAGE WHICH WILL BE IN HE ADDRESSING SPACE
	PUSH	P,J		;SAVE SEGMENT NUMBER
	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	JRST	VIRC15		;NO
	ADDI	T1,1		;YES, HIGHEST PAGE + 1
	LDB	T2,JBYHSO##	;HIGH SEGMENT ORIGIN
	MOVE	J,.USJOB	;JOB WHICH OWNS THIS HIGH SEGMENT
	DPB	T1,JBYHSS##	;STORE THE NEW HIGH SEGMENT SIZE
	JUMPE	T1,VIRC14	;JUMP IF HIGH SEGMENT IS BEING DESTROYED
	ADDI	T1,(T2)		;HIGHEST PAGE IN THE HIGH SEGMENT
	LSH	T1,P2WLSH##	;HIGHEST ADDRESS + 1
	SUBI	T1,1		;HIGHEST ADDRESS IN THE HIGH SEGMENT
VIRC14:	HRRM	T1,.JDAT+JOBHRL##
	ADD	P1,T2		;FIRST PAGE TO DELETE
	ADD	P2,T2		;LAST PAGE TO DELETE
	SETOB	T1,T2		;DELETE ONLY SPECIFIED HIGH SEGMENT PAGES
	JRST	VIRC17		;GO DELETE PAGES
VIRC15:	DPB	T1,JBYLSS##	;STORE NEW LOW SEGMENT SIZE
	HLRZM	R,.USHVA	;FOR ADDRESS CHECKING AT INTERRUPT LEVEL
	CAME	J,.CPJOB##	;CURRENT JOB?
	JRST	VIRC16		;NO, CORE COMMAND, DON'T CHANGE CURRENT
				; JOB'S SOFTWARE RELOCATION INFORMATION
	MOVEM	R,.CPADR##	;YES, STORE NEW PROTECTION,,RELOCATION
	HLRZM	R,.CPREL##	;STORE NEW LOW SEGMENT SIZE FOR ADDRESS CHECKING
VIRC16:	HLRZM	R,.JDAT+JOBREL## ;UPDATE JOBREL FOR THE PROGRAM'S BENEFIT
	SETOB	T1,T2		;ASSUME NO HIGH SEGMENT
	SKIPE	JBTSGN##(J)	;IS THERE A HIGH SEGMENT?
	DMOVE	T1,.USHSE	;YES, CALCULATE ITS EXTENT
VIRC17:	LSHC	T1,W2PLSH##	;STARTING PAGE NO.,,ENDING PAGE NO. OF HIGH SEG
	HRRZ	P4,T1		;ENDING PAGE OF HIGH SEGMENT OR -1
	HRRZ	P3,T2		;STARTING PAGE OF HIGH SEGMENT OR -1
VIRC18:	SKIPGE	T1,P1		;INCREASING SIZE?
	JRST	VIRC21		;NO
	PUSHJ	P,GTPME		;GET THE CURRENT CONTENTS OF THE MAP (ALSO
				; CALCULATE A BYTE POINTER TO THE MAP)
VIRC19:	CAMN	P1,P2		;REACHED TOP PAGE REQUESTED?
	JRST	VIRC21		;YES
	JUMPN	T2,VIRC20	;NO, MAP CONTENTS = 0? JUMP IF A PAGE TO DELETE
	SUBI	T4,1		;BACK UP BYTE POINTER
IFE FTKLP,<
	ILDB	T2,T4		;GET CONTENTS OF NEXT MAP SLOT
>
IFN FTKLP,<
	LDB	T2,T4
>
	SOJA	P1,VIRC19	;LOOP OVER ALL PAGES ENCOMPASSED BY THE ARGUMENT
VIRC20:	CAIL	P1,(P3)		;A HIGH SEGMENT PAGE?
	CAILE	P1,(P4)		; ..
	SKIPA	T1,P1		;NO, DELETE THE PAGE
	SOJA	P1,VIRC18	;YES, LOOP OVER ALL PAGES
IFN FTPEEKSPY,<
	PUSHJ	P,TSSPT		;IF A SPY PAGE
	  CAIA			;NOT
	SOJA	P1,VIRC18	; NEXT PAGE
>
	PUSHJ	P,DLTPAG	;DELETE THE PAGE FROM THE JOB'S ADDRESSING SPACE
	PUSHJ	P,DCVMT		;DECREMENT THE COUNT OF VIRTUAL PAGES IN-USE
	MOVSI	T1,(UP.WHC)	;WORKING SET HAS CHANGED BIT
	IORM	T1,.USBTS	;LIGHT IT FOR THE PAGE FAULT HANDLER
	SOJA	P1,VIRC18	;AND LOOP OVER ALL PAGES TO BE DELETED
VIRC21:	CLRPGT	(0)		;CLEAR THE A.M. SO THE NEW MAPPING WILL BE IN AFFECT
	POP	P,J		;RESTORE SEGMENT NUMBER
	MOVEM	R,JBTADR##(J)	;STORE SEGMENT PROTECTION,,ADDRESS
	HLRE	T1,R		;HIGHEST VIRTUAL ADDRESS WITHIN SEGMENT
	AOJE	T1,VIRC24	;IF -1, SEGMENT HAS NO CORE
	CAILE	J,JOBMAX##	;A HIGH SEGMENT?
	PJRST	SETVRT		;YES, ADJUST NUMBERS AND RETURN TO THE USER
	HRRZ	T1,.JDAT+JOBDDT## ;STARTING ADDRESS OF DDT
	LSH	T1,W2PLSH##	;CONVERT TO PAGE NUMBER
	PUSHJ	P,GTPME		;IS THE FIRST PAGE OF DDT STILL AROUND?
	JUMPN	T2,VIRC22	;JUMP IF SO
	SETZB	T1,.JDAT+JOBDDT## ;DDT WAS DELETED, ZERO JOBDDT
	CAMN	J,.CPJOB##	;CURRENT JOB?
	MOVEM	T1,USRDDT##	;YES, ALSO ZERO COPY IN USRDDT
VIRC22:	HRRZ	T1,.JDAT+.JBPFH## ;ADDRESS OF CURRENT JOB'S PFH
	PUSHJ	P,FLTST		;IS THAT STILL THERE?
	  CAIA			;NO
	JUMPN	T1,VIRC23	;YES
	SETZM	.USTMC		;ZERO TIME CONSTANT
	SETZM	.USTMI		;ZERO TIME INCREMENT
	SETZM	.JDAT+.JBPFH##	;ZERO THE ADDRESS OF PFH
	MOVSI	T1,(UP.MGP)	;MONITOR GOT PFH BIT
	ANDCAM	T1,.USBTS	;ZERO THAT
VIRC23:	SETZM	.USREL		;CORE IMAGE IS NOW CONTIGUOUS
	SETZM	.USMEM		;THERE ARE NO PAGES ABOVE UPREL
	PJRST	SETVRT		;ADJUST NUMBERS AND RETURN
VIRC24:	SETZB	R,JBTADR##(J)	;INDICATE SEGMENT NO LONGER HAS ANY CORE
	CAILE	J,JOBMAX##	;A HIGH SEGMENT?
	PJRST	SETVRT		;YES, ADJUST NUMBERS AND RETURN
	SETZM	.CPADR##	;ZERO CURRENT AMOUNT OF CORE ASSIGNED SO  CLOCK IRP.
				; WON'T TRY TO STORE IN A NON-EXISTANT JOB DATA AREA
	HRRZ	T1,JBTUPM##(J)	;GET PAGE MAP PAGE # FOR GVPAGS
	HLLZS	JBTUPM##(J)	;CLEAR THE PAGE MAP POINTER
	MOVEI	T2,UPMPSZ##+IFN FTKLP,<1> ;ACCOUNT FOR UPMP IN AMOUNT OF SWAPPING SPACE FREE
	ADDM	T2,VIRTAL##
	SETZM	JBTVRT##(J)	;JOB ISN'T VIRTUAL IF IT HAS NO CORE
	PJRST	GVPAGS##	;RETURN THE UPMP TO FREE STORAGE
;SUBROUTINE TO ALLOCATE PHYSICAL CORE
;ENTER  T1=HOW MANY PAGES, T2=STARTING VIRT PAGE NUMBER
;ALWAYS EXITS CPOPJ
PHYCRZ:	SOS	(P)		;INSDSK, INSPAG RETURN CPOPJ1
	PUSHJ	P,SAVE2##	;SAVE P1,P2
	MOVE	P1,T2		;1ST VIRT PAGE
	MOVN	P2,T1		;NUMBER OF PAGES
	ADDM	P2,VIRTAL##	;UPDATE VIRTAL
	HRROI	T4,777000
	TDNE	T4,.USVRT	;VIRTUAL?
	ADDM	P2,VMCMAX##	;YES, DECREMENT AMOUNT OF VM AVAILABLE
	MOVNS	T3,P2		;+N
	TDNE	T4,.USVRT	;VIRTUAL?
	ADDM	P2,VMTOTL##	;YES, INCREMENT AMOUNT OF VM IN USE
	PUSHJ	P,FRDCR##	;ENOUGH CORE IN CORE FOR THE REQUEST?
	  JRST	PHYCO2		;NO, HAVE TO EXPAND
	SE1ENT			;MUST BE IN SECTION 1 TO REFERENCE PAGTAB
	PUSH	P,J		;SAVE J
	MOVE	J,.USJOB	;LOW SEGMENT NUMBER
	PUSHJ	P,SCPAGS##	;FIND THE END OF HIS PAGTAB CHAIN
	MOVE	T2,P2
	PUSHJ	P,ADPAGS##	;PUT THE NEW PAGES ON THE END
	EXCH	T1,P1		;GO BACK TO THE START
	POP	P,J		;RESTORE J
PHYCO1:	PUSHJ	P,INSPAG	;PUT THE PAGE IN HIS MAP
	PUSHJ	P,ZERPAG	;ZERO THE CORE
	SSX	P1,MDSEC2	;PAGTAB SECTION
	SKIPGE	P1,PAGTAB(P1)	;GO TO NEXT PAGE
	STOPCD	.+1,DEBUG,PEW,	;++PAGTAB ENTRY WRONG
	PUSHJ	P,ICUPR		;INCREMENT UPREL
	SOSLE	P2		;MORE TO DO?
	AOJA	T1,PHYCO1	;YES, PUT NEXT PAGE IN MAP
	HRL	P1,T1		;DONE, HIGHEST PAGE IN LH(P1)
	PJRST	FIXADR		;FIX UP RELEVENT NUMBERS AND RETURN

;HERE IF NOT ENOUGH CORE IN CORE
PHYCO2:	MOVE	T1,P1		;FIRST PAGE
	MOVE	P1,P2		;NUMBER OF PAGES
PHYCO3:	PUSHJ	P,INSDSK	;SET UP SO EXPAND WILL "CREATE" PAGE
	PUSHJ	P,ICUPR		;INCREMENT UPREL
	SOSLE	P1		;DONE?
	AOJA	T1,PHYCO3	;NO, DO NEXT PAGE
	LDB	T2,JBYHSO##	;YES, SET UP RELEVENT NUMBERS
	CAILE	J,JOBMAX##	; CALL XPANDP TO BRING THE JOB BACK
	SUB	T1,T2		; IN THE RIGHT AMOUNT OF CORE
	HRL	P2,T1
	PJRST	FIXDSK		;AND RETURN AFTER JOB IS BACK IN CORE
;SUBROUTINE TO SET UP .UPVRT ACCORDING TO THE PAGE INVOLVED
;ENTER J=LOW SEG NUMBER, T1=PAGE
JSTVRT:	PUSHJ	P,TPAHS		;HIGH-SEG PAGE?
	  SKIPG	T2,JBTSGN##(J)	;YES, IS THERE A HI SEG?(SHOULD SKIP)
	PJRST	SETVRT		;LOW SEG- CALL SETVRT
	PUSH	P,J		;HIGH SEG - SAVE J
	MOVE	J,T2		;SET J TO HI SEG NUMBER
	PUSHJ	P,SETVRT	;CALL SETVRT
	PJRST	JPOPJ##		;RESTORE J AND RETURN

;SUBROUTINE TO SET UP .UPVRT
;ENTER J=SEGMENT NUMBER
SETVRT:	PUSHJ	P,SEGSIZ##	;GET PHYSICAL SIZE OF THIS SEG
	CAIG	J,JOBMAX##
	JRST	STVRT1
	LDB	T1,PCORSZ##
	MOVSI	T3,(HRROS)
	JRST	STVRT2
STVRT1:	SKIPN	T1,.USREL	;NUMBER OF CONTIGUOUS PAGES
	HLRZ	T1,R		;IF .UPREL = 0, ALL PAGES ARE CONTIGUOUS
	LSH	T1,W2PLSH##	;CONVERT TO NUMBER OF PAGES
	ADD	T1,.USMEM	;TOTAL NUMBER OF PAGES, BOTH PHYSICAL AND VIRTUAL
	ADDI	T1,UPMPSZ##	;LOW SEG, ACCOUNT FOR UPMP
	MOVSI	T3,(HLLOS)	;WORK WITH RH(UPVRT)
STVRT2:	SKIPE	R
	CAIN	T2,1(T1)	;PHYS SIZE = VIRTUAL SIZE?
	TLC	T3,30000	;YES, CONVERT HXXOS TO HXXZS
	HRRI	T3,.USVRT
	MOVE	T1,.USVRT	;SAVE CURRENT UPVRT
	TRZ	T1,777		;CLEAR .UPANA BITS FROM .UPVRT
	XCT	T3		;SET/CLEAR HALF OF .UPVRT
	MOVE	T3,.USANA
	IORB	T3,.USVRT
	TRZ	T3,777
	SKIPE	T3		;IF .UPVRT DIDN'T CHANGE
	JUMPN	T1,STVSIZ	; FROM 0 TO NON-0 OR VICE-VERSA
	SKIPN	T3
	JUMPE	T1,STVSIZ	;RETURN
	PUSHJ	P,VRTSZ		;YES, GET CURRENT TOTAL VIRT SIZE OF JOB
	SKIPE	T3		;IF WENT FROM 0 TI NON-0
	MOVNS	T2		; DECREASE VMCMAX
	ADDM	T2,VMCMAX##	;INCR/DECR VMCMAX
	MOVNS	T2
	ADDM	T2,VMTOTL##
STVSIZ::PUSH	P,J
	MOVE	J,.USJOB
	PUSHJ	P,VMSIZE
	CAIE	T1,0		;"CORE 0?"
	SUBI	T1,UPMPSZ##	;NO, DISCOUNT UPMPSZ
	DPB	T2,[POINT 9,T1,26]	;STORE NEW LO-SEG VIRT SIZE
	HRRM	T1,JBTVRT##(J)	;STORE NEW HI-SEG VIRT SIZE
	JRST	JPOPJ##		;AND RETURN
;SUBROUTINE TO ENSURE THAT THERE ARE NO MAP ENTRIES
;ENTER T1=NEW HIGHEST ADR, T2=CURRENT HIGHEST ADR
;EXITS CPOPJ IF SOME PAGE EXISTS IN THE RANGE, CPOPJ1 IF OK
;PRESERVES ALL ACS
;NOTE THAT THIS ROUTINE CANT BE CALLED FOR STARTING ADR AT PAGE 0
CKNZW::	PUSHJ	P,SAVT##	;SAVE T1-T4
	ADDI	T1,1		;CONVERT TO HIGHEST PAGE
	ADDI	T2,1		; ..
	LSHC	T1,W2PLSH##	; ..
	JRST	CKNZ1		;CHECK THAT RANGE OF PAGES

;ENTER HERE IF THE ARGS ARE IN PAGES
CKNZP::	PUSHJ	P,SAVT##	;SAVE T1-T4
CKNZ1:	MOVEI	T4,-1(T2)	;STARTING PAGE NUMBER - 1 FOR ILDB
	PUSHJ	P,GMPTR		;GET A BYTE POINTER TO THE MAP
	SUB	T1,T2		;NUMBER OF PAGES TO CHECK
CKNZ2:	ILDB	T2,T4		;CONTENTS OF THE MAP SLOT
	JUMPN	T2,CPOPJ##	;LOSE IF NON-ZERO
	SOJG	T1,CKNZ2	;LOOP OVER ALL NEW PAGES
	PJRST	CPOPJ1##	;ALL ARE ZERO, WIN RETURN

;SUBROUTINE TO DETERMINE IF A RANGE OF ADDRESSES OVERLAP THE HIGH
;SEGMENT CALLING SEQUENCE:
;	MOVE	T3,HIGHEST ADDRESS,,STARTING ADDRESS
;	PUSHJ	P,CKHSO	;SEE IF ADDRESSES OVERLAP THE HIGH SEGMENT
;RETURNS CPOPJ IF THE ADDRESSES OVERLAP THE HIGH SEGMENT,CPOPJ1 IF THEY
;DON'T . PRESERVES ALL AC'S

CKHSO:	PUSHJ	P,SAVE2##	;SAVE WORKING AC'S
	HLRZ	P1,T3		;HIGHEST ADDRESS IN THE RANGE
	HRRZ	P2,T3		;STARTING ADDRESS
	CAML	P1,.USHSS	;HIGHEST ADDRESS BELOW THE START OF THE HISEG?
	CAMLE	P2,.USHSE	;STARTING ADDRESS ABOVE THE END OF THE HISEG?
	AOS	(P)		;YES, ALL IS GOODNESS
	POPJ	P,		;RETURN
;SUBROUTINE TO ZERO PAGES ALLOCATED TO A JOB (LOW SEGMENT)
; WHEN THE JOB HAS A NON-SHARABLE HIGH SEGMENT
; CALLED ONLY ON A SWAP-IN
;CALLING SEQUENCE:
;	MOVE	J,SEGMENT NUMBER
;	PUSHJ	P,ZERHGH
;	...	RETURNS HERE (PAGES HAVE BEEN ZEROED)
;	...	RETURNS	HERE IF PAGES CAN BE ZEROED IN TRADITIONAL FASHION
;		T1=NUMBER OF WORDS TO ZERO
;MUST BE CALLED IN SECTION 1
ZERHGH::CAILE	J,JOBMAX##	;A HIGH SEGMENT?
	JRST	CPOPJ1##	;YES, KISER CAN ZERO THE PAGES
	PUSH	P,J		;SAVE THE JOB NUMBER
	SKIPLE	J,JBTSGN##(J)	;DOES THIS JOB HAVE A HIGH SEGMENT?
	TLNE	J,SHRSEG	;AND IS IT NON-SHARABLE?
	JRST	JPOPJ1##	;NO, KISER CAN ZERO THE PAGES
	PUSH	P,T2		;SAVE HIGHEST ADDRESS ALLOCATED
	HRRZS	J		;ZERO JUNK FOR SEGSIZ (MAY BE IN SECTION 1)
	PUSHJ	P,SEGSIZ##	;GET THE SIZE OF THE HIGH SEGMENT
	EXCH	T2,(P)		;T2 = HIGHEST ADDRESS ALLOCATED
	SUB	T2,(P)		;T2 = HIGHEST ADDRESS IN THE LOW SEG
	LSH	T1,W2PLSH##	;NUMBER OF PAGES TO ZERO
	MOVEM	T1,(P)		;SAVE THAT
	MOVE	J,-1(P)		;RESTORE THE JOB NUMBER
	PUSHJ	P,SNPAGS##	;FIND THE FIRST PAGE TO ZERO
	POP	P,T3		;RESTORE NUMBER OF PAGES TO ZERO
ZERHG1:	MOVE	T2,T1		;SETUP ARGUMENT TO ZPAGE
	PUSHJ	P,ZPAGE		;ZERO THE PAGE
	SSX	T1,MDSEC2	;PAGTAB SECTION
	HRRZ	T1,PAGTAB(T1)	;NEXT PAGE TO ZERO
	SOJG	T3,ZERHG1	;LOOP OVER ALL PAGES
	JRST	JPOPJ##		;INDICATE PAGES HAVE BEEN ZEROED
IFN FTIPCF!FTEXE,<
	SUBTTL	IPCF INTERFACE
;SUBROUTINE TO REMOVE A PAGE FROM A JOBS ADDRESS SPACE
;ENTER WITH T1= VIRTUAL PAGE NUMBER, J= JOB NUMBER (JOB ADDRESSABLE)
;ENTER ALSO WITH P3=ADDRESS OF TARGET IPCF PACKET, IF IPCF
;OR P3=0 IF NOT (COMCON).  THIS IS SO WE KNOW TO CALL MIGRATE WAITING
;ROUTINES IF P3 =/= 0
;RETURNS CPOPJ IF PAGE NOT IN JOBS ADDRESSING SPACE
;RETURNS CPOPJ1 NORMALLY, T2=PHYSICAL PAGE NUMBER IF PAGE IN CORE,
; OR T2 = BIT 18 + DSK ADDRESS IF PAGE IS ON DSK
;ON NORMAL RETURN, THE IPCF INTERLOCK WILL BE HELD FOR THE TARGET
;JOB IF P3 =/= 0 ON ENTRY.
IPCRMV::JUMPE	T1,CPOPJ##	;CANT REMOVE PAGE 0
	CAIG	T1,HLGPNO	; TOO HIGH A PAGE NUMBER
	PUSHJ	P,TPSHS
	  POPJ	P,		; OR A PAGE IN SHARABLE HI SEG
	PUSHJ	P,GTPME		;GET MAP ENTRY
	JUMPE	T2,CPOPJ##	;ERROR IF PAGE NOT ALLOCATED
	CAIN	T2,PM.ZER	; OR IF ALLOCATED BUT ZERO
	POPJ	P,
IFN FTPEEKSPY,<
	PUSHJ	P,TSSPT		;ERROR IF A SPY PAGE
	  CAIA
	POPJ	P,
>
IFN	FTDHIA,<
	SKIPE	P3
	  PUSHJ	P,IPMCHK##	;CHECK MIGRATE STUFF IF IPCF
>
IFN FTMP,<
	PUSHJ	P,GGVMM##	;GET MM RESOURCE
>
	PUSHJ	P,RMVPAG	;OK, REMOVE PAGE FROM MAP
	  TROA	T2,400000	;DISK ADR - LIGHT BIT 18
	PUSHJ	P,[SE1ENT
		   MOVSI T1,(UP.WHC)
		   IORM T1,.USBTS ;WORKING SET CHANGED
		   MOVSI T1,IPCBIT
  		   PUSH P,T2
		   SSX T2,MDSEC2;SET SECTION NUMBER
		   IORM T1,PAGTAB(T2) ;IPCF PAGE IN NO MAP
	IFN FTKL10&FTMP,<SETOM SAVCTL##> ;SWEEP CACHE
		   JRST T2POPJ##]
	LDB	T1,[POINT 9,R,8] ;GET NEW SIZE
	DPB	T1,JBYLSS##	;SAVE IN JBTUPM
	TRNE	T2,400000
	PUSHJ	P,DCVMT		;ADJUST VM COUNTERS
	PUSH	P,T2
	PUSHJ	P,STVSIZ
	POP	P,T2
	PJRST	FIXAD1		; AND SKIP-RETURN

;SUBROUTINE TO PAGE OUT A PAGE FOR IPCF
;ENTER J=JOB NO JOB ADDRESSABLE) T2=PHYS PAGE OR BIT 18+DSK ADR
;EXIT CPOPJ IF NO SWAPPING SPACE AVAILABLE OR IO ERROR
;EXIT CPOPJ1 IF ALL OK, T2=DSK ADDRESS OF PAGE
IPCPAG::TRNE	T2,400000	;DISK ADR?
	PJRST	CPOPJ1##	;YES, ITS ALREADY OUT
	PUSHJ	P,SAVE2##	;NO, SAVE SOME ACS
	PUSH	P,U
IFN FTMP,<
	PUSHJ	P,UPMM##	;GUARD AGAINST RACES
>
	PUSHJ	P,IPCSSP	;ALLOCATE SWAPPING SPACE AND MAKE A SWPLST ENTRY
	PUSHJ	P,PGWAIT	;START THE IO AND WAIT FOR IT
	  SOS	-1(P)		;ERROR - NON SKIP RETURN
	HRRZ	P1,T2		;SWPLST INDEX
IFN FTIPCF,<
	PUSHJ	P,GVIPCP	;RETURN THE PAGE IF NOT ALREADY RETURNED
>;END FTIPCF
IFN FTMP,<
	PUSHJ	P,DWNMM##	;RETURN MM
>
				; BY THE SWAPPER
	MOVE	T2,U		;GET DSK ADR IN T2 (+ BIT 18)
	PJRST	UPOPJ1##	;AND TAKE SKIP-RETURN

;SUBROUTINE TO ALLOCATE SWAPPING SPACE TO PAGE OUT AN IPCF PAGE
; RETURNS CPOPJ ALWAYS, T1 SETUP TO MAKE A SWPLST ENTRY

IPCSSP::PUSHJ	P,SAVE1##	;SAVE A WORKING AC
	SE1ENT			;MUST BE IN SECTION 1 TO ADDRESS MEMTAB
	MOVSI	P1,LOKPHB	;INDICATE SWAPPING OUT THIS PAGE
	IORM	P1,@[IW MDSEC2,PAGTAB(T2)] ;SO IT GETS LEFT ALONE BY LOKCON
	MOVE	P1,T2
	SKIPA	U,[PG.SLO+1]	;GET 1 PAGE ON SLOW SWAPPING MEDIUM
IPCSS1:	MOVEI	U,1
	PUSHJ	P,SWPSPC##
	  JRST	IPCSS1		;CANT GET ANY SPACE - ERROR RETURN
	TLO	T1,(MT.LEF)	;INDICATE LAST PAGE
	SSX	P1,MDSEC2	;SET SECTION NUMBER
	MOVEM	T1,MEMTAB(P1)	;SAVE DSK ADR IN MEMTAB
	MOVEI	U,400000(T1)	;DSK ADR (+ BIT 18)
	HRRZ	T1,P1		;CORE ADR
	LSH	T1,11		;MAKE SWPLST ENTRY
	TDO	T1,[SL.DIO+SL.IPC+1]	;OUTPUT 1 PAGE
	POPJ	P,		;RETURN
>	;END FTIPCF!FTEXE
IFN FTIPCF!FTEXE,<
;SUBROUTINE TO INSERT A PAGE INTO A JOBS ADDRESS SPACE
;ENTER J=JOB NUMBER (JOB ADDRESSABLE)
; T1=VIRTUAL PAGE NUMBER, T2=PHYSICAL PAGE NUMBER OR BIT 18 + DSK ADDRESS
;EXIT CPOPJ IF PAGE ALREADY EXISTS OR ERROR (NEW SIZE TOO BIG, IO ERROR)
;EXIT CPOPJ1 NORMALLY
IPCINS::PUSHJ	P,SAVE1##	;SAVE SOME ACS
	MOVE	P1,T2		;REMEMBER ADR
	HRL	P1,T1
	PUSHJ	P,GTPME		;GET MAP ENTRY
	JUMPN	T2,RTZER##	;ERROR IF PAGE ALREADY EXISTS
	MOVEI	T3,1		;ONE PAGE OF INCREASE
IFN FTMP,<
	PUSHJ	P,GGVMM##	;MUST OWN MM RESOURCE HERE
>
	PUSHJ	P,SZCHK		;TRYING TO GET TO BIG?
	  TLO	P1,400000	;YES
	HLRZ	T3,.PDCVL##(W)	;GET CURRENT VIRTUAL LIMIT
	CAIL	T1,UPMPSZ##(T3)	;TRYING TO GET TO BIG VIRTUALLY?
	JUMPN	T3,RTZER##	;YES
	HLRZ	T1,P1
	TRZ	T1,400000
	TRZN	P1,400000	;INSERTING A DSK ADR?
	JRST	IPCI3A		;NO

;HERE IF PAGE ON DSK
	SKIPE	.JDAT+.JBPFH##	;JOB HAVE A FAULT HANDLER?
	JRST	IPCI1A		;YES, JUST PUT THE DSK ADDRESS IN THE MAP
	JUMPGE	P1,IPCIN2	;NO, HAVE TO SWAP IN THE PAGE
	JUMPE	T3,RTZER##	;ERROR IF CAN'T GO VIRTUAL
IPCI1A:	DPB	P1,T4		;SAVE DSK ADR IN MAP
	PUSHJ	P,WSBIT		;YES, JUST MARK THE PAGE IN AABTAB
	IORM	T2,AABTAB(T4)	; AND LEACE IT ON THE DSK
	JRST	IPCIN5		;FINISH UP

;HERE TO SWAP THE PAGE IN SO CAN PUT IT IN THE MAP
IPCIN2:	PUSH	P,T1		;VIRTUAL PAGE NUMBER
	SKIPG	BIGHOL##	;IS THERE A FREE PAGE IN CORE?
	JRST	IPCIN3		;NO
	PUSHJ	P,SCPAGS##	;YES, GET END OF PAGTAB CHAIN
	MOVEI	T2,1
	PUSHJ	P,ADPAGS##	;AND INSERT ANOTHER PAGE THERE
	SSX	T1,MDSEC2	;SECTION WHICH CONTAINS MEMTAB
	PUSHJ	P,[SE1ENT	;ENTER SECTION 1
		   HRRZM P1,MEMTAB(T1) ;SAVE DSK ADR IN MEMTAB
		   POPJ P,]	;RETURN
	HRRZ	P1,T1		;PHYSICAL PAGE NUMBER IN P1
	MOVE	T1,(P)		;GET VIRTUAL PAGE NUMBER
	PUSHJ	P,INSPAG	;PUT THE NEW PAGE IN THE MAP
	MOVE	T1,P1		;RESTORE PHYSICAL PAGE NUMBER
	LSH	T1,11		;MAKE A SWPLST ENTRY
	TDO	T1,[SL.IPC+1]	; 1 PAGE, IPC-TYPE
	PUSHJ	P,PAGEIT	;SWAP IN THE PAGE
	  JRST	IPCIN6		;IO ERROR - RETURN
	POP	P,T1		;OK, RESTORE VIRT PAGE NO
	PUSHJ	P,GTPME		;SET UP POINTER TO MAP SLOT
	JRST	IPCIN4		;AND CONTINUE
;HERE WHEN NOT ENOUGH CORE IN CORE
IPCIN3:	DPB	P1,T4		;SAVE DSK ADR IN MAP
	MOVE	T1,(P)		;VIRTUAL PAGE NUMBER
	PUSHJ	P,INSDSK	;PUT DSK ADR IN MAP
	LDB	T1,IMGIN##	;SIZE OF JOB
	ADDI	T1,1		;IT WILL GROW BY 1 PAGE
	PUSHJ	P,XPANDP##	;GET THE PAGE INTO CORE
IFN FTMP,<
	PUSHJ	P,DIFMM##	;GIVE UP MM
>
	PUSHJ	P,WSCHED##	;WAIT FOR THE SWAP TO HAPPEN
IFN FTMP,<
	PUSHJ	P,UIFMM##	;RESTORE MM
>
	POP	P,T1		;RESTORE VIRT PAGE NO.
	JRST	IPCIN5		;AND FINISH UP

;HERE WHEN PAGE IS IN CORE
IPCI3A:	JUMPL	P1,RTZER##	;LOSE IF PHYSICAL LIMIT EXECEEDED
	PUSHJ	P,INSPAG	;INSERT THE PAGE IN THE JOB'S MAP
	SE1ENT			;ENTER SECTION 1
	LDB	T3,JBYLSA##	;FIRST PAGE IN THE LOW SEGMENT
	SSX	T3,MDSEC2	;TO ADDRESS PAGTAB SECTION
	MOVE	T2,PAGTAB(T3)	;ADD THIS PAGE TO THE FRONT
	HRRM	P1,PAGTAB(T3)	; OF THIS JOB'S PAGTAB LIST
	SSX	P1,MDSEC2	;PAGTAB SECTION
	HRRZM	T2,PAGTAB(P1)	;(CLEAR IPCBIT IN LH)
	SOS	%CNPIC##	;DECREMENT COUNT OF IPCF PAGES IN CORE
IPCIN4:	MOVSI	T2,(UP.WHC)	;WORKING SET HAS CHANGED
	IORM	T2,.USBTS	;TURN THAT ON FOR THE PAGE FAULT HANDLER
IPCIN5:	PUSHJ	P,ICUPR		;BUMP UPREL IF THIS PAGE CONTIGUOUS
	HRL	P1,T1		;FIX UP JBTADR, JOBREL, ETC
	PUSHJ	P,SETVRT	;ADJUST COUNTS, ETC.
	PJRST	FIXADR		; AND TAKE SKIP RETURN TO USER

;HERE ON A PAGING IO ERROR
IPCIN6:	HRRZ	P1,T2		;INDEX INTO SWPLST
	PUSHJ	P,DLTSLX	;ZAP THE SWPLST ENTRY
	POP	P,T1		;RESTORE THE VIRTUAL PAGE NUMBER
	PJRST	DLTPAG		;RETURN THE PAGE AND NON-SKIP RETURN
;SUBROUTINE TO DELETE A PAGE FROM CORE OR DISK
;ENTER T2=ADR OF PAGE (BIT 18 ON IF DSK)
;ALWAYS RETURNS CPOPJ
IPCDEL::
IFN FTMP,<
	PUSHJ	P,GGVMM##	;GET THE MM RESOURCE
>
	TRZE	T2,400000	;DSK?
	JRST	DLTPGD		;YES
	MOVSI	T1,IPCBIT
	ANDCAM	T1,PAGTAB(T2)
	JRST	DLTPGC		;NO

;SUBROUTINE TO RETURN IPC PAGES TO THE FREE CORE LIST
;CALLING SEQUENCE:
;	PUSHJ	P,GVIPCP
;ALWAYS RETURNS CPOPJ

GVIPCP::SKIPN	IPCCNT##	;ANY IPCF PAGES WHICH HAVE PAGING OUTPUT DONE?
	POPJ	P,		;NO, RETURN
	PUSHJ	P,SAVE2##	;SAVE SOME WORKING ACS
GVIPC0:	MOVEI	P1,SWPLST##	;START LOOKING AT THE BEGINNING OF SWPLST
	MOVE	P2,SLECNT##	;NUMBER OF ENTRIES IN SWPLST
GVIPC1:	SKIPE	T1,(P1)		;A NON-ZERO SWPLST ENTRY?
	TLNN	T1,(SL.IOD)	;YES, IS I/O DONE FOR THIS SWPLST ENTRY?
GVIPC2:	AOJA	P1,GVIPC1	;NO, LOOK AT THE NEXT SWPLST ENTRY
	TLZE	T1,(SL.IPC)	;AN IPCF PAGE? (CLEAR SL.IPC SO THIS PAGE
				; WON'T BE SEEN AGAIN)
	TLNN	T1,(SL.DIO)	;AND WAS IT BEING PAGED OUT?
	JRST	GVIPC3		;NO, LOOK AT THE NEXT SWPLST ENTRY
	PUSH	P,T1		;SAVE SWPLST INDEX
	SUBI	P1,SWPLST	;DLTSLE WANTS RELATIVE INDEX
	PUSHJ	P,DLTSLX	;REMOVE THE SWPLST ENTRY
	POP	P,T1		;RESTORE SWPLST INDEX
	LDB	T1,[POINT 13,T1,26]
	MOVSI	P1,IPCBIT+LOKPHB
	PUSHJ	P,[SE1ENT	;ENTER SECTION 1
		   SPUSH T1	;SAVE LEFT HALF OF T1
		   SSX	T1,MDSEC2 ;SECTION NUMBER
		   ANDCAM P1,PAGTAB(T1) ;NO LONGER AN IPCF PAGE
		   SPOP T1	;RESTORE LEFT HALF OF T1
		   POPJ P,]
	PUSHJ	P,GVPAGS##	;RETURN THE PAGE TO THE FREE CORE LIST
	SOSG	IPCCNT##	;DECREMENT THE COUNT OF IPCF PAGES PAGED OUT
	POPJ	P,		;RETURN IF NO MORE
	JRST	GVIPC0		;ELSE, LOOK FOR THE NEXT ONE
GVIPC3:	SOJG	P2,GVIPC2	;LOOK AT THE NEXT SWPLST ENTRY
	STOPCD	GVIPC4,DEBUG,IPN,	;++IPC PAGE NOT FOUND
GVIPC4:	SETZM	IPCCNT##	;ZERO IPCCNT TO AVOID A LOOP
	POPJ	P,		;AND RETURN
>	;END FTIPCF!FTEXE
	SUBTTL	SEGCON

;SUBROUTINE TO RETURN CORE ALLOCATED TO A NON-SHARABLE HIGH SEGMENT
;ENTER WITH JOB NUMBER -2(P), PHYSICAL SEGMENT SIZE -1(P)
KCOREV::LDB	T1,IMGIN##	;SIZE OF THE SEGMENT
	JUMPN	T1,KCOREH##	;IF NON-ZERO, ITS SHARABLE AND SEGCON CAN
				; GIVE BACK THE PAGES
	MOVE	T1,J		;SAVE HIGH SEGMENT NUMBER
	MOVE	J,-2(P)		;GET THE JOB NUMBER
	PUSHJ	P,SVEUB##	;SETUP THE UBR TO POINT AT THE CURRENT JOB
	MOVE	J,T1		;RESTORE THE HIGH SEGMENT NUMBER
	MOVEI	T1,0		;ASKING FOR 0K OF CORE
	PUSHJ	P,CORE1##	;RETURN THE CORE
	  STOPCD .+1,DEBUG,CMS,	;++CORE1 MUST SKIP
	SETZM	JBTSWP##(J)	;NO LONGER HAS CORE
IFE FTKL10,<
	SETZM	-3-IFN FTKLP,<1>(P) ;SO SEGCON WON'T CHANGE VIRTAL WHICH
				; WAS ALREADY MADE RIGHT BY VIRCHK
>
IFN FTKL10,<			;SVEUB USES MORE STACK ON KL
	SETZM	-4-IFN FTKLP,<1>(P)
>
	POPJ	P,		;RETURN
;GENERALIZED REMAP (GIVEN A COLLECTION OF CONTIGUOUS PAGES, MOVE
; THEM TO THE VIRTUAL ADDRESS SPECIFIED BY THE USER AND MAKE THEM A
; HIGH SEGMENT)
;CALLING SEQUENCE:
;	MOVE	J,CURRENT JOB NUMBER
;	MOVE	T1,CURRENT STARTING VIRTUAL PAGE NUMBER
;	MOVE	T2,NEW STARTING VIRTUAL PAGE NUMBER
;	MOVE	T3,NUMBER OF PAGES
;	MOVEI	T4,0		;IF THE NEW HIGH SEGMENT IS SHARABLE
;	MOVEI	T4,NON-ZERO	;IF THE NEW HIGH SEGMENT IS NON-SHARABLE
;RETURNS CPOPJ IF ARGUMENTS ARE WRONG, PAGES IN THE RANGE SPECIFIED
; DON'T ALL EXIST, OR MOVING THE PAGES TO THE VIRTUAL ADDRESSES
; SPECIFIED WOULD CAUSE THE HIGH SEGMENT AND LOW SEGMENT TO OVERLAP
;RETURNS CPOPJ1 IF EVERYTHING IS OK, NEW HIGH SEGMENT NUMBER IN J
NREMAP::TLO	M,400000	;CAUSE ERRORS TO JUST RETURN RATHER THAN GOING STOTAC
	JUMPLE	T3,IALERR	;REMAPPING NO PAGES IS ILLEGAL
	PUSHJ	P,SAVE4##	;SAVE WORKING ACS
	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER
	DMOVE	P1,T1		;SAVE ARGUMENTS
	DMOVE	P3,T3		; ..
	PUSHJ	P,LGLPG		;IS CURRENT STARTING VIRTUAL PAGE A LEGAL PAGE NUMBER?
	  POPJ	P,		;NO
	MOVE	T1,P2		;IS NEW STARTING VIRTUAL PAGE A LEGAL PAGE NUMBER?
	PUSHJ	P,LGLPG		; ..
	  POPJ	P,		;NO
	MOVE	T1,P1		;RESTORE STARTING VIRTUAL PAGE NUMBER
NREMA1:	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE USER'S MAP
	JUMPE	T2,PMEERR	;(REDO RELOCATION)
IFN FTPEEKSPY,<
	PUSHJ	P,TSSPT		;A SPY PAGE?
>
	PUSHJ	P,TPAHS		;IS THIS A HIGH SEGMENT PAGE?
	  JRST	PSHERR		;YES, THAT'S ILLEGAL
	ADDI	T1,1		;NEXT PAGE
	SOJG	T3,NREMA1	;CHECK ALL PAGES BEING REMAPPED
	PUSHJ	P,KILHSH##	;REMOVE THE JOB'S CURRENT HISEG
	CAMN	P1,P2		;NSA=OSA?
	JRST	NREMA4		;YES, NOTHING TO CHECK
	MOVE	T1,P2		;NSA
	ADD	T1,P3		;NSA+L
	CAML	P2,P1		;NSA.LT.OSA?
	JRST	NREMA2		;NO
	MOVE	T2,P2		;NSA
	CAMLE	T1,P1		;NSA+L.LE.OSA?
	MOVE	T1,P1		;NO, CHECK NSA TO OSA
	JRST	NREMA3		;YES, CHECK NSA TO NSA+L
NREMA2:	MOVE	T2,P1		;OSA
	ADD	T2,P3		;OSA+L
	CAMG	T2,P2		;OSA+L.GT.NSA?
	MOVE	T2,P2		;NO, CHECK NSA TO NSA+L
;	JRST	NREMA3		;YES, CHECK OSA+L TO NSA+L
NREMA3:	PUSHJ	P,CKNZP		;MAKE SURE PAGES BEING REMAPPED DON'T OVERLAP
				; OTHER PAGES IN THE PROGRAM'S ADDRESS SPACE
	  JRST	PCEERR		;THEY DO, GIVE PAGE CANNOT EXIST BUT DOES ERROR
NREMA4:	PUSHJ	P,FNDSGN##	;FIND A SEGMENT NUMBER FOR THE JOB'S NEW HI SEG
	DPB	P2,JBYHSO##	;STORE THE VIRTUAL PAGE NUMBER OF THE HI SEG ORIGIN
	SE1ENT			;MUST BE IN SECTION 1 FOR THE REST OF THIS
	PUSH	P,J		;SAVE THE NEW HIGH SEGMENT NUMBER
	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER
	DPB	P3,JBYHSS##	;STORE THE NEW HIGH SEGMENT'S SIZE
	JUMPN	P4,NREMA6	;JUMP IF NON-SHARABLE
	MOVN	T1,P3		;NUMBER OF PAGES IN THE NEW HIGH SEGMENT
	HRL	T1,P1		;STARTING PAGE NUMBER OF THE OLD HIGH SEGMENT
	MOVSS	T1		;MAKE AN ABOJN POINTER
NREMA5:	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE USER'S MAP
	ANDI	T2,17777	;CLEAR ACCESS BITS
	PUSH	P,T1		;SAVE THE AOBJN POINTER
	PUSH	P,T2		;AND THE PHYSICAL PAGE NUMBER
	PUSHJ	P,LKPSP		;LINK PAST THE PAGE IN PAGTAB
	PUSHJ	P,SCNPTB	;FIND THE PAGE AND ITS PREDESSOR IN PAGTAB
	POP	P,T2		;RESTORE THE PHYSICAL PAGE NUMBER
	SSX	T1,MDSEC2	;SET PAGTAB SECTION
	MOVEM	T2,PAGTAB(T1)	;LINK AROUND THIS PAGE, AND
	SSX	T2,MDSEC2	;DITTO
	HLLZS	PAGTAB(T2)	; INDICATE THAT THIS IS NOW THE LAST PAGE IN THE LIST
	POP	P,T1		;RESTORE THE AOBJN POINTER
	AOBJN	T1,NREMA5	;AND LOOP UNTIL ALL HIGH SEGMENT PAGES
				; ARE IN PAGTAB IN THE SAME ORDER THAT THEY APPEAR
				; IN THE JOB'S MAP
	MOVEI	P4,0		;THE HIGH SEGMENT IS SHARABLE
NREMA6:	CAML	P1,P2		;MOVING THE PAGES UP?
	TDZA	T1,T1		;NO, DOWN OR REMAP IN PLACE
	MOVEI	T1,-1(P3)	;NUMBER OF PAGES - 1
	HRLS	T1		;OFFSET
	HRLS	P1		;FIRST PAGE
	HRR	P1,P2		;DESTINATION PAGE
	ADD	P1,T1		;SOURCE,,DESTINATION
	PUSH	P,P4		;SAVE SHARABILITY ATTRIBUTE
	MOVEI	P4,0		;BECAUSE THERE ARE ONLY 16 ACS
	PUSH	P,P4		; ..
NREMA7:	MOVE	T1,P1		;SOURCE PAGE,,DESTINATION PAGE
	PUSHJ	P,MV1PG		;REMAP THE PAGE
	SKIPE	T3,-1(P)	;SHARABLE HIGH SEGMENT?
	JRST	NREMA8		;NO
	DPB	T3,T4		;YES, CLEAR THE WORKING SET BIT
	MOVEI	P2,AABTAB	;AND THE ACCESS ALLOWED BIT
	DPB	T3,T4		; ..
	PUSH	P,T1		;SAVE BYTE POINTER TO THE MAP
	PUSHJ	P,DCVMT		;ADJUST COUNTS
	POP	P,T1		;RESTORE BYTE POINTER TO THE MAP
NREMA8:	JUMPE	T2,NREMA9	;WAS THE LOW SEGMENT PAGE IN THE WORKING SET?
	LDB	T3,T1		;YES, GET THE CONTENTS OF THE MAP
	TDZ	T3,[PM.WRT]	;WRITE PROTECT THE PAGE
	DPB	T3,T1		;STORE THE WRITE PROTECTED ENTRY IN THE MAP
	AOS	(P)		;COUNT THE NUMBER OF PHYSICAL PAGES IN THE HIGH SEGMENT
NREMA9:	HLRZ	T1,P1		;SOURCE PAGE
	HRRZ	T2,P1		;DESTINATION PAGE
	MOVE	T3,T2		;ALSO DESTINATION PAGE
	CAIGE	T1,(P1)		;MOVING PAGES DOWN?
	JRST	NREM10		;NO
	SUB	T3,P4		;YES
	AOBJP	P1,NREM11	;BUMP SOURCE,,DESTINATION PAGES
NREM10:	ADD	T2,P4		;MOVING PAGES UP
	SUB	P1,[1,,1]	;DECREMENT SOURCE,,DESTINATION
NREM11:	LSHC	T2,P2WLSH##	;CONVERT TO WORDS
	TRO	T2,PG.BDY##	;NEXT PAGE BOUNDARY - 1
	DMOVEM	T2,.USHSE	;STORE ORIGIN,HIGHEST ADDRESS IN HIGH SEGMENT
	PUSHJ	P,DCUPN		;ADJUST UPREL
	CAIGE	P4,-1(P3)	;REMAPPED ALL THE PAGES REQUESTED?
	AOJA	P4,NREMA7	;NO, REMAP THE NEXT PAGE
	HLRZ	T1,P1		;LAST PAGE MOVED
	CAIGE	T1,(P1)		;MOVING PAGES UP?
	ADDI	P1,1(P3)	;YES, HIGHEST PAGE = NEW ORGIGIN + NUMBER OF PAGES
	MOVEI	T1,-1(P1)	;HIGHEST VIRTUAL PAGE IN THE HIGH SEGMENT
	LSH	P1,P2WLSH##	;CONVERT TO WORDS
	SUBI	P1,1		;PAGE BOUNDARY - 1
	HRRM	P1,.JDAT+JOBHRL## ;STORE HIGHEST VIRTUAL ADDRESS IN HI SEG FOR THE USER
	POP	P,P2		;RESTORE NUMBER OF PHYSICAL PAGES IN HI SEG
	POP	P,P4		;AND SHARABALITY
	LDB	T2,PCORSZ##	;CURRENT SIZE OF THE LOW SEGMENT
	DPB	T2,JBYLSS##	;STORE THAT
	MOVE	J,(P)		;RESTORE THE HIGH SEGMENT NUMBER
	JUMPE	P4,NREM12	;JUMP IF THE HIGH SEGMENT IS SHARABLE
	HRLZM	P2,JBTSWP##(J)	;STORE THE NUMBER OF IN CORE PAGES IN THE HI SEG
	JRST	NREM13		;AND SKIP ON
NREM12:	PUSHJ	P,GTPME		;PHYSICAL PAGE WHICH CORRESPONDS TO THE
	MOVE	T3,T2		; THE HIGHEST VIRTUAL PAGE IN THE HIGH SEGMENT
	DPB	P2,IMGIN##	;STORE THE SIZE OF THE HIGH SEGMENT
	MOVNS	P2		;MINUS PHYSICAL SIZE OF THE HIGH SEGMENT
	LDB	T1,JBYHSO##	;HIGH SEGMENT STARTING VIRTUAL PAGE
	PUSHJ	P,GTPME		;GET MAP CONTENTS (PHYSICAL PAGE)
	MOVE	P4,T2		;SET ARGUMENT TO SCNPT
	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER
	ADDM	P2,JBTSWP##(J)	;DECREASE LOW SEGMENT SIZE BY THE NUMBER OF
				; PAGES MAPPED INTO THE HIGH SEGMENT
	ANDI	P4,17777	;PAGE NUMBER OF THE START OF THE HIGH SEGMENT
	PUSHJ	P,SCNPT		;FIND ITS PREDECESSOR
	HLRZS	P4		;PREDECESSOR OF THE FIRST PAGE
	ANDI	T3,17777	;PHYSICAL PAGE OF THE TOP OF THE HIGH SEGMENT
	SSX	T3,MDSEC2	;PAGTAB SECTION
	SSX	P4,MDSEC2	;DITTO
	MOVE	T1,PAGTAB(T3)	;GET ITS LINK
	HLLZS	PAGTAB(T3)	;TERMINATE PAGTAB LINKED LIST FOR THE HIGH SEGMENT
	HRRM	T1,PAGTAB(P4)	;LINK PAGES PAST THE HI SEG TO THE LOW SEG
NREM13:	POP	P,J		;RESTORE HIGH SEGMENT NUMBER
	LDB	T1,JBYHSO##	;GET THE HIGH SEGMENT ORIGIN VIRTUAL PAGE
	PUSHJ	P,GTPME		;GET THE HIGH SEGMENT ORIGIN PHYSICAL PAGE
	DPB	T2,JBYHSA##	;STORE THAT FOR REDOING THE HIGH SEGMENT MAP
IFE FTKLP,<
	TRO	T2,PM.ACC+PM.WRT+IFN FTKL10!FTKS10,<PM.CSH>
	HRLM	T2,.UPMP+.MVJDT	;SETUP MAPPING FOR VESTIGUAL JOB DATA AREA
>
IFN FTKLP,<
	HRLI	T2,(<PM.DCD>B2+PM.WRT+PM.CSH)
	MOVEM	T2,.UPMP+.VJDT/PAGSIZ##
>
	MOVE	T1,P3		;HIGHEST RELATIVE PAGE IN THE HIGH SEGMENT
	LSH	T1,P2WLSH##	;CONVERT TO HIGHEST WORD
	SUBI	T1,1		;HIGHEST WORD - 1
	HRLI	T1,.VJDT	;VIRTUAL ADDRESS OF THE VESTIGUAL JOB DATA AREA
	MOVSM	T1,JBTADR##(J)	;SAVE HIGH PROTECTION,,RELOCATION
	MOVEM	R,.CPADR##	;STORE NEW LOW SEGMENT PROTECTION,,RELOCATION
	HLRZM	R,.CPREL##	;AND THE HIGHEST RELATIVE ADDRESS IN THE LOW SEGMENT
	HLRZM	R,.USHVA	;FOR ADDRESS CHECKING AT INTERRUPT LEVEL
	PJRST	FIXMJ1		;CLEAR THE A.M. AND SKIP RETURN
	SUBTTL	UUOCON  INTERFACE WITH UUO HANDLER AND IOCSS 

;SUBROUTINE TO TEST IF A UUO PAGE-FAULT WILL OCCUR
;ENTER WITH T1=ADR TO BE TESTED
;NON-SKIP RETURN IF A PAGE FAULT WILL OCCUR, CPOPJ1 IF ADR IS OK
;PRESERVES ALL ACS
FLTST::	PUSH	P,T1		;SAVE T1
	EXCTUU	<MAP T1,(T1)>	;MAP THE PAGE
	PUSHJ	P,FLTCHK
IFN FTKL10!FTKS10,<
	  JRST	TPOPJ##
>
IFN FTKI10,<
	  SKIPA	T1,0(P)		;GET UVA BACK AND SKIP
>
	JRST	TPOPJ1##
IFN FTKI10,<
	TRC	T1,1		;THE ADR ADJACENT TO THIS ONE
	EXCTUU	<MAP T1,(T1)>	;MAP THAT ADR
	TRNE	T1,400000	;IS IT OK NOW?
	TRNN	T1,20000
	PJRST	TPOPJ1##	;YES, FIRST TEST FAILED BECAUSE OF
	PJRST	TPOPJ##		; ADR BREAK
>;END IFN FTSET&FTKI10

FLTCHK::
IFN FTKI10,<
	TRNE	T1,400000	;IS IT OK?
	TRNN	T1,20000
	JRST	CPOPJ1##	;YES, SKIP RETURN
	POPJ	P,		;NO, NON SKIP
>;END IFN FTKI10

IFN FTKL10!FTKS10,<
	TLNN	T1,(1B8)	;PAGED REFERENCE?
	JRST	CPOPJ1##	;NO, WILL NOT FAULT
	TLNN	T1,(1B1)	;BAD FAIL OR
IFE FTKLP,<
	TLNN	T1,(1B2)	;NOT ACCESS ALLOWED?
>
IFN FTKLP,<
	TLNN	T1,(17B5)
>
	POPJ	P,		;YES TO EITHER, WILL FAULT
	JRST	CPOPJ1##	;REF OK. WIN.
>;END IFN FTKL10!FTKS10
;CHKIND  -- CHECK A USER WORD FOR US TO INDIRECT OFF OF.
;CALL:
;	MOVE	T1,[USER BYTE POINTER]
;	PUSHJ	P,CHKIND
;	 FAIL, ON ADDRESS CHECK OF SOME SORT
;	SUCCESS, T1 CONTAINS RESOLVED BYTE POINTER
;TRASHES M
;NOTE - THIS AND CHKBPT WILL HAVE TO BE RE-WRITTEN WHEN AND IF USER-MODE
;EXTENDED ADDRESSING IS IMPLEMENTED, SINCE NEITHER TRY TO SOLVE FOR THAT
;CASE (THINK OF ONE-WORD GLOBAL BYTE POINTERS! YIKES!)

CHKIND::TLNN	T1,(17B17)	;CHECK FOR INDEXING FIRST
	JRST	CHKAT		;NONE, CHECK FOR INDIRECTING
	PUSH	P,T1		;SAVE CURRENT ADDRESS
	LDB	T1,[POINT 4,T1,17] ;EXTRACT AC FROM INDEX FIELD OF WORD
	DPB	T1,[POINT 4,M,12] ; AND PLACE IT INTO AC FIELD OF A UUO
	PUSHJ	P,GETTAC##	;   SO GETTAC CAN RETURN US THE AC CONTENTS
	HRRZS	T1		;USE RIGHTMOST 18 BITS OF AC ONLY
	ADD	T1,(P)		;SIMULATE INDEXING BY ADDING RH TO ADDRESS
	POP	P,(P)

CHKAT:	TLNN	T1,(1B13)	;INDIRECT BIT ON?
	 JRST	CPOPJ1##	;NOPE - ADDRESS IS RESOLVED
	HRRI	M,(T1)		;ADDRESS (RH ONLY) FOR GETWRD TO USE
	PUSHJ	P,GETWRD##	;GET THE WORD, DOING ALL CHECKS 
	 POPJ	P,		;ADDRESS CHECK - LET CALLER HANDLE THIS
	PUSHJ	P,SCDCHK##	;GIVE OTHER JOBS A CHANCE, AND USER A CHANCE
				; TO ^C OUT OF THIS (IF HE GAVE US A LOOP).
	JRST	CHKIND		;START OVER AGAIN, WITH NEW ADDRESS

;CHKBPT  --  RANGE CHECK A BYTE POINTER AFTER RESOLVING INDIRECT AND INDEXING
;CALL IS:
;
;	MOVE	T1,[BYTE POINTER TO USER VIRTUAL SPACE]
;	MOVEI	T2,NUMBER OF BYTES
;	PUSHJ	P,CHKBPT
;	 ON ADDRESS CHECK
;	ON SUCCESS, T1 CONTAINS RESOLVED BYTE POINTER
;TRASHES M
;WILL NOT WORK ON A KI OR A KA.
IFE FTKI10,<

CHKBPT::PUSHJ	P,SAVE2##	;GET SOME PRESERVED REGISTERS
	LDB	P2,[POINT 6,T1,5] ;GET P FIELD OUT OF BYTE POINTER
	CAILE	P2,44		;IF IT IS GREATER THAN WORD SIZE, IT IS OWGBP
	POPJ	P,		;ERROR RETURN.
	MOVE	P2,T2		;SAVE BYTE COUNT
	HRLZI	P1,777740	;FIELD CONTAINING BYTE SIZE AND COUNT
	AND	P1,T1		;GET BYTE SIZE AND COUNT INTO SAVED REGISTER
	XOR	T1,P1		;WIPE SAID BITS IN T1 (FIGURE THIS ONE OUT!)
	PUSHJ	P,CHKIND	;RESOLVE INDIRECTION AND INDEXING IN ADDRESS
	 POPJ	P,		;ADDRESSING ERROR OF SOME SORT
	IOR	P1,T1		;ADD IN RESOLVED ADDRESS TO BYTE SIZE AND COUNT
	halt			;never... pl}thberg
	ADJBP	P2,P1		;GET A BYTE POINTER TO THE END OF THE STRING
	TLZ	P2,-1		;MAKE IT BE NOTHING BUT AN ADDRESS
	MOVEI	M,1		;1 BYTE
	ADJBP	M,P1		;GET POINTER TO FIRST BYTE (SINCE ILDB POINTER)
CHKBPN:	TLZ	M,-1		;MAKE IT BE AN ADDRESS
	PUSHJ	P,GETWRD##	;TRY TO GET THE WORD (CALL PFH MAYBE)
	 POPJ	P,		;CAN'T, ERROR RETURN
	TRO	M,777		;POINT M AT THE LAST WORD IN THAT PAGE
	AOJ	M,		;MAKE THAT THE FIRST WORD IN THE NEXT PAGE
	CAIG	M,(P2)		;WAS THE END OF STRING IN THAT PAGE?
	 JRST	CHKBPN		;NO, TRY THE NEXT PAGE
	MOVE	T1,P1		;GET BYTE POINTER TO RETURN
	JRST	CPOPJ1##	;SUCCESS RETURN
>;julgran

ifn ftki10,<

chkbpt::jrst	cpopj1##	;Orkar inte just nu...

>;ki10

;BRNGE  --  RANGE CHECK A USER I/O BUFFER
;CALL IS:
;
;	MOVX	T1,<BUFFER>
;	PUSHJ	P,BRNGE
;	RETURN
;
;WHERE <BUFFER> IS THE USER VIRTUAL ADDRESS OF THE .BFHDR WORD OF THE
;USER BUFFER (THE SECOND WORD OF THE BUFFER HEADER).
;
;	***   MAY ONLY BE CALLED AT UUO LEVEL   ***
;
;IF AN I/O-ILLEGAL ADDRESS IS GIVEN (IN PROTECTED JOBDAT OR IN USER'S
;HIGH SEGMENT) BRNGE DISPATCHES TO ADRERR TO GIVE AN ADDRESS CHECK; IF A
;PAGE FAULT OCCURS (ACCESS ALLOWED OFF OR PAGED OUT) BRNGE DISPATCHES TO
;THE PAGE FAULT HANDLER (WHICH WILL IN TURN RE-EXECUTE THE UUO . . .);
;IF A NONEXISTANT ADDRESS IS ENCOUNTERED BRNGE DISPATCHES TO ADRERR.
;
;ON RETURN THE ENTIRE BUFFER IS ADDRESSABLE.
;
;USES T1 AND T2.

BRNGE::	EXCTUX	<HLRZ T2,@T1>	;GET BUFFER SIZE (DATA SIZE + 1)
	TRZ	T2,IOUSE	;REDUCE TO COUNT ALONE
	SUBI	T1,1		;T1:=START OF BUFFER AREA (.BFSTS WORD)
	ADDI	T2,1(T1)	;T2:=END OF BUFFER
				;FALL INTO LRNGE
;LRNGE  --  RANGE CHECK A BLOCK OF USER ADDRESS SPACE (I/O)
;TRNGE  --  RANGE CHECK A BLOCK OF USER ADDRESS SPACE (NON-I/O)
;CALL IS:
;
;	MOVX	T1,<FIRST>
;	MOVX	T2,<LAST>
;	PUSHJ	P,LRNGE/TRNGE
;	RETURN
;
;WHERE <FIRST> IS THE FIRST ADDRESS OF THE BLOCK TO BE ADDRESS CHECKED,
;AND <LAST> IS THE LAST ADDRESS OF THE BLOCK TO BE ADDRESS CHECKED.
;
;	***   MAY ONLY BE CALLED AT UUO LEVEL   ***
;
;IF ANY ADDRESS WITHIN THE RANGE <FIRST> TO <LAST> INCLUSIVE IS NOT
;I/O-LEGAL LRNGE WILL DISPATCH TO ADRERR (TRNGE WILL IGNORE); IF ANY
;ADDRESS WOULD CAUSE A PAGE FAULT (EITHER ACCESS ALLOWED OFF OR PAGED
;OUT) BOTH LRNGE AND TRNGE DISPATCH TO THE PAGE FAULT HANDLER (WHICH
;WILL RE-EXECUTE THE USER UUO); IF AN ADDRESS IS ENCOUNTERED WHICH
;IS NON-EXISTANT BOTH LRNGE AND TRNGE DISPATCH TO ADRERR.
;
;ON RETURN THE ENTIRE RANGE IS ADDRESSABLE.
;
;USES T1 AND T2.

LRNGE::	TLNE	T2,-1		;IF BUFFER WRAPS AROUND CORE
	PJRST	ADRERR##	; IT'S AN ADDRESS ERROR
	TLO	T2,400000	;INDICATE CALL TO LRNGE
TRNGE::	CAILE	T1,(T2)		;IF BUFFER WRAPS AROUND CORE
	JRST	UADERR##	;IT'S AN ADDRESS ERROR
XRNGE::	JUMPGE	T2,TRNGE1	;IF CALL TO LRNGE ENSURE I/O LEGAL ADDR
	CAML	T1,.UPMP+.UPHSS	;IS ADDRESS IN THE USER HIGH SEGMENT?
	CAMLE	T1,.UPMP+.UPHSE	; . . .
	CAIG	T1,JOBPFI##	;NO, ABOVE PROTECTED JOBDAT?
	JRST	ADRERR##	;IN HIGH SEG OR PROTECTED JOBDAT, ERROR
TRNGE1:	EXCTUX	<SKIP	(T1)>	;ENSURE ADDRESS IS ACCESSIBLE
	  ERJMP	UUOFLT		;IF NOT, CHECK FOR PAGE FAULT
	TRO	T1,PG.BDY##	;HIGHEST ADR IN THE PAGE
	CAIL	T1,(T2)		;CHECKED ALL REQUIRED PAGES?
	POPJ	P,		;YES, RETURN
	ADDI	T1,PAGSIZ##	;NO, STEP TO NEXT PAGE
	JRST	XRNGE		;AND TEST IT
;PRNGE  --  RANGE CHECK A BYTE POINTER AND COUNT
;CALL IS:
;
;	MOVX	T1,<POINTER>
;	MOVX	T2,<COUNTER>
;	PUSHJ	P,PRNGE
;	RETURN
;
;WHERE <POINTER> IS A BYTE POINTER TO A USER VIRTUAL ADDRESS; AND
;<COUNTER> IS THE COUNT OF THE NUMBER OF BYTES FOR WHICH TO RANGE
;CHECK <POINTER>.
;
;	***   MAY ONLY BE CALLED AT UUO LEVEL   ***
;
;IF ANY BYTE IS CONTAINED WITHIN A I/O-ILLEGAL ADDRESS PRNGE WILL
;DISPATCH TO ADRERR; IF ANY BYTE IS CONTAINED WITHIN A NON-EXISTANT
;ADDRESS PRNGE DISPATCHES TO ADRERR; IF ANY BYTE IS CONTAINED WITHIN
;AN ADDRESS WHICH WOULD PAGE FAULT (ACCESS ALLOWED OFF OR PAGED OUT)
;PRNGE DISPATCHES TO THE PAGE FAULT HANDLER (WHICH WILL EVENTUALLY
;RE-EXECUTE THE USER'S UUO).
;
;ON RETURN THE BYTE POINTER IS SAFE TO USE FOR <COUNTER> BYTES.
;
;USES T1 - T4.

QRNGE:: SKIPA	T3,[TRNGE]
PRNGE:: MOVEI	T3,LRNGE
	PUSH	P,T3
	IBP	T1		;POINT TO FIRST REAL BYTE
	LDB	T3,[POINT 6,T1,5]  ;NUMBER OF BITS LEFT IN WORD
	LDB	T4,[POINT 6,T1,11] ;BITSIZE OF BYTE
	IDIVI	T3,(T4)		;BYTES LEFT WITHIN FIRST WORD
	SUB	T2,T3		;COUNT OUT FIRST WORD
	MOVEI	T3,^D36		;NUMBER OF BITS IN A WORD
	LDB	T4,[POINT 6,T1,11] ;BITSIZE OF BYTE (AGAIN)
	IDIVI	T3,(T4)		;T3:=NUMBER OF BYTES IN A WORD
	IDIVI	T2,(T3)		;T2:=NUMBER OF WORDS NEEDED
	CAILE	T3,0		;ANY BYTES "LEFT OVER"?
	ADDI	T2,1		;YES, ALLOW FOR ANOTHER WORD
	CAIGE	T2,0		;WORD COUNT IN FORWARD DIRECTION?
	SETZ	T2,		;NO (E.G., 7-BIT BYTES, POINTER IN MIDDLE
				;  OF WORD, AND COUNT OF 1)
	ANDI	T1,-1		;JUST USER VIRTUAL ADDRESS NEEDED
	ADD	T2,T1		;GET LAST ADDRESS NEEDED
	POP	P,T3		;AND GO RANGE CHECK THE BLOCK
	JRST	(T3)
;SUBROUTINE TO CHECK A RANGE OF ADDRESSES, CALLED FROM ANY LEVEL
;RETURNS CPOPJ IF SOME ADR NOT IN CORE (PAGE FAULT OR NON-EXISTANT)
;RETURNS CPOPJ1 IF EVERYTHING IS OK

REPEAT	0,<			;CAN'T USE AT INTERRUPT LEVEL YET
ZRNGE::	TROA	T1,PG.BDY##	;TOP ADR IN PAGE
ZRNGE1:	ADDI	T1,PAGSIZ##	;ADVANCE TO NEXT PAGE
	CAML	T1,.USHSS	;IS ADDRESS IN THE USER HIGH SEGMENT?
	CAML	T1,.USHSE	; . . .
	CAIG	T1,JOBPFI##	;NO, ABOVE PROTECTED JOBDAT?
	POPJ	P,		;IN HIGH SEG OR PROTECTED JOBDAT, ERROR
	EXCTUX	<SKIP	(T1)>	;SEE IF CAN REFERENCE THE USER PAGE
	  ERJMP	CPOPJ##		;IF CAN'T THEN TAKE ERROR RETURN
	CAIGE	T1,(T2)		;LEGAL, DONE?
	JRST	ZRNGE1		;NOT YET, CHECK NEXT PAGE
	JRST	CPOPJ1##	;YES, TAKE SUCCESSFUL RETURN
> ;END REPEAT 0

ZRNGE::	TRO	T1,PG.BDY##	;TOP ADR IN PAGE
	PUSH	P,T2		;SAVE T2 FROM IADRCK
ZRNGE1:	PUSHJ	P,IADRCK##	;MAKE SURE PAGE LEGAL AND IN CORE
	  PJRST	T2POPJ##	;PAGE FAULT OR ADR ERR
	CAML	T1,(P)		;LEGAL, DONE?
	PJRST	T2POJ1##	;YES, GOOD RETURN
	ADDI	T1,PAGSIZ##	;NO, STEP TO NEXT PAGE
	JRST	ZRNGE1		;AND TEST IT
;SUBROUTINE TO TEST IF AN ADDRESS WILL GIVE A PAGE FAULT
;ENTER J= JOB NUMBER, R=RELOACATION, RH(M)=ADR TO TEST
;SKIP-RETURNS IF ADR IS OK OR WILL GIVE AN ADRESS ERROR
;DISPATCHES TO PAGE-FAULT HANDLER IF LEGAL, PAGE NOT IN CORE
; AND AT UUO LEVEL (NOT PI OR SCHEDULER)
;NON-SKIP RETURN IF PAGE-FAULT TYPE ADDRESS, NOT AT UUO LEVEL
;PRESERVES ALL ACS
FLTSX::	PUSH	P,T1		;SAVE ACS
	PUSH	P,T2
	HLRZ	T1,R
	CAILE	T1,(M)		;ADR CHECK?
	JRST	FLTSX1		;NO, SEE IF ITS IN CORE
	SKIPE	T1,JBTSGN##(J)	;MAYBE, IS THERE A HI SEG?
	DMOVE	T1,.USHSE	;YES, GET ITS LIMITS
	CAIL	T1,(M)		;ADR IN THE HI SEG?
	CAILE	T2,(M)
	JRST	FLTSX2		;ADR CHECK - GIVE "OK" RETURN
FLTSX1:	HRRZ	T1,M		;NOT AND ADR CHECK, PAGE IN CORE?
	PUSHJ	P,FLTST
	  JRST	FLTSX3		;NO, CHECK IF AT UUO LEVEL
FLTSX2:	POP	P,T2		;YES, RESTORE ACS
	PJRST	TPOPJ1##	;AND GIVE OK RETURN

;HERE ON A PAGE-FAULT
FLTSX3:	PUSH	P,P4
	CONSO	PI,PI.IPA	;PI LEVEL?
	SKIPE	.CPISF##	;NO, IN SCHEDULER?
	JRST	FLTSX4		;YES, ERROR RETURN
	CAMN	J,.CPJOB##	;NO, IS THIS THE RUNNING JOB?
	PJRST	UUOFL1		;YES, CALL PFH
FLTSX4:	POP	P,P4		;ERROR - RESTORE P4
	PJRST	TTPOPJ##		;AND NON-SKIP RETURN

;SUBROUTINE TO INCREMENT JOBPD1
INCPD1::HRRZ	T2,.JDAT+JOBPD1##+IFN FTKLP,<1>	;JOBPD1
	ADDI	T2,1		;+1 (CAN'T AOS, SINCE MIGHT = -1)
	HRRM	T2,.JDAT+JOBPD1##+IFN FTKLP,<1>	;STORE BACK
	POPJ	P,		; AND RETURN
;SUBROUTINE TO CHECK ARGUMENTS TO A UUO
;ENTER T1=C(AC)  T3=CHECK-BITS FOR THE UUO
;CALLS PAGE FAULT HANDLER IF ERROR WILL OCCUR, RETURNS IF OK
;PRESERVES T1,T4
UUOCHK::MOVE	T2,JBTSTS##(J)	;GET JBTSTS FOR JOB
	TRNE	T2,JS.ASA	;JS.ASA ON?
	POPJ	P,		;YES, MONITOR KNOWS WHAT ITS DOING (???)
	PUSH	P,T1		;NO, SAVE T1
	TRNE	T3,UU.EA+UU.LER;EFFECTIVE ADR CHECK?
	SKIPA	T2,T1		;YES, GET ADR
	MOVE	T2,.JDAT+JOBPD1##+IFN FTKLP,<1>	;NO, GET LOC OF UUO
	TRNE	T3,UU.CEA+UU.LER	;CHECK C(ADR)?
	JRST	UUOCH1		;YES
	TRNN	T3,UU.CAC	;NO, CHECK C(AC)?
	LDB	T1,[POINT 6,T3,35]	;NO, GET NO OF ARGS FROM T3
	JRST	UUOCH2		;AND CONTINUE

;HERE TO CHECK ADR
UUOCH1:	PUSH	P,M		;SAVE M
	HRR	M,T1		;LOC TO CHECK
	PUSHJ	P,GETWRD##	;GET C(EA)
	  JRST	UUOCH3		;BAD - CALL PFH
	POP	P,M		;RESTOR M
	TRNE	T3,UU.LER	;LOOKUP/ENTER/RENAME?
	TLNN	T1,-1		;YES, LH=0?
	TRZA	T1,770000	;YES, NUMBER OF ARGS ALREADY IN T1, CLEAR FUNNY BITS
	MOVEI	T1,3		;NO, CHECK 4 WORDS (TO ADR+3)
UUOCH2:	TRNE	T3,UU.MNS	;MINUS N?
	MOVNS	T1		;YES
	TRNN	T3,UU.LFT	;NO OF ARGS IN LH?
	TLZA	T1,-1		;NO, CLEAR LH
	HLRZS	T1		;YES, USE LH
	EXCH	T1,T2		;GET 1ST ADR, SAVE NUMBER
	TLZ	T1,-1
	SKIPN	T1		;GET TOP ADR (A+N-1) IN T2
	AOSA	T2,T1
	ADDI	T2,(T1)
	TRNN	T3,UU.LER
	SUBI	T2,1
	PUSHJ	P,XRNGE		;ALL PAGES IN CORE?
	PJRST	TPOPJ##		;YES, RETURN

;HERE WHEN ADR ITSELF ISN'T IN CORE
UUOCH3:	HRRZ	T1,M		;BAD ADR IN T1
	POP	P,M		;RESTORE M
	PJRST	UUOFLT		;AND CALL PFH
;HERE IF ARGUMENT NOT IN CORE - PAGE FAULT WILL OCCUR IF UUO PROCEEDS
;T1= BAD ADDRESS
UUOFL1:	POP	P,(P)		;MAKE THE LIST RIGHT
	POP	P,(P)

UUOFLT::NTGIVE			;RETURN THE NETSER INTERLOCK.
IFN FTMP,<
	PUSHJ	P,TGVMM##	;OWN THE MM?
>
	HRLZ	T3,T1		;ADR
	LSH	T3,W2PLSH##	;PAGE
	TRO	T3,20		;INDICATE CALL IS FROM A UUO
	GETPC	T4,.JDAT+JOBPD1##	;ADR OF UUO
	HRRI	T4,-1(T4)
	MOVE	J,.CPJOB##	;SET UP J
	TLNE	T4,(XC.USR)	;LOSE IF NOT USER MODE (COMCON)
	PUSHJ	P,USRFL1	;CALL PFH (GENERALLY DOESN'T RETURN)
	  PJRST	UADERR##

;HERE ON A TIME INTERRUPT
TIMFLT::MOVE	T4,.USTMC
	MOVE	P,[XWD MJOBPD##+1+<IFN FTKLP,<1>>,.JDAT+JOBPDL##+1+<IFN FTKLP,<1>>] ;SET UP P
	PUTPC	T4,.JDAT+JOBPD1## ;SAVE PC (IN JOBPD1)
	MOVE	J,.CPJOB##	;SET UP J
	PUSHJ	P,FNDPDB##	;GET THE PDB
	  JRST	USRXIT		;IF NO FAULT DATA-IGNORE INTERRUPT
	SKIPN	T3,.USTMI	;RESET COUNTER--THIS MUST BE DONE AFTER
	JRST	TIMFL1
	MOVEM	T3,.USTMC	; RESET OF JOBPD1 TO PROTECT PSISER
	MOVEI	T3,0		;INDICATE TIME INTERRUPT
	PUSHJ	P,USRFL1	;CALL PFH
	  JRST	USRXIT##	;CANT GET PFH - IGNORE INTERRUPT

;HERE IF USER HASN'T ENABLED FOR TIME INTERRUPTS
;RECOMPUTE THE FAULT-RATE AND DISMISS THE INTERRUPT
TIMFL1:	MOVEI	P1,1		;USE 1 PAGE AS BASIS
	PUSHJ	P,USRATE	;COMPUTE NEW PAGE-INTERVAL
	MOVE	T1,TICSEC##	;RECOMPUTE IN 1 SECOND
	MOVEM	T1,.USTMC
	PJRST	USRXIT##	;GO RESTART USER JOB

;HERE WHEN THE PAGE CONTAINING TTY OUTPUT BUFFER FOR A JOB DOING
; NO BLOCKING TTY OUTPUT ISN'T IN CORE
TTYFLT::MOVE	P,[XWD MJOBPD##+1+<IFN FTKLP,<1>>,.JDAT+JOBPD1##+<IFN FTKLP,<1>>]
	PUSHJ	P,INCPD1	;SINCE UUOFLT WILL DECREMENT IT
	MOVE	T1,.USUPF	;FAULT ADDRESS
	JRST	UUOFLT		;TREAT IT LIKE A UUO FAULT
;T4=PC WORD, T3=PAGE FAIL WORD
;PRESERVES T1
USRFLT::
ife ftki10,<
	MOVSI	J,37		;SECTION NUMBER
	TDNN	J,.UPMP+.LMPFW	;FAIL IF SECTION IN PAGE FAIL WORD IS NON-ZERO
>;ki10
	TRNE	T3,20		;"BAD" TYPE FAULT?
	POPJ	P,		;YES, TOO BAD
	MOVE	J,.CPJOB##	;NO, SET J
	TRNE	T3,10		;ACCESS ALLOWED FAILURE?
	TRNN	T3,1		;YES, WRITE ATTEMPT?
	SKIPA	R,.CPADR##	;NO, SET UP R
	JRST	USRFL9		;YES, HANDLE SPECIALLY

USRFL1:	PUSH	P,T1		;PRESERVE T1
	PUSH	P,T4		;SAVE PC WORD
	JUMPE	T3,USRFL2	;GO IS A TIME INTERRUPT
	LDB	T1,[POINT 9,T3,17]	;NOT TIME, GET VIRT PAGE NO.
	PUSHJ	P,GTPME		;GET MAP CONTENTS
	JUMPE	T2,USRFL8	;GO IF NO PAGE
	CAIN	T2,PM.ZER	;PAGE EXISTS, IS IT  ZERO?
	TROA	T3,400000	;YES, REMEMBER THAT
	TRZ	T3,400000	;NO
USRFL2:	PUSHJ	P,FNDPDS##	;FIND PDB FOR JOB
	HRRZ	T1,.JDAT+.JBPFH##	;GET ADR OF PFH
	JUMPE	T1,GETPFH	;LOAD DEFAULT IF NONE THERE
	CAIL	T1,JOBPFI##	;PFH REALLY THERE?
	PUSHJ	P,FLTST
	  JRST	USRFL8		;NO, CANT DO ANYTHING
	ADDI	T1,5		;POINT TO TOP LOC TO STORE IN
	PUSHJ	P,FLTST		;IS TOP OF BLOCK THERE?
	  JRST	USRFL8		;NO, CANT DO GOOD THINGS FOR HIM
USRFL3:	JUMPE	T3,USRFL4	;IF NOT A TIME INTERRUPT,
	LDB	T1,[POINT 9,T3,17]	;GET VIRTUAL PAGE
	HRL	T3,T1		;SAVE IN LH(T3)
	PUSHJ	P,TSWST		;IS PAGE IN WORKING SET?
	  JRST	USRFL5		;NO
	TDNE	T2,AABTAB(T4)	;YES, IS ACCESS ALLOWED?
	STOPCD	.+1,DEBUG,WAD,	;++WSBTBL AND AABTBL DISCREPENCY
	MOVEI	T1,PC.PNA	;YES, SET REASON = PAGE NOT ACCESSABLE
	MOVSI	T2,(UP.SAA)	;SET ACCESS ALLOWED AUTOMATICALLY BIT
	TDNN	T2,.USBTS	;SHOULD WE SET A.A.?
	JRST	USRFL6		;NO, GIVE FAULT TO PFH
	HLRZ	T1,T3		;PAGE NUMBER, SIGN BIT SAYS SET A.A.
	PUSHJ	P,SCAABT	;TURN ON ACCESS ALLOWED
	PUSHJ	P,ADJANA	;MAKE .UPANA AND .UPVRT RIGHT
	JRST	USRFLX		;CONTINUE PROGRAM EXECUTION
USRFL4:	MOVEI	T1,PC.TIM	;SET REASON = TIME FAULT
	JRST	USRFL6		;AND CONTINUE
;HERE IF PAGE NOT IN WORKING SET
USRFL5:	MOVEI	T1,PC.PNC	;REASON = PAGE NOT IN CORE
	TRNE	T3,20		;IF FAULT FROM A UUO,
	MOVEI	T1,PC.UUO	; REASON = UUO FAULT
	TRNN	T3,400000	;ALLOCATED BUT ZERO PAGE?
	JRST	USRFL6		;NO
	ADDI	T1,PC.AZM-PC.UUO	;YES, INCEMENT REASON BY 3
	IORM	T2,AABTAB(T4)	;SET PAGE IN AABTAB

USRFL6:	HLL	T1,T3		;VIRTUAL PAGE IN LH(T1)
	HRRZ	M,.JDAT+.JBPFH## ;GET ADR OF OFH
	EXCH	T1,(P)		;SAVE PAGE,,REASON
	PUSHJ	P,PUTWD1##	;SAVE PC IN WORD 1 
	EXCH	T1,(P)		;SAVE PAGE,,REASON
	MOVE	T2,.USBTS
	TLZE	T2,(UP.WHC)	;WORKING SET CHANGED?
	TLO	T1,(PC.WHC)
	TLZE	T2,(UP.WSS)	;WORKING SET SCRAMBLED?
	TLO	T1,(PC.WSS)
	MOVEM	T2,.USBTS
	PUSHJ	P,PUTWD1##	; IN WORD 2
	HRRZ	P1,T1		;SAVE REASON
	.MOVE	T1,.PDTTM##(W)	;GET TIME
	SKIPE	.USFFT	;FIRST FAULT?
	JRST	USRFL7		;NO
	HRRZS	JBTVRT##(J)	;YES, CLEAR FAULT-INTERVAL
	MOVEM	T1,.USFFT	;YES, SAVE AS FIRST FAULT TIME
USRFL7:	SUB	T1,.USFFT	;COMPUTE VIRTUAL TIME
	IMULI	T1,^D1000	;CONVERT TO MILLISECS
	IDIV	T1,TICSEC##
	PUSHJ	P,PUTWD1##	;SAVE VIRT TIME IN WD 3
	CAIN	P1,PC.TIM	;TIME INTERRUPT?
	PUSHJ	P,PRTUPD	;YES, CALL PAGE RATE UPDATE ROUTINE
	CAIE	P1,PC.TIM	;TIME INTERRUPT?
	CAIN	P1,PC.PNA	;OR PAGE NOT IN AABTAB?
	SKIPA	P1,[1]		;COUNT IN RH FOR "NON-REAL" FAULTS
;HERE ON A TIME OR ACCESS-ALLOWED FAULT
	MOVSI	P1,1		;COUNT IN LH FOR "REAL" FAULTS
	ADDM	P1,.USVCT	;COUNT FAULT IN UPMP
	ADDM	P1,SYSVCT##	;COUNT SYSTEM FAULTS
	MOVE	T1,JBTVRT##(J)	;FAULT RATE OF JOB
	PUSHJ	P,PUTWD1##	;STORE IN WD 4
IFN FTPI,<
	PUSHJ	P,PSIIVA##	;DOING PSI TRAPS?
				;YES, GET INTERRUPT VECTOR ADDR
>
IFE FTPI,<
	MOVEI	T1,0
>
	PUSHJ	P,PUTWD1##	; AND STORE FOR USER WD 5
	SUBI	M,5		;POINT BACK TO START OF BLOCK
	PUSHJ	P,GETWDU##	;GET ADR OF PFH
	HLL	T1,(P)		;GET FLAGS
	TLZ	T1,(IC.BIS+IC.ATN+IC.LIP)	;CLEAR TRAP BITS, BIS
	PUSH	P,T1		;SAVE PC ON STACK 
	PUSHJ	P,CLRASA##	;CLEAR JS.ASA
	SKIPN	.CPTMF##	;DID THE CLOCK TICK?
	JRST	UFLTRT		;NO -- GO TO THE USER
	MOVE	T1,JBTSTS##(J)	;YES -- GET JOB STATUS
	PUSHJ	P,USCHD1##	;RESCHEDULE
	JRST	UFLTRT		;GO TO THE USER

;HERE IF CANT GO TO PFH FOR ANY REASON
USRFL8:	POP	P,T4		;RESTORE PC
	PJRST	TPOPJ##		;AND TAKE NON-SKIP RETURN BACK TO CALLER

;HERE WHEN THE PAGE FAULT IS A WRITE VIOLATION

USRFL9:	PUSH	P,T1		;SAVE T1
	LDB	T1,[POINT 9,T3,17]	;VIRTUAL PAGE NUMBER
	MOVE	T3,T4		;SAVE PC
	PUSHJ	P,TPWHS		;PAGE IN WRITABLE HI SEG?
	  CAIA			;YES
	JRST	TPOPJ##		;NO, ERROR RETURN TO CALLER
	PUSHJ	P,GTPME		;GET MAP CONTENTS
	TDO	T2,[PM.WRT]	;MAKE THE PAGE WRITABLE
	DPB	T2,T4
	PUSH	P,T3		;SAVE T3 ON STACK, DON'T WORRY ABOUT
				;LEAVING POINTER MESSED UP
USRFLX:	CLRPGT	(P4)
;	JRST	UFLTRT		;TRY, TRY AGAIN

;HERE TO RETURN TO USER, PC ON STACK SO WE CAN SWITCH BACK TO HIS ACS

UFLTRT:	POP	P,.USMUP	;PUT PC BACK FROM WHENCE IT CAME
	USERAC			;GIVE HIM BACK HIS ACS
IFN FTKLP,<
	JRST @[0,,.+1]		;BACK TO SECTION 0
>
	JEN	@.USMUP		;RETURN TO USER
GETPFH:
	PUSH	P,T3		;SAVE T3
	MOVSI	T1,(UP.MPF)
	IORM	T1,.USBTS
	MOVSI	T1,'PFH'	;GO GET SYS:PFH.VMX
	MOVEI	T2,0		;TOP LOC = -1
	PUSHJ	P,GETXXX	;LOAD PFH
	  JRST	[POP P,(P)	;CANT GET IT -ERROR
		PUSHJ P,CNGPFH
		JRST USRFL8]
	MOVSI	T1,(UP.MPF)
	ANDCAM	T1,.USBTS
	MOVEM	T2,.JDAT+.JBPFH## ;SAVE TOP,,START
	MOVSI	T3,(UP.MGP)	;INDICATE MONITOR GOT PFH
	IORM	T3,.USBTS
	PUSHJ	P,EXOPFH	;SEE IF PFH SHOULD BE CONCEALED
	POP	P,T3		;RESTORE T3
	HRRZS	.USFFT		;FIRST FAULT TIME = 0
	MOVE	T1,MAXINT##	;PRETEND NO FAULTS FOR A LONG TIME
	HRLZM	T1,JBTVRT##(J)	; TO ALLOW SEVERAL FAULTS TO GET
				; THE PROGRAM STARTED UP.
	LDB	T1,[POINT 9,T3,17] ;VIRTUAL PAGE
	LSH	T1,P2WLSH##	;CONVERT TO AN ADR
	MOVE	T2,.JDAT+.JBPFH## ;RESTORE T2
	HLRZ	T4,T2		;TOP OF PFH
	CAIL	T1,(T2)		;WAS FAULT FOR AN ADR WHICH WE HAVE CHANGED
	CAILE	T1,(T4)		; BY READING PFH OVER IT?
	JRST	USRFL3		;NO, CONTINUE
	TRNN	T3,20		;YES, WAS IT A UUO?
	JRST	USRFLX		;NO, GO READ CURRENT CONTENTS
	JRST	USRFL8		;YES, UUO ERROR


;HERE TO READ SYS:DDT.VMX
GETDDT::GETPC	T1,USRPC##
	TLNN	T1,(XC.USR)
	GETPC	T1,.JDAT+JOBPD1##
	MOVEM	T1,.JDAT+JOBOPC##
	PJSP	T2,MSTART##	;SET UP ACS
;
	JSP	T1,MONSTR##	;START JOB
	MOVE	T1,[SIXBIT /VMDDT/] ;LOAD SYS:VMDDT.EXE
	MOVEI	T2,700000	;WHERE TO PUT IT
	PUSHJ	P,GETXXX	;GO GET IT
	PUSHJ	P,CNGDDT
	JUMPN	T2,GETDD2	;JUMP IF GOT DDT
	PUSHJ	P,TTYFUW##	;MAKE SURE TTY ATTACHED FOR ERROR MSG
	PUSHJ	P,PPQCRL##	;PRINT CRLF ?
	JRST	URUNSB##	;
GETDD2:	MOVEM	T2,.JDAT+JOBDDT## ;SAVE L(DDT) IF WE WON
	MOVEM	T2,USRDDT##	;AND IN PROTECTED AREA
	PUSHJ	P,CHKMED##	;SET MEDDLE SO CAN'T CHANGE SHARABLE HIGH SEGMENT
	JRST	STARTU##	;START AT DDT OR "NO START ADR"
;SUBROUTINE CALLED BY THE SWAPPER TO MAKE PFH CONCEALED
SXOPFH::PUSHJ	P,SVEUB##	;MAKE ADDRESSABLE
	HRRZ	T1,.JDAT+.JBPFH## ;START OF PFH
	JUMPE	T1,CPOPJ##	;RETURN IF PFH ISN'T AROUND
	HLRZ	T2,.JDAT+.JBPFH## ;HIGHEST ADDRESS IN PFH
	CAML	T2,T1		;TOP .GT. START?
	PUSHJ	P,ZRNGE		;IN CORE AND LEGAL?
	  POPJ	P,		;NO, SKIP IT
	MOVE	T3,.JDAT+.JBPFH## ;TOP,,START
	PUSHJ	P,CKHSO		;CAN'T BE HI SEG PAGES EITHER
	  POPJ	P,		;FORGET IT
	MOVE	T2,T3		;T2 GETS (.JBPFH)
;YES, FALL INTO EXOPFH
;SUBROUTINE TO SEE IF PFH SHOULD BE CONCEALED
EXOPFH::MOVEI	T1,JS.XO	;EXECUTE ONLY BIT
	MOVSI	T3,(UP.MGP)	;MONITOR GOT PFH BIT
	TDNE	T3,.USBTS	;FROM SYS?
	TDNN	T1,JBTSTS##(J)	;IS THIS AN EXECUTE ONLY PROGRAM?
	POPJ	P,		;NO
	SKIPLE	T1,JBTSGN##(J)	;JOB HAVE A HI-SEG?
	TLNN	T1,GTSSEG	;AND WILL IT BE CONCEALED?
	POPJ	P,		;NO, FORGET IT
	HLRZ	T3,T2		;HIGHEST ADDRESS IN PFH
	SUBI	T3,(T2)		;LENGTH OF PFH
	TRZ	T3,PG.BDY##	;AND OUT LOW BITS
	ADDI	T3,PAGSIZ##	;ROUND UP
	LSH	T3,W2PLSH##	;LENGTH OF PFH IN PAGES
	HRRZ	T1,T2		;STARTING ADDRESS OF PFH
	LSH	T1,W2PLSH##	;STARTING PAGE NUMBER
EXOPF1:	PUSHJ	P,GTPME		;GET CONTENTS OF MAP SLOT
	TDZ	T2,[PM.PUB]	;MAKE THE PAGE CONCEALED
	DPB	T2,T4		;STORE IT BACK IN THE MAP
	SOSLE	T3		;DONE ALL OF PFH'S PAGES?
	AOJA	T1,EXOPF1	;NO, LOOP OVER ALL PAGES
	POPJ	P,		;RETURN
;SUBROUTINE TO TEST AND REMOVE PFH IF FROM SYS
RMVPFH::MOVSI	T1,(UP.MGP)
	SKIPE	T3,.JDAT+.JBPFH## ;IS THERE A PFH?
	TDNN	T1,.USBTS	;YES, FROM SYS?
	POPJ	P,		;NO, DONT DO ANYTHING
	PUSHJ	P,CKHSO
	  POPJ	P,
	ANDCAM	T1,.USBTS	;YES, CLEAR THE BIT
	PUSHJ	P,SAVE1##
	LDB	P1,[POINT 9,T3,8] ;LAST PAGE OF PFH
	LDB	T1,[POINT 9,T3,26] ;FIRST PAGE OF PFH
	JUMPE	T1,CPOPJ##
	CAMGE	P1,T1		;TOP .GE. START?
	POPJ	P,		;NO, FORGET IT
IFN FTMP,<
	PUSHJ	P,GGVMM##
>
	PUSH	P,U		;SAVE U FOR COMCON
	MOVE	R,JBTADR##(J)	;MAY NOT BE SETUP
RMVPF1:	PUSHJ	P,GTPME		;GET MAP CONTENTS
	JUMPE	T2,RMVPF1	;FORGET IT IF NO PAGE THERE
	PUSH	P,T1
	PUSHJ	P,DLTPAG	;GIVE BACK THE PAGE
	PUSHJ	P,DCVMT
	POP	P,T1
RMVPF2:	CAIGE	T1,(P1)		;DONE?
	AOJA	T1,RMVPF1	;NO, RETURN NEXT PAGE
	LDB	T1,[POINT 9,R,8] ;YES, GET NEW SIZE
	DPB	T1,JBYLSS##	;SAVE IN JBTUPM
	SETZM	.JDAT+.JBPFH##	;NOW NO PFH
	SETZM	.USTMC
	SETZM	.USTMI
	MOVEM	R,.CPADR##	;YES, ADJUST .CPREL, .CPADR
	HLRZM	R,.CPREL##
	HLRZM	R,.USHVA	;FOR ADDRESS CHECKING AT INTERRUPT LEVEL
	PJRST	UPOPJ##		;AND RETURN

;SUBROUTINE TO SAY "CAN NOT GET DDT"
CNGDDT:	SKIPA	T1,[SIXBIT /DDT/]
;DITTO FOR PFH
CNGPFH:	MOVSI	T1,'PFH'	;WHAT WE COULDN'T GET
	PUSH	P,U		;SAVE POSSIBLE LDB POINTER
	PUSH	P,T1		;SAVE 'XXX'
	PUSHJ	P,TTYSRC##	;FIND THE TTY
	  JRST	CNGXX1		;WHOOPS! FORGET IT
	MOVEI	T1,[ASCIZ "?
?Can not get "]
	PUSHJ	P,CONMES##	;TYPE "?CAN NOT GET"
	MOVE	T2,(P)		;RESTORE "XXX"
	PUSHJ	P,PRNAME##	;PRINT "PFH" OR "DDT" AND RETURN WITH T2=0 
CNGXX1:	POP	P,T1		;RESTORE T1
	JRST	UPOPJ##		;AND RETURN
;SUBROUTINE TO GET XXX.VMX
;CALLING SEQUENCE:
;	MOVE	T1,[SIXBIT/XXX/]
;	MOVEI	T2,WHERE TO PUT IT OR 0 IF AT THE TOP OF CORE
;	PUSHJ	P,GETXXX
;RETURNS CPOPJ ON ERROR
;RETURNS CPOPJ1 ON SUCCESS, T2 = HIGHEST ADDRESS READ INTO,,START ADDRESS
;ENTER AT MAKPGS TO CREATE PAGES, T2 = WHERE, T3 = HOW MANY

MAKPGS:	MOVEI	T1,0		;FLAG CREATING PAGES
	ANDI	T2,777000	;MAKE SURE IT STARTS AT PAGE BOUNDARY
	LSH	T3,P2WLSH##	;NUMBER OF WORDS TO MAKE
	MOVNS	T3		;-N
	HRLZM	T3,.JDAT+SGALEN## ;FAKE OUT LOOKUP STUFF
GETXXX:	MOVEI	T3,.USUAC;SAVE THE CURRENT EXEC ACS
	EXCTUX	<BLT T3,.USUAC+17>
	PUSHJ	P,SETASA##	;GET ARGUMENTS FROM SHADOW ACS
	PUSH	P,T2		;SAVE WHERE TO PUT IT
	PUSH	P,USRJDA##	;SAVE USER CHAN 0
	SETZM	USRJDA##	;DONT RELEASE WHEN WE INIT
IFE FTEXE,<
	MOVSI	T2,'VMX'	;XXX.VMX
>
IFN FTEXE,<
	MOVSI	T2,'EXE'
>
	DMOVEM	T1,.JDAT+SGANAM## ;INTO LOOKUP BLOCK
	JUMPE	T1,GETXX1	;SKIP THE LOOKUP IF MAKPGS
	MOVEI	T1,D		;INIT SYS: IN DUMP MODE
	MOVE	T2,[JACCT,,JS.XO]
	TDNE	T2,JBTSTS##(J)
	TLO	T1,PHONLY
	MOVSI	T2,'SYS'
	DMOVEM	T1,.JDAT+SGAMOD##
	SETZM	.JDAT+SGAHED##
	OPEN	SGAMOD##
	  JRST	GETXX9		;CANT INIT SYS:
	SETZM	.JDAT+SGALEN##
	LOOKUP	SGANAM##	;LOOKUP XXX.VMX
	  SKIPA	T1,[PHONLY,,DR]
	JRST	GETXX0
	MOVEM	T1,.JDAT+SGAMOD##
GETXX0:
IFN FTEXE,<
	SKIPL	.JDAT+SGAMOD##	;PHYSICAL ONLY?
	TDZA	T3,T3		;NO
	MOVEI	T3,UPHNLY	;YES, PHONLY
	MOVE	T1,.JDAT+SGANAM## ;FILE NAME
	MOVEM	T1,.JDAT+SGADEV##+1 ;STORE THAT IN THE MERGE ARGUMENT BLOCK
	DMOVE	T1,[SGADEV##	;POINTER TO ARGUMENT LIST
		    SIXBIT /SYS/] ;DEVICE
	DMOVEM	T1,.JDAT+SGADEV##-1 ;STORE THOSE IN THE MERGE ARGUMENT BLOCK
	SETZB	T1,T2		;ZERO WORDS 2,3,4,5
	DMOVEM	T1,.JDAT+SGADEV##+2 ;..
	DMOVEM	T1,.JDAT+SGADEV##+4 ;..
	PUSHJ	P,VJSIZ		;CURRENT SIZE OF THE PROGRAM
	PUSH	P,T4		;SAVE THAT
	PUSH	P,.JDAT+JOBPD1##;SAVE JOBPD1
	SETZM	.JDAT+JOBPD1##	;SO IT WON'T LOOK LIKE A USER MODE UUO
	MERGE.	10,(T3)		;MERGE XXX.EXE INTO THE ADDRESS SPACE
	  JRST	[POP	P,(P)	;FAILED
		 JRST	GETXX9]	;CAN'T GET XXX
	POP	P,.JDAT+JOBPD1##;RESTORE JOBPD1
	PUSHJ	P,VJSIZ		;SIZE OF THE PROGRAM AFTER THE MERGE
	POP	P,T1		;SIZE BEFORE THE MERGE
	SUB	T4,T1		;INCREASE IN SIZE
	LSH	T4,P2WLSH##	;CONVERT TO NUMBER OF WORDS
	SKIPE	T2,-1(P)	;WHERE TO PUT IT SPECIFIED?
	JRST	GETX0A		;YES
	MOVSI	T2,1		;NO. AT TOP OF ADDRESS SPACE
	SUB	T2,T4		;ORGIN
GETX0A:	HRLS	T2		;ORGIN TO THE LEFT HALF
	ADDI	T2,-1(T4)	;HIGHEST ADDRESS
	MOVSM	T2,-1(P)	;STORE HIGHEST ADDRESS,,ORGIN FOR RETURN
	AOS	-2(P)		;GOOD RETURN
	JRST	GETX10		;RESTORE THE WORLD AND EXIT
>
GETXX1:	MOVE	J,.CPJOB##	;RESTORE J
	HLRE	T3,.JDAT+SGALEN## ;LENGTH OF FILE
	JUMPGE	T3,GETXX9	;BETTER BE NEGATIVE
	MOVNS	T3		;+LENGTH
	ADDI	T3,PG.BDY##	;CONVERT TO REQUIRED NO OF PAGES
	LSH	T3,W2PLSH##
	CAILE	T3,7		;WILL PAGE. ARG LIST FIT IN ACS?
	JRST	GETXX9		;FILE TOO BIG, CANT READ IT IN
	MOVN	T4,T3		;-NO OF PAGES IN T4
	MOVEI	T2,0		;DECREASING BY 0 PAGES
	PUSHJ	P,SZCHK		;CAN WE GET ENOUGH NEW PAGES?
	  SKIPA	T2,[400000,,1]	;NO, HAVE TO PAGE SOME STUFF OUT
	JRST	GETXX5		;YES, JUST CREATE THE NEW PAGES
	MOVSI	T1,200000	;START AT PAGE 1
	HRLI	T4,.JDAT+SGAPPN##+1 ;WHERE TO STORE ARGS TO PAGEB
	MOVSS	T4		;AOBJN WORD FOR STORING PAGE NOS
	MOVEI	T3,0		;START AT BEGINNING
GETXX2:	TDNN	T1,WSBTAB(T3)	;THIS PAGE IN CORE?
	JRST	GETXX3		;NO
	MOVEM	T2,(T4)		;YES, SAVE ITS NUMBER
	AOBJP	T4,GETXX4	;GO IF HAVE ENOUGH PAGES TO PAGE OUT
GETXX3:	ADDI	T2,1		;STEP TO NEXT PAGE
	TRNE	T2,777000	;REACHED UPMP?
	JRST	GETXX4		;YES, PAGE OUT WHAT WE FOUND
	ROT	T1,-1		;WSBTAB BIT FOR NEXT PAGE
	JUMPG	T1,GETXX2	;GO TEST THAT PAGE
	AOJA	T3,GETXX2	;IN NEXT WSBTAB WORD
GETXX4:	SUBI	T4,.JDAT+SGAPPN##+1 ;NUMBER OF PAGES WE FOUND TO PAGE OUT
	HRRZM	T4,.JDAT+SGAPPN## ;STORE AS ARGUMENT TO PAGEB
	MOVEI	T1,SGAPPN##	;PAGE OUT
	MOVEM	T1,.JDAT+17
	PAGE.	17,		;PAGE OUT SOME PAGES
	  JRST	GETXX9		;CANT DO IT - TOUGH
GETXX5:	HLRE	T1,.JDAT+SGALEN## ;NO OF PAGES TO CREATE
	SKIPE	T2,-1(P)	;WHERE TO CREATE THEM
	JRST	GETXX6
	MOVSI	T2,1		;AT TOP OF CORE - FIND REAL START
	ADD	T2,T1		;START ADR
	TRZ	T2,PG.BDY##	;START PAGE
	HRRZM	T2,-1(P)	;SAVE ON LIST AS START LOC
GETXX6:	SUBM	T2,T1		;TOP ADDRESS
	SUBI	T1,1
	HRLM	T1,-1(P)	;TOP ADR,,START ADR
	MOVE	T3,-1(P)
	PUSHJ	P,CKHSO
	  JRST	GETXX9
	SUBI	T1,-1(T2)	;NUMBER OF WORDS NEEDED
	ADDI	T1,PG.BDY##	;ROUND UP
	LSHC	T1,W2PLSH##	;NUMBER OF PAGES AND START PAGE
	MOVEM	T1,.JDAT+SGAPPN## ;SAVE NUMBER OF PAGES
	MOVEI	T3,.JDAT+SGAPPN##+1 ;WHERE TO STORE NEEDED PAGE NUMBERS
GETXX7:	HRRZM	T2,(T3)		;SAVE NEEDED PAGE NUMBER
	SOJLE	T1,GETXX8	;GO IF HAVE ENOUGH
	ADDI	T3,1		;WHERE TO STORE NEXT PAGE NUMBER
	AOJA	T2,GETXX7	;BUMP THE PAGE NO AND CONTINUE
GETXX8:	MOVE	T1,[1,,SGAPPN##]
	MOVEM	T1,.JDAT+17	;CREATE PAGES
	PAGE.	17,
	  JRST	GETXX9		;CANT CREATE THE PAGES - TOUGH LUCK
	SKIPN	.JDAT+SGANAM##	;MAKPGS?
	JRST	[AOS -2(P)	;YES, DONE
		 JRST GETX10]
IFE FTEXE,<
	MOVE	T1,-1(P)	;NO, GET TOP,,START
	SUBI	T1,1		;MAKE AN IOWD
	HLL	T1,.JDAT+SGALEN##
	MOVEM	T1,.JDAT+SGAMOD## ;IO LIST IN CORE
	SETZM	.JDAT+SGADEV##	;TERMINATE THE LIST
	IN	SGAMOD##	;READ THE FILE
	  AOS	-2(P)		;NO ERRORS, SKIP RETURN
>
GETXX9:	CLOSE	CLSNMB		;CLOSE THE FILE
	RELEASE			;GET RID OF THE DDB
GETX10:	MOVE	J,.CPJOB##	;RESOTRE J
	PUSHJ	P,CLRASA##	;CLEAR JS.ASA IN JBTSTS
	MOVSI	T2,.USUAC ;RESTORE THE EXEC ACS ON ENTRY
	EXCTXU	<BLT T2,17>
	POP	P,USRJDA##	;RESTORE USER'S CHAN 0
	JRST	T2POPJ##	;RESTORE T2 AND RETURN
	SUBTTL	PAGE. UUO

UPAGE.::HLRZ	U,T1		;FUNCTION IN U
	CAIL	U,NPGUUO	;IS IT A LEGAL FUNCTION?
	JRST	UIFERR		;NO, ILLEGAL ARGUMENT LIST ERROR
	MOVE	U,PAGJMP(U)	;GET DISPATCH ENTRY
	HLRZ	T3,U		;PUT CHECK BITS IN T3
	HRR	M,T1		;ADDRESS OF THE ARGUMENT LIST
	TLNE	U,UU.NCL	;NEGATIVE ARGUMENT LEGAL?
	PUSHJ	P,[PUSH P,T1	;YES
		   PUSHJ P,GETWDU##
		   JUMPGE T1,TPOPJ ;GO IF NOT NEGATIVE
		   PUSHJ P,GETWD1## ;NEXT ARGUMENT MUST BE IN CORE
		   POP P,T1
		   POP P,(P)	;POP OFF CALL
		   SOJA M,UPAGE0] ;CHECK IF IT CAN BE DONE IF LOCKED
	HRRZS	T1		;CLEAR FUNCTION FROM LEFT HALF
	PUSHJ	P,UUOCHK	;INSURE THAT ALL ITEMS IN THE ARGUMENT LIST
				; ARE IN CORE
UPAGE0:	TLNN	U,UU.NAL	;IS THIS FUNCTION ALLOWED IF THE JOB IS LOCKED?
	JRST	UPAGE1		;YES, PROCEED
	MOVSI	T1,NSHF!NSWP	;LOCKED BITS
	SKIPLE	T2,JBTSGN##(J)	;DOES THIS JOB HAVE A HIGH SEGMENT?
	TLNE	T2,SHRSEG	;YES, IS IT SHARABLE?
	MOVEI	T2,0		;NO, SET HIGH SEGMENT NUMBER TO ZERO
	TDNN	T1,JBTSTS##(J)	;IS THE LOW SEGMENT LOCKED?
	TDNE	T1,JBTSTS##(T2)	;IS THE HIGH SEGMENT LOCKED?
	JRST	IILERR		;YES, ILLEGAL IF LOCKED ERROR
UPAGE1:
IFN	FTDHIA,<
	PUSHJ	P,MIGWAT	;MAKE SURE WORKING SET DOESN'T CHANGE ON US
>
IFN FTMP,<
	TLNN	U,UU.CP1	;CAN THIS UUO BE EXECUTED ON CPU1?
	PUSHJ	P,UPMM##	;NO, INSURE JOB OWNS THE MM RESOURCE
>
	HRRZ	T1,U		;GET SUBR ADDRESS
	CAIN	T1,PAGACC	;PAGE ACCESSIBILITY CHECK?
	JRST	UPAGE2		;YES, DON'T DECODE PAGE NUMBER AS ADDDRESS
	PUSHJ	P,GETWDU##	;GET THE NUMBER OF ARGUMENTS
	TLNE	U,UU.NCL	;IF NEGATIVE COUNT IS LEGAL,
	MOVMS	T1		;POSITIVE ARGUMENT COUNT
	HRLI	T1,1(M)		;LEFT HALF OF T1 POINTS AT THE FIRST ARGUMENT
	MOVSS	T1		;T1 = NUMBER OF ARGUMENTS,,ADDRESS OF FIRST ARGUMENT
UPAGE2:
	PUSH	P,U		;SAVE DISPATCH BITS
	PUSHJ	P,(U)		;DISPATCH TO PERFORM REQUESTED FUNCTION
IFE FTMP,<
	  PJRST	UPOPJ##		;ERROR RETURN - GIVE ERROR RETURN TO USER
>
IFN FTMP,<
	  JRST	[PUSHJ P,TGVMM##;OWN THE MM RESOURCE?
		 PJRST UPOPJ##]	;POP OFF U AND GIVE ERROR RETURN
				;SET JBTHSA
>
	PUSHJ	P,SETHSA
IFN FTMP,<
	PUSHJ	P,TGVMM##	;OWN THE MM?
>
	POP	P,U		;RESTORE DISPATCH BITS
	GETPC	T2,.JDAT+JOBPD1## ;GET USER PC
	TLNE	U,UU.WCC	;CAN THIS UUO CAUSE THE W.S. TO CHANGE
	PUSHJ	P,INPFH		;YES, PFH DOING THIS UUO?
	  PJRST	CPOPJ1##	;DON'T INDICATE W.S. HAS CHANGED
	MOVSI	T1,(UP.WHC)	;WORKING SET HAS CHANGED BIT
	IORM	T1,.USBTS	;REMEMBER THAT
	PJRST	CPOPJ1##	;SKIP RETURN TO THE USER
;PAGE. UUO DISPATCH TABLE

PAGJMP:	UU.NCL+UU.NAL+UU.LER+UU.WCC,,PAGEB   ;(0) PAGE IN/OUT
	UU.NCL+UU.NAL+UU.LER+UU.WCC,,CHGPGS  ;(1) CREATE/DESTROY PAGES
	UU.NCL+UU.NAL+UU.LER,,MOVPGS	;(2) MOVE/EXCHANGE PAGES
	UU.NCL+UU.LER,,SETAAB		;(3) SET/CLEAR ACCESS ALLOWED BITS
	UU.CP1+UU.LER,,GETWSB	;(4) GET WORKING SET BIT TABLE
	UU.CP1+UU.LER,,GETAAB	;(5) GET ACCESS ALLOWED BIT TABLE
	UU.CP1,,PAGACC		;(6) CHECK PAGE ACCESSABILITY
	UU.NAL+UU.LER+UU.WCC+UU.CP1,,GREMAP	;(7)GENERALIZED REMAP
				; UU.CP1 SO NREMAP CAN GET MM BY HAND

IFN FTKL10!FTKS10&FTLOCK,<
	UU.NCL+UU.LER+UU.CP1,,SETCSB	;(10) SET/CLEAR CACHE BITS
>
IFE FTKL10!FTKS10&FTLOCK,<
	UU.LER+UU.CP1,,UIFERR	;(10) NOT IMPLEMENTED
>
IFN FTPEEKSPY,<
	UU.NCL+UU.LER,,SPYPGS		;(11) SPY ON PAGES
>
IFE FTPEEKSPY,<
	UU.LER,,UIFERR		;(11) NOT IMPLEMENTED
>
NPGUUO==.-PAGJMP

HSPAG==200000			;PLTSN SETS IF PAGE IS IN A HIGH SEGMENT
ARGMD==100000			;ARGUMENT MODIFIER, SET BY PLTSN IF ANY AGRUMENT
				; HAS 1B1=1

;HERE TO DETERMINE PAGE ACCESSABILITY

PAGACC:	PUSHJ	P,GETTAC##	;GET THE CONTENTS OF THE USER'S AC
	HRRZS	T1		;GET PAGE NUMBER IN QUESTION
	CAILE	T1,HLGPNO	;IS IT LEGAL?
	JRST	ILPERR		;NO
	PUSHJ	P,PAGAC0	;GET THE PAGE BITS
	PJRST	STOTC1##	;STORE THE RESULTS AND RETURN TO THE USER

;SUBROUTINE TO GET THE PAGE ACCESSABILITY BITS
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,GETPAC
;	HERE WITH BITS IN T1
;
GETPAC::MOVE	J,.CPJOB##	;JOB NUMBER
	HRRZS	T1		;PAGE NUMBER THAT THE USER IS INTERESTED IN
	CAILE	T1,HLGPNO	;PAGE NUMBER SPECIFIED .LE. HIGHEST LEGAL PAGE?
	JRST	PAGAC6		;NON-EXISTENT
PAGAC0:	MOVEI	U,0		;ASSUME THE PAGE DOESN'T EXIST
	PUSHJ	P,GTPME		;GET CONTENTS OF THE MAP
	JUMPE	T2,PAGAC6	;NON-EXISTENT
	CAIN	T2,PM.ZER	;IS THE PAGE ALLOCATED BUT ZERO?
	TLO	U,(PA.ZER)	;ZERO PAGE
	MOVE	T3,T2		;SAVE THE MAP ENTRY
	PUSHJ	P,TSWST		;IS THE PAGE IN THE WORKING SET?
	  TLO	U,(PA.OUT)	;NO, INDICATE THAT THE PAGE IS PAGED-OUT
	TDNE	T2,AABTAB(T4)	;IS THE ACCESS ALLOWED BIT SET FOR THIS PAGE?
	TLO	U,(PA.AA)	;YES, INDICATE ACCESS IS ALLOWED
IFN	FTKL10!FTKS10,<
	TLNE	U,(PA.OUT)	;IN MEMORY?
	JRST	PAGAC1		;NO - MUST BE CACHED
	TDNN	T3,[PM.CSH]	;YES - CACHE TURNED OFF?
	TLO	U,(PA.NCS)	;YES, TELL USER NOT CACHED
>	;END OF FTKL10
PAGAC1:
IFN FTPEEKSPY,<
	MOVEI	T3,0		;ASSUME A SPY PAGE
	PUSHJ	P,TSSPT		;IS IT?
	  SKIPA	T3,JBTSGN##(J)	;NO, GET HIGH SEG STATUS
	JRST	PAGA1A		;YES
>
IFE FTPEEKSPY,<
	MOVE	T3,JBTSGN##(J)
>
	JUMPE	T3,PAGAC2	;IF NO HI SEG AND NOT SPY PAGE, MUST BE WRITEABLE
	PUSHJ	P,TPAHS		;SEE IF PAGE IS IN HIGH SEG
	  TLOA	U,(PA.GHI)	;IT IS, FLAG AS SUCH
	JRST	PAGAC2		;LOW SEGMENT ERGO WRITEABLE
	TLNE	T3,SPYSEG	;HIGH SEG ACTUALLY SPY SEG?
PAGA1A:	TLOA	U,(PA.GSP!PA.CPO) ;YES, TELL USER
	TLNE	T3,SHRSEG	;CAN PAGE BE SHARED WITH ANYONE ELSE?
	TLO	U,(PA.GSH!PA.CPO) ;YES, FLAG IT AS SHARABLE
	TLNE	T3,UWPOFF	;UWP OFF (I.E.,WRITE-ENABLED)?
PAGAC2:	TLO	U,(PA.WRT)	;YES, PAGE IS CONTAINED IN THE HIGH SEGMENT AND THE
				; HIGH SEGMENT IS WRITABLE SO THE PAGE IS WRITABLE
	GETPC	T4,.JDAT+JOBPD1## ;PC OF THE PAGE ACCESSABILITY UUO
	TLNN	T4,(IC.LIP)	;UUO DONE FROM A CONCEALED PAGE?
	JRST	PAGAC5		;YES, PAGE CAN BE READ
	PUSHJ	P,GTPME		;CONTENTS OF THE MAP
	TDNE	T2,[PM.PUB]	;A PUBLIC PAGE?
	JRST	PAGAC5		;THEN THE PAGE CAN BE READ
	TLNN	U,(PA.OUT)
	CAIN	T2,PM.ZER	;IF NOT ABZ,
	CAIA
	JRST	PAGAC4		;PAGE CANNOT BE READ
	SKIPLE	T2,JBTSGN##(J)	;JOB HAVE A HI-SEG?
	TLNN	T2,GTSSEG	;WAS IT GETSEGED?
	JRST	PAGAC5		;NO, PAGE CAN BE READ
	TLNE	U,(PA.GHI)	;IS THE TARGET PAGE IN THE HI SEG?
PAGAC4:	TLZA	U,(PA.RED!PA.WRT);  YES, PAGE CANNOT BE READ
PAGAC5:	TLO	U,(PA.RED)	;HERE IF PAGE CAN BE READ
	SKIPE	T1		;PAGE 0?
	TLNE	U,(PA.GSH!PA.GSP) ; OR SPY OR SHARABLE HISEG?
	TLOA	U,(PA.CPO!PA.AA);YES - NEVER PAGEABLE, ACCESS ALWAYS ALLOWED
	SKIPA			;NO
	TLZ	U,(PA.OUT)	;YES - ALSO NEVER PAGED OUT
	TLNE	U,(PA.GSP)	;SPYING?
	JRST	PAGAC7		;YES - "LOCK" MEANINGLESS
	MOVSI	T2,NSHF!NSWP	;LOCKED BITS
	TLNN	U,(PA.GHI)	;IS IT A HIGH-SEGMENT PAGE
	SKIPA	T4,J		;NO, GET IT'S LOW SEG "NUMBER"
	HRRZ	T4,JBTSGN##(J)	;YES, GET ITS HIGH SEG "NUMBER"
	TDNE	T2,JBTSTS##(T4)	;IS PAGE IN LOCKED SEGMENT
	TLO	U,(PA.LCK!PA.CPO)	;YES, THEN ALSO CAN'T BE PAGED OUT
PAGAC7:	SKIPA	T1,U		;YES, THEN IT CANNOT BE PAGED OUT
PAGAC6:	MOVSI	T1,(PA.NXP)	;PAGE IS NON-EXISTANT
	POPJ	P,		;RETURN

;HERE TO SET/CLEAR CACHE BITS IN THE LOW SEGMENT OF 
; A LOCKED JOB

IFN <FTKL10!FTKS10>&FTLOCK,<
SETCSB:	MOVSI	T2,NSHF!NSWP	;JOB MUST BE LOCKED
	TDNN	T2,JBTSTS##(J)	;IS IT?
	JRST	UIFERR		;NOT IMPLEMENTED FOR JOBS NOT LOCKED
	MOVEI	T2,PA.IHB+PA.PME	;CHECK ARGUMENT LIST (PAGE MUST EXIST)
	PUSHJ	P,PLTSN		;VERIFY LIST
	  POPJ	P,		;BAD ARGUMENT LIST
	TLNE	M,HSPAG		;A HIGH SEGMENT PAGE SEEN?
	JRST	UIFERR		;YES, NOT IMPLEMENTED FOR HIGH SEGMENTS
	ADD	T3,T2		;TOTAL NUMBER OF PAGES IN THE ARGUMENT LIST
	PUSHJ	P,FSTPAG	;POINT M AT FIRST ARGUMENT - 1
SETCS1:	PUSHJ	P,NXTPAG	;NEXT ARGUMENT
	PUSHJ	P,GTPME		;GET MAP ENTRY
	TLNE	T1,400000	;SET OR CLEAR THE CACHE BIT?
	TDOA	T2,[PM.CSH]	;SET IT
	TDZ	T2,[PM.CSH]	;CLEAR IT
	DPB	T2,T4		;STORE IT BACK IN THE MAP
	SOJG	T3,SETCS1	;LOOP OVER THE ENTIRE ARGUMENT LIST
	PUSHJ	P,CSDMP##	;FLUSH THE CACHE
	JRST	FIXMJ1		;CLEAR PAGING MEMORY AND RETURN
>
;HERE TO PAGE IN/OUT PAGES
PAGEB:	MOVEI	T2,PA.PME+PA.PMI+PA.PCI
	PUSHJ	P,PLTSN		;VERIFY THE ARGUMENT LIST (PAGE MUST EXIST
				; AND FOR PAGING OUT MUST BE IN CORE, FOR
				; PAGING IN THE PAGE MUST NOT BE IN CORE)
	  POPJ	P,		;ERROR IN THE ARGUMENT LIST
	PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSHJ	P,FSTPAG	;POINT M AT FIRST ARGUMENT - 1
	PUSHJ	P,SZCHK		;MAKE SURE THAT AFTER PAGING OUT THE REQUESTED PAGES
				; THAT PAGING IN THE REQUESTED PAGES WON'T EXCEED
				; THE USER'S PHYSICAL LIMIT
	  PJRST	TBGERR		;USER IS ATTEMPTING TO GET TO BIG
	JUMPN	T2,[HLRZ T4,.PDMVL##(W)
		    JUMPE T4,TBGERR
		    JRST .+1]
	PUSH	P,T3		;SAVE THE NUMBER OF PAGES TO PAGE-IN
	PUSH	P,T2		;AND THE NUMBER OF PAGES TO PAGE-OUT
	MOVE	P1,T2		;TOTAL NUMBER OF PAGES TO XFER
	ADD	P1,T3
	PUSHJ	P,USRATE	;COMPUTE PAGING INTERVAL
	MOVE	T1,UPTIME##
	SUB	T1,LSFTIM##	;COMPUTE SYSTEM-WIDE PAGING INTERVAL
	IDIVI	T1,(P1)
	IMUL	T1,VMCNST##
	MOVE	T2,JBTVRT##
	IMUL	T2,VMCDIF##
	ADD	T1,T2
	IDIV	T1,VMCEXP##
	MOVEM	T1,JBTVRT##	;SAVE SYSTEM-WIDE INTERVAL
	MOVE	T2,UPTIME##	;SAVE LAST FAULT TIME
	MOVEM	T2,LSFTIM##
	MOVE	T1,TICSEC##	;HAS HE GOT A VIRTUAL TIMER RUNNING?
	SKIPN	.USTMC
	MOVEM	T1,.USTMC	;NO, GET TIME INTERRUPTS ANYWAY
;HERE TO GET SWAPPING SPACE
	MOVE	U,(P)		;NUMBER OF PAGES OF DISK SPACE TO ALLOCATE
				; FOR PAGING OUT PAGES
	JUMPE	U,PAGEB6	;IF NO PAGES TO PAGE-OUT PROCEED WITH PAGING IN
	TLNE	M,ARGMD		;IS THE SPACE TO BE ALLOCATED ON THE SLOWER
				; SWAPPING DEVICES?
	TLO	U,(PG.SLO)	;YES, INDICATE THAT TO SWPSER
	PUSHJ	P,SWPSPC##	;GET ENOUGH PAGES OF SWAPPING SPACE TO SATISFY
				; THIS PAGE-OUT REQUEST
	  JRST	[PUSHJ P,NSAERR
		JRST PLTSN8]	;NOT ENOUGH AVAILABLE
	SETZB	P3,P4		;INDICATE FIRST CALL TO PAGOMT
	TRZE	T1,FRGSEG	;WAS THE SWAPPING SPACE ALLOCATED CONTIGOUSLY?
	JRST	PAGEB1		;NO, FRAGMENTED
	MOVN	U,(P)		;NEGATIVE NUMBER OF PAGES TO GO OUT
	HRLI	U,(T1)		;STARTING DISK ADDRESS
	MOVSS	U		;MAKE AN AOBJN POINTER
	PUSHJ	P,PAGOMT	;SETUP MEMTAB FOR PAGING OUT THE PAGES INDICATED
				; BY THE USER
	MOVE	T1,(P)		;P4 = PRED OF RH,,PHYS 1ST PAGE OUT
	DPB	P3,[POINT 13,T1,26]
	JRST	PAGEB4		;MAKE AN ENTRY IN SWPLST AND START THE PAGING I/O
PAGEB1:	MOVE	P1,T1		;SAVE THE ADDRESS OF THE FRAGMENT TABLE
PAGEB2:	MOVSI	P2,(SL.DIO)	;INDICATE PAGING OUT
	MOVEI	P3,0		;INDICATE FIRST PAGE IN FRAGMENT TO PAGOMT
	PUSHJ	P,NXTFRG	;GET THE ENTRY FROM THE FRAGMENT TABLE
	  JRST	PAGEB3		;ALL DONE
	PUSHJ	P,PAGOMT	;SETUP MEMTAB FOR THIS FRAGMENT
	DPB	P3,[POINT 13,P2,26]
	MOVEM	P2,-1(P1)	;STORE ENTRY DESCRI@ING THIS FRAGMENT
	JRST	PAGEB2		;AND LOOP FOR THE NEXT FRAGMENT
PAGEB3:	HLRZ	T1,JBTSWP##(J)	;ADDRESS OF THE FRAGMENT LIST
	TDC	T1,[FRGSEG,,FRGSEG]
PAGEB4:	TLO	T1,(SL.DIO)	;PAGING OUT
	PUSHJ	P,PGWAIT	;START PAGES OUT AND WAIT UNTIL THEY ARE WRITTEN
	  JRST	[PUSHJ P,PIOERR	
		JRST PLTSN8]	;PAGING I/O ERROR
	HRRZ	P1,T2		;SAVE THE ADDRESS OF THE SWPLST ENTRY
	MOVSI	T1,(UP.PGB)	;AFTER PAGING THE PAGES OUT, WERE THE PAGES
	TDNN	T1,.USBTS
				; RETURNED TO THE FREE CORE LIST BY THE SWAPPER?
				; (HAPPENS IF THE JOB IS SWAPPED WHEN COMMING
				; OUT OF PAGE I/O WAIT)
	JRST	PAGEB5		;YES, DON'T RETURN THE PAGES TO THE FREE CORE LIST
	HRRZ	T1,P4		;T1 = FIRST PAGE PAGED OUT
	PUSHJ	P,[SE1ENT	;ENTER SECTION 1
		   PUSHJ P,GVPAGS## ;RETURN ALL PAGES PAGED OUT TO THE FREE CORE LIST
		   HLRZS P4	;PREDECESSOR TO FIRST PAGE PAGED OUT
		   SSX	P4,MDSEC2 ;PAGTAB SECTION
		   HLLZS PAGTAB(P4) ;INDICATE THAT THIS IS NOW THE LAST PAGE
		   POPJ P,]	; IN THE PAGES ALLOCATED TO THIS JOB
PAGEB5:	PUSHJ	P,DLTSLX	;DELETE THE SWPLST ENTRY
PAGEB6:	POP	P,T2		;RESTORE THE NUMBER OD PAGES TO BE PAGED-OUT
	POP	P,T3		;AND THE NUMBER OF PAGES TO BE PAGED-IN
	JUMPE	T3,FIXMJ1	;CLEAR THE A.M. AND RETURN TO THE USER IF
				; THERE ARE NO PAGES TO BE PAGED OUT
	MOVE	P2,T3		;SAVE THE NUMBER OF PAGES REQUIRED
	PUSHJ	P,FSTPAG	;POINT M AT FIRST ARGUMENT - 1
	PUSHJ	P,FRDCR##	;ENOUGH PAGES IN CORE TO SATISFY THIS REQUEST?
	  JRST	CHGPG8		;NO, ALLOCATE THE SPACE ON THE DISK
	PUSHJ	P,SCPAGS##	;YES, FIND THE LAST PAGE CURRENTLY ALLOCATED TO THE JOB
	MOVE	T2,P2		;SETUP ARGUMENTS TO ADPAGS
	PUSHJ	P,ADPAGS##	;ALLOCATE THE REQUIRED NUMBER OF PAGES
;HERE WITH T1 = FIRST PHYSICAL PAGE ALLOCATED
	MOVEI	P4,0		;INDICATE INITIAL CALL TO PAGIMT
	PUSHJ	P,PAGIMT	;SETUP MEMTAB FOR PAGING INPUT
	  JRST	PAGE10		;PAGES BEING INPUT ARE CONTIGUOUS ON THE DISK
;HERE ON A PAGE IN WHEN THE PAGES ARE FRAGMENTED
	MOVE	P1,P4		;SAVE THE NUMBER OF PAGES IN THIS FRAGMENT
	MOVEI	P4,0		;INDICATE THE START OF A FRAGMENT TABLE
	PUSHJ	P,GT4MR		;GET A 4 WORD CORE BLOCK FOR THIS FRAGMENT
	  JRST	PAGE13		;NO AVAILABLE
	PUSH	P,P4		;SAVE THE START ADDRESS OF THE CORE BLOCK
PAGEB7:	MOVE	P2,P4		;P2 = AN AOBJN POINTER TO THE CURRENT BLOCK
				; IN THE FRAGMENT TABLE
PAGEB8:	DPB	P3,[POINT 13,P1,26]
	MOVEM	P1,(P2)		;STORE THE SWPLST ENTRY FOR THIS FRAGMENT
	JUMPGE	P3,PAGEB9	;JUMP IF THIS IS THE LAST FRAGMENT
	MOVEI	P4,0		;INITIALIZE THE COUNTEROF THE NUMBER OF PAGES
				; IN THIS FRAGMENT
	PUSHJ	P,PAGIMT	;SETUP MEMTAB FOR THIS FRAGMENT
	  TLZ	P3,(MT.LEF)	;INDICATE LAST FRAGMENT
	MOVE	P1,P4		;SAVE THE NUMBER OF PAGES IN FRAGMENT
	AOBJN	P2,PAGEB8	;STORE THE FRAGMENTED SWPLST ENTRY AND CONTINUE
	MOVE	P4,P2		;T4 = POINTER TOFRAGMENT TABLE
	PUSHJ	P,GT4MR		;ADD ANOTHER BLOCK TO THE FRAGMENT TABLA
	  JRST	PAGE12		;NONE AVAILABLE
	JRST	PAGEB7		;CONTINUE
PAGEB9:	SETZM	1(P2)		;ZERO LAST ENTRY + 1 IN FRAGMENT TABLE
	POP	P,T1		;RESTORE THE POINTER TO THE START OF THE
				; FRAGMENT TABLE
	HRLI	T1,FRGSEG	;INDICATE A FRAGMENTED SWPLST ENTRY
	JRST	PAGE11		;MAKE THE ENTRY IN SWPLST AND DO THE I/O
PAGE10:	MOVE	T1,P4		;BUILD A SWPLST ENTRY
	DPB	P3,[POINT 13,T1,26]
PAGE11:	PUSHJ	P,PAGEIT	;PAGE THE PAGES IN
	  JRST	PIOERR		;PAGING I/O ERROR
	SKIPN	T1,.USNXP	 ;IF RANGE SPECIFIED GET HIGHEST PAGE
	PUSHJ	P,GETWDU##	;GET LAST (HIGHEST) PAGE BEING CREATED
	PUSHJ	P,JSTVRT	;ZERO .UPVRT IF NOW NON-VIRTUAL
	PJRST	FIXMJ1		;CLEAR THE A.M. AND RETURN TO THE USER
PAGE12:	POP	P,(P)		;POP OFF JUNK
PAGE13:	HALT	.		;AND RECOVER (NOT IMPLIMENTED)
;SUBROUTINE TO SETUP MEMTAB AND THE UPMP FOR A PAGE IN
;CALLING SEQUENCE:
;	MOVE	T1,FIRST PHYSICAL PAGE ALLOCATED
;	MOVE	M,ADDRESS - 1 OF FIRST PAGE IN THE ARGUMENT LIST
;	MOVEI	P4,0
;	PUSHJ	P,PAGIMT
;RETURNS CPOPJ1 WHEN A NON-CONTIGUOUS DISK ADDRESS IS FOUND, CPOPJ WHEN
; THE ENTIRE ARGUMENT LIST HAS BEEN SCANNED, RETURNS P4 = # OF PAGES,
; P3 = FIRST PHYSICAL PAGE

PAGIMT:	PUSHJ	P,SAVE2##	;SAVE P1-P2
	SE1ENT			;MUST BE IN SECTION 1 TO ADDRESS PAGTAB/MEMTAB
	MOVE	P1,T1		;SAVE THE FIRST PHYSICAL PAGE ALLOCATED
PAGIM1:	PUSHJ	P,NXTPAG	;GET THE NEXT USER ARGUMENT
	JUMPL	T1,PAGIM1	;JUMP IF ARGUMENT INDICATES PAGE TO BE PAGED-OUT
	HRRZS	T1		;CLEAR JUNK
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP
	MOVEI	P2,-1(T2)	;P2 = DISK ADDRESS - 1
	HRRZ	P3,P1		;P3 = CURRENT PHYSICAL PAGE ALLOCATED
	TLOA	P3,<(MT.LEF)>(T1)
PAGIM2:	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP FOR THIS VIRTUAL PAGE
	CAIE	P2,-1(T2)	;IS THIS THE END OF THIS FRAGMENT? (THIS DISK ADDRESS
				; NOT ADJACENT TO THE LAST)
	SOJA	M,PAGIM4	;YES, SET LAST ENTRY IN FRAGMENT AND RETURN
	MOVE	P2,T2		;SAVE DISK ADDRESS FOR NEXT TIME THROUGH LOOP
	MOVE	T3,T4		;T3 = BYTE POINTER TO THE MAP SLOT
	PUSHJ	P,TPAHS		;IS THIS PAGE IN A HIGH SEGMENT?
	  CAIA			;YES, DON'T WRITE ENABLE IT
	TDO	P1,[PM.WRT]	;NO, IT IS A WRITABLE PAGE
	PUSHJ	P,WSBIT		;CHECK TO SEE IF THE PAGE IS IN THE WORKING
				; SET (STOP IF IT IS), AND RETURN AN INDEX
				; AND THE BIT POSITION TO ADD IT TO THE WORKING SET
	ADDI	P4,1		;COUNT THE NUMBER OF PAGES IN THIS FRAGMENT
	AOS	JBTSWP##(J)	;INCREASE THE NUMBER OF PAGES IN CORE
	IORM	T2,WSBTAB(T4)	;ADD THIS PAGE TO THE WORKING SET
IFN FTKI10,<
	MOVEI	T1,PM.ACC+PM.PUB(P1)
>
IFN FTKL10!FTKS10,<
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.PUB+PM.CSH(P1)
>
IFN FTKLP,<
	MOVE	T1,P1
	TLO	T1,(<PM.DCD>B2+PM.PUB+PM.CSH)
>
>
	TDNN	T2,AABTAB(T4)	;SHOULD ACCESS ALLOWED BE ON FOR THIS PAGE?
IFE FTKLP,<
	TRZ	T1,PM.ACC	;NO, CLEAR IT
>
IFN FTKLP,<
	TLZ	T1,(<PM.DCD>B2)
>
	DPB	T1,T3		;MAP THIS PAGE INTO THE USERS ADDRESS SPACE
	MOVSI	T3,1		;ASSUME THIS PAGE IS IN A HIGH SEGMENT
	TDZN	P1,[PM.WRT]	;IS IT? (ONLY IF WRITE PROTECTED)
	PUSHJ	P,INCHJA	;YES, INCREMENTED THE NUMBER OF PAGES IN THE
				; HIGH SEGMENT THAT ARE IN CORE
	ANDI	T1,17777	;CLEAR ACESS BITS TO RESTORE PHYSICAL PAGE NUMBER
	SSX	T1,MDSEC2	;PAGTAB SECTION
	SKIPGE	T1,PAGTAB(T1)	;GET THE NEXT PHYSICAL PAGE ALLOCATED
	STOPCD	CPOPJ##,DEBUG,APF,	;++ALLOCATED PAGE FREE
	JUMPE	T1,PAGIM5	;IS THIS THE LAST PAGE ALLOCATED? JUMP IF SO
PAGIM3:	PUSHJ	P,NXTPAG	;GET THE NEXT VIRTUAL PAGE FROM USER'S ARGUMENT LIST
	JUMPL	T1,PAGIM3	;JUMP IF PAGING-OUT IS INDICATED
	HRRZS	T1		;CLEAR JUNK
	SSX	P1,MDSEC2	;MEMTAB SECTION
	HRRZM	P2,MEMTAB(P1)	;STORE THE DISK ADDRESS OF THE PAGE
	DPB	T1,[POINT 13,MEMTAB(P1),17]
	MOVE	T3,P1		;SAVE PREVIOUS PHYSICAL PAGE
	HRRZ	P1,PAGTAB(P1)	;GET THE NEXT PHYSICAL PAGE
	JRST	PAGIM2		;LOOP OVER ALL PAGES SPECIFIED IN THE LIST
PAGIM4:	MOVE	T1,P1		;LAST PHYSICAL PAGE IN FRAGMENT
	MOVE	P1,T3		;NEXT TO THE LAST
	AOS	(P)		;SKIP RETURN TO INDICATE FRAGMENTED
PAGIM5:	HLL	P2,P3		;FIRST PAGE OF FRAGMENT (MT.LEF ON)
	SSX	P1,MDSEC2	;MEMTAB SECTION
	MOVEM	P2,MEMTAB(P1)	;STORE AS LAST PAGE OF FRAGMENT
	POPJ	P,		;AND RETURN
;SUBROUTINE TO SETUP MEMTAB FOR PAGING OUT
;CALLING SEQUENCE:
;	MOVE	M,ADDRESS - 1 OF ENTRY IN THE ARGUMENT LIST
;	MOVE	U,XWD - NUMBER OF PAGES ALLOCATED CONTIGUOUSLY ON THE DISK,
;		STARTING DISK ADDRESS
;	MOVEI	P3,0
;	PUSHJ	P,PAGOMT
;ALWAYS RETURNS CPOPJ

PAGOMT:	PUSHJ	P,SAVE2##	;SAVE P1-P2
	SE1ENT			;MUST BE IN SECTION 1
	HLRE	P1,U		;P1 = - NUMBER OF PAGES ALLOCATED CONIGUOUSLY ON
				; THE DISK
PAGOM1:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT FROM THE USER'S ARGUMENT LIST
	JUMPGE	T1,PAGOM1	;JUMP IF THE ARGUMENT REQUESTS PAGING-IN
PAGOM2:	HRRZS	T1		;PAGING-OUT, CLEAR THE HIGH ORDER BITS
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP
	SOS	JBTSWP##(J)	;DECREMENT THE NUMBER OF PAGES IN CORE
	ANDI	T2,17777	;CLEAR ACCESS BITS (GET PHYSICAL PAGE NUMBEP)
	JUMPN	P3,PAGOM3	;JUMP IF NOT FIRST TIME THROUGH FOR THIS FRAGMENT
	HRLI	P3,<(MT.LEF)>(T1)
	HRR	P3,T2		;REMEMBER FIRST VIRTUAL AND FIRST PHYSICAL PAGE
PAGOM3:	MOVE	P2,T2		;SAVE PHYSICAL PAGE NUMBER
	PUSH	P,T1		;SAVE VIRTUAL PAGE NUMBER
	PUSHJ	P,LKPSP		;LINK PAST THE PHYSICAL PAGE IN PAGTAB
	PUSHJ	P,SCNPTB	;FIND THE PREDECESSOR TO THIS PAGE IN PAGTAB
	TRNN	P4,-1		;FIRST TIME?
	HRR	P4,P2		;YES,SAVE PREDESSOR IN P2
	SSX	T1,MDSEC2	;PAGTAB SECTION
	MOVEM	P2,PAGTAB(T1)	;STORE SUCCESSOR
	SSX	P2,MDSEC2	;DITTO
	HLLZS	PAGTAB(P2)	;AND INDICATE LAST PAGE
	POP	P,T1		;RESTORE VIRTUAL PAGE NUMBER
	PUSHJ	P,DECHJ		;DECREMENT NUMBER OF PAGES IN CORE IF A HIGH SEGMENT
	PUSHJ	P,TSWST		;IS THIS PAGE IN THE WORKING SET? (MUST BE)
	  STOPCD PAGOM2,DEBUG,PIW,		;++PAGE ISN'T IN WORKING SET
	ANDCAM	T2,WSBTAB(T4)	;IT WON'T BE AFTER PAGING IT OUT
	AOJE	P1,PAGOM5	;GO IF LAST PAGE IN THE ARGUMENT LIST
PAGOM4:	PUSHJ	P,NXTPAG	;GET THE NEXT PAGE IN THE ARGUMENT LIST
	JUMPGE	T1,PAGOM4	;JUMP IF PAGING-IN INDICATED
	HRRZM	U,MEMTAB(P2)	;STORE THE DISK ADDRESS IN MEMTAB
	DPB	T1,[POINT 13,MEMTAB(P2),17]
	AOJA	U,PAGOM2	;MAKE THE MAP AND MEMTAB ENTRIES FOR THIS ARGUMENT
PAGOM5:	HLL	U,P3		;U = MT.LEF+FIRST VIRTUAL PAGE,,LAST DISK ADDRESS
	MOVEM	U,MEMTAB(P2)	;STORE THAT IN MEMDAB
	PJRST	JSTVRT		;SET .UPVRT NON-0, UPDATE VMCMAX AND RETURN
;SUBROUTINE TO COMPUTE THE PAGING-RATE FOR A USER
;ENTER WITH P1=NUMBER OF PAGES IN THE UUO
;EXIT LH(JBTVRT)=T1 CONTAINING THE NEW INTERVAL
USRATE:	PUSHJ	P,GTDTIM	;GET DELTA TIME MT2
	IDIVI	T2,(P1)		;BIAS BY NUMBER OF PAGES XFERRED
	CAMLE	T2,MAXINT##	;GREATER THAN MAX INTERVAL?
	MOVE	T2,MAXINT##	;YES, USE MAX INTERVAL
	IMUL	T2,VMCNST##	;ALPHA(*(DELTA-T)/N)
	HLRZ	T1,JBTVRT##(J)	;INT(I-1)
	IMUL	T1,VMCDIF##	;(EXP-ALPHA)*INT(I-1)
	ADD	T1,T2		;ADD IN THE CURRENT CONTRIBUTION
	IDIV	T1,VMCEXP##	;SCALE IT
USRAT1:	HRLM	T1,JBTVRT##(J)	;AND SAVE NEW VALUE
	POPJ	P,

;SUBROUTINE TO ADJUST PAGING RATE OF USER IF NO PAGES TRANSFERRED DURING INTERVAL
PRTUPD:	PUSHJ	P,GTDTIM	;GET DELTA-TIME IN T2
	CAMLE	T2,MAXINT##	;IF TOO BIT
	MOVE	T2,MAXINT##	;THEN CUT DOWN
	IMUL	T2,VMCNST##	;ADJUST BY PAGE RATE ALGORITHM
	IDIV	T2,VMCDIF##	;..
	HLRZ	T1,JBTVRT##(J)	;GET OLD VALUE
	ADD	T1,T2		;ADJUST BY TIME GONE BY
	CAMLE	T1,MAXINT##	;CHECK FOR OVERFLOW
	MOVE	T1,MAXINT##	;IF SO, USE MAXIMUM
	JRST	USRAT1		;SAVE NEW VALUE AND RETURN

;SUBROUTINE TO COMPUTE DELTA TIME.
; STARTS NEW INTERVAL, RETURNS TIME DURING LAST INTERVAL IN T2
GTDTIM:	MOVE	T1,.PDTTM##(W)	;GET CURRENT RUN TIME
	MULI	T1,RTUPS##	;CONVERT TO 10-MICRO SEC UNITS
	ADD	T2,.PDTT2##(W)
	DIV	T1,TICSEC##	;CONVERT
	MOVE	T2,T1
	SUB	T2,.USLFT	;COMPUTE DELTA-TIME
	MOVEM	T1,.USLFT	;SAVE NOW AS LAST FAULT TIME
	POPJ	P,		;RETURN
;SUBROUTINE TO SCAN PAGTAB
;RETURNS T1= LAST PAGE IN PAGTAB CHAIN
;RETURNS LH(P4)= PREDECSSOR PAGE TO RH(P4)
;SCNPT PRESERVES T3
SCNPT::
SCNPTB:	SE1ENT			;GET TO SECTION 1 TO ADDRESS PAGTAB
	LDB	T1,JBYLSA##	;GET FIRST PAGE ALLOCATED TO THIS JOB
	TLZA	P4,-1		;INDICATE NO PREDESSOR
SCNPT1:	HRRZ	T1,T2		;PREDESSOR TO NEXT PAGE
	SSX	T1,MDSEC2	;PAGTAB SECTION
	SKIPGE	T2,PAGTAB(T1)	;GET NEXT PAGE ALLOCATED TO THIS JOB
	STOPCD	.+1,DEBUG,IPF,	;++IN-USE PAGE FREE
	CAIN	P4,(T2)		;IS THIS PAGE THE PREDECESSOR TO RH(P4)?
	HRL	P4,T1		;YES, REMAMBER THE PAGE
	JUMPN	T2,SCNPT1	;JUMP IF NOT LAST PAGE ALLOCATED TO JOB
IFN FTKLP,<
	HRRZS	T1		;CLEAR SECTION NUMBER
>
	POPJ	P,		;RETURN


;MAKE SWPLST ENTRY, START IO, RETURN SWPLST INDEX IN T2
PGWAIT:	MOVEI	T2,PIOWQ##	;PAGE I/O QUEUE CODE
	...DPB	T2,PJBSTS##	;PUT THE JOB INTO PAGE I/O WAIT
	PUSHJ	P,MAKSLE	;MAKE THE SWPLST ENTRY
	HRRM	T2,.USSLX
	PUSHJ	P,SQOUT##	;START THE PAGING IO
	HRRZ	T2,.USSLX	;GET SWPLST INDEX
	MOVE	J,.CPJOB##	;CURRENT JOB'S JOB NUMBER
	MOVE	R,JBTADR##(J)	;ADDRESS OF THE JOB
IFN FTMP,<
	PUSHJ	P,REMMM##	;REMEMBER STATE OF THE MM
>
	PUSHJ	P,WSCHED##	;WAIT UNTIL IT IS RUNNABLE AGAIN
	MOVE	T1,SWPLST##(T2)	;GET THE SWPLST ENTRY FOR THIS PAGING OPERATION
	TLNN	T1,(SL.CHN+SL.ERR)
	AOS	(P)		;SKIP RETURN SINCE NO PAGING I/O ERRORS
	POPJ	P,		;RETURN TO WAITER


;SUBROUTINE TO GET A PAGE INTO CORE
;ENTER T1=SWPLST ENTRY
;RETURNS WHEN PAGE IS IN CORE - CPOPJ IF IO ERROR, CPOPJ1 IF OK
PAGEIT::PUSHJ	P,SAVE1##	;SAVE P1
	PUSHJ	P,PGWAIT	;WAIT UNTIL ITS DONE
	  POPJ	P,		;PAGING I/O ERROR
	HRRZ	P1,T2		;INDEX INTO SWPLST
	AOS	(P)		;OK RETURN
	PJRST	DLTSLX		;DELETE THE SWPLST ENTRY AND RETURN
;HERE TO CREATE OR DELETE PAGES

CHGPGS:	MOVEI	T2,PA.PME+PA.PCE;PAGE MUST EXIST ON DESTROY, CANNOT ON CREATE
	PUSHJ	P,PLTSN		;VALIDATE THE ARGUMENT LIST
	  POPJ	P,		;ILLEGAL ARGUMENT
	TLNE	M,HSPAG		;ANY HI SEG PAGES IN ARG LIST?
	JUMPN	T2,IALERR	;YES, CANT DELETE HI-SEG PAGES
	PUSHJ	P,FSTPAG	;POINT M AT THE USER'S ARGUMENT LIST
	PUSHJ	P,SZCHK		;MAKE SURE THAT THE JOB WON'T BE TO BIG IF
				; PAGES ARE CREATED AFTER DESTROYING THOSE
				; SPECIFIED IN THE ARGUMENT LIST
	  JRST	[TLNN	M,ARGMD	;TRYING TO GET TO BIG
		 JRST	TBGERR
		 JRST	.+1]
	SUBI	T1,(T2)		;CURRENT VIRTUAL SIZE MINUS PAGE BEING DESTROYED
	SUB	T1,.USTMP	;MINUS ALLOCATED BUT ZERO PAGES
	ADDI	T1,(T3)		;REAL NEW SIZE
	HLRZ	T4,.PDCVL##(W)	;CURRENT VIRTUAL LIMIT
	CAILE	T1,UPMPSZ##(T4)	;TRY TO GET TO BIG?
	JUMPN	T3,[JUMPN T4,TBGERR ;YES, ERROR RETURN
		    TLNE M,ARGMD
		    JRST NVLERR
		    JRST .+1]
	MOVE	T1,T3		;NUMBER OF PAGES BEING CREATED
	SUBI	T1,(T2)		;MINUS THE NUMBER OF PAGES BEING DESTROYED
	SUB	T1,.USTMP	;MINUS ALLOCATED BUT ZERO PAGES
				; (THEY'RE ALREADY ALLOCATED FOR IN VMCMAX)
	TLNN	M,ARGMD		;CREATING ABZ PAGES (IF SO WILL BE VIRTUAL)
	SKIPE	.USVRT		; OR IF ALREADY VIRTUAL
	CAMG	T1,VMCMAX##	;TRYING TO EXCEED MAX VIRTUAL CORE FOR VM?
	CAMLE	T1,VIRTAL##	;IS THERE ENOUGH VIRTUAL CORE TO SATISFY THE REQUEST?
	JRST	NSAERR		;NO, NOT ENOUGH SWAPPING SPACE AVAILABLE
	HRROI	T4,777000
	TDNN	T4,.USVRT
	JRST	CHGPG1
	ADDM	T1,VMTOTL##
	MOVNS	T1
	ADDM	T1,VMCMAX##	;DECREASE TOTAL AMOUNT OF VIRTUAL CORE AVAILABLE
CHGPG1:	PUSHJ	P,SAVE2##	;SAVE P1,P2
	JUMPE	T2,CHGPG3	;JUMP IF NOT DESTROYING PAGES
	PUSH	P,T3		;SAVE THE NUMBER OF PAGES BEING CREATED
	PUSH	P,T2		;AND THE NUMBER BEING DELETED
	PUSHJ	P,IOWATM	;WAIT FOR I/O TO STOP
CHGPG2:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	JUMPGE	T1,CHGPG2	;JUMP IF NOT A DELETE REQUEST
	HRRZS	P1,T1		;CLEAR THE HIGH ORDER BIT, CLEAR LEFT HALF OF P1
	PUSHJ	P,DLTPAG	;DELETE THE PAGE
	SOSLE	(P)		;DELETED ALL THAT WERE REQUESTED?
	JRST	CHGPG2		;NO, CONTINUE
	PUSHJ	P,FSTPAG	;RESTORE THE ARGUMENT LIST POINTER
	POP	P,(P)		;POP OFF JUNK
	POP	P,T3		;RESTORE THE NUMBER OF PAGES BEING CREATED
CHGPG3:	JUMPE	T3,FIXADR	;CLEAR THE A.M. AND RETURN TO THE USER IF NOT
				; CREATING PAGES
	MOVN	T1,T3		;MINUS THE NUMBER OF PAGES BEING CREATED
	ADDM	T1,VIRTAL##	;UPDATE VIRTAL TO REFLECT THE DECREASE
	MOVE	P2,T3		;SAVE THE NUMBER OF PAGES BEING CREATED
	TLNE	M,ARGMD
	JRST	CHGPG5
	PUSHJ	P,FRDCR##	;ARE THERE ENOUGH PAGES IN CORE TO SATISFY REQUEST?
	  JRST	CHGPG8		;NO, ALLOCATE THE SPACE ON THE DISK
	SE1ENT			;ENTER SECTION 1 TO REFERENCE PAGTAB
	PUSHJ	P,SCPAGS##	;FIND THE LAST PAGE CURRENTLY ALLOCATED TO THE JOB
	MOVE	T2,P2		;NUMBER OF PAGES TO ALLOCATE
	PUSHJ	P,ADPAGS##	;ALLOCATE THE PAGES
;HERE WITH T1 = FIRST PHYSICAL PAGE ALLOCATED
	MOVE	P1,T1		;FIRST PHYSICAL PAGE ALLOCATED TO P1
	JRST	CHGPG5
CHGPG4:	TLNN 	M,ARGMD
	HRR	P1,PAGTAB(T1)	;P1 = PHYSICAL PAGE NUMBER OF NEXT PAGE ALLOCATED
CHGPG5:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	JUMPL	T1,CHGPG5	;JUMP IF DELETE PAGE REQUEST
	HRRZS	T1		;CLEAR BIT 1
	HRL	P1,T1		;SAVE THE HIGHEST VIRTUAL PAGE SEEN SO FAR
	TLNN	M,ARGMD
	JRST	CHGPG6
	PUSHJ	P,GTPME		;GET POINTER TO THE MAP SLOT (PAGE NO IN T1)
	CAIN	T2,PM.ZER	;PAGE ALREADY ALLOCATED BUT ZERO?
	PUSHJ	P,INSMEM	;YES, FIX VIRTAL
	MOVEI	T2,PM.ZER	;ALLOCATED BUT ZERO
	DPB	T2,T4		;STORE THAT IN THE MAP
	PUSHJ	P,WSBIT		;GET POINTER TO AABTAB
	IORM	T2,AABTAB(T4)	;ACCESS IS ALLOWED
	JRST	CHGPG7		;GET THE NEXT ARGUMENT
;HERE TO ADD A PAGE, T1=VIRTUAL PAGE NUMBER, P1 = PHYSICAL PAGE NUMBER,
; MAKE THE MAP ENTRY AND TURN ON THE BIT IN THE WORKING SET BIT TABLE
CHGPG6:	PUSHJ	P,INSPAG	;INSERT THE PAGE IN THE USER'S MAP
;HERE TO ZERO THE PAGE OBTAINED
	PUSHJ	P,ZERPAG	;ZERO THE PAGE
	PUSHJ	P,INCHJ		;INCREMENT THE NUMBER OF PAGES ALLOCATED
				; IN CORE TO THE HIGH SEGMENT IF THIS IS A HIGH
				; SEGMENT PAGE
CHGPG7:	PUSHJ	P,ICUPR		;UPDATE THE HIGHEST CONTIGUOUS PAGE IN THE LOW SEG
	MOVE	T1,P1		;LAST PAGE
	SSX	T1,MDSEC2	;SET TO GET NEXT PAGE
	SOJG	P2,CHGPG4	;LOOP OVER THE ARGUMENT LIST
	PJRST	FIXADR		;FIX RELAVENT VARIABLES
;HERE WHEN NOT ENOUGH PAGES AVAILABLE IN CORE TO SATISFY A CREATE PAGES
; REQUEST
CHGPG8:	MOVE	P1,T3		;SAVE THE NUMBER OF PAGES TO BE CREATED
	PUSHJ	P,IOWATM	;WAIT FOR I/O TO STOP BEFORE CALLING XPAND
CHGPG9:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	JUMPL	T1,CHGPG9	;JUMP IF NOT CREATE PAGE ARGUMENT
	HRL	P2,T1		;SAVE THE HIGHEST VIRTUAL PAGE SEEN
	PUSHJ	P,INCHJ		;INCREMENT NUMBER OF HIGH SEGMENT PAGES
				; IN CORE IF THIS IS A HIGH SEGMENT PAGE
				; EVEN THOUGH ITS NOT IN CORE YET SINCE
				; IT WILL BE WHEN THE JOB SWAP IN
	PUSHJ	P,INSDSK	;ADD THE PAGE TO THE USER'S WORKING SET
	PUSHJ	P,GTPME		;CONTENTS OF THE MAP SLOT
	SKIPN	T2		;DON'T CALL ICUPR IF PAGING I/O
	PUSHJ	P,ICUPR		;UPDATE UPREL IF A CONTIGUOUS PAGE
	SOJG	P1,CHGPG9	;LOOP OVER ALL ARGUMENTS
	JRST	FIXDSK		;FIX REVELANT VARIABLES
;HERE TO EXCHANGE OR REMAP PAGES, ENTER T1 = N,,ARGUMENT LIST POINTER
; WHERE EACH WORD IN THE ARGUMENT LIST IS OF THE FORM
;	XWD	FLAG+SOURCE PAGE,DESTINATION PAGE
; WHERE FLAG = 1B0 IF THE PAGES ARE TO BE EXCHANGED, AND FLAG = 0B0
; IF THE SOURCE PAGE IS TO BE REMAPPED TO THE DESTINATION PAGE.
; IF FLAG = 1, BOTH SOURCE AND DESTINATION PAGES MUST EXIST.
; IF FLAG = 0, DESTINATION PAGE MUST NOT EXIST

MOVPGS:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSH	P,T1		;SAVE LEN,,ADDR OF ARG LIST
	HLRZ	P1,T1		;NUMBER OF ARGUMENTS
	MOVEI	P3,-1(T1)	;ADDRESS OF FIRST WORD OF ARGUMENT LIST
	MOVEI	P4,-1(T1)	;ADDRESS OF LAST WORD
	ADD	P4,P1		;  OF THE ARGUMENT LIST
	LSH	P3,W2PLSH##	;CONVERT TO PAGE NUMBER
	LSH	P4,W2PLSH##
	PUSHJ	P,FSTPAG	;POINT M AT THE USER'S ARGUMENT LIST
	PUSHJ	P,IOWATM	;WAIT UNTIL ALL I/O STOPS
MOVPG1:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	PUSH	P,T1		;SAVE IT AT 0(P)
	HRRZ	T3,T1		;SAVE DESTINATION PAGE
	TLZE	T1,400000	;MOVE OR EXCHANGE PAGE?
	TLO	T3,400000	;EXCHANGE, REMEMBER THAT
	HLRZS	T1		;GET THE SOURCE PAGE
	PUSHJ	P,LGLPG		;IS IT A LEGAL PAGE?
	  JRST	MOVPG7		;NO, ILLEGAL PAGE ERROR
	PUSHJ	P,TPMOV		;IN A SHARABLE HIGH SEGMENT, OR MOVPGS IN ANY HI SEG?
	  JRST	MOVPG7		;YES, GO PROCESS ERROR
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT
	JUMPN	T2,MOVPG2	;PAGE MUST EXIST
	PUSHJ	P,PMEERR	;IT DOESN'T, ERROR
	JRST	MOVPG7

;HERE WHEN IT HAS BEEN VERIFIED THAT THE SOURCE PAGE EXISTS
MOVPG2:	HRRZ	T1,T3		;DESTINATION PAGE
	PUSHJ	P,LGLPG		;IS IT A LEGAL PAGE?
	  JRST	MOVPG7		;NO, ERROR
	PUSHJ	P,TPMOV		;IS IT IN A SHARABLE HIGH SEGMENT?
	  JRST	MOVPG7		;YES, ERROR
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT FOR THE
				; DESTINATION PAGE
	JUMPL	T3,MOVPG3	;VERIFY DEST PAGE DIFFERENTLY IF EXCH
	JUMPE	T2,MOVPG5	;MOVE, PAGE MUST NOT EXIST
	PUSHJ	P,PCEERR	;IT DOES, ERROR
	JRST	MOVPG7
;HERE ON AN EXCHANGE
MOVPG3:	JUMPN	T2,MOVPG5	;DEST PAGE MUST EXIST
	PUSHJ	P,PMEERR	;IT DOESN'T, ERROR
	JRST	MOVPG7
;HERE WHEN IT HAS BEEN VERIFIED THAT THE DESTINATION PAGE DOES NOT
; EXIST IF THIS IS A REMAP OR DOES EXIST IF THIS IS AN EXCHANGE

MOVPG5:	MOVE	T1,(P)		;RESTORE USER'S ARG FOR MV1PG
	PUSHJ	P,MV1PG		;MOVE OR EXCHANGE THE PAGES
	XOR	T3,T2		;BOTH PAGES IN CORE OR ON DISK?
	MOVSI	T2,UU.WCC	;
	SKIPE	T3
	IORM	T2,-10(P)	;NO, SET WORKING SET HAS CHANGED BIT
	SKIPGE	(P)		;IF WE JUST DID AN EXCHANGE,
	JRST	MOVPG6		;  THEN NOTHING CHANGED
	HLRZ	T1,(P)		;LIKE DELETING FROM PAGE
	PUSHJ	P,DCUPR		;FIX NUMBERS (MEM,REL)
	HRRZ	T1,(P)		;LIKE CREATING TO PAGE
	PUSHJ	P,ICUPR		;ADJUST NUMBERS
MOVPG6:	POP	P,(P)		;DISCARD LAST ARGUMENT
	SOJG	P1,MOVPG1	;LOOP OVER THE ENTIRE ARGUMENT LIST
	POP	P,(P)		;DISCARD LEN,,ADDR OF ARG LIST
	LDB	T1,PCORSZ##	;NEW HIGHEST PAGE
	DPB	T1,JBYLSS##	;STORE SO KISER WON'T TOUCH THE MAP
	PJRST	FIXAD1		;UPDATE SOFTWARE RELOCATION INFORMATION, CLEAR A.M.


;HERE IF WE FOUND AN ILLEGAL ARGUMENT HALFWAY THROUGH THE ARGUMENT
;LIST.  SCAN THE LIST BACKWARDS, UNDOING EVERYTHING DONE SO FAR.

MOVPG7:	POP	P,(P)		;DISCARD ARG BEING PROCESSED
	EXCH	T1,(P)		;SAVE ERROR CODE, RETRIEVE LEN,,ADDR
	HLRZS	T1		;WE WANT NUMBER OF ARGUMENTS
	SUBM	T1,P1		;PUT NUMBER OF ARGUMENTS TO UN-DO IN P1
	JUMPE	P1,TPOPJ##	;GET OUT IF FIRST ARGUMENT WAS BAD
MOVPG8:	PUSHJ	P,PREPAG	;BACK UP TO PREVIOUS ARGUMENT
	MOVSS	T1		;MAKE IT AN ARG FOR UNDOING ITSELF
	TRZE	T1,400000	;WAS IT AN EXCHANGE?
	TLO	T1,400000	;YES, REMEMBER THAT
	PUSH	P,T1		;SAVE USER'S MODIFIED ARGUMENT
	PUSHJ	P,MV1PG		;UNDO THIS ARGUMENT
	SKIPGE	(P)		;IF THIS WAS AN EXCHANGE,
	JRST	MOVPG9		;  THEN NOTHING CHANGED
	HLRZ	T1,(P)		;IT WAS A MOVE, RETRIEVE SOURCE PAGE
	PUSHJ	P,DCUPR		;FIX REL, MEM
	HRRZ	T1,(P)		;NOW DEST PAGE
	PUSHJ	P,ICUPR		;FIX UP NUMBERS
MOVPG9:	POP	P,(P)		;DISCARD USER'S ARG
	SOJG	P1,MOVPG8	;LOOP OVER ALL ARGS
	CLRPGT	(0)		;CLEAR AM IN CASE WE GOT INTERRUPTED
	JRST	TPOPJ##		;RESTORE ERROR CODE
GBPTR:	IDIVI	T1,^D36		;WORD NUMBER
	MOVNI	T2,-^D35(T2)	;BIT POSITION
	HRLI	T1,000100+P2	;MAKE A 1 BIT BYTE POINTER
	DPB	T2,[POINT 6,T1,5]
	POPJ	P,		;RETURN

XCBITS:	LDB	T2,T1		;SOURCE BYTE (BIT)
	LDB	T3,T4		;DESTINATION BYTE (BIT)
	DPB	T2,T4		;SOURCE = DESTINATION
	DPB	T3,T1		;DESTINATION = SOURCE
	POPJ	P,		;RETURN


;SUBROUTINE TO TEST FOR PAGE-LEGALITY IN EXCHANGE, MOVE PAGES
TPMOV:	CAMLE	P3,P4		;ARG LIST CROSS 777777?
	JRST	TPMOV1		;YES, CHECK PAGE # DIFFERENTLY
	CAML	T1,P3		;NO, IS THE USER TRYING TO MOVE THE ARG LIST?
	CAMLE	T1,P4		;  OR EXCHANGE IT (JUST AS BAD)?
	JRST	TPMOV2		;NO, GO TEST OTHER THINGS
	JRST	IALERR		;YES, CAN'T LET HIM
;HERE WHEN ARG LIST CROSSES 777777
TPMOV1:	CAMGE	T1,P3		;HIS PAGE NUMBER BETWEEN ARG LIST AND 777777?
	CAMG	T1,P4		;  OR BETWEEN 0 AND END OF ARG LIST?
	JRST	IALERR		;YES, CAN'T ALLOW IT
TPMOV2:
IFN FTPEEKSPY,<
	PUSHJ	P,TSSPT		;A SPY PAGE?
	  CAIA
	JRST	PSHERR
>
	PUSHJ	P,TPAHS		;IN A HI SEG?
	  SKIPA	T2,JBTSGN##(J)	;YES
	PJRST	CPOPJ1##	;NO, OK
	TLNE	T2,SHRSEG!SPYSEG ;SHARABLE HI SEG OR SPY?
	PJRST	PSHERR		;YES
	JUMPG	T3,IALERR	;NO, CANT MOVPAG FROM ANY HI SEG
	PJRST	CPOPJ1##	;ALL OK
;SUBROUTINE TO MOVE OR EXCHANGE 1 PAGE IN MAP
;ENTER T1=FROM-PAGE,,TO-PAGE ; BIT 0=1 IF EXCHANGE THE PAGES
;EXIT T1=POINTER TO TO-PAGE MAP SLOT, T2= TO-PAGE WSBTAB BIT,
; T3= FROM-PAGE WSBTAB BIT, T4=POINTER TO WSBTAB FOR TO-PAGE
;RETURNS IN P2 INDEX INTO WSBTAB
MV1PG::	MOVE	T3,T1		;SAVE ARGUMENT
	HLRZS	T1		;GET SOURCE PAGE
	TRZ	T1,400000	;CLEAR MOVE/EXCHANGE BIT
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE SOURCE PAGE MAP SLOT
	HRRZ	T1,T3		;DESTINATION PAGE
	PUSH	P,T2		;SAVE CONTENTS OF SOURCE MAP SLOT
	PUSH	P,T4		;AND BYTE POINTER TO SOURCE MAP SLOT
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE DESTINATION MAP SLOT
	TLZN	T3,400000	;MOVE OR EXCHANGE?
	MOVEI	T2,0		;MOVE, SET TO STORE 0 IN SOURCE SLOT
	DPB	T2,(P)		;STORE 0 OR CONTENTS OF DESTINATION SLOT IN
				; SOURCE SLOT
	POP	P,(P)		;POP OFF JUNK
	POP	P,T2		;RESTORE CONTENTS OF SOURCE SLOT
	DPB	T2,T4		;STORE IN DESTINATION SLOT
	PUSH	P,T4		;SAVE THE BYTE POINTER TO THE DESTINATION SLOT
	PUSHJ	P,GBPTR		;GET A BYTE POINTER TO BIT TABLES
	MOVE	T4,T1		;SAVE IT
	HLRZ	T1,T3		;SETUP TO GET BYTE POINTER FOR DESTINATION BIT
	PUSHJ	P,GBPTR		;GET THAT
	MOVEI	P2,AABTAB	;EXCHANGE SOURCE AND DESTINATION BITS IN
	PUSHJ	P,XCBITS	; ACCESS ALLOWED BIT TABLE
	MOVEI	P2,WSBTAB	;EXCHANGE SOURCE AND DESTINATION BITS IN
	PUSHJ	P,XCBITS	; THE WORKING SET TABLE
	PJRST	TPOPJ##		;RESTORE BYTE POINTER TO DESTINATION SLOT AND RETURN
;HERE TO SET/CLEAR THE ACCESS ALLOWED BITS IN THE MAP AND AABTAB

SETAAB:	MOVEI	T2,PA.IHB+PA.PME+PA.PMI
	PUSHJ	P,PLTSN		;CHECK THE ARGUMENT LIST (PAGES MUST EXIST
				; AND BE IN CORE)
	  POPJ	P,		;ARGUMENT ERROR
	PUSHJ	P,SAVE1##	;SAVE P1,P2
	HLRZ	P1,T1		;NUMBER OF ARGUMENTS
	PUSHJ	P,FSTPAG	;POINT M AT USER'S ARGUMENT LIST
	MOVSI	T1,(UP.SAA)	;SET A.A. AUTOMATICALLY BIT
	TLNN	M,ARGMD		;DID THE USER SPECIFY IT?
	JRST	[ANDCAM T1,.USBTS
		JRST SETAA1]	;NO, CLEAR THE BIT
	IORM	T1,.USBTS	;YES, REMEMBER IT
SETAA1:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	PUSHJ	P,SCAABT	;SET OR CLEAR THE BIT
	SOJG	P1,SETAA1	;LOOP OVER ALL THE ARGUMENTS
	PUSHJ	P,ADJANA
FIXMJ1::CLRPGT	(0)		;CLEAR PAGE MEMORY
	JRST	CPOPJ1##	;SKIP RETURN
;SUBROUTINE TO SET OR CLEAR ACCESS ALLOWED BITS IN AABTAB AND THE MAP
; CALL WITH T1 = THE VIRTUAL PAGE NUMBER, SIGN BIT ON IF A.A. TO BE CLEARED
; EXITS CPOPJ ALWAYS

SCAABT:	PUSH	P,P2
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT FOR THIS PAGE
	TLNN	T1,400000	;SET OR CLEAR ACCESS ALLOWED?
	JRST	SCAAB1
IFE FTKLP,<
	TRZE	T2,PM.ACC	;CLEAR, WAS ACCESS ALLOWED?
>
IFN FTKLP,<
	TLZE	T2,(<PM.DCD>B2)
>
	AOS	.USANA		;YES, BUMP NO. OF NOT-ACCESSABLE PAGES
	JRST	SCAAB2
SCAAB1:
IFE FTKLP,<
	TRON	T2,PM.ACC	;SET, WAS ACCESS NOT ALLOWED?
>
IFN FTKLP,<
	TLON	T2,(<PM.DCD>B2)
>
	SOS	.USANA		;YES, DECR NO OF NOT-ACCESSABLE PAGES
SCAAB2:	DPB	T2,T4		;STORE ENTRY BACK IN THE MAP WITH THE
				; ACCESS ALLOWED BIT SET OR CLEARED
;THE FOLLOWING INSTRUCTION DEPENDS ON PM.ACC=400000
IFE FTKLP,<
	HRLE	T4,T2		;SET OR CLEAR LOW ORDER BIT
>
IFN FTKLP,<
	TLNN	T2,(<PM.DCD>B2)
	TDZA	T4,T4
	MOVEI	T4,1
>
	HRRZS	T1
	PUSHJ	P,GBPTR		;GET 1-BIT BYTE POINTER TO BIT POSITION WHICH
				; REPRESENTS THIS PAGE IN AABTAB
	MOVEI	P2,AABTAB
	DPB	T4,T1		;SET OR CLEAR THE BIT IN AABTAB
	POP	P,P2
	POPJ	P,		;RETURN

;SUBROUTINE TO MAKE UPVRT AGREE WITH UPANA

ADJANA:	MOVE	T3,.USANA
	IORM	T3,.USVRT	;ENSURE UPVRT NON-0 IF NON-ACCESS PAGES EXIST
	JUMPN	T3,CPOPJ##	;IF NO NON-ACCESS PAGES,
	MOVEI	T3,777		; CLEAR THAT PORTION OF UPVRT
	ANDCAM	T3,.USVRT
	POPJ	P,		;RETURN
;HERE TO RETURN THE WORKING SET BIT TABLE TO THE USER
GETWSB:	MOVSI	U,WSBTAB	;RETURN CONTENTS OF WSBTAB
	JRST	GETAA1		;JOIN COMMON CODE
;HERE TO RETURN THE ACCESS ALLOWED BIT TABLE TO THE USER
GETAAB:	MOVSI	U,AABTAB	;RETURN CONTENTS OF AABTAB
GETAA1:	HRR	U,T1		;ADDRESS OF USER'S ARGUMENT LIST
	HLRZS	T1		;NUMBER OF WORDS TO RETURN
	CAIL	T1,WSBTBL	;ASKING FOR MORE WORDS THAN THERE ARE?
	HRROI	T1,WSBTBL	;YES, RETURN THE NUMBER THERE ACTUALLY ARE
	ADDI	M,(T1)		;TOP ADDRESS IN  USER'S ADDRESS SPACE
	EXCH	T1,U		;BLT POINTER TO T1, WHETHER ENTIRE TABLE TRANSFERED
				; IN U
	EXCTXU	<BLT T1,(M)>	;MOVE TABLE TO THE USER
	ERJMP	UADERR##	;MUSTA BEEN TO A HISEG
	HRLOI	T1,1777		;SET TO CLEAR BIT REPRESENTING THE UPMP
	JUMPGE	U,CPOPJ1##	;WAS THE ENTIRE TABLE REQUESTED?
	EXCTUU	<ANDCAM T1,(M)>	;YES, CLEAR JUNK FROM THE LAST WORD
	JRST	CPOPJ1##	;GOOD RETURN
;HERE TO MAKE A CONTIGUOUS COLLECTION OF PAGES A HIGH SEGMENT

GREMAP:	PUSHJ	P,SAVE1##	;SAVE A WORKING AC
	HLRE	P1,T1		;GET THE NUMBER OF ARGUMENTS
	JUMPLE	P1,IALERR	;.LE. 0 IS ILLEGAL
	SOJLE	P1,IALERR	;THERE MUST BE AT LEAST TWO ARGUMENTS
				; (NUMBER OF PAGES AND STARTING PAGE)
	HRRI	M,(T1)		;ADDRESS OF THE ARGUMENTS
	PUSHJ	P,IOWATM	;WAIT FOR I/O TO STOP
	PUSHJ	P,GETWDU##	;GET THE FIRST ARGUMENT (NUMBER OF PAGES TO BE REMAPPED)
	PUSH	P,T1		;SAVE IT
	PUSHJ	P,GETWD1##	;GET THE STARTING PAGE NUMBER
	PUSHJ	P,LGLPG		;IS IT A LEGAL PAGE?
	  JRST	T2POPJ##	;NO, TELL THE USER ILLEGAL PAGE NUMBER
	MOVE	T2,T1		;STARTING PAGE NUMBER TO T2
	SOJLE	P1,GREMA1	;JUMP IF THIRD ARGUMENT WASN'T SPECIFIED
	PUSH	P,T1		;SAVE SECOND ARGUMENT (GETWDU CLOBBERS T2)
	PUSHJ	P,GETWD1##	;GET THE DESTINATION PAGE NUMBER
	PUSHJ	P,LGLPG		;IS THAT A LEGAL PAGE NUMBER?
	  JRST	[POP P,(P)	;NO
		JRST T2POPJ##]	;ILLEGAL PAGE RETURN TO THE USER
	MOVE	T2,T1		;DESTINATION PAGE TO T2
	POP	P,T1		;RESTORE SOURCE PAGE
GREMA1:	POP	P,T3		;RESTORE THE NUMBER OF PAGES TO BE REMAPPED
	SETOM	T4		;DON'T ALLOW A USER TO CREATE A SHARABLE
				; HIGH SEGMENT WITH A REMAP
IFN FTMP,<
	PUSHJ	P,UPMM##	;MUST HAVE THE MM TO DO A REMAP
>
	PUSHJ	P,NREMAP	;DO THE REMAP
	  PJRST	STOTAC##	;ERROR, STORE THE ERROR CODE FOR THE USER
	PJSP	T3,SHARE1##	;WIN, MAKE REMAPPED PAGES INTO A HIGH SEGMENT

;HERE TO CREATE/DESTROY SPY PAGES

IFN FTPEEKSPY,<
SPYPGS:	PUSHJ	P,SAVE2##	;SAVE P1,P2
	PUSH	P,T1		;SAVE ADDRESS OF THE ARGUMENT LIST
	MOVSI	T1,PVSPYA	;REQUIRES SPY PRIVILEGES
	PUSHJ	P,PRVBIT##	;DOES THE JOB HAVE THEM?
	  SKIPA	T1,(P)		;YES, PROCEED
	JRST	[POP P,(P)	;NO, POP OFF JUNK AND
		 JRST NPVERR]	; GIVE NEED PRIVILEGES ERROR RETURN
	PUSHJ	P,FSTPAG	;POINT M AT USERS ARGUMENT LIST
	HLRE	P1,T1		;NUMBER OF ARGUMENTS
	JUMPLE	P1,[POP P,(P)	;ZERO OR NEGATIVE ARGUMENT COUNT IS ILLEGAL
		    JRST IALERR];GIVE ILLEGAL ARGUMENT LIST RETURN
	SKIPGE	-3(P)		;PHYSICAL ONLY? P1 ON STACK
	SKIPA	P2,MEMSIZ##	;YES, HIGHEST LEGAL ADDRESS
IFE FTKLP,<
	MOVSI	P2,1		;NO, HIGHEST LEGAL VIRTUAL ADDRESS
>
IFN FTKLP,<
	MOVSI	P2,MXSECN+1
>
	LSH	P2,W2PLSH##	;HIGHEST LEGAL PAGE NUMBER
SPYPG1:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	PUSHJ	P,LGLPR		;LEGAL USER VIRTUAL PAGE NUMBER?
	  JRST	TPOPJ##		;NO, ILLEGAL PAGE RETURN
	PUSHJ	P,GTPME		;GET CONTENTS OF THE MAP CORRESPONDING TO THAT PAGE
	SKIPL	T1		;DELETE SPY PAGE?
	JUMPN	T2,[POP P,(P)	;NO, MAP SLOT MUST BE ZERO
		    JRST PCEERR];PAGE CANNOT EXIST ERROR
	TLZE	T1,400000	;SKIP IF NOT DELETE PAGE
	JRST	[HRRZS T1	;ISOLATE USER VIRTUAL PAGE NUMBER
		 PUSHJ P,TSSPT	;SINCE DELETING IT, IT MUST BE A SPY PAGE
		   JRST [POP P,(P) ;IT ISN'T
			 JRST PMEERR] ;PAGE MUST EXIST ERROR
		 JRST .+1]	;ALL IS WELL
	HLRZS	T1		;MONITOR PAGE NUMBER
	CAML	T1,P2		;BELOW MEMSIZ?
	JRST	[POP P,(P)	;NO
		 JRST ILPERR]	;ILLEGAL PAGE NUMBER ERRROR
	SOJG	P1,SPYPG1	;LOOP OVER THE ENTIRE ARGUMENT LIST
	POP	P,T1		;RESTORE ARGUMENT LIST POINTER
	HLRZ	P1,T1		;COUNT OF ARGUMENTS
	PUSHJ	P,FSTPAG	;POINT M AT USER'S ARGUMENT LIST
	MOVEI	P2,SPYTAB	;BIT TABLE TO KEEP TRACK OF SPY PAGES
SPYPG2:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	HRRZ	T4,T1		;USER VIRTUAL PAGE NUMBER
	PUSHJ	P,GMPTR		;GET A POINTER TO THE MAP SLOT
	HLRZ	T2,T1		;MONITOR PAGE NUMBER
	HRRZS	T1		;CLEAR JUNK
	TRNE	T2,400000	;DELETING A SPY PAGE?
	JRST	SPYPG4		;YES
	MOVE	T3,T2		;MONITOR PAGE NUMBER TO T3
	SKIPGE	-2(P)		;PHYSICAL ONLY? P1 ON THE STACK
				;NO, GREATER THAN 112K?
	JRST	SPYPG3		;NO
	LSH	T2,P2WLSH##	;FORM A VIRTUAL ADDRESS
	PUSH	P,T1		;SAVE USER VIRTUAL PAGE NUMBER
	PUSHJ	P,PPPV2P##	;MAP THE VIRTUAL ADDRESS
	  JRST	[POP P,T1	;BAD PAGE NUMBER
		 JRST ILPERR]	;RETURN ILLEGAL PAGE ERROR
	MOVE	T3,T1		;PHYSICAL ADDRESS
	POP	P,T1		;RESTORE USER VIRTUAL PAGE NUMBER
	LSH	T3,W2PLSH##	;CONVERT TO PHYSICAL PAGE NUMBER
SPYPG3:
IFE FTKLP,<
	TROA	T3,PM.ACC+PM.PUB;ACCESSIBLE AND PUBLIC
>
IFN FTKLP,<
	TLOA	T3,(<PM.DCD>B2+PM.PUB)
>
SPYPG4:	SETZ	T3,		;SET TO REMOVE THE SPY PAGE
	DPB	T3,T4		;STORE MAPPING IN THE USER'S MAP
	PUSHJ	P,GBPTR		;GET POINTER TO BIT IN SPYTBL
	SKIPE	T3		;REMOVING A SPY PAGE?
	MOVEI	T3,1		;NO, SET THE BIT INDICATING A SPY PAGE
	DPB	T3,T1		;STORE 0 OR MAPPING FOR THE PAGE BEING SPYIED ON
	SOJG	P1,SPYPG2	;NEXT ARGUMENT
	MOVSI	T1,(UP.CSP)	;MAP MAY CONTAIN SPY PAGES BIT
	IORM	T1,.USBTS	;TURN IT ON TO SAVE TIME LATER
	JRST	FIXMJ1		;NEW MAPPING IN AFFECT, GOOD RETURN
;SUBROUTINE TO DELETE A SPY PAGE, CALL WITH T1 = USER VIRTUAL PAGE
; NUMBER OF THE PAGE, RETURNS CPOPJ IF SPY PAGE DELETED, CPOPJ1 IF NOT
; A SPY PAGE
DLTSP:	PUSHJ	P,TSSPT		;A SPY PAGE?
	  JRST	CPOPJ1##	;NO, SKIP RETURN
	ANDCAM	T2,SPYTAB(T4)	;NO LONGER A SPY PAGE
	PUSHJ	P,GTPME		;GET BYTE POINTER TO THE MAP SLOT
	MOVEI	T2,0		;ZERO MAP SLOT
	DPB	T2,T4		; ..
	POPJ	P,		;AND RETURN

;SUBROUTINE TO CLEAR SPY PAGES FROM A USER'S MAP, CALLED BY GETMIN
CLRSPG::MOVSI	T1,(UP.CSP)	;JOB MAY HAVE SPY PAGES IN ITS MAP BIT
	SKIPE	JBTADR##(J)	;DOES IT HAVE CORE IN CORE?
	TDNN	T1,.USBTS	;YES, AND DID IT DO A FUNCTION 11 OF THE PAGE. UUO?
	POPJ	P,		;NO, RETURN DOING NOTHING
	ANDCAM	T1,.USBTS	;CLEAR THE BIT SINCE NO SPY PAGES NOW
	PUSHJ	P,SAVE1##	;SAVE A WORKING AC
	MOVSI	P1,-SPYTBL	;AOBJN POINTER TO SPYTAB
CLRSP1:	SKIPE	T1,SPYTAB(P1)	;ANY BITS ON IN THIS WORD?
	JFFO	T1,CLRSP2	;YES, FIND THE FIRST ONE
	AOBJN	P1,CLRSP1	;NO, LOOK AT THE NEXT WORD
	POPJ	P,		;ALL PAGES HAVE BEEN REMOVED, RETURN
CLRSP2:	MOVE	T1,T2		;BIT POSITION TO T1
	HRRZ	T2,P1		;OFFSET INTO TABLE TO T2
	IMULI	T2,^D36		;NUMBER OF BITS PER WORD
	ADDI	T1,(T2)		;VIRTUAL PAGE NUMBER OF THE SPY PAGE IN USERS ADDRESS SPACE
	PUSHJ	P,DLTSP		;DELETE THE SPY PAGE
	  JRST	CLRSP1		;DELETED
	STOPCD	CLRSP1,DEBUG,DSS, ;++DLTSP SKIPPED
>	;END IFN FTPEEKSPY
;SUBROUTINE TO SCAN A LIST OF PAGES, VERIFY THAT EACH ENTRY IN THE
; LIST REPRESENTS A LEGAL VIRTUAL PAGE NUMBER, AND COUNT THE NUMBER
; OF ENTRIES WITH THE HIGH ORDER BIT ON AND THE NUMBER OF ENTRIES WITH
; THE HIGH ORDER BIT OFF.
;CALLING SEQUENCE:
;
;	MOVE	T1,[XWD N,ADDRESS OF LIST]
;	MOVE	T2,REQUIRED ATTRIBUTES
;	PUSHJ	P,PLTSN
;ERROR RETURNS, ILLEGAL PAGE NUMBER, PAGE EXISTS BUT MUST NOT, PAGE
; DOESN'T EXIST BUT MUST, PAGE MUST BE IN CORE BUT ISN'T, PAGE MUST
; NOT BE IN CORE BUT IS, AN ATTEMPT HAS BEEN MADE TO DO ANYTHING TO A
; PAGE IN A SHARABLE HIGH SEGMENT.
;RETURNS CPOPJ ON AN ERROR, T1 = ERROR CODE,
; RETURNS CPOPJ1 ON SUCCESS, T1 PRESERVED, T2 = NUMBER OF ENTRIES
; WITH THE SIGN BIT ON, T3 = THE NUMBER OF ENTRIES WITH THE SIGN BIT OFF
; .UPTMP=C(T3) - NUMBER OF ALLOCATED BUT ZERO PAGES
;RETURNS WITH BIT 0 ON IN M IF BIT 1(PG.SLO, PG.DSK) IS ON IN ANY ARGUMENT WORD

PLTSN:	PUSHJ	P,IOWAT		;WAIT FOR I/O TO STOP (SO I/O CAN'T CHANGE ARG LIST)
	PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSH	P,T1		;SAVE POINTER TO THE ARGUMENT LIST
	PUSHJ	P,FSTPAG	;POINTER TO USER'S ARGUMENT LIST
	HLRES	T1		;NUMBER OF ARGUMENTS
	JUMPLE	T1,[PUSHJ P,IALERR
		JRST T2POPJ##]	;MUST BE A POSITIVE NUMBER OF ARGUMENTS
	PUSH	P,T1		;SAVE THE NUMBER OF ARGUMENTS
	SETZB	P1,.USTMP	;INITIALIZE ARGUMENT TYPE COUNTER AND .UPTMP TO ZERO
	MOVE	P2,T2		;CHECK BITS
	SETZB	P3,P4		;HIGEST PAGES SEEN
PLTSN1:	PUSHJ	P,NXTPAG	;GET THE NEXT ARGUMENT
	TLZE	T1,(PG.SLO)	;CREATE VIRTUAL OR PAGE ON SLOW DEVICE?
	TLO	M,ARGMD		;YES, REMEMBER THAT
	PUSHJ	P,LGLPG		;A LEGAL PAGE?
	  JRST	PLTSN8		;NO, ILLEGAL PAGE ERROR
	TRNN	P2,PA.IHB	;IGNORE THE HIGH ORDER BIT OF THE ARGUMENT?
	JUMPGE	T1,PLTSN3	;NO, JUMP IF THE HIGH ORDER BIT IS OFF
	TLZ	T1,400000	;CLEAR THE HIGH ORDER BIT
	CAIL	P3,(T1)		;THIS PAGE HIGHER THAN THE LAST ONE SEEN?
	JRST	[PUSHJ P,IALERR	;NO, ILLEGAL ARGUMENT LIST ERROR
		JRST PLTSN8]	;ARGUMENT LIST MUST BE IN INCREASING VIRTUAL ORDER
	MOVE	P3,T1		;SAVE AS HIGHEST PAGE SEEN SO FAR
	MOVEI	T3,1		;ADD 1 TO THE COUNT OF ARGUMENTS WITH THE
				; HIGH ORDER BIT ON
	TRNN	P2,PA.PMI	;MUST THE PAGE BE IN CORE?
	JRST	PLTSN5		;NO
	PUSHJ	P,TSWST		;SEE IF THE PAGE IS IN THE WORKING SET
	  JRST	[PUSHJ P,PMIERR	;PAGE MUST BE IN CORE BUT ISN'T
		JRST PLTSN8]	;LOSE
	JRST	PLTSN5		;CONTINUE
PLTSN3:	CAIL	P4,(T1)		;THIS PAGE HIGHER THAN THE LAST PAGE SEEN?
	JRST	[PUSHJ P,IALERR	;NO, ILLEGAL ARGUMENT LIST ERROR
		JRST PLTSN8]	;LOSE
	MOVE	P4,T1		;SAVE AS HIGHEST PAGE SEEN
	MOVSI	T3,1		;ADD 1 TO THE COUNT OF ARGUMENTS WITH THE
				; HIGH ORDER BIT OFF
	PUSHJ	P,GTPME		;GET CONTENTS OF MAP SLOT
	CAIN	T2,PM.ZER	;ALLOCATED BUT ZERO?
	AOS	.USTMP	;YES, BUMP COUNTER
	TRNN	P2,PA.PCE	;CAN THE PAGE EXIST?
	JRST	PLTSN4		;YES, PROCEED
	TRNE	T2,-1-PM.ZER	;DOES THE PAGE EXIST?
	JRST	[PUSHJ P,PCEERR	;YES, PAGE CANNOT EXIST BUT DOES ERROR
		JRST PLTSN8]	;LOSE
	JRST	PLTSN6		;CONTINUE
PLTSN4:	TRNN	P2,PA.PCI	;CAN THE PAGE BE IN CORE?
	JRST	PLTSN5		;YES, PROCEED
	CAIN	T2,PM.ZER	;NO, ALLOCATED BUT ZERO?
	JRST	[PUSHJ P,ILPERR	;YES, THAT'S A NO-NO
		JRST PLTSN8]
	PUSHJ	P,TSWST		;NO, IS THE PAGE IN THE WORKING SET?
	  JRST	PLTSN5		;NO, ALL IS WELL
	JRST	[PUSHJ P,PCIERR	;YES, PAGE CANNOT BE IN CORE BUT IS ERROR
		JRST PLTSN8]	;LOSE
PLTSN5:	TRNN	P2,PA.PME	;MUST THE PAGE EXIST?
	JRST	PLTSN6		;NO, PROCEED
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT
	JUMPE	T2,[PUSHJ P,PMEERR ;JUMP IF PAGE DOESN'T EXIST SINCE IT MUST
		JRST PLTSN8]	;LOSE
PLTSN6:	PUSHJ	P,TPAHS		;IS THE PAGE IN A HIGH SEGMENT?
	  TLO	M,HSPAG		;YES, REMEMBER HIGH SEGMENT PAGE SEEN
	MOVE	T2,JBTSGN##(J)	;GET HIGH SEGMENT BITS
	TLNE	M,HSPAG		;WAS THIS A HIGH SEGMENT PAGE?
	TLNN	T2,SHRSEG!SPYSEG;YES, IS THE HIGH SEGMENT SHARABLE OR A SPY SEG?
	JRST	PLTSN7		;NO
	PUSHJ	P,PSHERR	;YES, PAGE IN A SHARABLE HIGH SEGMENT ERROR
	JRST	PLTSN8		;LOSE
PLTSN7:	ADD	P1,T3		;ACCUMULATE NUMBER OF ARGUMENTS
	SOSLE	(P)		;LOOKED AT ALL ARGUMENTS IN THE LIST?
	JRST	PLTSN1		;NO, LOOP OVER ALL ARGUMENTS
	POP	P,(P)		;POP OFF JUNK
	HRRZ	T2,P1		;T2 = NUMBER OF ARGUMENTS WITH THE SIGN BIT ON
	HLRZ	T3,P1		;T3 = NUMBER OF ARGUMENTS WITH THE SIGN BIT OFF
	JRST	TPOPJ1##	;RESTORE T1 AND RETURN
PLTSN8:	POP	P,(P)		;POP OFF JUNK
	PJRST	T2POPJ##	;POP OFF JUNK AND GIVE ERROR RETURN
				; ERROR CODE IN T1
;SUBROUTINE TO POINT M AT THE FIRST ARGUMENT IN THE USER'S ARGUMENT
; LIST AND SETUP .UPNXP IF A NEGATIVE COUNT WAS SPECIFIED, I.E.,
; A RANGE OF PAGES RATHER THAN A LIST OF PAGES

FSTPAG:	PUSHJ	P,SAVT##	;MAKE THIS LOOK LIKE A HRRI M,-1(T1)
	PUSHJ	P,GETTAC##	;GET CONTENTS OF USER'S AC
	SETOM	.USNXP		;ASSUME A TRADITIONAL ARGUMENT LIST
	HRRI	M,(T1)		;SETUP M TO GET ARGUMENT COUNT
	PUSHJ	P,GETWDU##	;GET ARGUMENT COUNT
	JUMPGE	T1,CPOPJ##	;POSITIVE MEANS A LIST IS SPECIFIED
	PUSHJ	P,GETWD1##	;GET THE RANGE
	JRST	PREPA1		;STORE IT FOR CALLS TO NXTPAG AND RETURN

;SUBROUTINE TO GET THE NEXT WORD FROM THE USER'S ARGUMENT LIST
; FSTPAG MUST HAVE BEEN CALLED BEFORE CALLING NXTPAG

NXTPAG:	MOVE	T1,.USNXP ;A RANGE OF PAGES SPECIFIED?
	CAMN	T1,[-1]
	PJRST	GETWD1##	;NO, GET NEXT ARGUMENT FROM LIST
	TLNN	T1,777		;LEFT HALF, RIGHT HALF ARGUMENT?
	AOSA	T1		;NO, JUST INCREMENT LEFT HALF
	AOBJN	T1,.+1		;YES, INCREMENT BOTH HALVES
	JRST	PREPA2		;STORE FOR NEXT CALL AND RETURN

;SUBROUTINE TO GET PREVIOUS WORD FROM THE USER'S ARGUMENT LIST
; FSTPAG MUST HAVE BEEN CALLED BEFORE CALLING PREPAG

PREPAG:	MOVE	T1,.USNXP ;A RANGE OF PAGES SPECIFIED?
	CAMN	T1,[-1]
	SOJA	M,GETWDU##	;NO, BACK UP TO PREVIOUS ARGUMENT IN LIST AN GET IT
PREPA1:	TLNN	T1,777		;PAGE PAIR?
	SOSA	T1		;NO, BACK UP THE PAGE NUMBER
	SUB	T1,[1,,1]	;BACK UP 1 PAGE
PREPA2:	MOVEM	T1,.USNXP ;SAVE FOR NEXT CALL
	POPJ	P,		;AND RETURN
;ERROR RETURNS

PIOERR:	PUSHJ	P,SAVE1##
	HRRZ	P1,T2		;SWPLST INDEX
	MOVE	S,SWPLST##(P1)	;GET THE SWPLST ENTRY CONTAINING THE ERROR
	TLNN	S,(SL.DIO)	;INPUT ERROR?
	JRST	PIOER1		;YES, NOTHING CAN BE DONE ABOUT IT
	PUSHJ	P,MAPBAK	;RESTORE THE MAP
	SOS	.JDAT+JOBPD1##+IFN FTKLP,<1> ;FORCE THE UUO TO BE REDONE
	POPJ	P,		;RETURN
PIOER1:	PUSHJ	P,DLTSLX	;DELETE THE SWPLST ENTRY
	JRST	PIOER2		;RETURN ERROR CODE TO THE USER

;ERROR RETURNS
	ERCODE	UIFERR,PAGUF%	;(0)UNIMPLEMENTED FUNCTION
	ERCODE	IALERR,PAGIA%	;(1)ILLEGAL ARGUMENT LIST
	ERCODE	ILPERR,PAGIP%	;(2)ILLEGAL PAGE
	ERCODE	PCEERR,PAGCE%	;(3)PAGE CANNOT EXIST BUT DOES
	ERCODE	PMEERR,PAGME%	;(4)PAGE MUST EXIST BUT DOESN'T
	ERCODE	PMIERR,PAGMI%	;(5)PAGE MUST BE IN CORE BUT ISN'T
	ERCODE	PCIERR,PAGCI%	;(6)PAGE CANNOT BE IN CORE BUT IS
	ERCODE	PSHERR,PAGSH%	;(7)PAGE IN A SHARABLE HIGH SEGMENT
	ERCODE	PIOER2,PAGIO%	;(10)PAGING I/O ERROR
	ERCODE	NSAERR,PAGNS%	;(11)NO SWAPPING SPACE AVAILABLE
	ERCODE	TBGERR,PAGLE%	;(12)CORE (VIRTAL OR USER LIMIT) EXCEEDED
	ERCODE	IILERR,PAGIL%	;(13)ILLEGAL IF LOCKED
	ERCODE	NVLERR,PAGNV%	;(14)ATTEMPT TO CREATE ABZ PAGE WITH CVPL=0
	ERCODE	NPVERR,PAGNP%	;(15)NOT PRIVILEGED
	SUBTTL	SUBROUTINES

FIXDSK:	PUSH	P,J		;SAVE J
	MOVE	J,.USJOB	;J = THE CURRENT JOB'S JOB NUMBER
	LDB	T1,IMGIN##	;T1 = THE NUMBER OF PAGES THIS JOB HAS IN CORE
	ADDI	T1,(P2)		;THE NEW SIZE
	PUSHJ	P,XPANDP##	;CAUSE THE ADDITIONAL PAGES TO BE ALLOCATED ON
				; THE NEXT SWAP-IN
	LDB	T1,[POINT 9,R,8];CURRENT SIZE OF THE JOB
	HLRZS	P2		;HIGHEST VIRTUAL PAGE SEEN
	CAIG	P2,(T1)		;HAS THE JOB INCREASED ITS VIRTUAL SIZE?
	MOVE	P2,T1		;NO, ORIGIONAL SIZE
	MOVE	T1,(P)		;RESTORE SEGMENT OR JOB NUMBER
	CAIG	T1,JOBMAX##	;IS THIS A HIGH SEGMENT?
	DPB	P2,JBYLSS##	;NO, STORE NEW LOW SEGMENT SIZE
	CAIG	T1,JOBMAX##	;IS THIS A HIGH SEGMENT?
	JRST	FIXDS1
	DPB	P2,JBYHSS##	;YES, STORE NEW HIGH SEGMENT SIZE
	DPB	P2,[POINT 9,R,8];STORE NEW HIGHEST VIRTUAL ADDRESS IN SEGMENT
	MOVEM	R,JBTADR##(T1)	;STORE THAT
FIXDS1:	MOVE	J,(P)		;SEGMENT NUMBER
	PUSHJ	P,SETVRT	;SET .UPVRT NON-0, UPDATE VMTOTL,VMCMAX
	MOVE	J,.USJOB	;JOB NUMBER
	MOVE	T1,(P)		;SEGMENT NUMBER
	MOVE	R,JBTADR##(J)	;SETUP R FOR THE LOW SEGMENT FOR WSCHED
	SKIPN	.CPISF##	;ON CLOCK LEVEL (CORE COMMAND)?
	CAILE	T1,JOBMAX##	;IF A HIGH SEG,
	PJRST	JPOPJ1##	; SEGCON WILL CALL WSCHED
	POP	P,J		;RESTORE SEGMENT NUMBER
IFN FTMP,<
	PUSHJ	P,REMMM##	;REMEMBER STATE OF THE MM RESOURCE
>
	AOS	(P)		;SKIP RETURN
	PJRST	WSCHED##	;AND WAIT UNTIL JOB GOES OUT AND COMES BACK IN

FIXADR:	HLRZ	T1,P1		;HIGHEST PAGE SEEN
	CAIG	J,JOBMAX##	;IS THIS A HIGH SEGMENT?
	PUSHJ	P,TPAHS		;PAGE IN THE HIGH SEGMENT?
	  JRST	FIXMJ1		;YES, NOTHING TO DO
	PUSHJ	P,JSTVRT	;SET .UPVRT NON-0, UPDATE VMCMAX
	LDB	T1,PCORSZ##	;LOW SEGMENT SIZE - 1
	HLRZS	P1		;PUT HIGHEST VIRTUAL PAGE SEEN IN THE RIGHT HALF
	CAIG	P1,(T1)		;WAS A PAGE CREATED ABOVE THE HIGHEST WHICH EXISTED?
	MOVE	P1,T1		;YES, NEW HIGHEST
	DPB	P1,PCORSZ##	;STORE NEW LOW SEGMENT SIZE
	DPB	P1,JBYLSS##	; ..
	MOVE	R,JBTADR##(J)	;GET SEGMENT SIZE,,SEGMENT ADDRESS
	CAME	J,.CPJOB##
	PJRST	FIXMJ1
FIXAD1:	MOVEM	R,.CPADR##	;STORE FOR UUOCON
	HLRZM	R,.CPREL##	;AND FOR ADDRESS CHECKING
	HLRZM	R,.USHVA	;FOR ADDRESS CHECKING AT INTERRUPT LEVEL
	PJRST	FIXMJ1		;CLEAR THE A.M. AND RETURN TO THE USER
;ROUTINE TO INCREMENT .UPREL ON CREATE PAGES UUO
;PRESERVES T1
ICUPRW:	LSH	T1,W2PLSH##	;GET PAGE NUMBER INVOLVED
ICUPR:	CAIG	J,JOBMAX##
	PUSHJ	P,TPAHS
	  POPJ	P,
	SKIPN	T2,.USREL	;JOB VIRTUAL?
	HLRZ	T2,R		;NO, PHYSICAL SIZE EQUALS VIRTUAL SIZE
	LSH	T2,W2PLSH##	;CONVERT TO HIGHEST PAGE NUMBER
	CAIGE	T1,1(T2)	;PAGE IN THE MIDDLE OF THE ADR SPACE?
	POPJ	P,		;YES, NOTHING TO DO
	SKIPN	.USREL		;NON-CONTIGUOUS CORE IMAGE?
	HLRZM	R,.USREL	;NO, STORE R SINCE IT MAY BE NOW
	PUSH	P,T1		;SAVE CURRENT VIRTUAL PAGE
	HLRZ	T3,R		;HIGHEST VIRTUAL ADDRESS IN THIS JOB'S ADDRESS SPACE
	LSH	T3,W2PLSH##	;CONVERT TO HIGHEST PAGE
	CAIE	T1,1(T2)	;NEXT PAGE NON-CONTIGUOUS?
	JRST	ICUPR4		;YES, UPDATE UPMEM, SETUP R AND RETURN
	MOVE	T2,.USHSS	;IS THERE A HI SEG?
	SKIPN	.USHSE
	MOVSI	T2,1		;NO, MAKE SURE TEST WILL FAIL
	LSH	T2,W2PLSH##	;COMPUTE START PAGE OF HI SEG
	PUSH	P,T2		;SAVE START PAGE ON THE LIST
	ADDI	T1,1		;NEXT PAGE
ICUPR1:	CAILE	T1,(T3)		;IS THIS PAGE ABOVE THE HIGHEST?
	JRST	ICUPR3		;YES, ALL PAGES ARE CONTIGUOUS
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP
	JUMPE	T2,ICUPR2	;IF NEXT PAGE EXISTS,
	CAML	T1,(P)		; IF ABOVE HI SEG
	JRST	ICUPR2		; WE'RE DONE. IF NOT ABOVE HI SEG,
	SOS	.USMEM	; IT WILL NOW BE INCLUDED IN .UPREL
				; SO REMOVE IT FROM .UPMEM
	AOJA	T1,ICUPR1
ICUPR2:	LSH	T1,P2WLSH##	;CONVERT FROM PAGE NUMBER TO ADDRESS
	SOSA	T1		;ADDRESS - 1
ICUPR3:	MOVEI	T1,0		;ALL PAGES ARE CONTIGUOUS
	MOVEM	T1,.USREL	;STORE NEW UPREL
	POP	P,(P)		;REMOVE START HI-SEG PAGE FROM LIST
	SKIPA	T1,(P)		;GET PAGE IN QUESTION
ICUPR4:	AOS	.USMEM		;A NON-CONTIGUOUS PAGE, COUNT UP THE NUMBER OF SAME
	CAIL	T1,(T3)		;CURRENT PAGE HIGHER THAN PREVIOUS HIGHEST?
	DPB	T1,[POINT 9,R,8];YES, MAKE R REFLECT THE HIGHER PAGE
	MOVEM	R,JBTADR##(J)	;NEW PROTECTION,,RELOCATION
	SKIPN	T1,.USREL
	HLRZ	T1,R
	MOVEM	T1,JOBREL##+.JDAT
	PJRST	TPOPJ##		;RESTORE VIRTUAL PAGE NUMBER AND RETURN
;ROUTINE TO DECREMENT .UPREL (PRESERVES T1)
DCUPR:	CAIG	J,JOBMAX##	;A HIGH SEGMENT?
	PUSHJ	P,TPAHS		;MAKE SURE
	  POPJ	P,		;YES, NOTHING TO DO
DCUPN:	SKIPN	T2,.USREL	;ALREADY A VIRTUAL USER?
	HLRZ	T2,R		;LH(R) = HIGHEST VIRTUAL ADDRESS
	ADDI	T2,1
	MOVE	T3,T1		;T3 = VIRTUAL PAGE NUMBER
	LSH	T3,P2WLSH##	;CONVERT TO HIGHEST VIRTUAL ADDRESS
	CAMLE	T3,T2		;LOWER THAN PREVIOUS HIGHEST?
	SOJA	T2,DCUPR1	;UPDATE UPREL AND R
	MOVEI	T4,PG.BDY##(T3)	;TOP NEW ADR
	ADDI	T4,1
	SUBM	T2,T4		;NUMBER OF PAGES ABOVE .UPREL
	ASH	T4,W2PLSH##
	ADDM	T4,.USMEM	;INCREASE NO OF NON-CONTIG VIRTUAL PAGES
	ADD	T2,[-1,,MPGSIZ##]
	CAMN	T3,T2		;ADJACENT TO HIGHEST PAGE?
	SKIPE	T2,.USREL	;YES, NO CHANGE
	SOSA	T2,T3		;NEW UPREL = NEW ALLOCATION - 1
	SOJA	T3,DCUPR3	;LEAVE UPREL = 0, DECREASE R
	MOVEM	T2,.USREL	;STORE NEW VALUE OF UPREL
	SKIPN	T2		;IF NOW CONTIGUOUS
	HLRZ	T2,R		; USE JOB SIZE
	MOVEM	T2,.JDAT+JOBREL## ;UPDATE USERS JOBREL
	POPJ	P,		;AND RETURN
DCUPR1:	SOS	.USMEM	;DECREMENT COUNT OF NON-CONTIGUOUS PAGES
	LDB	T3,[POINT 9,R,8] ;CURRENT HIGHEST PAGE IN THE LOW SEGMENT
	CAIE	T1,(T3)		;DECREASING SIZE?
	POPJ	P,		;NO, GO AWAY
	PUSHJ	P,SAVE3##
	DMOVE	P1,.USHSE	;GET LIMITS OF HIGH SEG
	ADDI	P1,1
	LSHC	P1,W2PLSH##	;P1=HI-SEG END PAGE, P2=HI-SEG START PAGE
	MOVE	P3,T1		;SAVE START PAGE IN P3
	LSH	T2,W2PLSH##	;CONVERT HIGEST CONTIGUOUS ADDRESS TO PAGE NUMBER
	SUBI	T3,1(T2)	;NUMBER OF PAGES ABOVE NEW HIGHEST PAGE
IFE FTKLP,<
	MOVEI	T4,1(T1)	;START LOOKING AT THIS MAP SLOT
	PUSHJ	P,GMPTR		;GET A BYTE POINTER TO THE MAP
>
IFN FTKLP,<
;THE ABOVE MOVEI T4,1(T1) DEPENDS ON GMPTR RETURNING A POINTER TO
; USER VIRTUAL PAGE 1000? SO THAT THE SUBI BELOW DECREMENTS THE BYTE POINTER
	MOVE	T4,T1
	PUSHJ	P,GMPTR
	ADDI	T4,1
>
DCUPR2:	SUBI	T4,1
IFE FTKLP,<
	ILDB	T2,T4		;GET THE CONTENTS OF THE PREVIOUS MAP SLOT
>
IFN FTKLP,<
	LDB	T2,T4		;EACH MAP ENTRY IS A FULL WORD
>
	CAIL	P3,(P2)		;UNLESS THIS PAGE IS IN MIDDLE OF HI-SEG
	CAIL	P3,(P1)
	JUMPN	T2,DCUPR4	; IF NON-ZERO, DON'T CHANGE UPREL
	SUB	R,[PAGSIZ##,,0]	;THIS SLOT EMPTY - DECREMENT R
	SUBI	P3,1
	SOJG	T3,DCUPR2	;LOOP OVER ALL PAGES POSSIBLY NOT IN THE MAP
	SKIPE	.USREL
	HRL	R,.USREL	;NEW HIGHEST ADDRESS
	SETZM	.USREL		;ALL PAGES IN THE LOW SEGMENT ARE CONTIGUOUS
	JRST	DCUPR4		;STORE R AND RETURN
DCUPR3:	HRL	R,T3		;NEW HIGHEST ADDRESS
	HLRZM	R,.JDAT+JOBREL##;STORE NEW HIGHEST ADDRESS IN LOW SEG FOR THE USER
DCUPR4:	MOVEM	R,JBTADR##(J)	;STORE NEW PROTECTION,,RELOCATION
	POPJ	P,		;AND RETURN
;ROUTINE TO ADD A DISK PAGE TO THE WORKING SET
;ENTER T1=VIRTUAL PAGE NUMBER OF THE PAGE
INSDSK:	PUSHJ	P,WSBIT		;GET BIT AND INDEX INTO WORKING SET TABLE
	IORM	T2,AABTAB(T4)	;AND MAKE SURE ACCESS IS ALLOWED
INSMPD:	IORM	T2,WSBTAB(T4)	;ADD THE PAGE TO THE WORKING SET
	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT
	CAIE	T2,PM.ZER	;IS THIS AN ALLOCATED BUT ZERO PAGE?
	POPJ	P,		;NO, RETURN
	MOVEI	T2,0		;YES, ZERO THE MAP ENTRY SO SETIMT WON'T
	DPB	T2,T4		; TRY TO SWAP-IN A PAGE
	PJRST	INSMEM		;FIX UPMEM AND RETURN



;ROUTINE TO INSERT A PAGE IN THE MAP, WSBTAB AND AABTAB
;ENTER T1=VIRTUAL PAGE NUMBER, P1=PHYSICAL PAGE NUMBER
;EXIT T1=VIRTUAL PAGE NUMBER
INSPAG:	MOVE	T3,.USJOB	;CURRENT JOB'S JOB NUMBER
	AOS	JBTSWP##(T3)	;INCREMENT NUMBER OF PAGES ALLOCATED IN PHYSICAL CORE
INSMPC:
IFE FTKLP,<
	MOVEI	T3,PM.ACC+PM.PUB+PM.WRT+IFN FTKL10!FTKS10,<PM.CSH>(P1)
>
IFN FTKLP,<
	MOVE	T3,P1
	HRLI	T3,(<PM.DCD>B2+PM.PUB+PM.WRT+PM.CSH)
>
	PUSHJ	P,WSBIT		;GET BIT AND INDEX INTO WSBTAB
	IORM	T2,AABTAB(T4)	;AND THAT ACCESS IS ALLOWED
INSMPU:	IORM	T2,WSBTAB(T4)	;INDICATE THIS PAGE IS NOW IN THE WORKING SET
	CAILE	J,JOBMAX##	;HIGH SEGMENT?
	TDZ	T3,[PM.WRT]	;YES, WRITE LOCK THE PAGE
	PUSHJ	P,GTPME		;GET THE CURRENT CONTENTS OF THE MAP
	DPB	T3,T4		;STORE THE PHYSICAL PAGE NUMBER IN THE MAP
	CAIE	T2,PM.ZER	;ALLOCATED BUT ZERO?
	POPJ	P,
;HERE TO ADJUST VIRTAL, UPMEM FOR ALLOCATED BUT 0 PAGES
INSMEM:	AOS	VIRTAL##	;VIRTAL WAS ALREADY UPDATED
	CAIG	J,JOBMAX##
	PUSHJ	P,TPAHS
	  POPJ	P,
	SKIPN	T2,.USREL
	HLRZ	T2,R		;IF THIS PAGE IS NON-CONTIGUOUS,
	LSH	T2,W2PLSH##
	CAILE	T1,1(T2)	; ICUPR WILL AOS UPMEM
	SOS	.USMEM	;SO DECREMENT IT IN ANTICIPATION
	POPJ	P,
;ROUTINE TO ZERO A PAGE
;ENTER WITH T1=VIRTUAL PAGE NUMBER
;EXIT T1=VIRTUAL PAGE NUMBER
ZERPAG:	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT
ZPAGE:
IFE FTKLP,<
	TRO	T2,PM.WRT+PM.ACC+IFN FTKL10!FTKS10,<PM.CSH>  ;MAKE PAGE WRITABLE
>
IFN FTKLP,<
	HRLI	T2,(<PM.DCD>B2+PM.WRT+PM.CSH)
>
IFN FTMP&FTKL10,<
	PUSHJ	P,MLSCSH##	;IS FREEOR CACHED
	  TDZ	T2,[PM.CSH]	;MUST BE UNCACHED
>
IFE FTKLP,<
	HRRM	T2,.UPMP+.MTEMP	;MAP THE PAGE IN THE EXEC MAP
>
IFN FTKLP,<
	MOVEM	T2,.UPMP+.TEMP/PAGSIZ##
>
	CLRPGT	(0,.TEMP)	;CLEAR THE A.M. SO NEW MAPPING WILL BE USED
	MOVE	T2,[.TEMP,,.TEMP+1]
	SETZM	.TEMP		;CLEAR THE FIRST WORD OF THE PAGE
	BLT	T2,.TEMP+PG.BDY## ;ZERO THE PAGE
	MOVEI	T2,PAGSIZ##	;NUMBER OF WORDS ZEROED
	ADDM	T2,CLRWRD##	;UPDATE AMOUNT OF TIME SPENT ZEROING CORE

	POPJ	P,		;AND RETURN


;SUBROUTINE TO ADJUST VMTOTL AND VMCMAX WHEN A PAGE
; IS BEING REMOVED
;PRESERVES ALL ACS BUT T1

DCVMT::	SKIPL	T1,.USVRT	;IF HI SEG IS VIRTUAL,
	TRNE	T1,777000	;OR LOW SEG IS VIRTUAL
	SOSA	VMTOTL##	;ADJUST NUMBERS
	POPJ	P,		;JUST ACCESS ALLOWED - RETURN
	AOS	VMCMAX##	;INCR. VMCMAX
	POPJ	P,

;SUBROUTINE TO RETURN THE CURRENT VIRTUAL SIZE
; OF A JOB IN T4
;PRESERVES T3

VJSIZ:	PUSH	P,T3		;SAVE T3
	PUSH	P,J		;AND J
	MOVE	J,.USJOB	;CURRENT JOB'S JOB NUMBER
	PUSHJ	P,VMSIZE	;GET THE JOB'S VIRTUAL SIZE
	MOVE	T4,T1		;LOW SEGMENT VIRTUAL SIZE
	ADD	T4,T2		;ADD HIGH SEGMENT VIRTUAL SIZE
	POP	P,J		;RESTORE J
	JRST	T3POPJ##	;RESTORE T3 AND RETURN JOB'S VIRTUAL SIZE IN T4
;SUBROUTINE TO SEE IF PAGE UUO WILL CAUSE THE JOB TO BECOME TOO BIG
;ENTER  WITH ACS AS RETURNED BY PLTSN
;EXIT CPOPJ IF TOO BIG, CPOPJ1 IF OK
;EITHER EXIT T1 = CURRENT VIRTUAL SIZE OF THE JOB
;PRESERVES T2-T4
SZCHK:	JUMPE	T3,CPOPJ1##	;RETURN IF NOT INCREASING NUMBER OF PAGES IN CORE
	PUSH	P,T4
	PUSHJ	P,GSIZD		;SEE IF IT WILL FIT
	SOS	-1(P)		;NO, ERROR
	  JFCL			;YES, HE CAN GROW TO MPPL
	MOVE	T1,T4		;CURRENT VIRTUAL SIZE
	POP	P,T4
	PJRST	CPOPJ1##	;SKIP RETURN

;SUBROUTINE TO WAIT FOR I/O TO STOP
;PRESERVES T1-T4
IOWAT:	PUSHJ	P,SAVT##	;SAVE T1-T4
IFN FTMP,<
	PUSHJ	P,REMMM##	;REMEMBER STATE OF THE MM
>
	CAIE	T2,PA.PME+PA.PCE ;CREATING A PAGE?
	JRST	IOWAIT##	;NO, WAIT FOR I/O TO STOP
	JRST	INWAT1		;YES,,WAIT FOR INPUT TO STOP

;SUBROUTINE TO WAIT FOR INPUT TO STOP
;PRESERVES T1-T4
INWAT::	PUSHJ	P,SAVT##	;BE NICE AND SAVE T1-T4
INWAT1:	MOVEI	T1,WAITI	;WAIT FOR INPUT TO STOP
	JRST	IOALL##

;SUBROUTINE TO WAIT FOR INPUT TO STOP ON A DEVICE
WAITI:	TLNN	S,IO		;INPUT
	JRST	WAIT1##		;YES, WAIT UNTIL IT COMPLETES
	POPJ	P,		;NO, DON'T WAIT

;SUBROUTINE TO REMEMBER THE STATE OF THE MM RESOURCE AND CALL IOWAIT
IOWATM:
IFN FTMP,<
	PUSHJ	P,REMMM##	;REMEMBER THE STATE OF THE MM
>
	PJRST	IOWAIT##	;WAIT FOR I/O, MM WILL RESTORED ON EXIT
;SUBROUTINE TO CHECK IF ADDING A HIGH SEGMENT TO A JOBS ADDRESSING
; SPACE WOULD CAUSE IT TO BE TO BIG
;EXITS CPOPJ IF IT WON'T FIT AT ALL,
;EXITS CPOPJ1 IF PAGING OUT THE LOW SEGMENT WILL MAKE IT FIT,
;EXITS CPOPJ2 IF IT WILL FIT PHYSICALLY
;RESPECTS T2
GSZSG::	LDB	T1,IMGIN##	;SIZE OF THE HIGH SEGMENT
	ADDI	T1,UPMPSZ##+1	;PLUS SIZE OF THE UPMP + PAGE 0
	LSH	T1,P2WLSH##	;CONVERT TO WORDS
	PUSH	P,T2		;SAVE T2
	HRRZ	T2,.PDCVL##(W)	;CURRENT PHYSICAL LIMIT/GUIDELINE
	JUMPE	T2,GSZSG1	;JUMP IF THERE ISN'T ONE
	TRZN	T2,400000	;LIMIT?
	HRRZ	T2,.PDMVL##(W)	;NO, GUIDELINE - USE MAX PHYSICAL LIMIT
	JUMPE	T2,GSZSG1	;JUMP IF NONE
	LSH	T2,P2WLSH##	;CONVERT TO WORDS
	CAMG	T1,T2		;EXCEEDING LIMIT?
GSZSG1:	CAMLE	T1,CORMAX##	;OR BIGGER THAN CORMAX?
	PJRST	T2POPJ##	;YES, THEN IT WILL NEVER FIT
	PUSHJ	P,VJSIZ		;GET CURRENT VIRTUAL SIZE
	PUSHJ	P,SEGSIZ##	;AND SIZE OF NEW HISEG
	ADD	T4,T2		;COMPUTE NEW VIRTUAL SIZE
	HLRZ	T2,.PDCVL##(W)	;GET CURRENT VM LIMIT
	CAMGE	T2,T4		;WILL IT FIT?
	JUMPN	T2,T2POPJ##	;NO, ERROR TO EXCEED VM LIMIT
	SETZB	T2,T3		;IT WILL FIT PHYSICALLY, SEE IF MUST GO VIRTUAL
	PUSHJ	P,GSIZD		;CHECK LIMITS
	  JRST	[HRRZ T2,.PDMVL##(W) ;IGNORE WON'T FIT SINCE ALREADY CHECKED THAT
		 JUMPE T2,T2POPJ## ;WON'T FIT IF NOT MPPL
		 JRST .+1]	;OK
	  SKIPA	T4,T1		;T4 = VIRTUAL SIZE
	JRST	GSZSG3		;IT WILL FIT PHYSICALLY
	HLRZ	T2,.PDCVL##(W)	;GET CURRENT VM LIMIT
	JUMPE	T2,T2POPJ##	;DOESN'T FIT IF NO VIRTUAL AND TOO BIG FOR PHYSICAL
	MOVSI	T1,(UP.GET)	;GETTING GET?
	TDNE	T1,.USBTS	;IF SO, THATS OK
	JRST	GSZSG3		;SAY IT WILL FIT PHYSICALLY
	PUSH	P,J		;SAVE THE HIGH SEGMENT NUMBER
	MOVE	J,.CPJOB##	;JOB NUMBER
	LDB	T1,IMGIN##	;JOB'S CURRENT PHYSICAL SIZE
	LSH	T1,P2WLSH##	;CONVERT TO WORDS
	ADD	T4,T1		;COMPUTE NEW JOB SIZE
	MOVE	T2,JBTSTS##(J)	;JOB STATUS FOR THIS JOB
	TLNE	T2,JACCT	;IS IT A PRIVILEGED PROGRAM?
	JRST	GSZSG2		;YES, DON'T GO VIRTUAL
	TRNN	T2,JS.RUU	;GETSEG?
	PJRST	GSZSG0		;YES, DON'T CHECK FOR RUNNING A PRIV. PROG.
	MOVE	T1,.JDAT+SGANAM## ;NAME OF THE PROGRAM BEING RUN
	TLNE	F,SYSDEV	;BEING RUN FROM SYS?
	PUSHJ	P,PRVPG##	;YES, IS IT A PRIVILEDGED PROGRAM?
GSZSG0:	SOS	-2(P)		;NO, ONLY FITS IF VIRTUAL
GSZSG2:	POP	P,J		;RESTORE HIGH SEGMENT NUMBER
GSZSG3:	POP	P,T2		;AND PRESERVED AC
	JRST	CPOPJ2##	;GIVE SINGLE OR DOUBLE SKIP RETURN
;SUBROUTINE TO TEST VARIOUS CORE LIMITS
;ENTER GSIZI WITH T3=# PAGES OF INCREASE
;ENTER GSIZD WITH T3-T2=# PAGES OF INCREASE
;EXIT CPOPJ IF WILL NEVER FIT PHYSICALLY
;EXIT CPOPJ1 IF .GT. CPPL, .LE. MPPL
;EXIT CPOPJ2 IF .LE. CPPL
;RETURNS T1=NEW HIGHEST ADR, T4=NEW JOB SIZE, RESPECTS T2-T3
GSIZT::	PUSH	P,T1		;SAVE T1
	PUSH	P,T3		;AND T3
	MOVE	T3,T4		;SET ARGUMENT FOR GSIZI
	PUSHJ	P,GSIZI		;SEE IF IT WILL FIT
	  SOS	-2(P)		;NOT AT ALL
	  CAIA			;ONLY VIRTUALLY
	AOS	-2(P)		;PHYSICALLY
	POP	P,T3		;RESTORE PRESERVED AC
	PJRST	TPOPJ1##	;RESTORE T1 AND RETURN
GSIZI::	PUSH	P,T2		;SAVE T2
	TDZA	T2,T2		;NO PAGES OF DECREASE
GSIZD::	PUSH	P,T2		;PRESERVE T2
	PUSH	P,T2		;PUT ARGUMENT ON THE STACK
	PUSHJ	P,VJSIZ		;GET THE JOBS CURRENT VIRTUAL SIZE
	PUSHJ	P,SEGSIZ##	;PHYSICAL SIZE OF THE SEGMENT
	CAIG	J,JOBMAX##	;IS THIS A HIGH SEGMENT?
	SUBI	T2,UPMPSZ##	;NO, SUBTRACT OUT THE UPMP SIZE
	SUB	T2,(P)		;SUBTRACT OUT THE NUMBER OF PAGES OF DECREASE
	POP	P,(P)		;POP OFF JUNK
	ADD	T2,T3		;NEW PHYSICAL SIZE OF THE SEGMENT
	LSH	T2,P2WLSH##	;CONVERT TO WORDS
	SOS	T1,T2		;HIGHEST ADDRESS REQUESTED IN T1
	PUSH	P,P1		;SAVE P1
	MOVSI	P1,PHONLY	;ASK IF IT WILL FIT PHYSICALLY
	PUSHJ	P,SUMSEG##	;WILL BOTH SEGMENTS PLUS THE INCREASE FIT?
	  SKIPA	P1,.PDCVL##(W)	;NO, GET THE CURRENT PHYSICAL LIMIT/GUIDELINE
	AOJA	T2,[HRRZ P1,.PDCVL##(W)
		    JUMPE P1,GSIZ2
		    LSH T2,W2PLSH##
		    CAIGE T2,(P1)
		    JRST GSIZ2	;NOT EXCEEDING GUIDELINE
		    LSH T2,P2WLSH##
		    SOJA T2,.+1];EXCEEDING GUIDELINE, SEE IF IT WILL FIT ANYWAY
	ADDI	T2,UPMSZW##	;ACCOUNT FOR THE UPMP
	TLO	P1,PHONLY	;GET PHYSICAL LIMIT
	EXCH	J,.USJOB
	PUSHJ	P,CORBND##	; ..
	EXCH	J,.USJOB
	CAMG	T2,T1		;GETTING TO BIG PHYSICALLY?
	TRNE	P1,400000	;NO, GUIDELINE OR LIMIT?
	JRST	GSIZ1		;LIMIT, CAN'T HELP HIM
	MOVE	P1,.PDMVL##(W)	;GET THE MAXIMUM PHYSICAL LIMIT
	LSH	T2,W2PLSH##	;CONVERT TO WORDS
	TRNE	P1,-1		;WAS MPPL SET?
	CAILE	T2,-1(P1)	;YES, TRYING TO EXCEED THAT?
GSIZ1:	SOS	-2(P)		;YES, WON'T FIT
	JRST	GSIZ3		;RESTORE ACS AND NON-SKIP RETURN
GSIZ2:	AOS	-2(P)		;HERE IF CAN FIT PHYSICALLY
GSIZ3:	POP	P,P1		;RESTORE P1
	PJRST	T2POJ1##	;RESTORE T2 AND RETURN
;SUBROUTINE TO GET THE MAP ENTRY FOR THE VIRTUAL PAGE SPECIFIED BY
; THE CONTENTS OF T1
;CALLING SEQUENCE:
;
;	MOVE	T1,VIRTUAL PAGE NUMBER
;	PUSHJ	P,GTMPE
;RETURN CPOPJ,  T2 = CONTENTS OF THE MAP, T4= MAP SLOT POINTR
;T1,T3 PRESERVED

GTPME::	HRRZ	T4,T1		;ARGUMENT TO GMPTR
	PUSHJ	P,GMPTR		;GET A BYTE POINTER TO THE MAP SLOT
	LDB	T2,T4		;CONTENTS OF THE SLOT
	POPJ	P,		;RETURN


;SUBROUTINE TO GET THE MAP ENTRY FOR A PAGE
;ENTER T4=VIRTUAL PAGE NUMBER
;EXIT T4=CONTENTS OF MAP SLOT
;T1-T3 PRESERVED
GTPM4::	PUSHJ	P,GMPTR		;GET POINTER TO MAP SLOT
	LDB	T4,T4		;GET MAP CONTENTS
	POPJ	P,		;AND RETURN

;SUBROUTINE TO SEE IF THE VIRTUAL PAGE NUMBER SPECIFIED BY THE CONTENTS OF
; T1 IS A LEGAL VIRTUAL PAGE NUMBER
;PRESERVES T1

LGLPG::	TLNE	T1,377777	;EXTRA BITS ON IN LH
	JRST	ILPERR		;YES, ILLEGAL PAGE NUMBER
LGLPR:	HRRZ	T2,T1		;PAGE NUMBER (HIGH ORDER BIT MAY BE ON IN T1)
	SKIPE	T2		;PAGE ZERO IS ILLEGAL
	CAILE	T2,HLGPNO	;LESS THAN HIGHEST LEGAL PAGE NUMBER?
	JRST	ILPERR		;ILLEGAL PAGE
	JRST	CPOPJ1##	;OK RETURN

;SUBROUTINE TO TEST TO SEE IF THE VIRTUAL PAGE SPECIFIED BY THE CONTENTS
; OF T1 IS IN THE WORKING SET, I.E., IN CORE, RETURNS CPOPJ IF NOT, CPOPJ1
; IF SO, T2 = MASK TO SET OR CLEAR THE BIT, T4 IS THE INDEX INTO THE
; WORKING SET BIT TABLE
;PRESERVES T1,T3

IFN FTPEEKSPY,<
TSSPT::	SKIPA	T4,[SPYTAB]
>
TSWST::	MOVEI	T4,WSBTAB
	PUSH	P,T1		;SAVE ARGUMENT
	IDIVI	T1,^D36		;WORD NUMBER IN T1, BIT POSITION IN T2
	MOVE	T2,BITTBL##(T2)	;GET POSITIONED BIT FROM BIT NUMBER
	TLO	T4,400000+T1	;IFIW
	TDNE	T2,@T4		;IS THE BIT ON IN WSBTAB (PAGE IN CORE)?
	AOS	-1(P)		;YES, SKIP RETURN
	MOVE	T4,T1		;RETURN WORD NUMBER IN T4
	PJRST	TPOPJ##		;RESTORE VIRTUAL PAGE NUMBER AND RETURN

;SUBROUTINE TO GET BIT, INDEX FOR WSBTAB AND AABTAB
;ENTER AND EXIT WITH ACS LIKE TSWST
;RETURNS NON-SKIP IF PAGE ISNT IN WORKING SET, HALTS IF IT IS
;PRESERVES T1,T3
WSBIT:	PUSHJ	P,TSWST		;IS THE PAGE IN THE WORKING SET?
	  POPJ	P,		;NO, RETURN
	STOPCD	CPOPJ##,DEBUG,PIN,	;++PAGE IN WORKING SET

;SUBROUTINE TO TEST IF BIT ON IN AABTAB
;ENTER T1=BIT, T2=INDEX INTO TABLE (AFTER DIVIDE OF PAGE NUMBER BY 36)
;EXIT CPOPJ IF NOT ON IN AABTAB, CPOPJ1 IF IT IS
;PRESERVES ALL ACS
TSAAT:	PUSH	P,T1		;SAVE BIT
	MOVNI	T1,-^D35(T1)	;CALCULATE INDEX INTO BITTBL
	MOVE	T1,BITTBL##(T1)	;GET POSITIONED BIT
	TDNE	T1,AABTAB(T2)	;IS THE BIT ON IN THE ACCESS ALLOWED TABLE?
	AOS	-1(P)		;YES, SKIP RETURN
	PJRST	TPOPJ##		;RESTORE T1 AND RETURN

;SUBROUTINE TO TEST TO SEE IF USER IS IN HIS PAGE FAULT HANDLER
;CALL WITH:
;	T2 = PC
;	PUSHJ	P,INPFH
;	  RETURN HERE IF IN PFH
;	RETURN HERE IF NOT
;
; RESPECTS ALL AC'S EXCEPT T3
;
INPFH::	HRRZ	T3,.JDAT+.JBPFH## ;GET START OF PFH
	SKIPE	.JDAT+.JBPFH##	;ANY PAGE FAULT HANDLER AT ALL
	CAILE	T3,(T2)		;ABOVE START?
	JRST	CPOPJ1##	;NO--NOT IN PFH
	HLRZ	T3,.JDAT+.JBPFH## ;GET END OF PFH
	CAIGE	T3,(T2)		;ABOVE END?
	JRST	CPOPJ1##	;YES--NOT IN PFH
	POPJ	P,0		;IN PFH
;SUBROUTINE TO DESTROY PAGES.  ENTER WITH VIRTUAL PAGE NUMBER OF PAGE
; TO BE DELETED IN T1, PAGE MUST EXIST
; GET PHYSICAL PAGE NUMBER, ZERO MAP ENTRY, FIND PHYSICAL PAGE NUMBER
; IN PAGTAB, LINK PAGTAB AROUND IT, UPDATE CORTAL, BIGHOL

DLTPAG:	PUSHJ	P,DLTSP		;DELETE SPY PAGE?
	  POPJ	P,		;YES
IFN FTMP,<
	PUSHJ	P,MMOWN##	;OWN THE MM?
	  PUSHJ	P,MMDIE##	;NO, STOP
>
	PUSHJ	P,RMVPAG	;REMOVE THE PAGE FROM THE MAP
	  JRST	DLTPGD		;GIVE BACK THE SWAPPING SPACE

;HERE WITH T2=PAGE TO BE GIVEN BACK
DLTPGC:	SE1ENT			;MUST BE IN SECTION 1 TO ADDRESS PAGTAB
	MOVE	T1,PAGPTR##	;FIRST PAGE ON THE FREE CORE LIST
	SKIPG	T2		;TRYING TO RETURN PAGE 0 ?
	STOPCD	.,STOP,RPZ,	;++RETURNING PAGE 0
	MOVEM	T2,PAGPTR##	;STORE THIS PAGE AS NEW FIRST PAGE
	TLO	T1,FREPAG	;INDICATE THAT THIS IS A FREE PAGE
	SSX	T2,MDSEC2	;PAGTAB SECTION
	MOVEM	T1,PAGTAB(T2)	;ADD THE PAGE TO THE FREE CORE LIST
	AOS	BIGHOL##	;INCREMENT NUMBER OF FREE PAGES
	AOS	CORTAL##	;AND THE NUMBER OF POTENTIALLY FREE PAGES
	AOS	VIRTAL##	;AND THE AMOUNT OF SWAPPING SPACE AVAILABLE
IFN FTKL10&FTMP,<
	SETOM	SAVCTL##	;MAKE SURE A SWEEP HAPPENS
>
	POPJ	P,		;RETURN

;HERE IF PAGE IS ON DISK
DLTPGD:	AOS	VIRTAL##	;INCREMENT THE AMOUNT OF SWAPPING SPACE AVAILABLE
	CAIN	T2,PM.ZER	;ALLOCATED BUT ZERO PAGE?
	POPJ	P,		;YES, ALL DONE
	MOVE	T1,T2		;ARGUMENT TO FXSAT
	MOVEI	U,1		;NUMBER OF PAGES TO RETURN
	PJRST	FXSAT1##	;GIVE BACK THE SWAPPING SPACE
;SUBROUTINE TO REMOVE PAGE FROM JOBS ADDRESSING SPACE
;ENTER T1= VIRTUAL PAGE TO BE REMOVED
;EXIT CPOPJ, T2=DSK ADDRESS IF PAGE ON DSK
; OR EXIT CPOPJ1, T2= PHYSICAL PAGE NUMBER IF PAGE IN CORE
RMVPAG:	PUSHJ	P,GTPME		;GET THE CONTENTS OF THE MAP SLOT
	MOVEI	T3,0		;ZERO THE MAP SLOT SINCE PAGE NO LONGER
	DPB	T3,T4		; EXISTS
	PUSH	P,T2		;SAVE THE PREVIOUS MAP CONTENTS
	PUSHJ	P,DCUPR		;DECREMENT UPREL
	POP	P,T3		;PREVIOUS MAP-SLOT CONTENTS
	PUSHJ	P,TSWST		;WAS THE PAGE IN THE WORKING SET?
	  TLOA	T3,-1		;NO, REMEMBER THAT
	SOS	JBTSWP##(J)	;YES, DECREMENT THE COUNT OF THE NUMBER OF
				; PAGES IN CORE
	ANDCAM	T2,WSBTAB(T4)	;CLEAR THE BIT IN THE WORKING SET TABLE
	TRNN	T3,-1-PM.ZER
	JRST	RMVPG1
	TDNN	T2,AABTAB(T4)	;ACCESS NOT ALLOWED?
	SOS	.USANA		;YES, DECR COUNT
RMVPG1:	ANDCAM	T2,AABTAB(T4)	;CLEAR THE BIT IN THE ACCESS ALLOWED TABLE
	HRRZ	T2,T3		;PHYSICAL PAGE NUMBER
	JUMPL	T3,CPOPJ##	;NON-SKIP RETURN IF PAGE WAS ON THE DISK
	SE1ENT			;GET TO SECTION 1
	ANDI	T2,17777	;CLEAR ACCESS BITS
	SKIPE	T1		;DON'T LINK PAST PAGE ZERO
	PUSHJ	P,LKPSP		;LINK PAST THE PAGE IN PAGTAB
	PUSH	P,T2		;SAVE THE PHYSICAL PAGE NUMBER
	SSX	T2,MDSEC2	;PAGTAB SECTION
	HLLZS	PAGTAB(T2)	;INDICATE LAST PAGE ALLOCATED
	PUSHJ	P,DECHJ		;DECREMENT THE NUMBER OF HIGH SEGMENT PAGES
				; IN CORE IF THIS IS A HIGH SEGMENT PAGE
	MOVEI	T2,777		;IF REMOVED ALL NON-ACCESSABLE PAGES,
	SKIPN	.USANA
	ANDCAM	T2,.USANA	; CLEAR THAT PORTION OF .UPVRT
	PJRST	T2POJ1##	;RESTORE T2 AND GIVE PAGE-IN-CORE RETURN
;SUBROUTINE TO LINK PAGTAB AROUND THE PAGE SPECIFIED BY THE CONTENTS OF T2
;CALLING SEQUENCE:
;	MOVE	T2,PAGE TO BE LINKED PAST
;	PUSHJ	P,LKPSP
;RETURNS CPOPJ, T3 = PREDECESSOR TO PAGE LINKED AROUND
;PRESERVES T1

LKPSP::	LDB	T4,JBYLSA##	;FIRST PAGE OF THE LOW SEGMENT
	SE1ENT			;SETION 1 TO ADDRESS PAGTAB
LNKPS1:	MOVE	T3,T4		;SAVE PREVIOUS PAGE IN T3
	SSX	T3,MDSEC2	;PAGTAB SECTION
	SKIPG	T4,PAGTAB(T3)	;NEXT PAGE OF THE SEGMENT
	STOPCD	.+1,DEBUG,FIP,	;++FREE-PAGE IN USE
	CAIE	T2,(T4)		;IS THIS THE PAGE TO BE LINKED AROUND?
	JRST	LNKPS1		;NO, TRY THE NEXT PAGE
	SSX	T4,MDSEC2	;PAGTAB SECTION
	SKIPGE	T4,PAGTAB(T4)	;GET THE NEXT PAGE
	STOPCD	CPOPJ##,DEBUG,PIF,	;++PAGE IS FREE
	MOVEM	T4,PAGTAB(T3)	;LINK AROUND THE PAGE
IFN FTKLP,<
	HRRZS	T3		;CLEAR SECTION NUMBER
>
	POPJ	P,		;AND RETURN
;SUBROUTINE TO TEST IF THE PAGE SPECIFIED BY THE CONTENTS OF T1
; IS CONTAINED IN A SHARABLE HIGH SEGMENT OR A SPY SEGMENT
;CALLING SEQUENCE:
;	MOVE	T1,PAGE NUMBER TO BE TESTED
;	MOVE	J,JOB NUMBER
;	PUSHJ	P,TPSHS
;RETURNS CPOPJ IF THE PAGE IS CONTAINED IN A SHARABLE HIGH SEGMENT
; OR A SPY SEGMENT, CPOPJ1 IF NOT
;PRESERVES T1,T3

TPWHS:	SKIPLE	T2,JBTSGN##(J)	;DOES THIS JOB HAVE A REAL HIGH SEGMENT?
	TLNN	T2,UWPOFF	;IS WRITE PROTECT OFF FOR THE HIGH SEGMENT?
	JRST	CPOPJ1##	;NO, PAGE ISN'T IN A WRITABLE HIGH SEGMENT
IFN FTPEEKSPY,<
	PUSHJ	P,TSSPT		;A SPY PAGE?
	  JRST	TPAHS		;NO
	JRST	CPOPJ1##
>
IFE FTPEEKSPY,<
	JRST	TPAHS		;TEST TO SEE IF THE PAGE IS IN THE HIGH SEGMENT
>
TPSHS::	MOVE	T2,JBTSGN##(J)	;HIGH SEGMENT NUMBER PLUS HIGH SEGMENT BITS
	TLNN	T2,SHRSEG!SPYSEG;SHARABLE SEGMENT OR SPY SEGMENT?
	JRST	CPOPJ1##	;NO, PAGE IS NOT IN A SPY OR SHR SEG
TPAHS::	PUSH	P,T1		;SAVE THE VIRTUAL PAGE NUMBER
	PUSHJ	P,HSVAD##	;GET STARTING AND ENDING VIRTUAL ADDRESSES
				; OF THE HIGH SEGMENT
	LSHC	T1,W2PLSH##	;CONVERT TO STARTING AND ENDING PAGE NUMBERS
	MOVE	T4,(P)		;VIRTUAL PAGE IN QUESTION
	CAIL	T4,(T2)		;BELOW THE START OF THE HIGH SEGMENT?
	CAILE	T4,(T1)		;OR ABOVE THE TOP OF THE HIGH SEGMENT
	AOS	-1(P)		;PAGE ISN'T IN THE HIGH SEGMENT
	PJRST	TPOPJ##		;RESTORE THE VIRTUAL PAGE NUMBER AND RETURN


;SUBROUTINE TO INCREMENT OR DECREMENT JBTSWP FOR A HI SEG
;PRESERVES T1
INCHJ:	SKIPA	T3,[1,,0]	;PREPARE TO INCREMENT NUMBER OF HIGH SEGMENT
				; PAGES IN CORE
DECHJ:	MOVSI	T3,-1		;DECREMENT NUMBER OF HIGH SEGMENT PAGES IN CORE
	PUSHJ	P,TPAHS		;IS THIS PAGE IN THE HIGH SEGMENT?
INCHJA:   SKIPG	T4,JBTSGN##(J)	;YES, IS THERE A HIGH SEGMENT?
	POPJ	P,		;NO, NOTHING TO DO
IFN FTKLP,<
	HRRZS	T4		;COULD BE IN NON-ZERO SECTION,LH(T4)=JUNK
>
	ADDM	T3,JBTSWP##(T4)	;INCREMENT OR DECREMENT PAGE COUNT
	JUMPL	T3,CPOPJ##	;RETURN IF REMOVING A PAGE FROM CORE
	PUSH	P,T1
	PUSH	P,T4
	PUSHJ	P,SCWEXO##
	POP	P,T4
	POP	P,T1
	LDB	T4,[POINT 9,JBTUPM##(T4),8] ;FIRST VIRTUAL PAGE IN THE HI-SEG
MAPHI::	PUSHJ	P,GTPM4		;YES, GET FIRST PHYSICAL PAGE IN HI SEG
IFE FTKLP,<
	TRO	T4,PM.ACC+PM.WRT ;ALLOW WRITING FOR SAVE
	HRLM	T4,.UPMP+.MVJDT	;MAKE THE HI SEG ADDRESSABLE VIA THE PER-PROCESS MAP
>
IFN FTKLP,<
	HRLI	T4,(<PM.DCD>B2+PM.WRT)
	MOVEM	T4,.UPMP+.VJDT/PAGSIZ##
>
	POPJ	P,		;AND RETURN
;SUBROUTINE TO SET UP JBTHSA FOR NON-SHARABLE HI SEG CASES
;IN CASE IT CHANGED (PARTICULARY FOR LOKCON, BUT SO THE INFORMATION
;WILL BE CORRECT ANYWAY). PRESERVES ALL ACS, IF A NON-SHARABLE HI SEG UPDATES
;JBTHSA ACCORDING TO CURRENTLY MAPPED UPMP
SETHSA:	PUSHJ	P,SAVT##		;SAVE TEMP AC'S
	PUSH	P,J			;AND J
	MOVE	J,.UPMP+.UPJOB		;GET JOB NUMBER
 	MOVEI	T1,JS.RUU		;IN RUN UUO?
	MOVSI	T2,(JS.IGS)		;OR GETSEG UUO?
	TDNN	T1,JBTSTS##(J)		;IF SO, .UPHSS IS NOT
	TDNE	T2,JBTST2##(J)		;RELIABLE
	JRST	JPOPJ##			;SO DON'T TRUST IT
	SKIPLE	J,JBTSGN##(J)		;DOES JOB HAVE A REAL
	TLNE	J,SHRSEG		;NON-SHARABLE HI SEG
	JRST	JPOPJ##			;NO
	HRRZS	J			;IN CASE S1
	MOVE	T1,.UPMP+.UPHSS		;GET START OF HI SEG
	LSH	T1,W2PLSH##		;CVT TO PAGE #
	PUSHJ	P,TSWST			;IS IT IN THE WORKING SET?
	TDZA	T2,T2			;NO, STORE ZERO IN JBTHSA
	PUSHJ	P,GTPME			;GET CONTENTS OF THAT SLOT IF IN WS
	DPB	T2,JBYHSA##		;STORE IN JBTHSA
	JRST	JPOPJ			;AND RETURN
IFN	FTDHIA,<
;SUBROUTINE TO SET UP.DDW AND WAIT FOR MIGRAT TO PASS US
;CALLED BY PAGE UUO AND IPCFS
MIGWAT::
	PUSHJ	P,MIGWTX
	SKIPA
	AOS	(P)
	PUSH	P,T1
	MOVSI	T1,(UP.DDW)
	ANDCAM	T1,.USBTS
	JRST	TPOPJ
MIGWTX:	EXCH	T1,(P)
	EXCH	T1,-1(P)
	EXCH	T1,(P)			;REVERSE CALLING ADDRESSES
	PUSH	P,T1			;SAVE T1
	PUSH	P,T2			;AND T2
MIGWT1:	MOVSI	T1,(UP.DDW)
	TDNE	T1,.USBTS		;WAS IT ALREADY ON?
	  JRST	MIGWT2			;YES
	IORM	T1,.USBTS
	SKIPE	T2,MIGRAT##		;MIGRATE IN PROGRESS?
	CAMLE	T2,.USJOB		;IF SO, HAS IT PASSED US?
	  JRST	TTPOPJ##		;NOT IN PROGRESS OR HAS PASSED US
	ANDCAM	T1,.USBTS		;LET IT DO SO THEN
	MOVEI	T1,1			;SLEEP A BIT
	PUSHJ	P,SLEEPF##		;..
	JRST	MIGWT1			;AND CHECK AGAIN
MIGWT2:	POP	P,T2
	POP	P,T1
	POP	P,-1(P)
	POPJ	P,
;SUBROUTINE TO WAIT FOR MIGRAT TO PASS US, BUT NOT BOTHER UP.DDW
;CALLED BY IPCFS
;USES T1
IPMWAT::
	PUSH	P,J			;SAVE J
IPMWT1:	SKIPE	T1,MIGRAT##		;MIGRATE IN PROGRESS?
	CAMLE	T1,.USJOB		;IF SO, HAS IT PASSED US?
	  JRST	JPOPJ##			;NOT IN PROGRESS OR HAS PASSED US
	MOVEI	T1,1			;SLEEP A BIT
	MOVE	J,.CPJOB
	PUSHJ	P,SLEEPF##		;..
	JRST	IPMWT1			;AND CHECK AGAIN
>	;END FTDHIA
PNTCNT:	POINT	18,T1,17
	POINT	14,T1,13
	POINT	14,T1,13
MAXCNT:	400000+T1,,-1
	400000+T1,,37
	400000+T1,,3

	$LIT
VMEND:	END
