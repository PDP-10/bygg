TITLE COMCON - COMMAND DECODER AND SAVEGET ROUTINES - V1531
SUBTTL /PFC/RCC/DAL/JBS    3 JAN 84
	SEARCH	F,S
stupid==-1		;Modified for SuperTOPS.
newsend==0		;*** this don't work yet ***
peter==1		;If we run out of core or PDB's, take a dump and reload
	$RELOC
	$HIGH
	SALL

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>



;DATE		LOAD	EDIT #
;----		----	------

;02-SEP-80	70114	1370
;9377,9380 MCO'S
;23-SEP-80	70117	1371
;30-SEP-80	70120	1372
;9424
;07-OCT-80	70121	1373
;9429-9430-
;14-OCT-80	70122	1374
;9434-9441-
;21-OCT-80	70123	1375
;9443
;28-OCT-80	70124	1376
;9447-9451
;04-NOV-80	70125	1377
;25-NOV-80	70126	1400
;9457,9468,9466
;02-12-80	70127	1401
;9476-9479-
;09-DEC-80	70130	1402
;9485-
;23-DEC-80	70132	1403
;9510-
;13-JAN-81	70134	1404
;9510-
;20-JAN-81	70135	1405
;9534,9535
;27-JAN-81	70136	1406
;MCO 9551
;03-FEB-81	70137	1407
;9555-9562-
;
;10-FEB-81	70140	1410
;9569-9577-
;26-FEB-81	70142	1411
;03-MAR-81	70143	1412
;9601
;07-APR-81	70150	1413
;21-APR-81	70152	1414
;9691
;28-APR-81	70152	1415
;9700,9701,9702,9705
;19-MAY-81	70156	1416
;9730
;26-MAY-81	70157	1417
;9729-
;09-JUN-81	70161	1420
;9749
;16-JUN-81	70162	1421
;9759-
;30-JUN-81	70164	1422
;9798-9799
;07-JUL-81	70165	1423
;9801
;14-JUL-81	70166	1424
;9815-9820-9822-
;21-JUL-81	70167	1425
;9825
;28-JUL-81	70170	1426
;9839-9841-
;04-AUG-81	70171	1427
;9847-9852-
;11-AUG-81	70172	1430
;9858,9860
;18-AUG-81	70173	1431
;9876-
;15-SEP-81	70174	1432
;9880-9888-
;22-SEP-81	70175	1433
;9894-
;13-OCT-81	70111	1434
;27-OCT-81	70113	1435
;9946-
;17-NOV-81	70116	1436
;01-DEC-81	70120	1437
;15-DEC-81	70122	1440
;10013
;10018
;22-DEC-81	70123	1441
;29-DEC-81	70124	1442
;10022
;12-JAN-82	70126	1443
;10032
;19-JAN-82	70127	1444
;10050
;26-JAN-82	70130	1445
;10059
;02-FEB-82	70131	1446
;10069-10080-10081
;23-MAR-82	70140	1447
;10162
;06-APR-82	70142	1450
;10193
;13-APR-82	70143	1451
;10199
;27-APR-82	70144	1452
;10224-10232
;4-MAY-82	70145	1453
;10234-10237-10235
;11-MAY-82	70146	14540
;10244
;18-MAY-82	70147	1455
;10253
;25-MAY-82	70150	1456
;10237-10258
;29-JUN-82	70155	1457
;13-JUL-82	70157	1460
;10308
;20-JUL-82	70160	1461
;10316-10319-10322-10327
;27-JUL-82	70161	1462
;10332
;3-AUG-82	70162	1463
;17-AUG-82	70164	1464
;10354
;24-AUG-82	70165	1465
;10366-10367
;7-SEPT-82	70167	1466
;10397
;14-SEP-82	70170	1467
;10401
;21-SEP-82	70171	1470
;28-SEP-82	70172	1471
;5-OCT-82	70173	1472
;10429
;12-OCT-82	70174	1473
;19-OCT-82	70175	1474
;10448
;26-OCT-82	70176	1475
;10460
;09-NOV-82	70111	1476
;10484
;23-NOV-82	70113	1477
;10503,10507
;30-NOV-82	70114	1500
;10518-10520
;08-DEC-82	70115	1501
;10522-10524
;11-JAN-83	70120	1502
;22-FEB-83	70126	1503
;10615
;15-MAR-83	70131	1504
;10658-10662
;5-APR-83	70134	1505
;10684
;12-APR-83	70135	1506
;10693-10702
;18-APR-83	70136	1507
;26-APR-83	70137	1510
;10-MAY-83	70141	1511
;17-MAY-83	70142	1512
;10765
;7-JUN-83	70144	1513
;10788
;14-JUN-83	70145	1514
;10801
;21-JUN-83	70146	1515
;24-JUN-83	70147	1516
;12-JUL-83	70151	1517
;19-JULY-83	70152	1520
;10865
;26-JULY-83	70153	1521
;10877
;16-AUG-83	70156	1522
;10915
;23-AUG-83	70157	1523
;6-SEPT-83	70161	1524
;20-SEPT-83	70163	1525
;10968
;11-OCT-83	70166	1526
;10970-10974
;25-OCT-83	70170	1527
;11015
;1-NOV-83	70171	1530
;3-JAN-84	70173	1531
;
;
XP VCOMCN,1531
				;THIS MACRO PUTS VERSION NO. IN STORAGE MAP AND GLOB

	ENTRY	COMCON		;ALWAYS LOAD COMCON IF LIBRARY SEARCH
COMCON::

;CALLED FROM CLOCK ROUTINE WHEN 'COMCNT' IS GREATER THAN 0
;AS SET BY TTY SERVICE ROUTINE
;ALL AC'S HAVE BEEN SAVED BY CLOCK CHANNEL
;THE COMMAND DECODER CALLS TTYCOM WHICH SCANS FOR TTY WHICH TYPED
SUBTTL	TABLE OF CONTENTS
;               TABLE OF CONTENTS FOR COMCON
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   1
;    2. INTRODUCTION..............................................   3
;    3. COMMAND SETUP AND DISPATCH................................   5
;    4. COMMAND RETURN AND CLEANUP................................  12
;    5. COMMAND TABLE.............................................  14
;    6. CORE 0 COMMAND............................................  20
;    7. PJOB & KJOB COMMANDS......................................  21
;    8. START GROUP (START,CSTART,REE,DDT)........................  23
;    9. DUMP & DCORE COMMANDS.....................................  25
;   10. CONTROL-C PROCESSING......................................  26
;   11. SET COMMAND AND UUO
;        11.1   DISPATCH..........................................  29
;        11.2   JBSET.............................................  30
;        11.3   PRIVILEGE TESTS...................................  31
;        11.4   CORMAX AND CORMIN.................................  35
;        11.5   DAYTIME AND SCHED.................................  40
;        11.6   OPR, LOGMIN&MAX BATMIN&MAX........................  41
;        11.7   WATCH.............................................  42
;        11.8   DATE..............................................  44
;        11.9   SPOOL.............................................  45
;        11.10  DEFER/NODEFER.....................................  47
;        11.11  CDR...............................................  48
;        11.12  DISK STUFF........................................  49
;        11.13  ROUTINE TO READ DATE..............................  51
;        11.14  ROUTINES TO PRINT WATCH INFO......................  53
;   12. CONTINUE, CCONT AND JCONT.................................  57
;   13. CORE COMMAND..............................................  60
;   14. CONTROL-T PRINTOUT........................................  65
;   15. SAVE, SSAVE AND GET - COMMAND SETUP.......................  70
;   16. COMMANDS WHICH RUN PROGRAMS...............................  72
;   17. ASSIGN, DEASSIGN AND REASSIGN COMMANDS....................  75
;   18. ATTACH, DETACH AND EXCHANGE COMMANDS......................  92
;   19. DATASET CONNECT & SYSTEM START............................  99
;   20. DAYTIME COMMAND........................................... 100
;   21. RUNTIME ROUTINE (TIME COMMAND)............................ 101
;   22. SEND COMMAND.............................................. 102
;   23. VERSION COMMAND & PRVERS SUBROUTINE....................... 107
;   24. EXAMINE AND DEPOSIT COMMAND............................... 109

;CONTINUED ON NEXT PAGE
;   25. TTY COMMAND AND SET TTY COMMAND........................... 113
;   26. FINISH AND CLOSE COMMANDS................................. 123
;   27. SUBROUTINES
;        27.1   COMMAND SETUP..................................... 126
;        27.2   GET A WORD........................................ 127
;        27.3   GET CHARACTER..................................... 129
;        27.4   TYPE OUT ROUTINES................................. 130
;   28. SAVGET
;        28.1   PARAMETERS........................................ 143
;        28.2   COMMAND SCAN...................................... 144
;        28.3   RUN AND GETSEG UUO'S.............................. 147
;        28.4   SAVE A JOB........................................ 148
;        28.5   "EXE" SAVE FILES.................................. 151
;        28.6   GET AND RUN COMMANDS.............................. 177
;        28.7   RUN UUO........................................... 179
;        28.8   GETSEG UUO........................................ 182
;        28.9   COMMON CODE....................................... 183
;        28.10  GET FILE FROM DEVICE (R,RUN,GET,GETSEG)........... 186
;        28.11  IO ROUTINES....................................... 192
;        28.12  EXPAND COMPRESSED FILES........................... 195
;        28.13  SUBROUTINES....................................... 201
	SUBTTL	INTRODUCTION

;THE COMMAND AND THEN DISPATCHES(PUSHJ) TO APPROPRIATE
;COMMAND SETUP ROUTINE WITH AC'S SET AS:
;J = JOB NUMBER
;F = ADDRESS OF DEVICE DATA BLOCK TYPING COMMAND, IF ANY
;R = ADDRESS OF JOB'S CORE AREA, = 0 IF NO CORE
;S IS SET TO 0, USED FOR ADDRESS OF SUBSEQUENT CALLS
;U = ADDRESS OF LINE DATA BLOCK OF TTY TYPING COMMAND
;W = ADDRESS OF JOB'S PDB
;P4 = JOB STATUS WORD (C(JBTSTS(J)))
;P1 = 0 (USED FOR SAVGET FLAGS)
;P2 = COMMAND NAME (2ND NAME IF SET)
;THE PUSHDOWN LIST CONTAINS:
;LH(M) = 1B0=1B1= 1 (FLAG FOR COMMAND AT COMMAND LEVEL)
;      = 1B8-17= COMMAND TABLE ENTRY
;-1 (P) = U = ADDRESS OF LDB
;THE FOLLOWING GLOBAL USAGE PREVAILS:
;T3 LAST INPUT CHARACTER
;   ALSO TYPE OUT CHARACTER
;IN GENERAL, T1 - T4 AND P2 - 4 ARE SCRATCH
;AT COMMAND RETURN, IF J = 0 AND A
;  JOB WAS REQUIRED, AN ERROR IS ASSUMED.
;  ALL OTHER ACS CAN HAVE BEEN CHANGED
;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED TO
;MESSAGE AND TTY IS STARTED ON TTY SPECIFIED BY -1(P)
;SEVERAL COMMAND FLAGS ARE CHECKED BEFORE DISPATCHING TO
;COMMAND SETUP ROUTINES TO SEE IF COMMAND IS LEGAL AT THIS TIME
;SEVERAL MORE FLAGS ARE CHECKED UPON RETURN FROM COMMAND SETUP
;ROUTINES(UNLESS AN ERROR HAS OCCURRED) FOR STANDARD
;COMMAND RESPONSE
;IF AN ERROR OCCURS, THE JOB NO.(J) SHOULD BE 0 ON RETURN
;SO THAT JOB WILL NOT BE INITIALIZED IF FIRST COMMAND.
;ERRMES ROUTINE WILL SET J TO 0

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINE MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO RUNABLE STATUS AND RETURN IMMEDIATELY
;OR DELAY THE COMMAND FOR LATER EXECUTION
;THE FOLLOWING AC USAGE PREVAILS FOR TTY IN/OUT:
;
;INPUT:	U=LDB, T3=CHARACTER		CLOBBERS T1
;
;	CTEXT CLOBBERS W, RETURNS T2=NAME
;	SKIPS		  RETURNS T2=0
;	DEC/OCT IN CLOBBERS P4, RETURNS T2=NUMBER
;	PJPGNO CLOBBERS T2,P4, RETURNS P2=USER
;
;
;OUTPUT:U=LDB, T3=CHARACTER		CLOBBERS T1,S
;
;	CONMES POINTER IN T1
;	OCTPNT/PRTDI8/RADX10 NUMBER IN T1
;		(PRTDI8 CLOBBERS T2)
;	PRNAME NAME IN T2

;P1 ASSIGNMENTS:
;
;PHONLY==1B0			;PHYSICAL ONLY
;INCREMENT==777777		;STARTING ADDRESS OFFSET
	SUBTTL	COMMAND SETUP AND DISPATCH

COMMAN::PUSHJ	P,TTYCOM##	;SETUP F,U,J, AND W
				; FOR ANY TTY WHICH HAS TYPED A COMMAND
	JRST	[AOS CMNOTF##	;NONE FOUND, COUNT THE BUG
		 SOS COMCNT##	;ADJUST COUNT
		 POPJ P,]	;RETURN
IFN FTMP,<
	MOVEM	J,COMJOB##	;TO AVOID JOBSTS UUO RACE
>
	PUSHJ	P,SVEUB##	;SAVE EBR AND UBR AND SETUP UBR FOR
				; THE JOB THE COMMAND IS BEING EXECUTED FOR

	PUSH	P,U		;SAVE TTY LINE DATA BLOCK ADDRESS
IFN FT2741,<
	MOVEI	T3,377
	MOVEI	T1,LDR2741##	; TRUE MAGIC OF THE
	TDNE	T1,LDBDCH##(U)	; 2741 COMMUNICATIONS
	PUSHJ	P,COMTYO##	; TERMINAL
>	;END FT2741
ifn FtIRun,<			;[ImplRun]
	movei	t1,lclced	;[ImplRun] Standard command error action
	movem	t1,erract	;[ImplRun]
>				;[ImplRun]
	MOVE	P3,[XWD UNQTAB##,DISP##] ;SET P3=UNIQNESS BITS, LOC OF DISPATCH TABLE
	MOVE	P4,[XWD -DISPL##,COMTAB##] ;SET P4=-LENGTH,TABLE LOC
	LDB	T1,LDPCMX##	;GET FORCED COMMAND INDEX, IF ANY
	HRLM	T1,(P)		;SAVE IT FOR COMPARISON
	MOVSI	T2,LDBCMF##	;IS COMMAND FORCED?
	TDNE	T2,0(U)		; ..
	SKIPA	T2,TTFCOM##(T1)	;YES. GET SIXBIT NAME OF COMMAND
COM1:	PUSHJ	P,CTEXT		;SCAN COMMAND NAME, RETURN IT IN T2
	CAIN	T3,"C"-100	;BREAK ON CONTROL-C?
	MOVE	T2,HALTXT##	;YES--TURN COMMAND INTO HALT
;HERE WITH T2=COMMAND, P3=DISPATCH TABLE, P4=AOBJN TABLE
COM1A:	SETZ	T1,		;NO FLAGS, INDICATE NORMAL TABLE SEARCH
ifn stupid,<
	jumpn	t2,com1aa	;Got anything?
	cain	t3,"/"		;No, typed "/"?
	 movsi	t2,'MIC'	; Yes, use MIC.
ifn fthistory,<
	cain	t3,"^"		;Or maybe "^"?
	 move	t2,['.CEDIT']	; Yes, start command editor.
>;fthistory
com1aa:!
>;end stupid
	PUSHJ	P,FNDABV	;LOOK IT UP
	  SETOM	T1		;ERROR--SET FLAG
	JUMPGE	T1,COM1B	;GO IF NO ERROR
	HRRZ	P2,LINTAB##+FRCLIN## ;GET LDB ADDRESS OF FRCLIN
	CAIE	P2,(U)		;UNKNOWN COMMAND TYPED ON FRCLIN?
	JRST	COM1B		;NO, CONTINUE
	MOVEI	T1,.RNTXT##-COMTAB##(P4) ;GET OFFSET OF .RUN COMMAND
	MOVE	P2,T2		;GET NAME TO RUN
	MOVE	M,.RNTXT##-COMTAB##+DISP##
	JRST	COM1C		;JOIN COMMON CODE
COM1B:	CAIL	T1,COMPIL##-COMTAB##
	CAILE	T1,LASCCL##-COMTAB##
	TRNA
	MOVEI	T1,COMPIL##-COMTAB##
	HRRZ	M,P3		;GET BITS,DISPATCH
	ADDI	M,(T1)
	MOVE	M,(M)
	SKIPE	.PDCMN##(W)	;ARE THERE USER-DEFINED COMMANDS?
	CAME	P3,[XWD UNQTAB##,DISP##] ;ARE WE STILL IN PRIMARY TABLE?
	JRST	COMNLG		;NO LOG NAME FOR THIS COMMAND
	TLNE	M,NOLOGC##	;CAN THERE BE A LOGICAL NAME FOR THIS COMMAND?
	JRST	COMNLG		;NO, DON'T LOOK FOR NAME AGAIN
	MOVE	T3,JBTSTS##(J)	;NEED TO SEARCH PATHOLOGICAL NAMES
	TLNN	T3,SWP		;IS JOB ON DISK OR ON ITS WAY?
	JRST	COMLG1		;NO, PROCEED
	HRRI	M,DLYCM		;YES, SET TO SWAP JOB IN
	JRST	COMDIS		;WAIT FOR IT TO COME IN
COMLG1:	PUSH	P,T1		;SAVE CURRENT POINTER
	PUSH	P,M		;AND YET ANOTHER POINTER
	PUSH	P,P3		;AND YET ANOTHER
	PUSH	P,P4		;AND YET ANOTHER
	MOVE	P4,.PDCMN##(W)	;GET AOBJN POINTER TO COMMAND NAMES
	MOVE	P3,.PDUNQ##(W)	;GET POINTER TO UNIQNESS BITS
	MOVSI	T1,1		;FLAG INDICATING THIS IS USER-COMMAND SEARCH
	PUSHJ	P,FNDABV	;SEE IF WE CAN FIND AN ABBREVIATION
	 JRST	COMLG3		;DEFAULT TO MONITOR'S UNIQUE COMMANDS
	TLZN	T1,1		;IS OUR FLAG SET?
	JRST	COMLG3		;NO, ASSUME SAVED STUFF IS GOOD
	ADD	T1,.PDUNQ##(W)	;POINT TO DISPATCH FOR THIS COMMAND
	HRL	P3,(T1)		;AND SAVE THE DISPATCH IN LH P3
	HRRI	P3,DISP##	;FOR LATER USE
	MOVEI	T1,PLNTXT##-COMTAB## ;SET UP FOR PATHOLOGICAL RUN COMMAND
	MOVE	M,DISP##(T1)	;MORE SETUP
COMLG2:	POP	P,P4		;RESTORE AOBJN POINTER
;	ADJSP	P,-3		;AND FORGET THIS POINTER
	sub	p,[3,,3]	;this works better on a KI processor
	JRST	COMNLG		;AND JOIN COMMON CODE
COMLG3:	POP 	P,P4		;START RESTORING THE WORLD.
	POP 	P,P3
	POP 	P,M
	POP	P,T1
COMNLG:
	ADDI	T1,(P4)		;COMPUTE MATCH LOCATION
	MOVE	P2,(T1)		;SAVE NAME OF COMMAND
COM1C:	TLZ	T1,-1		;CLEAR JUNK
	CAILE	T1,COMPIL##	;SEE IF COMPIL##
	CAIL	T1,LASCCL##	;  ..
	JRST	COM1D		;NO
	MOVEI	T1,COMPIL##	;YES
	MOVE	M,COMPIL##-COMTAB##+DISP##
COM1D:	SUBI	T1,(P4)		;INDEX OF TABLE
	ADDI	P3,(T1)		;POINT P3 TO DISPATCH ENTRY
ifn FtIRun,<			;[ImplRun]
	jumpge	t1,NotErr	;[ImplRun] skip this if not an error
	skipn	p3,erract	;[ImplRun] get error action
	  jrst	IsErro		;[ImplRun] none set: take normal action
	SETZM	.PDNAM##(W)	;[ImplRun] RESET LAST COMMAND
	skipa	p2,t2		;[ImplRun] save the command name for the run,
				;[ImplRun]  skip over normal error setting.
IsErro:				;[ImplRun] here if an error without special
				;[ImplRun]  action.
	  MOVEI	P3,COMERD##	;[ImplRun] YES--SET DISPATCH
NotErr:				;[ImplRun] here if not an error
>				;[ImplRun]
ife FtIRun,<			;[ImplRun]
	SKIPGE	T1		;SEE IF ERROR
	MOVEI	P3,COMERD##	;YES--SET DISPATCH
>				;[ImplRun]
	HRR	M,(P3)		;GET DISPATCH TABLE ENTRY
	TLZ	M,NOLOGC##	;BIT MUST BE OFF BEFORE DISPATCH
	MOVE	P4,JBTSTS##(J)	;JOB STATUS WORD FOR THIS JOB
IFN FT2741,<
	TLNE	P4,JLOG		; WHILE NOT LOGGED IN?
	JRST	NT2741		;NO--LEAVE ALONE
	JUMPGE	T1,NT2741	;JUMP IF NOT COMMAND ERROR
	CAMN	T2,[SIXBIT .YQAOS.]
	HRRI	M,SET987
	CAMN	T2,[SIXBIT .VI.];DID HE TYPE LOGIN WITH WRONG BALL?
	HRRI	M,SET988	;YES--SET TTY ELEMENT 988
NT2741:> ;END FT2741
IFN FTEL,<
	TRNE	P4,JS.DEP	;IS JOB BEING STOPPED ON ERROR SO DAEMON CAN LOG?
	JRST	CHKDLY		;YES, DELAY COMMAND UNTIL DAEMON IS FINISHED LOGGING
>
	TLNN	P4,JLOG		;IS JOB LOGGED IN?
	TLNE	M,NOLOGIN##	;NO, CAN COMMAND PROCEED WITH NO LOGIN?
	JRST	CHKNO		;YES
	JSP	T1,COMER	;NO, TYPE "LOGIN PLEASE"
LOGPLM::ASCIZ	/LOGIN please
/
CHKNO:	SETZB	P1,R		;CLEAR PHYSICAL I/O FLAG, AND CORE LOCATION
	JUMPN	J,CHKRUN	;JOB NUMBER ALREADY ASSIGNED?
	TLNE	M,NOJOBN##	;NO, DOES THIS COMMAND NEED A JOB NUMBER?
	JRST	COMGO		;NO
	MOVEI	J,1		;YES, SCAN FOR ONE STARTING WITH 1
NUMLOP:	HLLZ	P4,JBTST2##(J)	;FOR JS.SIP
	HLR	P4,JBTSTS##(J)	;FOR OTHER BITS
	TDNN	P4,[JS.SIP+JNA+JRQ+CMWB] ;OR ONE OF THESE?
IFN	FTMP,<
	PUSHJ	P,ANYRUN##
	JRST	NUMLO1		;JOB ISN'T REALLY AVAILABLE
	MOVE	P4,JBTSTS(J)	;KEEP REST OF CODE HAPPY
>
IFE	FTMP,<
	SKIPA	P4,JBTSTS(J)	;KEEP OTHER CODE HAPPY
	  JRST	NUMLO1		;JOB ISN'T AVAILABLE
>
	JRST	NEWJOB
NUMLO1:	CAIGE	J,JOBMAX##	;YES, IS THE MAX. JOB NO.?
	AOJA	J,NUMLOP	;NO, KEEP LOOKING
	SKIPG	ARFLAG##	;SYSTEM STARTING UP?
	JRST	CHKDLY		;YES--DELAY IT
IFN FTNET,<
	MOVSI	T1,LDBCMF##	;WAS THIS COMMAND FORCED?
	TDNN	T1,(U)
	JRST	NEWJER		;NO, OKAY TO COMPLAIN
	MOVEI	T1,LDRREM##	;IF FROM NETWORK, PROBABLY INITIA OR
	TDNE	T1,LDBDCH##(U)	; .NETLD SO DELAY IT
	JRST	CHKDLY
>
NEWJER:	JSP	T1,COMER	;YES, NONE LEFT, PRINT "JOB CAPACITY EXCEEDED"
	ASCIZ	/Job capacity exceeded
/
IFN STUPID,<
ifn peter,<
newjed:				;If this occurs, i want to have a dump and the
newjep:	STOPCD	.,STOP,LPL,	;system to be reloaded.  pl 890614
>;ifn peter

ife peter,<
NEWJED:	JSP	T1,COMER	;PRINT "NO FREE DDBs"
	ASCIZ	/Job capacity exceeded (No free TTY DDBs)
/
NEWJEP:	JSP	T1,COMER	;Not enough core
	ASCIZ	/Job capacity exceeded (No core for a PDB)
/
>;ife peter
>;IFN STUPID
				; EVEN THOUGH THIS IS A NEW JOB NUMBER
				; IT MAY HAVE CORE ASSIGNED NOW BECAUSE IT WAS DELAYED
				; UNTIL IT COULD BE SWAPPED IN(LOGIN WITH CORE FULL)
NEWJOB:	SKIPE	F,TTYTAB##(J)	;ANY TTY DDB?
	PUSHJ	P,TTYKIL##	;YES--KILL IT OFF
	SETZB	F,TTYTAB##(J)	;KEEP TTYATI HAPPY
	MOVE	U,(P)		;RESTORE U
	PUSHJ	P,TTYATI##	;TRY TO ATTACH TTY TO THIS JOB NUMBER
IFE STUPID,<
	  JRST	NEWJER		;IF CAN'T, NO DDB'S. SAY JOB CAP EXC
>;IFE STUPID
IFN STUPID,<
	  JRST	NEWJED		;IF CAN'T, NO DDB'S. SAY JOB CAP EXC
>;IFN STUPID
	PUSHJ	P,CREPDB##	;CREATE A PDB FOR THIS JOB
	  JRST	[PUSHJ	P,TTYKIL##  ;KILL TTY DDB OBTAINED ABOVE
IFE STUPID,<
		 JRST	NEWJER]	;CAN'T GET A PDB, SAY JOB CAP EXC
>;IFE STUPID
IFN STUPID,<
		 JRST	NEWJEP]	;CAN'T GET A PDB, SAY JOB CAP EXC
>;IFN STUPID
	SETZM	JBTPRG##(J)
	PUSHJ	P,CLRJBT##	;GO CLEAR ALL THE JOB TABLES AND PDB
	PUSHJ	P,ASICPT##	;ASSIGN INITIAL IN CORE PROTECT
	MOVE	T2,DATE##
	MOVEM	T2,JBTJLT##(J)
IFN FTMDA,<
	MOVEM	T2,.PDSTM##(W)	;INITIAL SETTING OF LAST RESET
> ;IFN FTMDA
IFN FTCIMP,<			;[arpa] now that we have a PDB, we can do this
				;[arpa]  stuff we tried to do in ImpAtt (via
				;[arpa]  TTyATI) but couldn't.
	MOVE	U,DDBLDB(F)	;[arpa] get LDB from DDB
	MOVEI	T1,LDRIMP##	;[arpa] load IMP bit.
	TDNE	T1,LDBDCH(U)	;[arpa] IS TTY REALLY AN ITY?
	  PUSHJ	P,IMPATT##	;[arpa] ATTACH AND FORCE INTO LOGICAL NAME TABLE
>				;[arpa]
	SKIPE	JBTADR##(J)	;CONTACT BOUNCE ON DLYCM?
	PUSHJ	P,MKADD##	;YES, MAKE SURE JOB IS ADDRESSABLE
IFN FTMP,<
	MOVEM	J,COMJOB##	;FOR PTYSER
>
	PUSHJ	P,CTLJBU##	;GET PTY DDB IF THERE IS ONE
	JUMPL	T1,NEWJB1	;JUMP IF NOT PTY CONTROLLED
	MOVSI	T1,DVDIBP	;GET BATCH PTY BIT
	MOVSI	T2,(JB.LBT)	;GET A BATCH JOB BIT
	TDNE	T1,DEVCHR(F)	;IS IT A BATCH PTY ?
	IORM	T2,JBTLIM##(J)	;YES, THEN ITS A BATCH JOB
NEWJB1:	HRRZ	F,LDBDDB##(U)	;RESTORE TTY DDB
	MOVEI	T1,BPTBIT##	;GET INITIAL VALUE OF JS.BPT
	DPB	T1,BPTPTR	;SET IT

IFN FTWATCH,<
	MOVE	T1,TIME##	;INITIALIZE TO TIME OF DAY
	TLO	T1,M.WCH##	;OR IN INITIAL SET WATCH BITS
				; (IN CASE THIS JOB GETS AUTOMATIC LOGIN)
	MOVEM	T1,JBTWCH##(J)	;STORE FOR THIS JOB
>
	CAMLE	J,HIGHJB##	;HIGHEST JOB NUMBER ASSIGNED?
	MOVEM	J,HIGHJB##	;YES,SAVE IT FOR SCHEDULER SCAN OF JOBS
IFN FTNET,<

	PUSHJ	P,FNDSTA##	;WHERE IS HE?
	DPB	T1,PDVSTA##	;THAT IS WHERE HIS TTY IS NOW
	HRRZM	T1,JBTLOC##(J)	;AND LOCATE HIM THERE

>
CHKRUN:
IFN FTMP,<
	TLNE	M,NORUN##	;CAN COMMAND BE EXECUTED WHILE RUNNING?
	TLNE	P4,RUN		;YES, IS IT
	JRST	CHKRU1		;YES
	PUSHJ	P,ANYRUN##	;RUN BIT COULD BE OFF BUT THE JOB
	  JRST	CHKDLY		; COULD STILL BE THE CURRENT JOB ON ANOTHER CPU
>
CHKRU1:	TLNE	P4,RUN		;RUN BIT ON IN JOB STATUS?
	TLNN	M,NORUN##	;YES, DOES THIS COMMAND REQUIRE A JOB?
	JRST	CHKBAT		;NO
	JSP	T1,COMER	;YES.
RUNERR::ASCIZ	/Please type ^C first
/

CHKBAT:	MOVE	T1,JBTLIM##(J)	;GET BATCH BIT
	TLNE	T1,(JB.LBT)	;SEE IF BATCH JOB
	TLNN	M,NBATCH##	;YES--SEE IF ILLEGAL COMMAND
	JRST	CHKXO		;NO--OK TO PROCEED
	JSP	T1,COMER	;YES--BOMB USER
BATMSG:	ASCIZ	/Illegal in batch job
/


CHKXO:	TRNE	P4,JS.XO!JS.RUU	;SEE IF EXECUTE ONLY JOB
	TLNN	M,NXONLY##	;YES--SEE IF ILLEGAL COMMAND
	JRST	CHKACT		;NO--OK TO PROCEED
	JSP	T1,COMER	;YES--BOMB USER
ILLXOM:	ASCIZ	/Illegal when execute only
/
CHKACT:	MOVE	R,JBTADR##(J)	;XWD PROTECTION,RELOCATION
	SKIPGE	.PDSAC##(W)
	JRST	CHKAC0
	MOVSI	T1,(JS.SAC)
	TDNN	T1,JBTST2##(J)
	TLZN	M,SACFLG##
	JRST	CHKAC2
CHKAC0:	TLNN	P4,SWP
	JRST	CHKAC1
	JUMPN	R,CHKDLY
	PUSHJ	P,PUSHCT
	  JRST	CHKDLY
	MOVSI	T1,(JS.SAC)
	SKIPL	.PDSAC##(W)
	IORM	T1,JBTST2##(J)
	JRST	COMGO
CHKAC1:	LDB	T1,IMGIN##
	PUSHJ	P,XPANDP##
	JRST	CHKDLY
CHKAC2:	TLNE	M,INCORE##	;MUST JOB NOT BE SWAPPING OR
				; IF JOB HAS CORE ASSIGNED, MUST IT BE
				; IN PHYSICAL CORE (RATHER THAN DISK OR ON ITS WAY)
	TLNN	P4,SWP		;YES, IS JOB ON DISK OR ON ITS WAY?
	JRST	CHKCO2		;NO
	HRRI	M,DLYCM		;ASSUME JOB MUST BE IN PHY CORE
				; SO SET TO SWAP JOB IN
	JRST	COMDIS		;WAIT FOR JOB
CHKDLY:	HRRI	M,DLYCM1	;NO, JUST DELAY COMMAND UNTIL SWAP OUT OR IN IS FINISHED
	JRST	COMDIS		;AND DISPATCH TO DELAY COMMAND

CHKCO2:	TLNE	M,NOACT##	;CAN COMMAND BE PERFORMED WITH ACTIVE DEVICES?
	PUSHJ	P,RUNCHK	;NO, RETURN IF JOB STOPPED AND NO ACTIVE DEVICES
	TLNE	M,NOCORE##	;DOES THIS COMMAND NEED CORE?
	JRST	COMGO		;NO. GO DISPATCH
	JUMPN	R,CHKXPN	;YES, IS CORE IN MEMORY?
	JSP	T1,COMER	;NO, PRINT "NO CORE ASSIGNED"
	ASCIZ	/No core assigned
/
CHKXPN:	TLNN	M,INCORE##	;DOES THIS COMMAND NEED CORE TO BE EXPANDED?
	JRST	COMGO		;NO
	HLRE	S,USRHCU##	;YES, IS CORE STILL COMPRESSED(SAVE DID NOT GO
				; TO COMPLETION)
	JUMPGE	S,COMGO		;LH=-2 DURING SAVE, WHEN CORE COMPRESSED
				;LH=-1 DURING SAVE OF HIGH SEG, OR GET OF LOW
				; OR HIGH SEG
	CAME	P2,FCOTXT##	;IS THIS A FORCED CONTINUE?

	CAMN	P2,CONTXT##	; OR CONTINUE COMMAND?
	JRST	COMGO		;YES, DON'T EXPAND (LET SAVE FINISH)
	PUSHJ	P,CLRASA	;CLEAR EXEC MODE UUO FLAG
	AOJGE	S,COMGO		;JUMP IF DON'T NEED TO EXPAND
	PUSHJ	P,EXPAND	;NO, EXPAND CORE FIRST
	  JFCL			;IGNORE ADDRESS CHECK ERROR, WE TRIED
	MOVSI	T1,JERR		;SET JERR SO CONT WON'T WIN
	IORM	T1,JBTSTS##(J)	; (WOULD GET ADR CHK IF ATTEMPTED)
	JRST	CHKDLY		;DELAY COMMAND BECAUSE COMMAND DECODER ACS ARE
				; ALL GONE, NEXT TIME JOBHCU WILL BE 0



COMER::	MOVSI	M,NOINCK##
	HRRI	M,ERRMES	;CALL ERROR MESSAGE ROUTINE

COMGO:	TLNN	P4,CMWB		; WAS JOB IN COMM WAIT
	TLZ	M,CMWRQ##	;NO, CLEAR REQUEUE BIT IN DISP. FLAGS
	MOVSI	S,CMWB		;CLEAR CMWB
	ANDCAM	S,JBTSTS##(J)


COMDIS:	MOVEI	S,0		;CLEAR S FOR SETTING DISPATCH ADDRESSES
	TLO	M,FLMCOM##!FLMCLV## ;SET COMMAND AT COMMAND LEVEL FLAGS
	MOVEM	P,.CPISF##	;SAVE PDL FOR DLYCOM & ABORTC
	PUSHJ	P,(M)		;DISPATCH TO COMMAND
	  JFCL			;IGNORE ERROR RETURN
	SUBTTL	COMMAND RETURN AND CLEANUP

;RETURN FROM COMMAND SETUP ROUTINE

COMRET:	NTDBUG	NO,EITHER	;STOP IF NETWORK INTERLOCK NOT RELEASED
	HLRZ	T1,(P)		;GET FORCED COMMAND INDEX BACK
	POP	P,U		;RESTORE TTY LDB ADDRESS
	HRRZ	F,LDBDDB##(U)	;RESTORE TTY DDB IF ANY
	PUSHJ	P,TTYCMR##	;TELL SCNSER COMMAND IS COMPLETED
	SOS	COMCNT##
	AOS	COMTOT##	;KEEP COUNT OF TOTAL COMMANDS PROCESSED
				; (DO NOT COUNT DELAYED COMMANDS UNTIL PROCESSED)
	MOVSI	T1,1		;ALSO KEEP COUNT OF COMMANDS PROCESSED
	ADDM	T1,LDBBCT##(U)	;ON A PER-TERMINAL BASIS FOR ACCOUNT PURPOSES
	TLNN	M,ERRFLG##	;ERROR?
	JRST	COMRT1		;NO, PROCEED
	SETZM	J		;YES, CLEAR J
	TLZ	M,NOCRLF##!NOPER##!TTYRNU##!TTYRNC##!TTYRNW##!NOMESS##	;ERROR--CLEAR PROBLEM BITS
	TLO	M,NOINCK##+CMWRQ##;YES, JOB NUMBER REQUIRED, BUT NONE IN J.
				; PRINT ERROR MESSAGE ONLY, AND
				; REQUEUE JOB IF NECESSARY.

COMRT1:	MOVSI	P4,JNA		;JOB STATUS WORD
	TLNN	M,NOINCK##	;SUPPRESS JOB INIT. CHECK?
	TDOE	P4,JBTSTS##(J)	;NO, IS JOB INIT BIT ALREADY SET?
	JRST	PCRLFA		;YES.
	MOVSI	P4,JNA		;GET JNA BIT AGAIN
	IORB	P4,JBTSTS##(J)	;NO, SO SET IT THIS COMMAND
	PUSHJ	P,TTYATI##	;ATTACH TTY TO JOB
	  JFCL			;IGNORE IF CAN NOT(SHOULD NEVER HAPPEN)
PCRLFA:	MOVEI	T1,JDCON	;CLEAR JDCON SO THAT A RUNNING JOB
	TLNE	M,TTYRNU##!TTYRNC##!TTYRNW##	;WILL NOT BE THE "JCONT INVABLE" FROM
	ANDCAM	T1,JBTSTS##(J)	;ANOTHER TTY

IFN FTWATCH,<
	TLNE	M,NOMESS##	;SEE IF MESSAGE SUPPRESSED
	JRST	PCRLF0		;YES--SKIP WATCH
	TLNE	M,TTYRNU##!TTYRNC##!TTYRNW##	;COMMAND START JOB UP (TTY IN EITHER MODE)?
	PUSHJ	P,WCHBEG	;YES, PRINT [HH:MM:SS] STARTED TO WAIT FOR RESPONSE
>
PCRLF0:	TLNN	M,NOCRLF##	;SUPRESS CRLF?
	PUSHJ	P,CRLF		;NO
	TLNE	M,NOPER##	;SUPRESS PRINTING PERIOD?
	JRST	PCRLF2		;YES
ife stupid,<pushj p,prper>	;NO, GIVE A "."
ifn stupid,<pushj p,prompt>	;No, give a promter
	PUSHJ	P,CLRPCT##	;RESET STOP COUNTER
	PUSHJ	P,STRTDL##	;ALLOW A DEFERRED LINE TO ECHO IF NEEDED
PCRLF2:	JUMPE	J,PCRLF1	;JOB DOES NOT RUN IF ERROR OR NO JOB NO. ASSIGNED
	TLNE	M,TTYRNU##	;JOB TO RUN WHEN TTY FINISHED TYPING?
				; COMMAND RESPONSE (TTY TO USER MODE)?
	PUSHJ	P,TTYUSR##	;YES, CALL SCANNER AND SCHEDULER ROUTINES
	TLNE	M,TTYRNW##	;COMMAND RESTART TTY RESPECTING IO WAIT?
	PUSHJ	P,TTYUSW##	;YES. CALL SCANNER ROUTINE AND SCHEDULER
	TLNE	M,TTYRNC##	;NO, JOB TO RUN AND REMAIN IN MONITOR MODE?
	PUSHJ	P,SETRUN##	;YES, CALL SCHEDULER ROUTINE
PCRLF1:	TLNN	M,NOMESS##	;IS THERE A MESSAGE?
	PUSHJ	P,TTYSTR##	;YES, START TTY TYPING IT OUT
	TLNE	M,ERRFLG##	;WAS AN ERROR?
	PUSHJ	P,TSETBI##	;YES--CLEAR TYPE-AHEAD
	TLNN	M,NOJOBN##	;WAS NO JOB NUMBER NEEDED?
	TLNE	M,ERRFLG##	;OR DID AN ERROR OCCUR?
	PUSHJ	P,[
		   jumpe f,cpopj##	;[mfe] guard against no DDB here.
		   MOVSI T1,JNA
		   LDB T2,PJOBN##
		   SKIPE T2
		   TDNE T1,JBTSTS##(T2)
		   PJRST TTYKLQ##
		   SETZM TTYTAB##(T2)
		   PJRST TTYKIL##]	;YES, KILL TTY IN CASE NO JOB LEFT
	PUSHJ	P,DECHJB##	;DECREMENT HIGHJB IF APPROPRIATE
IFN FTMP,<
	SETOM	COMJOB##	;NO JOB IN COMCON NOW
>
	JUMPE	F,CPOPJ##	;IF NO JOB, QUIT
	MOVSI	T1,LDBDET##	;SHOULD LINE BE DETACHED?
	TDNN	T1,LDBDDB##(U)	;DELAYED BECAUSE OF CMW
	JRST	PCRLF3
	ANDCAM	T1,LDBDDB##(U)
	PUSHJ	P,PTYDET##	;YES, DO IT NOW
PCRLF3:	LDB	J,PJOBN##	;GET ATTACHED JOB # FROM TTY DDB
	JUMPE	J,CPOPJ##
	CAME	J,.CPJOB##	;NEVER SET JRQ FOR CURRENT JOB!
	TLNN	M,CMWRQ##	;REQUEUE JOB AFTER COMMAND WAIT OR ERROR?
	POPJ	P,
	JRST	REQUE##		;YES
	SUBTTL	CORE 0 COMMAND

COR0:	JUMPE	R,CPOPJ##	;RETURN IF JOB DOES NOT HAVE CORE

IFN FTFDAE,<
	PUSHJ	P,CHKXTM	;SEE IF AN "EXIT" MESSAGE SHOULD
				; BE SENT TO THE FILE DAEMON AND IF
				; SO, SEND IT.
>
	JSP	T2,MONJOB##	;SET TO RUN MONITOR JOB(PC IN EXEC MODE)
				; RETURN HERE AT UUO LEVEL(NO ACS SET UP)
	MOVEI	T2,ESTOP##	;PUT ERROR STOP ON END OF PDL
	JSP	T1,MONSTR##	;START MONITOR JOB BY SETTING UP ACS AND
JOB1::	PUSHJ	P,RESET##	;RELEASE ALL IO DEVICES ASSIGNED TO THIS JOB
	PUSHJ	P,TTYFNU##	;FIND TTY FOR THIS JOB(SETUP J WITH JOB NO.)
IFN FTMP,<
	PUSHJ	P,UPMM##	;MUST HAVE THE MM RESOURCE
	JRST	ZAPPG1		;ZAP THE PROGRAM (UUO LEVEL STYLE)
>
ZAPPGM::
IFN FTMP,<
	PUSHJ	P,GETMM##	;GET MEMORY MANAGEMENT RESOURCE
	  JRST	.-1		;MUST WAIT IF NOT AVAILABLE
>
ZAPPG1:	PUSHJ	P,KILHGH##	;HIGH SEG FOR THIS USER, RETURN CORE
				; REMOVE HIGH SEG FROM THIS USER
				; LOGICAL ADDRESSING SPACE
				; IF NO OTHER USERS IN CORE ARE USING IT
				; RETURN DISK SPACE IF NO LONGER SHARABLE HIGH SEG
	PUSHJ	P,NOCORQ##	;PUT JOB IN NO CORE Q
	PUSHJ	P,CLRTAB	;CLEAR BITS AND TABLE ENTRIES
	MOVSI	T1,JLOG		;IF NOT LOGGED IN
	SKIPN	.CPISF##	; OR COMING FROM ERRCON
	TDNN	T1,JBTSTS##(J)
	JRST	JOB2		;ALWAYS DELETE FUNNY PAGES
	LDB	T1,NFYPGS##	;ANY MONITOR FREE CORE PAGES?
	CAIN	T1,UPMPSZ##+IFN FTKLP,<1>
	JRST	JOB2		;NO, RETURN CORE
	MOVE	T1,[.JDAT,,.JDAT+1] ;ZERO JOB DATA AREA
	SETZM	.JDAT		;JOBSA, JOBDDT, ETC.
	SETZM	USRDDT##	;AND REMEMBERED COPY
	BLT	T1,.JDAT+PG.BDY## ; AND THE REST OF PAGE 0 IN CASE XO
IFE FTMP,<
	POPJ	P,		;YES, JUST RETURN
>
IFN FTMP,<
	PJRST	GIVMM##
>
JOB2:	SKIPE	T1,JBTADR##(J)	;SKIP THIS IF NO CORE
	PUSHJ	P,VMSIZE##	;VIRTUAL SIZE OF THE JOB
	LDB	T2,NFYPGS##	;NUMBER OF FUNNY PAGES
	ADDI	T1,-UPMPSZ##(T2) ;VMSIZE ADDED UPMP SIZE
	ADDM	T1,VIRTAL##	;VIRTUAL CORE RETURNED
	PUSHJ	P,ZERSWP##	;RETURNED SWAPPING SPACE
	PUSHJ	P,FNDPDS##	;MAKE SURE W POINTS TO PDB
	SETZM	.PDCMN##(W)	;CLEAR POINTER TO COMMAND NAMES
	SETZM	.PDUNQ##(W)	;CLEAR POINTER TO UNIQNESS BITS
	PUSHJ	P,UUOLVL##	;AT UUO LEVEL?
	  JRST	JOB3		;NO
	MOVE	T1,(P)		;YES, CAN'T USE STACK IN THE
	MOVE	P,.CPNPD##	; UPMP AFTER GIVING THE
	PUSH	P,T1		; UPMP BACK TO FREE CORE
JOB3:	PUSHJ	P,KCORE1##
	SETZM	.CPADR##
	SETZM	JBTSWP##(J)	;NO VIRTUAL CORE
IFN FTMP,<
	PJRST	GIVMM##		;RETURN THE MM RESOURCE
>
IFE FTMP,<
	POPJ	P,
>
	SUBTTL	PJOB & KJOB COMMANDS

; "PJOB" PRINT JOB NUMBER OF JOB TTY IS ATTACHED TO


PJOB::	MOVE	T1,J		;JOB NO.
DECLF::	PUSHJ	P,RADX10##	;PRINT T1 AS DEC. THEN CRLF
	JRST	CRLF


;THIS PRINTS OUT:
;
; JOB N USER NAME [P,PN] TTY#
;
PJOBX:: PUSHJ	P,SAVJW##	;SAVE J(W GETS A RIDE)
	PUSHJ	P,GETJOB	;GET JOB NUMBER TO DO PJOB ON
	  SKIPA			;NO JOB NUMBER SO USE CURRENT JOB
	MOVE	J,T2		;PUT REQUESTED JOB NUMBER IN AC(J)
	JUMPE	J,ATT4		;ERROR IF NO JOB ASSIGNED
	PUSHJ	P,INLMES	;GIVE FOLLOWING MESSAGE
	ASCIZ	\Job \		;
	MOVE	T1,J		;PRINT THE
	PUSHJ	P,RADX10##	; JOB NUMBER
ifn stupid,<
ifn ftnet,<
	pushj	p,inlmes	;Type name of system too.
	asciz	" at "
	move	t2,stanam##	;get node name
	pushj	p,prname##	;print it
>;end ftnet
>;end stupid
	PUSHJ	P,INLMES	;GIVE FOLLOWING MESSAGE
	ASCIZ	\   User \		;
	PUSHJ	P,FNDPDB##	;SEE IF A PDB AND POINT AC(W) TO IT
	  JRST	PJOBX2		;NO PDB, SO CAN'T PRINT USERS NAME
	MOVE	T2,.PDNM1##(W)	;GET FIRST PART OF USERS NAME
	SKIPN	.PDNM2##(W)	;PRINT IT
	  JRST	PJOBX1		;GET USERS NAME
	PUSHJ	P,PRSIXB##	;IF LAST PART IS NULL WE'RE DONE
				; WITH THE NAME PRINTOUT
	MOVE	T2,.PDNM2##(W)	;DOES FIRST NAME END WITH A SPACE?
PJOBX1:	PUSHJ	P,PRNAME##
PJOBX2:	PUSHJ	P,PR3SPC	;GIVE A SPACE
	MOVE	T2,JBTPPN##(J)	;GET PPN
	PUSHJ	P,PRTPPN	;PRINT PPN
	PUSHJ	P,PR3SPC
	MOVE	T2,@TTYTAB##(J)	;GET TTY NAME
	TLNN	T2,-1		;DETACHED?
	HRLI	T2,'DET'	;YES
	PUSHJ	P,PRNAME##	;PRINT THE TTY NAME
	PJRST	CRLF		;END WITH A CRLF
; "KJOB" KILL ATTACHED JOB


KJOB::	JUMPE	J,ATT4		;WAS JOB INITIALIZED?
	TLNN	P4,JLOG		;TEST JLOG ALSO IN CASE JOB NOT LOGGED IN
	JRST	KJOB2		;IF JOB NOT LOGGED IN
	PUSHJ	P,TTYATI##	;ATTACH TTY
	  JFCL

	TLO	M,TTYRNU##	;SET TTYRNU## FOR COMRET
	MOVSI	P1,PHONLY	;SET PHYSICAL I/O FORCE SYSTEM KJOB

	MOVSI	T1,(JS.BPR)	;SET BYPASS PROGRAM TO RUN
	IORM	T1,JBTST2##(J)	;TO INSURE KJOB REALLY RUNS

IFN FTMP,<
	PUSHJ	P,ALLJSP##	;SET CPU SPECIFICATION TO MAKE THIS JOB RUNNABLE
				; ON ALL CPU'S. THIS ALSO LEAVES A REASONABLE
				; SPECIFICATION FOR THE NEXT USER WHO GETS
				; THIS JOB NUMBER
>
	MOVE	P2,LGONAM##	;GET 'LOGOUT'
	JRST	RUNAME		;GO RUN CUSP

KJOB2:	PUSHJ	P,GETCIC	;GET MINIMAL JOB AREA ON DISK OR CORE
	JSP	T2,MONJOB##	;YES, SCHEDULE MONITOR JOB(PC IN EXEC MODE)
				; RETURN HERE AT UUO LEVEL WHEN SCHEDULED
JOBKL::	MOVEI	T2,ESTOP##	;PUT ESTOP ON END OF PDL
	JSP	T1,MONSTR##	;GO SETUP ACS AND PD LIST AT UUO LEVEL
				;RETURN HERE AT UUO LEVEL AFTER BEING SCHEDULED
IFN FTDECNET,<
	PUSHJ	P,SCULGO##	;Tell SCMUUO that job is going away.
>; END IFN FTDECNET

	PUSHJ	P,DSKKJB##	;CLEAR UP CORE BLOCKS ON A KJOB COMMAND
				; MAY GO INTO WAIT, SO DO BEFORE GIVING UP USER CORE

ifn fthistory,<
	pushj p,cmhlgo##	;Deallocate the command history free core.
>;ifn fthistory
ifn stupid,<
	setzm	jbtlpn##(J)	;No logged-in PPN any more.
>;ifn stupid

	JUMPE	W,JOBKL1	;IF THIS JOB HAS A PDB,
	SKIPGE	.PDDVL##(W)	; AND IF THERE ARE TOO MANY LOGICAL NAMES FOR THE TABLE,
	SETZM	.PDDVL##(W)	; DON'T TRY TO REBUILD THE TABLE
				; SINCE IT IS COUNTER PRODUCTIVE
				; AND CAN CAUSE PDLOVF AFTER CORE HAS BEEN FLUSHED
IFN FTKI10!FTKL10,<
	PUSHJ	P,BRKDEC	;MAKE SURE ADDRESS BREAK COUNT IS DECREMENTED,
				; IF NEED BE.
>
	PUSHJ	P,KILJSL##	;DESTROY THE JSL (GET MOUNT COUNTS RIGHT)
JOBKL1:	PUSHJ	P,DEASTY	;DEASSIGN ALL BUT TTY
IFN FTIPCF,<
	PUSHJ	P,IPCLGO##	;TELL [SYSTEM] INFO THAT JOB IS GONE
>
	PUSHJ	P,JOB1		;FLUSH CORE AFTER RELEASING DEVICES
	PUSHJ	P,FNDPDS##	;TAPUUO COULD USE W
	PUSHJ	P,TTYKIL##	;RETURN TTY TO VIRGIN STATE
	JRST	KSTOP##		;CLEAR JOB STATUS WORD AND STOP JOB
	SUBTTL	START GROUP (START,CSTART,REE,DDT)

; "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS

START::				;SAME AS CSTART, DIFF BY COMTAB BITS
			; WHICH PUT TTY IN MONITOR OR USER MODE


; "CSTART L" OR  "CSTART" - START AT LOC. L(TTY IN COMMAND MODE)


STARTC::MOVE	P3,P4		;SAVE STATUS
	PUSHJ	P,OCTIN1	;CONVERT POSSIBLE OCTAL NO ARG.
	  JRST	SNOARG		;NO ARG SPECIFIED RETURN
	  JRST	COMERA		;ILLEGAL CHARACTER
	TLNN	P3,JLOG		;IS IT LOGGED IN?
	JRST	STARTE		;NO--ERROR

	TRNE	P3,JS.XO!JS.RUU	;SEE IF EXECUTE ONLY
	JRST	ILLXO		;YES -- BOMB USER
	PUSHJ	P,CHKMED##	;CHECK TO SEE IF HIGH SEG WHICH IS SHARABLE
				; IF YES, TURN ON USER MODE WRITE PROTECT
				; FOR THIS USER, AND SET MEDDLE BIT SO HE CANNOT
				; TURN UWP OFF.

	TLZ	T2,-1		;CLEAR JUNK
	JRST	STARTN		;START IN USER MODE
STARTE:	MOVEI	T1,LOGPLM	;SETUP ERROR MESSAGE
	PJRST	ERRMES		;GO ISSUE IT

ILLXO:	MOVEI	T1,ILLXOM	;GET ERROR MESSAGE
	PJRST	ERRMES		;GO ISSUE IT
;"REENTER" - REENTER USER PROGRAM


REENTE::SKIPE	T2,JBTADR##(J)
	HRRZ	T2,.JDAT+JOBREN##	;GET REENTER ADDRESS FROM JOB DATA AREA

	JRST	CHKPCM		;CHECK IF PC IS IN MONITOR

; "DDT" - START EXECUTION AT DDT IN USER AREA


DDTGO::	JUMPE	R,STARTE	;ERROR IF NO CORE (NOT A JOB)

	HRRZ	T2,.JDAT+JOBDDT##	;DDT STARTING ADR. IN JOB DATA AREA
	JUMPN	T2,CHKPCM	;OK IF WE HAVE DDT
	TLNN	P4,JLOG		;MAKE SURE LOGGED IT
	JRST	CHKPCM		;NOT BOMB HIM
	TRNN	P4,JS.XO!JS.RUU ;SKIP IF EXECUTE ONLY
	PJRST	GETDDT##	;MERGE IN DDT


CHKPCM:	JUMPE	J,STARTE	;ERROR IF NOT A JOB (DDT,REENTER)
	JUMPE	T2,CHKSTR	;IS A START ADR SPECIFIED? (ERROR IF 0)
STARTN:	MOVE	T1,USRPC##	;YES, GET JOB'S PC
	HLR	T1,JBTSTS##(J)	;AND JOB STATUS BITS
	TDNE	T1,[XWD USRMOD,JERR]	;IS JOB IN USER MODE, OR STOPPED ON AN ERROR?
	JRST	USTART##	;YES, START HIM UP NOW
	HRRZ	T1,T2		;GET START ADDRESS
	PUSHJ	P,SETUTP##	;SETUP UUO TRAP
	  JRST	USTART##	;START USER
	JRST	RSTART##	;CLEAR STATUS FLAGS AND START JOB
				; IN MIDDLE OF MONITOR WHERE IT STOPPED

;HERE TO START USER WHEN NO START ADR TYPED IN
SNOARG:	SKIPE	T2,JBTADR##(J)
	HRRZ	T2,.JDAT+JOBSA##	;START ADR. SPECIFIED BY LINKING LOADER
				; FROM END STATEMENT
				;FALL INTO CHKSTR
;HERE TO CHECK TO SEE IF STARTING ADDRESS IS NON-ZERO, AND START USER IF OK

CHKSTR:	JUMPE	J,STARTE	;ERROR IF NOT A JOB
	JUMPN	T2,USTART##	;IS IT NON-ZERO?, IF YES
				; STORE OLD PC IN JOBOPC IN JOB DATA AREA
				; THEN START WITH PC IN USER MODE
	JSP	T1,ERRMES	;NO, PRINT "NO START ADR"
MESNSA:	ASCIZ	/No start adr
/
	SUBTTL	.BPT (CONTROL-D) COMMAND

;HERE WHEN THE USER TYPES A ^D TO FORCE AN "UNSOLICITED" DDT BREAKPOINT.
;
;THE EFFECT IS TO "EXECUTE" A "JSR @.JBBPT" ON BEHALF OF THE CURRENTLY
;RUNNING USER PROGRAM; THE USER WILL THEN BE IN DDT, AND CAN "$P" TO
;RESUME THE USER PROGRAM WHERE IT WAS INTERUPTED BY THE BREAKPOINT.

CDBPT::	JUMPE	J,ATT4		;BOMB COMMAND IF NO JOB
	JUMPGE	P4,BPTER2	; OR IF THE JOB IS ^C'ED
	TRNE	P4,JS.XO	;EXECUTE-ONLY?
	JRST	BPTER1		;YES--THEN YOU CAN'T DO THAT!

IFN	FTMP,<			;IF MORE THAN ONE PROCESSOR,
	PUSHJ	P,SPSTOP##	;MAKE SURE NOT RUNNING ANYWHERE ELSE
	 JRST	DLYCM		;OOPS, WE WERE, WAIT TILL OTHER CPU LETS GO
IFN	FTKL10,<		;IF NON-WRITE-THROUGH CACHES EXIST,
	PUSHJ	P,CHKCSH##	;NOT RUNNING, BUT MIGHT BE IN OTHER CPU'S CACHE
	 CAIA			;OK WRT CACHE
	JRST	DLYCM		;STUCK IN OTHER CPU'S CACHE, WAIT
> ;END IFN FTKL10
> ;END IFN FTMP

	PUSHJ	P,SIMCHK##	;SEE IF JOB IN GOOD STATE TO BE STOPPED
	 CAIA			;CAN STOP JOB NOW
	JRST	DLYCM		;CAN'T STOP JOB (EXEC PC), WAIT
	SKIPG	T2,.JDAT+JOBBPT##  ;ADDRESS OF BREAKPOINT TRAP ENTRY
	JRST	BPTER3		;NO BREAKPOINT TRAP ADDRESS
	PUSHJ	P,FLTTC##	;CHECK VALIDITY OF ADDRESS
	 JRST	BPTER5		;ERROR: OUT OF BOUNDS
	 JRST	BPTER6		;ERROR: PAGED OUT/INACCESSIBLE


	PUSHJ	P,CDBRK##	;ALL SET, LET CLOCK1 PLAY WITH THE USER'S PC
	 JFCL			;FAILED???

IFN	FTMP,<			;IF WE CALLED SPSTOP ABOVE,
	PUSHJ	P,CLRCCB##	;THEN UNDO THE CALL TO SPSTOP HERE
> ;END IFN FTMP

	POPJ	P,		;.BPT COMMAND COMPLETED
;.BPT COMMAND ERRORS

BPTER1:	JSP	T1,BPTERM
	ASCIZ	\Breakpoint trapping is illegal when execute-only\

BPTER2:	TLZ	M,NOPER##	;PRINT "." AFTER ERROR
	JSP	T1,BPTERM
	ASCIZ	\Program is not running\

BPTER3:	SKIPE	.JDAT+JOBDDT##
	JRST	BPTER4
	JSP	T1,BPTERM
	ASCIZ	\DDT is not loaded\

BPTER4:	JSP	T1,BPTERM
	ASCIZ	\No breakpoint trap address\

BPTER5:	JSP	T1,BPTERM
	ASCIZ	\Breakpoint trap address out of bounds\

BPTER6:	JSP	T1,BPTERM
	ASCIZ	\Breakpoint trap address paged out\


;COMMON BPT COMMAND ERROR MESSAGE PROCESSOR

BPTERM:	PUSH	P,T1		;SAVE ERROR MESSAGE ADDRESS
	PUSHJ	P,CRLF		;TYPE A CRLF
	POP	P,T1		;GET ADDR BACK
	PUSHJ	P,ERRMES	;PRINT THE ERROR MESSAGE
	TLZ	M,ERRFLG##	;DON'T WANT COMCON'S "." ETC
	POPJ	P,		;"ERROR" RETURN
; PROCESS A "SET EDDT BREAKPOINT" COMMAND
;
SETEBP::MOVEI	T1,LDRCTY##	;GET THE CTY BIT
	TLNN	P4,JLOG		;LOGGED IN?
	TDNN	T1,LDBDCH##(U)	;NO--RUNNING ON THE CTY?
	PUSHJ	P,PRVJ		;THEN HE BETTER BE [1,2]
	  CAIA			;HE IS
	PJRST	COMERA		;LOSER
	PUSHJ	P,SAVE1##	;SAVE P1
	MOVEI	P1,0		;JOB 0
	JRST	SETBP1		;ENTER COMMON CODE


; PROCESS A "SET DDT BREAKPOINT" COMMAND
;
SETBPT::PUSHJ	P,SAVE1##	;SAVE P1
	MOVE	P1,J		;GET OUR JOB NUMBER

SETBP1:	PUSHJ	P,CTEXT		;GET A KEYWORD
	JUMPE	T2,SETBP3	;IF NO ARGUMENT, JUST TYPE CURRENT SETTING
	MOVE	T1,[-3,,BPTTAB]	;POINT TO TABLE
	PUSHJ	P,FNDNAM	;AND SEARCH IT
	  JRST	COMERA		;AMBIGUOUS OR UNKNOWN KEYWORD
	SKIPE	T1		;USER INCLUDE "BREAKPOINT" CHATTER?
	SOJA	T1,SETBP2	;NO--JUST STORE ON/OFF VALUE
	PUSHJ	P,CTEXT		;GET "ON" OR "OFF"
	JUMPE	T2,SETBP3	;INFORM CONFUSED USER OF .BPT STATE
	MOVE	T1,[-2,,BPTTB1]	;POINT TO ON/OFF TABLE
	PUSHJ	P,FNDNAM	;SCAN IT
	  JRST	COMERA		;AMBIGUOUS OR UNKNOWN KEYWORD
SETBP2:	DPB	T1,BPTPT1	;TURN .BPT ON OR OFF
SETBP3:	MOVEI	T1,[ASCIZ |[Control-D breakpoint facility is turned |]
	PUSHJ	P,CONMES	;TYPE TEXT
	LDB	T1,BPTPT1	;GET THE BIT
	MOVEI	T1,[ASCIZ |off|
		    ASCIZ |on|](T1)
	PUSHJ	P,CONMES	;TYPE ON OR OFF
	MOVEI	T1,[ASCIZ | for exec mode debugging|] ;INCASE "SET EXEC CTRLD"
	SKIPN	P1		;JOB 0?
	PUSHJ	P,CONMES	;YES
	MOVEI	T3,"]"		;GET MESSAGE TERMINATOR
	PJRST	COMTYO		;TYPE IT AND RETURN


; PROCESS SETUUO FUNCTIONS .STEBP AND .STBPT
;
SETEBU:	MOVEI	J,0		;SET EDDT SETUUO FUNCTION
SETUBU:	ANDI	T2,1		;SET DDT SETUUO FUNCTION (FOR USERS)
	DPB	T2,BPTPTR	;TURN .BPT ON OR OFF
	MOVE	J,.CPJOB##	;RELOAD OUR JOB NUMBER
	JRST	CPOPJ1##	;AND RETURN

BPTPTR::POINT 1,JBTSTS##(J),^L<JS.BPT>
BPTPT1:	POINT 1,JBTSTS##(P1),^L<JS.BPT>
BPTTAB:	SIXBIT	/BREAKP/
BPTTB1:	SIXBIT	/OFF/
	SIXBIT	/ON/
	SUBTTL	DUMP & DCORE COMMANDS

IFN FTDAEM,<
DAECOM:	HRLI	M,NOCORE##!NOACT##!NORUN##!NOCRLF##!NOPER##!TTYRNW##!INCORE##!NXONLY##
	GETPC	T1,.JDAT+JOBPC##
	TLNE	T1,USRMOD
	JRST	DCORE1
	GETPC	T1,.JDAT+JOBPD1##
	HRRI	T1,-2(T1)
	MOVSI	T2,(JS.HIB)
	TDNN	T2,JBTST2##(J)
	HRRI	T1,1(T1)
DCORE1:	MOVEM	T1,.JDAT+JOBOPC##
	PUSHJ	P,STDAEM##
	  JRST	NODAEM
	MOVEI	T1,JDC
	ORM	T1,JBTSTS##(J)
	PJRST	REQUE##

NODAEM:	JSP	T1,ERRMES
	ASCIZ	/DAEMON not running
/


>

IFN FTIPCF,<
SNDTXS:	MOVE	P3,[POINT 7,(T4)] ;TO COPY THE STRING
	MOVEI	T3,7		;GET A BELL
	IDPB	T3,P3		;STORE IN MESSAGE
	SUBI	P1,1		;ADJUST CHAR COUNT
SNDTX1:	PUSHJ	P,COMTYI##	;NEXT CHARACTER
	IDPB	T3,P3		;STORE IT FOR THE ACTDAE
	CAIE	T3,12		;END OF LINE?
	CAIN	T3,3
	TDZA	P1,P1
	SOJG	P1,SNDTX1	;OR USED ALL THE SPACE?
	IDPB	P1,P3		;ASCIZIZE
	MOVE	T1,P4		;ACTDAE
	MOVE	T4,P2		;LENGTH,,ADDRESS
	PJRST	SNDFFC##	;SEND IT
>
	SUBTTL	CONTROL-C PROCESSING

; "HALT" OR "<CONTROL>C"
;SCANNER ROUTINES DUMMY UP HALT WHEN CONTROL C TYPED IN
;STOP MUST BE DELAYED IF THIS JOB IS SYSTEM TAPE USER
;AND SYSTEM TAPE IS ACTIVE. OTHERWISE, THE JOB WILL NOT BE
;STOPPED WHEN DONE USING THE SYSTEM TAPE.
;IF JOB IS IN MONITOR MODE AND NOT IN TTY WAIT THIS JOB CANNOT BE STOPPED YET
;IN THIS CASE SET A BIT IN JOB STATUS WORD (CNTRLC) WHICH WILL BE CHECKED
;WHEN JOB RETURNS TO USER MODE


STOP::	MOVE	P2,HALTXT##
STOPF::	JUMPE	J,STOPB
	TLNE	P4,JACCT	;JACCT AND WAITING
	TRNN	P4,JDCON	;..
	JRST	STOPD		;NO--PROCEED
	JUMPL	P4,STOPD	;JUMP IF RUN BIT IS SET
	TLO	M,NOCRLP##	;KILL THE DOT
	POPJ	P,0		;PUNT THE COMMAND
STOPD:	MOVEI	T1,JDCON!JDC	;CLEAR JCONT.ABLE (DEV OK?) AND DAEMON BIT
	ANDCAM	T1,JBTSTS##(J)	; SO USER CAN STOP ONCE-A-MINUTE STUFF

IFN FTMP,<
	PUSHJ	P,SPSTOP##	;TEST IF JOB ON SLAVE, IF SO SIGNAL TO STOP IT,
	  JRST	DLYCM1		;  AND DELAY COMMAND
>

	PUSHJ	P,SIMCHK##	;OK TO "STOP IN MONITOR"?
	  JRST	STOPA		;YES, STOP JOB
	MOVSI	T1,CNTRLC	;NO, FLAG THAT USER MUST BE STOPPED WHEN
	IORB	T1,JBTSTS##(J)	; RETURNING TO USER MODE IN UUO HANDLER
	TLNE	M,CMWRQ##	;IS JOB IN COMMAND WAIT?
	PUSHJ	P,REQUE##	;YES. PUT HIM BACK IN RUNNABLE QUEUE
	JRST	DLYCM1		;THEN DELAY COMMAND (IE ECHO CR-LF, DOT)
				;UNTIL SWAPPED IN
STOPA:	MOVSI	T1,SWP		;IS THE JOB SWAPPED?
	TDNE	T1,JBTSTS##(J)	;IF SO, DELAY THE CONTROL C SINCE
	PJRST	DLYCM		; THE JOB DATA AREA MUST BE IN CORE
				; TO SEE IF THE JOB IS INTERCEPTING
				; CONTROL C'S
	MOVSI	T1,CNTRLC+CMWB	;DELAYED CONTROL C+ COMMAND WAIT
	ANDCAM	T1,JBTSTS##(J)	;CLEAR THEM
IFN FTWATCH,<
	SKIPL	JBTSTS##(J)	;IS RUN BIT ALREADY OFF?
	JRST	STOPAA		;IF YES, DO NOT PRINT [XXXX] AGAIN
	PUSHJ	P,STOPX		;STOP JOB
	TLNN	M,NOPER##	;IF NO PERIOD, SKIP [XXX]
	PUSHJ	P,WCHEND	;PRINT [XXXX] CRLF IF USER IS WATCHING RESPONSES
	JRST	STOPAB		;GO FINISH
>
STOPAA:	PUSHJ	P,STOPX		;STOP JOB
STOPAB:	SKIPGE	T1,JBTSTS##(J)	;GET JOB STATUS
	JRST	STOPB		;IF NOT STOPPED, DON'T KJOB
	TLNN	T1,JLOG		;IS JOB LOGGED IN?
	PUSHJ	P,TTKJOB##

STOPB:	SKIPL	JBTSTS##(J)	;RUNNING?
	PUSHJ	P,FNDPDB##	;FIND PDB
	  POPJ	P,
	MOVEI	T1,TTFCXI##	;FORCE .INITIA
	MOVEI	T2,JS.RPC	;IF JS.RPC = 1
	SKIPE	.PDPGM##(W)	;AND PROGRAM TO RUN
	TDNN	T2,JBTST2##(J)	; ..
	POPJ	P,0
	PUSHJ	P,TTFORC##
	PJRST	DLYCM

STOPX:	PJUMPL	P2,STOP1C##	;IF "HALT", STOP REGARDLESS
	PJRST	STOP1##		;IF "^C^C", STOP IF POSSIBLE
;MONITOR COMMAND LEVEL RESPONSE ROUTINES
;FIVE MULTIPLE ENTRY SUBROUTINES TO PRINT SYSTEM RESPONSE DATA FOR A JOB
;CONTROL REACHES ONE OF THESE ROUTINES ON ANY OF THE FOLLOWING:
;1. USER TYPES CONTROL C
;2. PROGRAM HALTS
;3. PROGRAM CALLS EXIT, OR CALL N,EXIT
;4. DEVICE BECOMES UNREADY  DEVICE XXX OK?
;5. ERROR IN JOB MESSAGE

;PRRSP1 - PRINT CRLF CRLF
;PRRSP3 - PRINT [XXXX] CRLF IF USER WATCHING SYSTEM DATA RESPONSE
;PRRSP4 - PRINT CRLF
;PRRSP5 - PRINT PERIOD


PRRSP1::PUSHJ	P,CRLF		;PRINT CR-LF
PRRSP3::
IFN FTWATCH,<
	PUSHJ	P,WCHEND	;PRINT SYSTEM RESPONSE DATA IF USER IS WATCHING IT.
>
PRRSP4::PUSHJ	P,CRLF		;PRINT CR-LF
PRRSP5::PUSHJ	P,FNDPDB##	;ENSURE W IS SETUP
	  PJRST	PRPER		;?
	MOVEI	T1,JS.RPC	;RUN PROGRAM BIT
	SKIPE	.PDPGM##(W)	;ANY TO RUN?
	TDNN	T1,JBTST2##(J)	;DOES HE WANT IT RUN
ife stupid,<pjrst prper>	;NO, PRINT DOT
ifn stupid,<pjrst prompt>	;No, print prompt
	POPJ	P,		;YES, DONT PRINT DOT

ifn stupid,<

PROMPT::JUMPE	U,PRPER		;If no LDB (how?), use a dot.
	HRRZ	F,LDBDDB##(U)	;Pick up DDB pointer.
	JUMPE	F,PRPER		;If no DDB (how?), use a dot.
	LDB	T1,PJOBN##	;Get owner job number.
	JUMPE	T1,PRPER	;If no job (how?), use a dot.
	HRRZ	W,JBTPDB##(T1)	;Finally, get PDB pointer.
	JUMPE	W,PRPER		;If no PDB (how?), use a dot.
PROMPW:	SKIPN	.PDPRO##(W)	;Any prompter set up for this job?
	 PJRST	PRPER		; No, use a dot.
	MOVEI	T1,.PDPRO##(W)	;Yes, load adress of it.
	PJRST	CONMES		;Print it out.

; Here for PROMPT UUO (CALLI -something) -- Manipulate job-wide prompter.

UPROMP::HLRZ	U,T1		;Get function code from left half.
	HRR	M,T1		;Get address of user argument block.
	PUSHJ	P,FNDPDB##	;Set up W.
	 POPJ	P,		; Can't -- error.
	JUMPE	U,PROM.0	;Check for function code 0.
	SOJE	U,PROM.1	;Check for function code 1.
	SOJE	U,PROM.2	;Check for function code 2.
	POPJ	P,		;Bad function code.

; Function code 0 -- type out a prompter.

PROM.0:	HRRZ	T1,TTYTAB##(J)	;Get TTY DDB pointer.
	JUMPE	T1,CPOPJ##	;Error if none.
	HRRZ	U,DDBLDB##(T1)	;Get LDB pointer.
	JUMPE	U,CPOPJ##	;Error if none.
	PUSHJ	P,PROMPT	;Do the job.
	JRST	CPOPJ1##	;Skip return.

; Function code 1 -- set prompter.

PROM.1:	PUSHJ	P,GETWRD##	;Get first word from user.
	 POPJ	P,		; Address check.
	MOVEM	T1,.PDPRO##+0(W);Store first word in PDB.
	PUSHJ	P,GETWR1##	;Get second word.
	 POPJ	P,		; Address check.
	TRZ	T1,377		;Make sure we get ASCIZ.
	MOVEM	T1,.PDPRO##+1(W);Store second word in PDB.
	JRST	CPOPJ1##	;Skip return.

; Function code 2 -- read prompter.

PROM.2:	MOVE	T1,.PDPRO##+0(W);Get first word of prompter.
	PUSHJ	P,PUTWRD##	;Give to user.
	 POPJ	P,		; Address check.
	MOVE	T1,.PDPRO##+1(W);Get second word of prompter.
	PUSHJ	P,PUTWD1##	;Give to user.
	 POPJ	P,		; Address check.
	JRST	CPOPJ1##	;Done, skip return.

; Here for SET PPN [p,pn] command.

SETPPN::MOVSI	T1,JP.POK	;This is after all a priviliged command...
	PUSHJ	P,PRVBIT
	 CAIA
	  JRST	COMERA
	PUSHJ	P,PJPGNO	;Read PPN argument.
	JUMPE	T2,NOTENF	;Must be there.
	MOVEM	T2,JBTPPN##(J)	;Store.
	POPJ	P,		;Done.

>;end ifn stupid
	SUBTTL	SET COMMAND AND UUO  -- DISPATCH

;SET COMMAND/UUO

SET::	MOVE	P3,[XWD UNQTB2##,DISP2##] ;UNIQUENESS PLUS START OF SET-TABLE
	MOVE	P4,[XWD -DISPL2##,COMTB2##] ;LENGTH, NAME
ifn FtIRun,<			;[ImplRun]
	setzm	ErrAct		;[ImplRun] make sure not to try to run the
				;[ImplRun]  set argument if it isn't known.
>				;[ImplRun]
	POP	P,T1		;REMOVE RETURN ADR FROM STACKS
	JRST	COM1		;GO INTERPRET 2ND PART OF COMMAND

;SUBROUTINE TO SEE IF A SYSTEM-WIDE SET COMMAND IS LEGAL
;SKIP RETURN IF LEGAL, ELSE NON-SKIP

SETLGF==FUPOPJ##
SETLGK==FUPOJ1##
SETLGL::HRRZ	T3,LINTAB##+FRCLIN##
	CAIN	T3,(U)
	JRST	CPOPJ1##
	PUSHJ	P,OPRLGL	;OPR?
	  SKIPA	T2,JBTPPN##(T1)	;NO, CHECK FURTHER
	JRST	CPOPJ1##	;YES, OK
	CAMN	T2,FFAPPN##	;1,2?
	AOS	(P)		;YES, OK
	POPJ	P,		;RETURN
OPRLGL:	PUSH	P,U		;PRESERVE LINE
	PUSH	P,F		;AND F
	MOVE	T1,J
	HRRZ	T3,OPRLDB##	;SEE IF OPR
	CAIN	T3,(U)		;ALSO OPR
	JRST	SETLGK		;WE WIN
	MOVE	T2,JBTSTS##(J)	;GET JOB STATUS
	TLNE	T2,JLOG		;A JOB ON THE TTY?
	JRST	SETLGF		;YES. COMMAND LOSES
	LDB	T2,LDPLNO##	;GET LINE NUMBER
	PUSHJ	P,CTLJB##	;LOSE -- SEE IF PTY
	JUMPLE	T1,SETLGF	;NO --- GIVE UP
	HRRZ	U,TTYTAB##(T1)	;OK -- GET DDB
	HRRZ	U,DDBLDB##(U)	;THEN GET LDB
	JUMPE	U,SETLGF	;IF CONTROL JOB DETACHED STOP SCAN AND FAIL
	MOVSI	T2,DVDIBP	;GET BATCH JOB BITS
	TDNE	T2,DEVCHR(F)
	JRST	SETLGF		;YES. COMMAND LOSES
	CAIN	T3,(U)		;OR HIS TTY?
	JRST	SETLGK		;YES. COMMAND WINS
	JRST	SETLGF		;LOSE
	SUBTTL	SET COMMAND AND UUO -- JBSET.

;HERE FROM UUOCON ON JBSET. UUO
;CALL:	MOVE	AC,[+N,,BLK]
;	CALLI	AC,JBSET.
;	  ERROR RETURN AC=0
;	NORMAL RETURN
;BLK:	JOB	NUMBER
;	XWD	FUNCTION,VALUE
JBSET.::PUSHJ	P,PRVJ		;ARE WE A GOOD GUY
	  JRST	JBSET1		;YES--GO DO THE SET
	JRST	RTZER##		;NO--RETURN 0

JBSET1:	PUSH	P,M		;SAVE M
	HRRI	M,(T1)		;GET ADDRESS OF BLK
	PUSHJ	P,GETWDU##	;PICK UP JOB#
	MOVE	J,T1		;PUT JOB NUMBER IN J
	PUSHJ	P,LGLPRC##	;SKIP IF LEGAL JOB NUMBER
	  JRST	JBSET2		;NO, GIVE UP
	MOVSI	T1,JNA		;SEE IF JOB EXISTS
	TDNN	T1,JBTSTS##(J)	;  AND EXISTENT
	JRST	JBSET2		;  YES--GIVE UP
	MOVE	T4,J		;SAVE NEW JOB
	PUSHJ	P,GETWD1##	;GET NEXT WORD(XWD) PUT IT IN T1
	MOVE	J,T4		;RESTORE NEW JOB
	NOSCHED
	PUSH	P,JBTPPN##(J)	;SAVE PPN
	MOVE	T2,FFAPPN##	;GET A GOOD PPN
	MOVEM	T2,JBTPPN##(J)	;FAKE OUT PRIVJ AND PRVBIT

	PUSH	P,J
	PUSH	P,W		;PRDSERVE W
	PUSHJ	P,FNPDBS##	;GET THE PDB FOR THE TARGET JOB
	PUSHJ	P,SETUUO	;DO IT
	  TDZA	T1,T1		;NOTE BAD RETURN
	SETO	T1,		;GOOD RETURN
	POP	P,W		;RESTORE W
	POP	P,J
	POP	P,JBTPPN##(J)	;RESTORE PPN
	SCHEDULE

	POP	P,M
	JUMPN	T1,CPOPJ1##	;PASS THE GOOD WORD ON
	JRST	STOTAC##	;ELSE RETURN ZERO
JBSET2:	POP	P,M		;RESTORE AC
	JRST	RTZER##		;GIVE ERROR
	SUBTTL	SET COMMAND AND UUO -- PRIVILEGE TESTS

;DISPATCH HERE (FROM UUOCON) ON A SETUUO
;CALL:	MOVE AC,[XWD FUNCTION,ARGUMENT]
;	CALLI AC,SETUUO
NEDPRV==1			;BIT ON IN DISPATCH TABLE IF PRIVS NEEDED
NLOGOK==2			;BIT ON IS DISPATCH IF OK WHEN NOT LOGGED IN
SETUUO::HRRZ	T2,T1		;ARGUMENT
	HLRES	T1		;FUNCTION
	CAML	T1,[SETTBC-SETTBL] ;A LEGAL CUSTOMER FUNCTION?
	CAILE	T1,SETLEN	;A LEGAL FUNCTION?
	POPJ	P,		;NO, RETURN DOING NOTHING
	MOVE	T1,SETTBL(T1)	;YES, GET TABLE WORD
	TLNE	T1,NEDPRV	;NEED SPECIAL PRIVS TO DO IT?
	PUSHJ	P,PRVJ		;YES, JOB HAVE PRIVS?

	  PJRST (T1)		;YES, DISPATCH
	TLNE	T1,NLOGOK	;NO PRIVS, IS IT OK IF NOT  LOGGED IN
	TLNE	T3,JLOG		;YES, IS JOB LOGGED IN
	JRST	ECOD0##		;LOGGED IN OR NO PRIVS, ERROR RETURN
	PJRST	(T1)		;DISPATCH FUNCTION
;SUBROUTINE TO SEE IF A JOB HAS PRIVILEGE:
;CALL:	MOVE T1,BIT TO BE TESTED IN PRIVILEGE WORD
;	MOVE J,JOB NUMBER
;	PUSHJ P,PRVBIT
;	RETURN IF PRIVILEGED BY BIT, [1,2], OR JACCT
;	RETURN IF NOT PRIVILEGED
;PRVBT RESPECTS T2
PRVBT::
PRVBIT::TDNE	T1,JBTPRV##(J)	;IS REQUESTED BIT ON IN TABLE?
	POPJ	P,0		;YES. OK RETURN
;	PJRST PRVJ		;NO. CHECK FOR JACCT OR FSFPNN


;SUBROUTINE TO TEST FOR [1,2] OR JACCT -
;PRIVILEGES NEEDED IF A SETUUO FRO A SYSTEM-PARAMETER IS DONE
;RETURNS CPOPJ IF HAVE PRIVS, CPOPJ1 IF DONT
;RESPECTS T2


PRVJ::	MOVE	T3,JBTSTS##(J)	;JBTSTS WORD
	SKIPGE	M		;COMMAND LEVEL?
	TLZA	T3,JACCT	;YES--CLEAR JACCT
PRVJC::	MOVE	T3,JBTSTS##(J)	;IF AT UUO LEVEL AND THE SIGN BIT OF M COULD BE ON
	MOVE	T4,JBTPPN##(J)	;JOB'S PRJ-PRG
	CAME	T4,FFAPPN##	;=1,2?
	TLNE	T3,JACCT	;NO, JACCT ON?
	POPJ	P,		;YES, OK
	PJRST	CPOPJ1##	;NO, ERROR RETURN
;TABLE FOR SETUUO.  NEGATIVE FUNCTIONS ARE CUSTOMER DEFINED.
;POSITIVE FUNCTIONS ARE RESERVED FOR DEC.

SETTBC:				;MINIMUM CUSTOMER DEFINED FUCTION
IFN	FTPATT,<
	EXP	CPOPJ##		;ROOM FOR PATCHING
>
SETTBL:	XWD	NEDPRV,SETMX1	;(0) - SET CORMAX
	XWD	NEDPRV,SETMN1	;(1) - SET CORMIN
	XWD	NEDPRV,SETDA1	;(2) - SET DAYTIME
	XWD	NEDPRV,SETSC1	;(3) - SET SCHED
	EXP	SETSPI		;(4) - SET CDR
	EXP	SETSPB		;(5) - SET SPOOL
	EXP	SETWTU		;(6) - SET WATCH
	XWD	NEDPRV,SETDT1	;(7) - SET DATE
	XWD	NEDPRV,SETOP1	;(10) - SET OPR (INDIRECT)
	XWD	NEDPRV,SETKSY	;(11) - SET KSYS
	XWD	NEDPRV,CORELM##
	EXP	SETIM1		;(13) - SET TIME LIMIT
	EXP	SETCPU##	;(14) - SET USER CPU SPECIFICATION
	XWD	NEDPRV,SETCRN##	;(15) - SET CPU RUNABILITY
	XWD	NEDPRV,SETLMX	;(16) - SET LOGMAX
	XWD	NEDPRV,SETBMX	;(17) - SET BATMAX
	XWD	NEDPRV,SETBMN	;(20) - SET BATMIN
	EXP	DSKFUL		;(21) - SET DSKFUL- PAUSE OR ERROR
	XWD	NEDPRV,SETVM1##	;(22) - SET VMMAX (SYSTEM-WIDE)
	XWD	NEDPRV,CPOPJ1##	;(23) - HISTORICAL
	XWD	NEDPRV,SETUVL##	;(24) - SET VM MAXIMA (USER)
	EXP	SETUV1##	;(25) - SET CURRENT VM MAXIMA (USER)
	EXP	SETVTM##	;(26) - SET TIME FOR VIRTUAL TIME INTERRUPTS

	EXP	SETABR		;(27)-SET ADDRESS BREAK
	EXP	SETPGM		;(30)-SET PROGRAM TO RUN
	EXP	SETDFU		;(31)-SET DEFERED SPOOLERS
IFN FTNET,<
ifn stupid,<
	exp	HOST.U##	;(32)-SET HOST, not priviliged anymore
>
ife stupid,<
	XWD	NEDPRV,HOST.U##	;(32)-SET HOST
>>
IFE FTNET,<
	EXP	CPOPJ##
>
	EXP	SETDLU		;(33)-SET DEFAULTS
	EXP	SETPRV		;(34)-SET PRIVILEGES

	XWD	NEDPRV,SETBSN	;(35) SET BATCH STREAM NUMBER
	XWD	NEDPRV,SETWTO	;(36) SET WTO CAPABALITIES
	XWD	NEDPRV,SETCDN##	;(37) SET CPU UP/DOWN STATUS
IFN FTKL10,<
IFN FTMP,<
	XWD	NEDPRV,SETCSB##	;(40) SET/CLEAR CACHE BITS
>
IFE FTMP,<
	EXP 	CPOPJ##
>
	EXP	SETFPS##	;(41) SET/CLEAR FLOATING POINT SIMULATION
> ;END IFN FTKL10
IFN FTKI10,<
	EXP	CPOPJ##
	EXP	CPOPJ##
>
IFN FTKS10,<
	EXP	CPOPJ##		;(40)
	EXP	SETFPS##	;(41)
>
	XWD	NEDPRV+NLOGOK,SETOPP ;(42) SET OPERATOR PRIVS
	XWD	NEDPRV,SETQST	;(43) SET QUEUE STRUCTURE
	XWD	NEDPRV,CSHSIZ##	;(44) SET DISK BLOCK CACHE SIZE
	XWD	NEDPRV,SETEBU	;(45) SET EDDT BREAKPOINT ON/OFF
	EXP	SETUBU		;(46) SET DDT BREAKPOINT ON/OFF
	XWD	NEDPRV,SETDA0	;(47) SET TIME OF DAY IN SECONDS
IFN FTPATT,<
	EXP	CPOPJ##		;ROOM FOR PATCHING
>
SETLEN==.-SETTBL-1



IFE FTLOCK,<
SETMN1==CPOPJ##
>
IFE FTSPL,<
SETSPI==CPOPJ##
SETSPB==CPOPJ##
SETSPL==CPOPJ##
>
IFE FTWATCH,<
SETWTU==CPOPJ##
>



;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- CORMAX AND CORMIN

IFN FTLOCK,<
SETMX1:	SKIPN	LOCK##		;JOB BEING LOCKED?
	JRST	SETMX2		;NO - OK
	JRST	ECOD0##		;YES - CAN'T CHANGE CORMAX
>
SETMAX::PUSHJ	P,CORLGL	;GET DECIMAL ARG IF LEGAL
IFN FTLOCK,<
	SKIPE	LOCK##		;IF A JOB IS BEING LOCKED,
	JRST	DLYCM1		;WAIT TILL LATER
>
SETMX2:				;SET NEW VALUE IN CORMAX
IFE FTLOCK,<
SETMX1==SETMX2
>
	MOVE	T1,MAXMAX##	;MAXMAX IS HIGHEST CORMAX
	SUBI	T1,NWMCP+IFN FTKLP,<PAGSIZ##>	;ALLOW FOR FUNNY PAGES
	CAMG	T2,T1		;TRY TO SET IT TOO HIGH?
	JRST	SETAOK		;NO
	JUMPGE	M,ECOD0##
	PUSHJ	P,INLMES
	ASCIZ	/
%Exceeds physical maximum-/
	MOVE	T1,MAXMAX##	;GET MAXIMUM
	SUBI	T1,NWMCP+IFN FTKLP,<PAGSIZ##>	;ALLOW FOR FUNNY PAGES
	LSH	T1,W2PLSH##	;SET UP FOR P OR K
	PUSHJ	P,PRCORE	;TELL WHAT IT IS
	MOVE	T2,MAXMAX##	;REDUCE TO PHYSICAL LIMIT
	SUBI	T2,NWMCP+IFN FTKLP,<PAGSIZ##>	;ALLOW FOR FUNNY PAGES
SETAOK:	CAIL	T2,MINMAX##	;TOO SMALL?
	JRST	SETIOK		;NO
	JUMPGE	M,ECOD0##
	PUSHJ	P,INLMES
	ASCIZ	/
%Below minimum-/
	MOVEI	T1,MINMAX##	;GET MINIMUM
	LSH	T1,W2PLSH##
	PUSHJ	P,PRCORE	;REPORT IT
	MOVEI	T2,MINMAX##
SETIOK:	CAMGE	T2,CORMAX##	;DECREASING?
	PUSHJ	P,CHKMAX	;YES. CHECK JOB SIZES
	MOVEM	T2,CORMAX##	;SAVE NEW VALUE
	LSH	T2,W2PLSH##	;REDUCE TO N
	HRRM	T2,CORLIM##	;SAVE IN RH(CORLIM)
	JRST	CPOPJ1##	;AND SKIP RETURN
CHKMAX:	PUSHJ	P,SAVE3##	;SEE IF NEW CORMAX
	SETZ	P1,0		;IS TOO SMALL FOR
	PUSH	P,J		;JOBS NOW RUNNING
	MOVE	P2,T2		;SAVE DESIRED NEW VALUE
	MOVEI	J,1		;SCAN ALL JOBS
CHKMX1:	MOVE	T2,JBTSTS##(J)	;DON'T COUNT LOCKED JOBS
	TLNE	T2,NSHF!NSWP
	TDZA	T2,T2		;THIS JOB IS LOCKED
	PUSHJ	P,SEGSIZ	;GET LOW SEG SIZE
	PUSH	P,J		;SAVE JOB #
	SKIPG	J,JBTSGN##(J)	;GET ITS HISEG (IF ANY)
	JRST	CHKMX2		;NONE
	MOVSI	T3,NSWP!NSHF
	TDNE	T3,JBTSTS##(J)	;HISEG LOCKED?
	JRST	CHKMX2		;YES
	MOVE	P3,T2		;SAVE LOW SEG SIZE
	PUSHJ	P,SEGSIZ	;GET HISEG SIZE
	ADDI	T2,(P3)		;TOTAL
CHKMX2:	LSH	T2,P2WLSH##	;TOTAL WORDS
	CAMLE	T2,P1		;BIGGEST SO FAR?
	MOVE	P1,T2		;YES
	POP	P,J		;GET BACK JOB #
	CAMGE	J,HIGHJB##	;ALL JOBS SCANNED?
	AOJA	J,CHKMX1	;NO
	CAMG	P1,P2		;BIGGEST JOB FIT NEW CORMAX?
	JRST	CHKMX3		;YES. OK AS IS
	MOVE	P2,P1		;NO. ADJUST REQUEST
	JUMPGE	M,CHKMX3
	PUSHJ	P,INLMES
	ASCIZ	/
%Too small for current job(s)-/
	MOVE	T1,P2		;GET SIZE OF LARGEST JOB
	LSH	T1,W2PLSH##
	PUSHJ	P,PRCORE	;REPORT IT
CHKMX3:	MOVE	T2,P2
	POP	P,J		;BALANCE STACK
	JRST	ECOD0##		;RETURN ERROR


IFN FTLOCK,<
SETMIN::PUSHJ	P,CORLGL	;GET DECIMAL ARG IF LEGAL
SETMN1:	CAMLE	T2,CORMAX##	;CORMIN CAN'T
	MOVE	T2,CORMAX##	;EXCEED CORMAX
	MOVEM	T2,CORMIN##	;SET NEW VALUE IN CORMIN
	JRST	CPOPJ1##	;AND SKIP RETURN
>
;SUBROUTINE TO GET CORE ARGUMENT AND CHECK FOR LEGALITY
; DOES NOT RETURN IF NOT LEGAL
CORLGL::PUSHJ	P,SETLGL	;TEST FOR LEGALITY
	  JRST	COMERP		;NOT LEGAL

	PUSHJ	P,CORARG	;GET THE CORE ARGUMENT
	  JRST	NOTENP		;NOT ENOUGH ARGUMENTS
	AOS	T2,T1		;CONVERT TO NUMBER OF WORDS
	POPJ	P,		;RETURN
;SUBROUTINE TO TEST FOR LEGALITY, RETURN NEXT TYPED ARGUMENT IF LEGAL
;DOES NOT RETURN IF NOT LEGAL
DECLGL::PUSHJ	P,SETLGL	;TEST FOR LEGALITY
	  JRST	COMERP		;NOT LEGAL

	PUSHJ	P,DECIN1	;LEGAL - GET DECIMAL NUMBER
	  PJRST NOTENP		;NOT ENOUGH ARGS
	  PJRST COMERP		;NOT A NUMBER
	POPJ	P,		;OK - RETURN
;STILL IN FTSET CONDITIONAL
IFN FTMONL!FTMOFFL,<
;HERE TO SET MEMORY ON OR OFF LINE
SETMEM::PUSHJ	P,SETLGL	;MUST BE PRIVILEGED
	  JRST	COMERA		;NOT PRIVLEGED, LOSE
;	PUSHJ	P,SAVE2##
	PUSHJ	P,CTEXT		;GET MODIFIER
	JUMPE	T2,NOTENF	;MUST BE ONE
	MOVE	T1,[-2,,[SIXBIT /ON/
			 SIXBIT /OFF/]]
	PUSHJ	P,FNDNAM	;LOOK FOR EITHER "ON" OR "OFF"
	  JRST	COMERA		;IF NEITHER, LOSE
	MOVE	P1,T1		;REMEMBER WHETHER HE SAID ON OR OFF
	PUSHJ	P,SKIPS1	;SKIP SPACES, TABS, ETC.
	  JFCL			;IGNORE NON-SKIP RETURN
	CAIN	T3,"-"		;ALLOW "-LINE"
	PUSHJ	P,COMTYS	;IF A MINUS SIGN WAS TYPED, SKIP IT
	MOVE	T1,[-2,,[SIXBIT /LINE/
			 SIXBIT /FROM/]]
	PUSHJ	P,TXTARG	;ALLOW NOISE WORDS
	  JRST	SETME0		;NONE WAS TYPED
	JUMPN	T1,SETME0	;SKIP ON IF "FROM" WAS TYPED
	HRROI	T1,[SIXBIT/FROM/]
	PUSHJ	P,TXTARG	;"LINE" WAS TYPED, EAT "FROM" IF ITS THERE
	  JFCL			;DON'T CARE WHETHER IT WAS ON NOT
SETME0:	PUSHJ	P,DECIN1	;READ AN ARGUMENT (DEFAULT IS DECIMAL)
	  JRST	NOTENF		;THERE MUST BE ONE
	  PUSHJ	P,[CAIE	T3,"K"	;NUMBER ENDED WITH A NON-DIGIT,
		   CAIN	T3,"P"	; WAS IT "P" OR "K"?
		   CAIA		;YES
		   JRST	COMERP	;NO, COMPLAIN
		   MOVEI T1,P2WLSH##
		   CAIE	T3,"P"	;ARGUMENT SPECIFIED IN PAGES?
		   MOVEI T1,K2WLSH##
		   LSH	T2,(T1)	;CONVERT TO WORDS
		   JRST	COMTYS]	;AND EAT THE "P" OR "K"
	MOVE	P2,T2		;SAVE THE LOWER BOUND
	HRROI	T1,[SIXBIT/TO/]
	PUSHJ	P,TXTARG	;ALLOW THE NOISE WORD "TO"
	  JFCL			;DON'T CARE IF IT ISN'T THERE
	PUSHJ	P,DECIN1	;READ THE SECOND ARGUMENT
	  JRST	NOTENF		;THERE MUST BE ONE
	  PUSHJ	P,[PUSHJ P,[CAIE T3,"K"
		   CAIN	T3,"P"	;ONCE AGAIN, ALLOW ARGUMENT TO BE
		   CAIA		; QUALIFIED BY "P" OR "K"
		   JRST	COMERP	;HOWEVER, NOTHING ELSE WILL DO
		   MOVEI T1,P2WLSH##
		   CAIE	T3,"P"	;PAGES?
		   MOVEI T1,K2WLSH##
		   LSH	T2,(T1)	;CONVERT TO WORDS
		   JRST	COMTYS]	;AND THROW AWAY THE CHARACTER
		   SOJA T2,CPOPJ##]
;STILL IN FTMONL, FTMOFFL, FTSET CONDITIONAL
	CAMG	P2,T2		;FIRST ARGUMENT MUST BE .LT. THE SECOND
	CAIE	T3,12		;AND THE LINE MUST BE PROPERLY TERMINATED
	JRST	COMERA		;GRUMBLE
	MOVE	T1,P2		;RESTORE FROM ARGUMENT
	TRZ	T1,PG.BDY##	;ROUND TO A PAGE BOUNDARY
	TRZ	T2,PG.BDY##	; ..
	ADDI	T2,PAGSIZ##	;ROUND UP
	LSHC	T1,W2PLSH##	;CONVERT FROM WORDS TO PAGES
;HERE T1 = LOWEST PAGE NUMBER (K NUMBER) OPR TYPED
;     T2 = HIGHEST PAGE NUMBER (K NUMBER) + 1 OPR TYPED
;P1 = 0 IF SET MEMORY ON LINE
;P1 = 1 IF SET MEMORY OFF LINE
;DISPATCH TO ROUTINE TO SET MEMORY ON OR OFF LINE
	JUMPN	P1,SETME1
IFE FTMONL,<
	JRST	COMERA		;ERROR IF NOT SUPPORTED
>
IFN FTMONL,<

;HERE TO SET MEMORY ON LINE, T1 = FIRST PAGE TO SET ON LINE, T2 = LAST
; PAGE + 1
MEMONL::HRLZ	S,T1		;STARTING PAGE TO SET ON LINE
	HRR	S,T2		;HIGHEST PAGE TO SET ON LINE
	JSP	T2,SAVCTX##	;SAVE THE JOB'S CONTEXT AND RETURN AT UUO LEVEL
				; (THE JOB'S CONTEXT MUST BE SAVED BECAUSE
				; IF SETTING THE MEMORY ON LINE CAUSES
				; A NXM, THE JOB'S CONTEXT WILL BE DESTROYED)
	HLRZ	T1,S		;RESTORE THE STARTING PAGE TO SET ON LINE
	HRRZ	T2,S		;AND THE HIGHEST PAGE TO SET ON LINE
IFN FTKI10!FTKL10,<
	CAIG	T2,1000		;TRYING TO SET MEMORY ON LINE ABOVE 256K?
	JRST	MEMON5		;NO, CAN DO THAT WITHOUT CHECKING
; 18 BIT MODE
	HLRZ	T3,SYSUNI##	;ADDRESS OF THE FIRST UDB IN THE SYSTEM
MEMON1:	HRRZ	T4,UNICHN##(T3)	;ADDRESS OF THE CHANNEL DATA BLOCK FOR THIS UNIT
	SKIPL	T4,CHB22B##(T4)	;IS THE CHANNEL IN 22 BIT MODE?
IFN FTKL10,<
	TLNE	T4,CP.RH2##	;OR AN RH20?
	CAIA			;YES
>
	JRST	MEMON4		;NO, CAN ONLY SET UP TO 256K ON LINE
	HLRZ	T3,UNISYS##(T3)	;ADDRESS OF THE NEXT UNIT DATA BLOCK
	JUMPN	T3,MEMON1	;JUMP IF NOT THE LAST
	SKIPN	T3,CNFMTA##	;ANY MAGTAPES?
	JRST	MEMON5		;NO
MEMON2:	HLRZ	U,TDVUDB##(T3)	;ADDRESS OF THE UDB FOR THIS DDB
	HRRZ	T4,TDVKDB##(T3)	;ADDRESS OF THE CONTROLLER DB FOR THIS UNIT
	HRRZ	T4,TKBCDB##(T4)	;ADDRESS OF THE CHANNEL DB FOR THIS CONTROLLER
	JUMPE	T4,MEMON3	;JUMP IF NOT A CHANNEL DEVICE
	MOVE	T4,CHB22B##(T4)
	TLNN	T4,CP.22B##!CP.RH20##!CP.DX1##
	JRST	MEMON4		;NO, CAN ONLY SET UP TO 256K ON LINE
MEMON3:	HLRZ	T3,DEVSER(T3)	;ADDRESS OF THE NEXT DDB
	JUMPE	T3,MEMON5	;ALL DONE IF THIS IS THE LAST DDB
	MOVE	T4,DEVMOD(T3)	;DEVICE CHARACTERISTICS
	TLNE	T4,DVMTA	;IS THIS A MTA DDB?
	JRST	MEMON2		;YES, MAKE SURE ALL CHANNELS ARE IN 22 BIT MODE
	JRST	MEMON5		;NO, ALL DONE
MEMON4:	MOVEI	T2,1000		;REDUCE THE HIGHEST PAGE TO SET ON LINE
				; TO 256K SINCE SOME CHANNEL IS IN 18 BIT MODE
> ;END IFN FTKI10!FTKL10

;STILL IN FTMONL
;HERE WHEN OPR IS REQUESTING .LE. 256K OR IF .GT. 256K, NO DF10 IN
; 18 BIT MODE WAS FOUND
MEMON5:	SE1ENT			;ENTER SECTION 1, TO LOOK AT PAGTAB.
	MOVE	T3,MEMSIZ##	;CURRENT HIGHEST ADDRESS IN THE MACHINE
	MOVE	T4,NWCORE##	;HIGHEST ADDRESS THAT CAN BE SET ON LINE
				; (CANNOT MAKE PAGTAB AND MEMTAB BIGGER)
	LSHC	T3,W2PLSH##	;CONVERT TO PAGES
	CAMG	T3,T4		;PICK THE BIGGER OF THE TWO AS THE
	MOVE	T3,T4		; HIGHEST ADDRESS THAT CAN BE SET ON LINE
	TRZE	T3,PG.BDY##	;ROUND UP TO A 256K BOUNDARY (IF NOT
	ADDI	T3,PAGSIZ##	; ALREADY ON A 256K BOUNDARY
	CAMG	T3,T2		;IF ASKING FOR MEMORY ON LINE ABOVE THE
				; HIGHEST WHICH CAN BE DONE,
	MOVE	T2,T3		; SET ON UP TO THE HIGHEST THAT CAN BE DONE
	CAML	T1,T2		;LOWEST PAGE ABOVE THE HIGHEST PAGE?
	POPJ	P,		;YES, NOTHING TO SET ON LINE
	MOVE	P1,T1		;LOWEST PAGE TO SET ON LINE
	IDIVI	P1,^D36		;COMPUTE BIT POSITION AND WORD NUMBER WITHIN NXMTAB
	MOVNI	P2,-^D35(P2)	;BIT POSITION BYTE POINTER STYLE
	HRLI	P1,(POINT 1,0,0);FORM A 1 BIT BYTE POINTER TO NXMTAB
	DPB	P2,[POINT 6,P1,5]
	ADDI	P1,NXMTAB##	;BYTE POINTER TO BIT CORRESPONDING TO FIRST PAGE TO SET ON
	SETZB	T4,P2		;INITIALIZE FIRST AND HIGHEST NON-EXISTANT PAGES SEEN
	MOVEI	P3,PAGSIZ##	;TO UPDATE MAXMAX ON EACH PAGE SET ON LINE
IFN FTMP,<
	PUSHJ	P,UPMM##	;GET THE MM RESOURCE
>
MEMON6:	MOVE	T3,@[IW MDSEC2,PAGTAB(T1)] ;PAGE DESCRIPTOR BITS
	TLNE	T3,NXMBIT	;IS THIS PAGE NON-EXISTANT?
	TLNE	T3,MONTRB	;IF AN UNMAPPED MONITOR PAGE SKIP IT TOO
	JRST	MEMON8		;NO, ITS ALREADY ON LINE
	ADDM	P3,MAXMAX##	;INCREASE THE MAXIMUM VALUE FOR CORMAX
	DPB	P3,P1		;INDICATE THAT THIS PAGE EXISTS IN NXMTAB
	SKIPN	P2		;SKIP IF NOT THE FIRST PAGE SET ON LINE
	MOVE	P2,T1		;REMEMBER THE FIRST PAGE SET ON LINE
	JUMPE	T4,MEMON7	;JUMP IF FIRST PAGE
	HRRZM	T1,@[IW MDSEC2,PAGTAB(T4)] ;LINK PAGES BEING SET ON LINE TOGETHER
MEMON7:	MOVE	T4,T1		;REMEMBER LAST PAGE
MEMON8:	IBP	P1		;BUMP BYTE POINTER TO NEXT PAGE IN NXMTAB
	CAIE	T1,-1(T2)	;LOOKED AT THE ENTIRE RANGE OF PAGES TO SET ON LINE?
	AOJA	T1,MEMON6	;NO, LOOK AT THE NEXT PAGE
IFE FTMP,<
	JUMPE	P2,CPOPJ##	;RETURN DOING NOTHING IF ALL PAGES WERE ALREADY
>				; ON LINE
IFN FTMP,<
	PJUMPE	P2,DWNMM##	;GIVE UP THE MM
>
	SETZM	@[IW MDSEC2,PAGTAB(T4)] ;INDICATE END OF THE LIST OF PAGES SET ON LINE

; STILL IN FTMONL
;HERE WHEN MEMORY HAS BEEN MARKED ON LINE TO ADD ALL PAGES WHICH
; WERE OFF LINE TO THE FREE CORE LIST
	MOVE	T1,P2		;FIRST PAGE IN THE LIST OF PAGES SET ON LINE
	MOVE	P1,T4		;LAST PAGE FREED
	LSH	T4,P2WLSH##	;HIGHEST ADDRESS SET ON LINE
	ADDI	T4,PAGSIZ##	;ADDRESS OF PAGE FOLLOWING HIGHEST SET ON LINE
	CAMLE	T4,MEMSIZ##	;IS THAT GREATER THAN CURRENT MEMORY SIZE?
	MOVEM	T4,MEMSIZ##	;YES, SAVE NEW HIGHEST ADDRESS IN MEMORY + 1
	MOVE	T4,MEMSIZ##	;HIGHEST ADDRESS IN MEMORY + 1
	LSH	T4,W2PLSH##	;CONVERT TO HIGHEST PAGE
	MOVE	T2,T4		;NEW HIGHEST PAGE
	TRZE	T2,PG.BDY	;ROUND UP
	ADDI	T2,PP256K##	;TO A 256K BOUNDARY
	IDIVI	T2,^D36		;BITS/WORD
	MOVNI	T2,1(T2)	;NEGATIVE LENGTH OF NXMTAB
	HRLM	T2,NXMPTR##	;UPDATE NXMPTR TO REFLECT ADDITIONAL MEMORY
	MOVEI	T4,PAGTAB-1(T4)	;BYTE POINTER TO HIGHEST PAGE IN MEMORY
	SSX	T4,MDSEC2	;GIVE IT A SECTION NUMBER
	MOVEM	T4,CORLST##	;STORE THAT FOR CHKTAL
	PUSHJ	P,GVPAGS##	;ADD THE PAGES SET ON LINE TO THE FREE CORE LIST
;HERE TO REFERENCE PAGES ADDED TO THE FREE CORE LIST SO IF THEY ARE
; OFF LINE, IT WILL BE DETECTED BEFORE THEY ARE ATTEMPTED TO BE USED
MEMON9:
	HRRZ	T1,P2		;FIRST PAGE SET ON LINE
	IDIVI	T1,^D36		;COMPUTE WORD AND BIT POSITION WITHIN NXMTAB
	MOVE	T2,BITTBL##(T2)	;MASK CORRESPONDING TO THAT BIT POSITION
	TDNE	T2,NXMTAB##(T1)	;IS THIS PAGE NOW ON LINE?
	JRST	MEMO11		;NO, FORGET IT
	HRRZ	T3,P2		;YES, GET PAGE NUMBER
	MOVE	T4,.CPMAP##
IFE FTKLP,<
	TRO	T3,PM.ACC+PM.WRT;ACCESS ALLOWED AND WRITEABLE
	HRLM	T3,.MEUPM(T4)
>
IFN FTKLP,<
	HRLI	T3,(<PM.DCD>B2+PM.WRT)
	MOVEM	T3,.EUPMP/PAGSIZ##(T4)
>
	CLRPGT	(0,.EUPMP)	;FLUSH PAGE TABLE SO NEW MAPPING IS IN EFFECT
;WORRY ABOUT INTERLEAVED MEMORY
	MOVEI	T3,MEMITL##	;NUMBER OF WAYS MEMORY CAN BE INTERLEAVED
	MOVEM	J,MOFLPG##	;FLAG THAT MEMORY BEING SET ON LINE
				; NXM AT THIS POINT ISN'T A SERIOUS ERROR
MEMO10:	MOVEI	T4,1000		;TIME TO WAIT FOR NXM FLAG TO CAUSE AN IRP.
	SETZM	.EUPMP-1(T3)	;REFRENCE THE PAGE TO MAKE SURE ITS REALLY THERE
	SOJG	T4,.		;WAIT LONG ENOUGH FOR NXM INTERRUPT TO HAPPEN
	TDNN	T2,NXMTAB##(T1)	;IS THE PAGE STILL ON LINE?
	SOJG	T3,MEMO10	;YES, CHECK NEXT WORD OF THE PAGE
				; TO INSURE THAT THERE ISN'T AN INTERLEAVING PROBLEM
	SETZM	MOFLPG##	;NO LONGER CHECKING FOR OFF LINE PAGES
MEMO11:	CAIN	P2,(P1)		;REFERENCED ALL PAGES IN THE RANGE SET ON LINE?
	JRST	MEMO12		;FIX CORE ALLOCATION VARIABLES, TELL DAEMON, AND RETURN
	HRRZ	P2,@[IW MDSEC2,PAGTAB(P2)] ;NO, GET THE NEXT PAGE SET ON LINE
	JRST	MEMON9		;AND REFERENCE IT TO MAKE SURE ITS THERE
MEMO12:	PUSHJ	P,CPINXF##	;FIX CORE ALLOCATION VARIABLES
	  JFCL			;CORMAX MAY HAVE CHANGED, BUT ALL JOBS WILL STILL FIT
IFN FTMP,<
	PUSHJ	P,DWNMM##	;GIVE UP THE MM
>

IFN FTDAEM,<
	MOVE	T1,[.CSCMO,,.ERCSC]
	PJRST	DAEEIM##	;TELL DAEMON CONFIGURATION HAS CHANGED AND RETURN
>
IFE FTDAEM,<
	POPJ	P,		;IF NO DAEMON, JUST RETURN
>

> ;END FTMONL

;STILL IN FTMONL, FTMOFFL, FTSET CONDITIONAL
SETME1:
IFE FTMOFFL,<
	JRST	COMERA		;ERROR IF NOT IMPLEMEMTED
>
IFN FTMOFFL,<
	SKIPN	[LOKINC##]	;MUST HAVE THE LOCK UUO TO SET MEMORY OFF
	JRST	COMERA		;ERROR IF LOKCON NOT LOADED
	PUSHJ	P,CKMOL##	;CHECK THAT RANGE DOESN'T OVERLAP THE MONITOR
	  JRST	SETME6		;IT DOES SO WE CAN'T DO IT
	LDB	T3,[POINT 14,NWCORE##,26] ;GET TOTAL SIZE (ON OR OFF)
	CAIL	T1,(T3)		;LOWER BOUND BEYOND END?
	  POPJ	P,		;YES, IT'S ALREADY OFF
	CAIL	T2,(T3)		;UPPER BOUND BEYOND END?
	  MOVE	T2,T3		;YES,CHANGE UPPER BOUND
	PUSH	P,T1		;SAVE LOWER BOUND
	PUSH	P,T2		;AND UPPER BOUND
	MOVEI	P1,[ASCIZ /?Job(s) to big to continue to run/]
	PUSHJ	P,NEWCMX##	;SEE IF ALL JOBS CAN CONTINUE TO RUN
	JUMPLE	T1,[POP P,(P)	;IF .LE. 0, TRYING TO SET MONITOR MEMORY OFF LINE
		    POP P,(P)
		    JRST SETME6];GO EXPLAIN THE PROBLEM
	PUSH	P,J		;SAVE J FOR COMRET
	MOVEI	J,0		;STARTING WITH JOB 0,
SETME3:	PUSHJ	P,JBSTBG##	;MAKE SURE ALL JOBS CAN STILL RUN (I.E., NONE IS TOO BIG)
	  JRST	SETME4		;NONE ARE
	PUSHJ	P,MOLMS		;TELL THE OPR ABOUT THIS JOB
	JRST	SETME3		;AND LOOK FOR MORE THAT ARE TOO BIG
SETME4:	JUMPE	P1,SETME7	;EXIT IF SOME JOBS WERE TO BIG
	MOVEI	P1,[ASCIZ /?Attempt to set memory containing locked jobs off-line/]
	MOVEI	J,0		;STARTING WITH JOB 0,
	MOVE	T1,-2(P)	;LOWER BOUND,
SETME5:	MOVE	T2,-1(P)	;UPPER BOUND,
	PUSHJ	P,CKLJB##	;SEE IF RANGE OVERLAPS SOME LOCKED JOB
	  JRST	SETME7		;IT DOESN'T SO ALL IS WELL
	PUSHJ	P,MOLMS		;TELL THE OPR ABOUT THIS JOB
	JRST	SETME5		;AND LOOP TO SEE IF THERE ARE ANY MORE IN THE WAY
SETME6:	JSP	T1,ERRMES	;PRINT THE ERROR MESSAGE
	ASCIZ	/Attempt to set monitor memory off-line/
SETME7:	POP	P,J		;RESTORE J FOR COMRET
	POP	P,T2		;RESTORE UPPER BOUND
	POP	P,T1		;AND LOWER BOUND
	JUMPE	P1,PCRLF	;EXIT IF THERE WAS AN ERROR
	PJRST	MEMOFL##	;GO SET THE MEMORY OFF-LINE

MOLMS:	PUSH	P,T1		;SAVE T1
	SKIPE	T1,P1		;SKIP IF ERROR MESSAGE WAS ALREADY TYPED
	PUSHJ	P,CONMES	;TYPE THE ERROR MESSAGE
	MOVEI	T1,[ASCIZ/
?Problem with job(s)/]
	SKIPE	P1		;SAY PROBLEM WITH JOBS ONCE
	PUSHJ	P,CONMES	;TYPE THAT
	MOVEI	P1,0		;FLAG AN ERROR AND DON'T PRINT ERROR HEADING TWICE
	TLO	M,ERRFLG##	;TELL COMRET THAT THERE WAS AN ERROR
	PUSHJ	P,PRJBNM##	;DISPLAY INFO. ABOUT THE PROBLEM JOB
	JRST	TPOPJ##		;RESTORE T1, AND RETURN

>;END FTMOFFL CONDITIONAL
>;END FTMONL, FTMOFFL CONDITIONAL
;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- DAYTIME AND SCHED

SETDAY::PUSHJ	P,SETLGL
	JRST	COMERA
	PUSHJ	P,RDTIM		;GET TIME OF DAY
	  PJRST	ERRCRL		;ISSUE CRLF/ERROR MESSAGE AND RETURN
	JRST	SETDA3		;SKIP AROUND SETUUO CHECK

SETDA0:	CAIL	T2,<^D24*^D60*^D60> ;RANGE CHECK IT
	JRST	ECOD3##		;ILLEGAL TIME (GREATER THAN 23:59:59)
	MOVE	T1,T2		;SHUFFLE TIME TO SAME AC RDTIM USES

SETDA3:	MOVE	T4,T1		;SAVE RESULT
	IDIVI	T1,^D60*^D60	;T1:= HOURS
	IDIVI	T2,^D60		;T2:= MINUTES, T3:= SECONDS
	MOVEM	T1,LOCHOR##	;SAVE HOURS
	MOVEM	T2,LOCMIN##	;SAVE MINUTES
	MOVEM	T3,LOCSEC##	;SAVE SECONDS
	IMUL	T4,TICSEC##	;CONVERT TO JIFFIES
	MOVEM	T4,TIME##	;SAVE IT
	MOVEM	T4,.CPTML##	;SAVE TIME AT THE LAST CLOCK TIC
	MOVEI	T1,.C0CDB##	;POINT AT FIRST CDB
	MOVN	T2,T3		;GET -SECONDS
	ADDI	T2,^D60		;GET SECONDS 'TIL NEXT MINUTE
	MOVE	T3,TICSEC##	;TIME TO NEXT SECOND
	JRST	SETDA2		;ENTER COMMON CODE

SETDA1:	IDIVI	T2,^D100	;HOURS INTO T2
	MOVEM	T3,LOCMIN##
	MOVEM	T2,LOCHOR##
	SETZM	LOCSEC##	;ZERO SECOND COUNTER
	IMULI	T2,^D60		;CONVERT HOURS TO MINS
	ADD	T2,T3		;+ORIGINAL MINS
	IMUL	T2,TICMIN##	;CONVERT TO JIFFIES
	MOVEM	T2,TIME##	;SAVE AS NEW TIME
	MOVEM	T2,.CPTML##
	MOVEI	T1,.C0CDB##	;POINT AT FIRST CDB
	MOVEI	T2,^D60		;TIME TO NEXT MINUTE
	MOVE	T3,TICSEC##	;TIME TO NEXT SECOND
SETDA2:	MOVEM	T2,.CPSEC##-.CPCDB##(T1) ;STORE IN THIS CDB
	MOVEM	T3,.CPHTM##-.CPCDB##(T1) ;TIME TO NEXT SECOND
	HLRZ	T1,.CPCDB##-.CPCDB##(T1) ;STEP TO NEXT
	JUMPN	T1,SETDA2	;LOOP FOR ALL
	PUSHJ	P,OMSTIM##	;RECOMPUTE OPR MESSAGE TIME
	PJRST	SETDT2		;FIXUP 'DATE' & SKIP RETURN

SETSCD::PUSHJ	P,SETLGL	;CHECK FOR LEGALITY
	  JRST	COMERA		;NOT LEGAL

	PUSHJ	P,OCTIN1	;OK - GET OCTAL NUMBER
	  PJRST NOTENF		;NOT ENOUGH ARGS
	  PJRST COMERA		;ILLEGAL NUMBER
SETSC1:	HRRM	T2,STATES##	;SAVE NUMBER
	JRST	CPOPJ1##	;AND SKIP RETURN

SETIM1:	IMUL	T2,TICSEC##	;CONVERT TO JIFFIES
	MOVSI	T3,(JB.LBT)	;GET BATCH BIT
	TDNN	T3,JBTLIM##(J)	;BATCH JOB?
	  JRST	SETIM2		;NO, GO STORE
	LDB	T3,JBYLTM##	;YES, LAST CHANCE
	JUMPE	T3,SETIM2	;CAN ALWAYS ADD RESTRICTIONS
	PUSHJ	P,PRVJC		;IS HE [1,2] OR JACCT?
	JRST	SETIM2		;LET HIM THROUGH
	PJRST	RTZER##		;NO, BOMB HIM

SETRTM::PUSHJ	P,DECIN1	;GET DECIMAL NO OF SECS
	  PJRST NOTENF		;NOT ENOUGH ARGS
	  PJRST COMERA		;NOTA NUMBER
	IMUL	T2,TICSEC##	;CONVERT TO JIFFIES
	TLNE	T2,(-JB.LTM-1)	;SEE IF TOO BIG
	PJRST	COMERA		;YES. ERROR
	MOVEI	T1,BATMSG
	LDB	T3,JBYLTM##
	JUMPE	T3,SETIM2
	MOVE	T3,JBTLIM##(J)
	TLNE	T3,(JB.LBT)
	JRST	ERRMES
SETIM2:	DPB	T2,JBYLTM##
	JRST	CPOPJ1##	;AND RETURN
	SUBTTL	SET COMMAND AND UUO -- OPR, LOGMIN&MAX BATMIN##&MAX

SETOPR::PUSHJ	P,SETLGL	;SEE IF SET OPR LEGAL
	  JRST	COMERA		;NOT LEGAL

	PUSHJ	P,CTEXT1	;GET NAME OF DEVICE
	MOVE	T1,T2		;MOVE FOR STDOPR
	PUSHJ	P,STDOPR##	;SET IT
	  PJRST	COMERA		;NO GOOD
	POPJ	P,0		;GOOD

SETOP1:	HRR	M,T2		;UUO, GET ADDRESS
	PUSHJ	P,GETWDU##	;GET CONTENTS IF LEGAL

	PUSHJ	P,STDOPR##	;CHANGE DEVICE
	  JRST ECOD0##		;ERROR RETURN
	JRST	CPOPJ1##	;GOOD RETURN


;LOGIN CONTROL PARAMETERS

SETLMX:	CAIL	T2,1		;LOGMAX MUST BE .GE. 1
	CAILE	T2,M.JOB##	;  AND .LE. M.JOB
	JRST	ECOD0##
	MOVEM	T2,LOGMAX##
	JRST	CPOPJ1##

SETBMX:	CAIL	T2,0		;BATMAX MUST BE .GE. 0
	CAILE	T2,M.JOB##	;  AND .LE. M.JOB
	JRST	ECOD0##
	MOVEM	T2,BATMAX##
	JRST	CPOPJ1##

SETBMN:	CAIL	T2,0		;BATMIN MUST BE .GE. 0
	CAMLE	T2,BATMAX##	;  AND .LE. BATMAX
	JRST	ECOD0##
	MOVEM	T2,BATMIN##
	JRST	CPOPJ1##

;SET QUEUE STRUCTURE
SETQST:	HRR	M,T2		;GET ADDR OF USER'S ARG
	PUSHJ	P,GETWDU##	;GET THE ARGUMENT
	SKIPE	T1		;WEED OUT JUNK
	PUSHJ	P,SRSTR##	;MAKE SURE ITS A KNOWN STR
	  PJRST	ECOD2##		;LOSE - ILLEGAL STRUCTURE
	MOVEM	T1,QUESTR##	;SAVE FOR % LDQUS GETTAB
	JRST	CPOPJ1##	;RETURN
;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- WATCH

IFN FTWATCH,<
SETWAT::PUSHJ	P,SAVE1##	;SAVE P1
	MOVE	P1,[IORM T2,JBTWCH##(J)]	;WE'RE CHANGING JBTWCH(J)
	PUSHJ	P,CTEXT		;GET 1ST ARG
	JUMPE	T2,WATLP1	;ERROR IF MISSING
	SKIPA	T1,[-WATLEN-NOTLEN,,WATTAB]	;SCAN BOTH TABLES 1ST TIME
WATLOP:	MOVE	T1,[-WATLEN,,WATTAB]	;POINT TO TABLE
	PUSHJ	P,FNDNAM	;LOOK FOR ABBREV.
	  JRST	WATLP1		;ERROR
	CAIL	T1,NOTTAB-WATTAB	;SEE IF IN NOTTAB
	JRST	WATCH2		;YES, MUST BE NO, ALL, NONE
	MOVNI	T1,(T1)		;-NO. OF ENTRY IN TABLE
	MOVSI	T2,JW.WDY	;FIRST BIT
	ROT	T2,(T1)		;ROTATE RIGHT TO PROPER POSITION
WATCH1:	XCT	P1		;ANDCAM OR IORM T2,JBTWCH(J)
	PUSHJ	P,CTEXT		;GET NEXT ARG
	JUMPE	T2,CPOPJ##	;0 IF FINISHED OR NONE
	JRST	WATLOP		;AND SET A BIT FOR IT
WATCH2:	SUBI	T1,WATLEN	;RELATIVE TO NOTTAB
	TRNN	T1,1		;NO OR NONE?
	HRLI	P1,(ANDCAM T2,(J))	;YES
	MOVSI	T2,WCHALL	;READY FOR ALL,NONE
	JUMPN	T1,WATCH1	;YES IT IS
	PUSHJ	P,CTEXT		;GET ARG OF NO
	JUMPN	T2,WATLOP	;SEE IF VALID


WATLP1:	JSP	T1,ERRMES	;NO, TELL USER THE LEGAL ONES
	ASCIZ	/Args are: day,run,wait,read,write,version,mta,files,all,none/
$LOW
WATTAB::<SIXBIT /DAY/>
	<SIXBIT	/RUN/>
	<SIXBIT	/WAIT/>
	<SIXBIT	/READS/>
	<SIXBIT	/WRITES/>
	<SIXBIT	/VERSION/>
	<SIXBIT	/MTA/>
	<SIXBIT	/FILES/>
;ADD NEW ITEMS HERE AND IN ERROR COMMENT AND IN S.MAC
WATLEN==.-WATTAB
WTCMXL==:<WATLEN-1>B26
>	;END FTWATCH
IFN FTWATCH!FTSPL,<
;THIS TABLE MUST BE IN ORDER NO, ALL, NONE
;AND MUST FOLLOW WATTAB IF FTWATCH IS NON-ZERO
NOTTAB:	<SIXBIT	/NO/>
	<SIXBIT	/ALL/>
	<SIXBIT	/NONE/>
NOTLEN==.-NOTTAB
$HIGH
>	;END FTWATCH!FTSPL
;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- DATE


SETDAT::PUSHJ	P,SETLGL	;TEST FOR LEGALITY
	  JRST	COMERA		;NOT PRIVILEGED
	PUSHJ	P,SAVE3##	;FRE UP SOME ACS
	MOVE	P1,LOCYER##	;SAVE THE OLD DATE
	MOVE	P2,LOCMON##
	MOVE	P3,LOCDAY##
	MOVEI	T1,LOCYER##
	PUSHJ	P,GTDATE	;ACCEPT E.G. 3-JAN-72
	JRST	[MOVEM P1,LOCYER## ;RESTORE OLD DATE
		 MOVEM P2,LOCMON##
		 MOVEM P3,LOCDAY##
		 JRST COMERR]	;BAD DATA
SETDT2:	AOS	(P)		;SKIP RETURN
	PUSH	P,DATE##	;SAVE OLDDAE
	PUSHJ	P,SUDATE##	;RECOMPUTE UNIV. DATE
IFN STUPID,<
	MOVEI	T1,1		;Assume daylight savings (simplifies testing).
	PUSHJ	P,DSTTMZ##	;Set up TMZWRD.
SETDL1:
>;IFN STUPID
	POP	P,T1		;GET OLD DATE BACK
	SUB	T1,DATE##	;SUBTRACT NEW FROM OLD
	MOVNS	T1		;MAKE IT ADDITIVE
	MOVE	T2,HIGHJB##	;GET HIGHEST JOB ASSIGNED
SETDT3:	SKIPE	JBTJLT##(T2)	;ANYTHING THERE?
	ADDM	T1,JBTJLT##(T2)	;YES, ADJUST IT
	HRRZ	T3,JBTPDB##(T2)	;GET PDB ADDR
	CAIE	T3,0		;SEE IF THERE
	ADDM	T1,.PDSTM##(T3)	;YES ADJUST IT
	SOJG	T2,SETDT3	; AND LOOP
	SKIPE	RSDTTM##	;LAST CPU ROLE SWITCH?
	 ADDM	T1,RSDTTM##	;YES--UPDATE IT
IFN FTNSCHED,<
	SKIPE	SCDSTS##	;LAST SETTING OF SCHEDULER PARAMETERS?
	 ADDM	T1,SCDSTS##	;YES--UPDATE IT
>;END IFN FTNSCHED
	SKIPE	SCDSET##	;..
	 ADDM	T1,SCDSET##	;YES
	PUSHJ	P,FILSDT##	;TELL FILSER TO FIX THINGS UP
	PUSHJ	P,ENQSDT##	;AND QUESER
	PUSHJ	P,PSISDT##	;SIGNAL USERS TOO
IFN FTDAEM,<
	PUSH	P,F		;SAVE F AROUND CALL TO DAEMON
	HRRZ	U,T1		;TIME PART
	HLRZ	F,T1		;DATE PART
	MOVE	T1,[.CSCTC,,.ERCSC] ;DATE OR TIME CHANGE
	PUSHJ	P,DAERPT##	;TELL DAEMON
	POP	P,F		;RESTORE F
>
IFN FTKL10,<
	PUSHJ	P,THSDA##	;RECOMPUTE 12 BIT DATE
	PJRST	COMSDT##	;TELL ANY FRONT ENDS THAT NEED TELLING
				; ABOUT NEW DATE.  COUNT ON SET DAYTIME
				; GETTING HERE WITH NEW TIME ALSO.
>;END IFN FTKL10

IFN FTKI10!FTKS10,<
	PJRST	THSDA##		;RECOMPUTE 12 BIT DATE AND RETURN
>;END IFN FTKI10!FTKS10
SETDT1:	IDIVI	T2,^D31		;DECOMPOSE 12 BIT DATE INTO LOCYER...
	AOS	T3
	MOVEM	T3,LOCDAY##
	IDIVI	T2,^D12
	AOS	T3
	MOVEM	T3,LOCMON##
	ADDI	T2,^D1964
	MOVEM	T2,LOCYER##
	JRST	SETDT2		;GO MAKE & STORE THSDAT & DATE

IFN STUPID,<
SETDST::			;Entry point for daylight savings change.
	PUSH	P,DATE##	;SAVE OLDDAE
	PUSHJ	P,SUDATE##	;RECOMPUTE UNIV. DATE
	JRST	SETDL1		;Join common code.
>;IFN STUPID

SETKSY::MOVEM	T2,SYSKTM##	;STORE VALUE FOR CLOCK1
IFN FTPI,<PUSHJ P,PSIKSY##>	;TELL EVERYONE OF CHANGE
	JRST	CPOPJ1##	;RETURN

;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- SPOOL

IFN FTSPL,<
SETSPL::PUSHJ	P,SAVE2##	;SAVE P1
	MOVE	P1,[IORM T2,JBTSPL##(J)]	;WE'RE CHANGING JBTSPL
	PUSHJ	P,CTXDEV	;GET 1ST ARG
	JUMPE	T2,NOTENF	;NOT ENOUGH ARGS
	MOVE	T1,[-NOTLEN,,NOTTAB]
	PUSHJ	P,FNDNAM	;SEE IF NO. ALL, NONE
	  JRST	SETSP0		;NO, SEE IF DEVICE
	TRNN	T1,1		;IS IF NO OR NONE
	HRLI	P1,(ANDCAM T2,(J))	;YES, TURN OFF BIT
	JUMPN	T1,SETSP3	;ALL OR NONE?
	PUSHJ	P,CTXDEV	;NO, GET ARG FOR NO
	JUMPE	T2,NOTENF	;NOT ENOUGH ARGS
SETSP0:	MOVEI	F,SPLTAB##	;POINT TO SPOOL TABLE
	TRNN	T2,-1		;DID HE SPEC A PHYS DEV?
	JRST	SETSP1		;NO ALL IS OK
	JSP	T1,ERRMES	;YES, GIVE A MESSAGE
	ASCIZ	/Cannot spool a physical device
/

SETSP1:	CAMN	T2,SPLNAM##(F)	;HATCH?
	JRST	SETSP2		;YES!
	ADDI	F,SPLLEN##	;BUMP TO NEXT CARRY
	CAIGE	F,SPLTOP##	;DONE?
	JRST	SETSP1		;NO, LOOP
	JSP	T1,ERRMES	;YES, NOT FOUND
	ASCIZ	/Not a spoolable device
/
SETSP2:	HRRZ	T2,SPLBIT##(F)	;GET THE SPOOL BIT
	SKIPA			;SKIP ALTERNATE ENTRY
SETSP3:	MOVEI	T2,.SPALL	;ALL OR NONE

	TLNE	P1,20000	;P1 AN ANDCAM?
	JRST	SETSP4		;NO - ALWAYS ALLOWED TO SET SPOOLING
	MOVSI	T1,PVNSPL	;PRIV?
	TSNN	T1,STATES##	;OR SCHED BIT?
	PUSHJ	P,PRVBIT	;90 SEC.
;NOTE THIS CODE DEPENDS ON PVNSPL=ST.NSP
IFN PVNSPL-ST.NSP,<PRINTX ST.NSP DOESN'T=PVNSPL>
	JRST	SETSP4		;YES - OK
	JSP	T1,ERRMES	;NO - TYPE THE MESSAGE:
	ASCIZ	/No privs to unspool
/
SETSP4:	XCT	P1		;TURN ON/OFF SPOOL BIT(S)
	MOVE	F,LDBDDB##(U)	; AND F
	PUSHJ	P,CTXDEV	;GET NEXT DEV
	JUMPE	T2,CPOPJ##	;RETURN IF NOTHING
	JRST	SETSP0		;AND SET ITS BIT

;STILL IN FTSPL CONDITIONAL
;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- DEFER/NODEFER - BATCH STREAM - WTO - OPER PRIV
;ENTER HERE ON SETUUO FOR DEFER/NODEFER
SETDFU:	JUMPE	T2,SETNDC	;ZERO MEANS NO-DEFERED
				; ELSE FALL INTO DEFER

;ENTER HERE ON SET DEFER COMMAND
SETDFC::MOVEI	T2,JB.DFR	;GET DEFER BIT
	IORM	T2,JBTSPL##(J)	;SET IT
	JRST	CPOPJ1##	;RETURN

;ENTER HERE ON SET NODEFER COMMAND
SETNDC::MOVEI	T2,JB.DFR	;GET DEFER BIT
	ANDCAM	T2,JBTSPL##(J)	;CLEAR IT
	JRST	CPOPJ1##	;RETURN

;ENTER HERE ON SETUUO FOR BATCH-STREAM-NUMBER

SETBSN:	MOVSI	T1,(JB.BSS)	;LOAD "ALREADY SET" BIT
	TDNE	T1,.PDOBI##(W)	;TEST IT
	JRST	ECOD0##		;SET ALREADY!
	DPB	T2,[EXP JBPBSN]	;STORE VALUE
	IORM	T1,.PDOBI##(W)	;SET BIT
	JRST	CPOPJ1##	;RETURN

;ENTER HERE ON SETUUO FOR WTO CAPABILITIES

SETWTO:	DPB	T2,[EXP JBPWTO]	;STORE VALUE
	JRST	CPOPJ1##	;AND RETURN


;ENTER HERE ON SET OPER PRIVILEGE
SETOPP:	DPB	T2,[EXP JBPOPP]
	JRST	CPOPJ1##

;STILL IN FTSPL CONDITIONAL
;STILL IN FTSET CONDITIONAL
	SUBTTL	SET COMMAND AND UUO -- DEFAULTS

SETDFL::PUSHJ	P,CTEXT		;GET DEFAULT ARGUMENT MODIFIER
	JUMPE	T2,NOTENF	;MUST BE ONE
	MOVE	T1,[-DFLTTL,,DFLTTB]	;ARGUMENT FOR FNDNAM
	PUSHJ	P,FNDNAM	;SEE IF A LEGAL MODIFIER WAS SPECIFIED
	  JRST	COMERA		;BAD ARGUMENT
	TLNN	P4,JLOG
	SKIPGE	DFLCTB(T1)
	JRST	@DFLCTB(T1)	;DISPATCH TO SET THE DEFAULT
	JRST	STARTE

;HERE ON SET DEFAULT UUO
SETDLU:	HRR	M,T2		;ADDRESS OF FUNCTION CODE
	PUSHJ	P,GETWDU##	;GET THE FUNCTION CODE
	HLRZ	T2,T1		;NUMBER OF ARGUMENTS
	HRRZS	T1		;FUNCTION CODE
	CAILE	T1,DFLUTL	;IS IT A DEFINED FUNCTION CODE?
	JRST	ECOD0##		;NO, ERROR RETURN
	JRST	@DFLUTB(T1)	;DISPATCH TO SET THE DEFAULT

DEFINE NAMES<
	C	PROTECTION,DFLPRT,0
	C	BUFFERS,DFLBFN,0
	C	ACCOUNT,DFLACS,400000
	C	BIGBUF,DFLBBC,0

>
DEFINE C(A,B,D,E)<
IFNB<E>,<E:>
	<SIXBIT /A/>
>
XALL
DFLTTB::NAMES
DFLTTL==.-DFLTTB
DFLMXL==:<DFLTTL-1>B26
DEFINE C(A,B,D,E)<
	XWD	D,B
>
DFLCTB:	NAMES
DFLUTB:	EXP	DFLPRU
	EXP	DFLBFU
	EXP	DFLDAU
	EXP	DFLBBU
DFLUTL==.-DFLUTB-1
SALL
;HERE ON SET DEFAULT PROTECTION COMMAND
DFLPRT:	MOVE	T1,[-2,,[SIXBIT /ON/
		         SIXBIT /OFF/]]
	PUSHJ	P,TXTARG	;WAS "ON OR OFF" TYPED?
	  JRST	DFLPR0		;NO
	JUMPE	T1,DFLPR1	;JUMP IF ON WAS TYPED
	MOVSI	T1,(PD.DPS)	;YES, CLEAR THE BIT WHICH SAYS
	ANDCAM	T1,.PDDFL##(W)	; DEFAULT PROTECTION WAS SET
	POPJ	P,		;AND RETURN
DFLPR0:	PUSHJ	P,SKIPS1	;SKIP BLANKS, TABS, ETC.
	  JFCL			;IGNORE
	CAIN	T3,074		;WAS A BRACKET TYPED ?
	PUSHJ	P,COMTYS	;YES, FLUSH IT.
	PUSHJ	P,OCTIN1	;READ THE PROTECTION VALUE
	  JRST	NOTENF		;IT MUST BE THERE
	  JRST	COMERA		;ILLEGAL CHARACTER
	TDNE	T2,[-1,,777000]	;LEGAL PROTECTION VALUE ?
	JRST	COMERA		;NO, COMPLAIN
	.DPB	T2,PDYDPT##	;STORE DEFAULT PROTECTION
	JRST	DFLPR1		;AND INDICATE A DEFAULT WAS SPECIFIED

;HERE ON SET DEFAULT PROTECTION UUO
DFLPRU:	PUSHJ	P,GETWD1##	;GET THE PROTECTION VALUE
	TDNE	T1,[-1,,777000]	;LEGAL ?
	JRST	ECOD0##		;NO, ERROR RETURN
	.DPB	T1,PDYDPT##	;STORE DEFAULT PROTECTION
DFLPR1:	MOVSI	T1,(PD.DPS)	;DEFAULT PROTECTION SPECIFIED BIT
	IORM	T1,.PDDFL##(W)	;LITE THAT
	JRST	CPOPJ1##	;AND GIVE GOOD RETURN

;HERE ON SET DEFAULT NUMBER OF BUFFERS COMMAND
DFLBFN:	PUSHJ	P,DECIN		;READ NUMBER
	  JRST	NOTENF		;NOT THERE
	  JRST	COMERA		;NOT A NUMBER
	TDNE	T2,[-1,,777000]	;IN RANGE?
	JRST	COMERA		;NO, ERROR
	SKIPA	T1,T2		;YES, STORE DEFAULT NUMBER
;HERE ON SET DEFAULT BUFFERS UUO
DFLBFU:	PUSHJ	P,GETWD1##	;GET ARGUMENT
	TDNE	T1,[-1,777000]	;IN RANGE?
	JRST	ECOD0##		;NO, ERROR
	DPB	T1,PDYBFN##	;STORE DEFAULT NUMBER OF DISK BUFFERS
	JRST	CPOPJ1##	;AND GIVE GOOD RETURN
;HERE ON SET DEFAULT DON'T ASK ABOUT DETACHED JOBS UUO
DFLDAU:	PUSHJ	P,GETWD1##	;GET ARGUMENT
	MOVE	T2,.PDDFL##(W)	;DEFAULT WORD
	SKIPN	T1		;SET?
	TLZA	T2,(PD.DAD)	;NO, CLEAR
	TLO	T2,(PD.DAD)	;YES
	MOVEM	T2,.PDDFL##(W)	;STORE ANSWER
	JRST	CPOPJ1##	;AND GIVE GOOD RETURN
;HERE TO SET DEFAULT ACCOUNT STRING (USED FOR JOBS LOGGED IN ON FRCLIN)
DFLACS:	PUSHJ	P,SETLGL	;MUST BE OPR
	 JRST	COMERA		;NOT, COMPLAIN
	PUSHJ	P,SAVE2##	;WORKING ACS
	HRRZ	P1,JBTPDB##+0	;NULL JOB'S PDB
	ADD	P1,[POINT 7,.PDACS##] ;WHERE TO STORE DEFAULT
	HRREI	P2,5*ACTSTL##-1	;LENGTH OF ACCOUNT STRING
	JUMPLE	P2,COMERA	;FORGET IT IF ZERO LENGTH
DFLAC1:	PUSHJ	P,COMTYI##	;NEXT CHARACTER
	CAIE	T3,12		;LINEFEED?
	CAIN	T3,3		;OR CONTROL C
	JRST	DFLAC2		;YES, THAT'S ALL FOLKS
	IDPB	T3,P1		;NO, STORE THE CHARACTER
	SOJG	P2,DFLAC1	;LOOP FOR MORE
DFLAC2:	MOVEI	T1,0		;ASCIZIZE
	IDPB	T1,P1
	POPJ	P,		;RETURN


;HERE ON SET DEFAULT BIGBUF COMMAND
DFLBBC:	PUSHJ	P,DECIN		;GET THE NUMBER OF BLOCKS PER BUFFER
	  JRST	NOTENF		;NOT THERE
	  JRST	COMERA		;NOT A NUMBER
	MOVE	T1,T2
	CAILE	T1,LIMBBF	;IN RANGE?
	JRST	COMERA		;NO, ERROR
	JRST	DFLBB2

;HERE ON SET DEFAULT BIGBUF UUO
DFLBBU:	PUSHJ	P,GETWD1##
	TLNN	T1,-1		;SET JOB-WIDE DEFAULT?
	JRST	DFLBB1		;NO, CONTINUE
	HLRZS	T1		;YES, MAKE IT AN RH QUANTITY
	TLO	M,400000	;PRETEND WE HAVE A COMMAND
DFLBB1:	CAILE	T1,LIMBBF##	;IN RANGE?
	JRST	ECOD0##		;NO, ERROR
DFLBB2:	LSH	T1,BLKLSH##	;YES, CONVERT TO NUMBER OF WORDS
	SKIPE	T1		;CLEAR IT IF ARGUMENT IS 0
	ADDI	T1,1
	SKIPL	M		;UUO?
	HRLM	T1,.PDLBS##(W)	; SAVE IN PDB
	SKIPGE	M		;COMMAND?
	HRRM	T1,.PDLBS##(W)	; SAVE IN PBD
	JRST	CPOPJ1##	;AND TAKE GOOD RETURN
SUBTTL	SET COMMAND AND UUO -- BREAK

IFN FTKS10,<
;NO ADDRESS BREAK
	XP	SETBRK,COMERA
	XP	SETABR,CPOPJ##
	XP	CLRBRK,CPOPJ##
>

IFN FTKI10!FTKL10,<

;HERE IF THE USER TYPED SET BREAK
SETBRK::PUSHJ	P,SAVE2##	;SAVE P1,P2
	PUSHJ	P,FNDPDS##	;FIND THE PDB FOR THIS USER
	PUSHJ	P,CTEXT		;GET THE FIRST ARGUMENT
	JUMPE	T2,NOTENF	;IF NONE, COMPLAIN
	PUSHJ	P,GETNUM	;SEE IF ARGUMENT TYPED IS A NUMBER
	  JRST	SETBR2		;NOT A NUMBER, LOOK FOR LEGAL TEXT
SETBR1:	CAIN	P1,-1		;DON'T ALLOW -1 FOR THE TIME BEING SINCE IT
				; CONFUSES THE HARDWARE
	JRST	COMERA		;COMPLAIN
	.HRRM	P1,.PDABS##(W)	;STORE THE BREAK ADDRESS
	PUSHJ	P,CTEXT		;GET THE NEXT ARGUMENT
	JUMPN	T2,SETBR2	;JUMP IF ONE WAS TYPED
	SKIPN	P2,P1		;BREAK ADDRESS ZERO?
	  JRST	SETB10		;YES, TREAT SET BREAK 0 WITH NO CONDITION LIKE NONE
	.HLLZ	P2,.PDABS##(W)	;GET PREVIOUS CONDITIONS IF ANY
	TLZ	P2,(OC.BSU)	;CLEAR SET BY UUO
SETB1A:	TLNN	P2,(OC.BCI+OC.BCD+OC.BCW+OC.BCM)	;WERE THERE ANY PREVIOUSLY?
	TLO	P2,(OC.BCI+OC.BCD+OC.BCW)	;NO, ASSUME ALL
	JRST	SETBR8		;ENABLE BREAK, STORE CONDITIONS, AND GO AWAY
SETBR2:	MOVE	T1,[-4,,BRKLS1]	;TABLE LENGTH,,ADDRESS OF THE TABLE
	PUSHJ	P,FNDNAM	;RECOGNIZABLE TEXT ARGUMENT?
	  JRST	SETBR5		;NO, POSSIBLY IN ANOTHER CONTEXT
	MOVE	P2,T1		;INDEX INTO BRKTBL
	JUMPN	T1,SETBR3	;JUMP IF THE USER DIDN'T TYPE 'NONE'
;HERE WHEN THE USER TYPED 'NONE'
	JUMPGE	P1,COMERA	;IF A NUMBER WAS TYPED WE SHOULDN'T BE HERE
	JRST	SETB10		;GO CLEAR BREAK CONDITIONS
SETBR3:	PUSHJ	P,CTEXT		;GET THE NEXT TEXT ARGUMENT
	JUMPE	T2,NOTENF	;IF WE'RE HERE THERE HAS TO BE ONE
	JRST	.(P2)		;DISPATCH TO THE APPROPRIATE PROCESSOR
	JRST	SETBR4		;USER TYPED 'AT'
	JRST	SETBR5		;USER TYPED 'ON'
	JRST	SETBR6		;USER TYPED 'NO'
;HERE WHEN THE USER TYPED 'AT'
SETBR4:	JUMPGE	P1,COMERA	;NO PREVIOUS NUMBERS ALLOWED IF WE GET HERE
	PUSHJ	P,GETNUM	;CONVERT THE NUMBER FROM SIXBIT TO OCTAL
	  JRST	COMERA		;IT MUST BE A NUMBER BUT ISN'T SO COMPLAIN
	JRST	SETBR1		;LOOK FOR THE NEXT TEXT ARGUMENT
;HERE WHEN THE USER TYPED 'ON'
SETBR5:	SKIPA	P1,[TDO P2,BRKTBL-1(T1)]
;HERE WHEN THE USER TYPED 'NO'
SETBR6:	MOVE	P1,[TDZ P2,BRKTBL-1(T1)]
	.HLLZ	P2,.PDABS##(W)	;GET CURRENT BREAK CONDITIONS
	TLZ	P2,(OC.BSU)	;CLEAT SET BY UUO
SETBR7:	MOVE	T1,[-7,,BRKLS2]	;TABLE LENGTH,,TABLE ADDRESS
	PUSHJ	P,FNDNAM	;GET A BREAK CONDITION
	  JRST	COMERA		;IT CAN'T BE ANYTHING ELSE
	JUMPE	T1,SETB11	;JUMP IF 'USERS'
	CAIN	T1,AFTERX
	JRST	SETB12
	XCT	P1		;SET OR CLEAR THE CONDITION
	PUSHJ	P,CTEXT		;GET THE NEXT ARGUMENT
	JUMPN	T2,SETBR7	;LOOP BACK IF THERE WAS ONE
	TLZ	P2,(OC.ABE+OC.FUP)	;ASSUME NO CONDITIONS
	TLNN	P2,(OC.BCI+OC.BCD+OC.BCW+OC.BCM)	;ANY CONDITIONS DESIRED?
	JRST	SETB10		;NO, DECREMENT NUMBER OF USERS USING ADDRESS BREAK
SETBR8:	PUSHJ	P,BRKAV		;SEE IF ADDRESS BREAK IS AVAILABLE AND INCREMENT
				; THE COUNT OF USERS USING IT IF SO
	  JRST	NOBRAK		;NOT AVAILABLE, COMPLAIN
SETBR9:	TLOA	P2,(OC.ABE+OC.FUP)	;ENABLE THE USER FOR ADDRESS BREAK
SETB10:	PUSHJ	P,BRKDEC	;DECREMENT THE COUNT OF USERS USING ADDRESS BREAK
	.HLLM	P2,.PDABS##(W)	;STORE THE NEW CONDITIONS
	POPJ	P,		;AND RETURN TO COMCON
;HERE WHEN THE USER TYPED 'USERS', MUST BE PRIVILEGED
SETB11:	PUSHJ	P,SETLGL	;USER SUFFICIENTLY PRIVILEDGED TO MONOPOLIZE
				; ADDRESS BREAK?
	  JRST	COMERA		;NO, COMPLAIN
	PUSHJ	P,FDNJP		;FIND THE NULL JOB'S PDB
	MOVSI	T2,400000	;SET TO TURN ON OR OFF ADDRESS BREAK
	CAME	P1,[TDZ P2,BRKTBL-1(T1)]	;WAS 'USERS' WITHOUT A 'NO' TYPED?
	JRST	[.ANCAM	T2,.PDABS##(T1)	;YES, ALLOW USERS TO USE ADDRESS BREAK
		 POPJ	P,]	;RETURN
;HERE WHEN THE USER TYPED 'NO USERS'
	.SKPLE	.PDABS##(T1)	;IS ADDRESS BREAK CURRENTLY BEING USED?
	JRST	NOBRAK		;DON'T ALLOW HIM TO YANK IT OUT FROM UNDER THEM
	.IORM	T2,.PDABS##(T1)	;DON'T ALLOW USERS TO USE ADDRESS BRAEK
	POPJ	P,		;RETURN TO COMCON

;HERE WHEN THE USER TYPED 'AFTER'
SETB12:	PUSHJ	P,DECIN		;GET THE NEXT ARGUMENT
	  PJRST	NOTENF		;THERE MUST BE ONE
	  JRST	COMERA		;NOTHING BUT A NUMBER IS LEGAL
	CAILE	T2,^D510	;IS IT TOO BIG?
	JRST	COMERA		;YES
	ADDI	T2,1
	DPB	T2,[POINT 9,P2,17]	;SAVE THE REPEAT COUNT
	JRST	SETB1A		;STORE IT AND GO AWAY
;HERE ON A SET ADDRESS BREAK UUO
SETABR::PUSHJ	P,SAVE2##	;SAVE P1,P2
	HRR	M,T2		;ADDRESS OF USER'S ARGUMENT
	PUSHJ	P,GETWDU##	;GET THE ARGUMENT
	HRRM	T1,.PDABS##(W)	;STORE THE BREAK ADDRESS
	MOVE	P2,T1		;P2 = BREAK CONDITIONS
	TLZ	P2,(OC.FEP)	;HE ISN'T ALLOWED TO SET FOLLOW EXEC PAGING
	TLO	P2,(OC.BSU)	;INDICATE SET BY UUO
	AOS	(P)		;PREPARE TO GIVE GOOD RETURN
	TLNN	P2,(OC.BCI+OC.BCD+OC.BCW+OC.BCM)
	JRST	[PUSHJ P,SETB10	;TURNING OFF BREAK
		 PJRST SETRL1##]
	PUSHJ	P,BRKAV		;IS ADDRESS BREAK AVAILABLE?
	  SOSA	(P)		;NO, ERROR RETURN
	JRST	[PUSHJ P,SETBR9	;YES, SETUP BREAK CONDITIONS
		 PJRST SETRL1##]
	JRST	ECOD0##		;GIVE ERROR RETURN
;HERE ON RESET TO CLEAR BREAK ADDRESS AND CONDITIONS
; IF SET BY UUO
CLRBRK::SKIPE	T1,.PDABS##(W)	;BREAK IN USE AT ALL?
	TLNN	T1,(OC.BSU)	;AND SET BY UUO?
	POPJ	P,		;NO
	PUSHJ	P,BRKDEC	;YES, DECREMENT COUNT OF USERS
	SETZM	.PDABS##(W)	;CLEAR ADDRESS AND CONDITIONS
	POPJ	P,		;AND RETURN
;THE ORDER OF AND THE NUMBER OF ENTRIES
; IN THE FOLLOWING TABLES CANNOT BE CHANGED
; WITHOUT CHANGING THE CODE IN SETBRK

BRKLS1:	SIXBIT	/NONE/
	SIXBIT	/AT/
	SIXBIT	/ON/
	SIXBIT	/NO/
BRKLS2:	SIXBIT	/USERS/
	SIXBIT	/EXECUT/
	SIXBIT	/READ/
	SIXBIT	/WRITE/
	SIXBIT	/MUUO/
	SIXBIT	/ALL/
BRKLS3:	SIXBIT	/AFTER/
AFTERX==BRKLS3-BRKLS2
;THE ENTRIES IN THIS TABLE CORRESPOND IN ORDER
; TO THE ENTRIES IN THE ABOVE TABLE
BRKTBL:	EXP	OC.BCI
	EXP	OC.BCD
	EXP	OC.BCW
	EXP	OC.BCM
	EXP	OC.BCI+OC.BCD+OC.BCW

;SUBROUTINE TO DETERMINE IF THE SIXBIT STRING IN
; T2 IS A LEGAL OCTAL NUMBER
;CALLING SEQUENCE:
;
;	MOVE	T2,SIXBIT STRING
;	PUSHJ	P,GETNUM
;NON-SKIP RETURN IF T2 DOES NOT CONTAIN A
; NUMBER, P1.LT.0, AND T2 PRESERVED
;SKIP RETURN P1=NUMBER IF T2 CONTAINS A NUMBER
;NEVER RETURNS IF T2 CONTAINS A MALFORMED
; NUMBER
;N.B. P1 MUST BE SAVED BEFORE CALLING THIS
;SUBROUTINE

GETNUM:	MOVSI	P1,400000	;INDICATE NO NUMBER SEEN
	MOVEI	T3,0		;CLEAR RESULT SO FAR
	MOVE	T4,[POINT 6,T2]	;BYTE POINTER TO PICKUP CHARACTERS
GETNM1:	ILDB	T1,T4		;GET THE NEXT CHARACTER
	CAIL	T1,'0'		;IS THE CHARACTER .LT. ZERO?
	CAILE	T1,'7'		;OR G.GE. 7?
	JRST	GETNM2		;YES, ITS NOT AN OCTAL DIGIT
	LSH	P1,3		;MULTIPLY ACCUMULATED RESULT BY 8
	ADDI	P1,-'0'(T1)	;ADD IN THE CURRENT CHARACTER
	JRST	GETNM1		;AND GET THE NEXT DIGIT
GETNM2:	JUMPL	P1,CPOPJ##	;NON-SKIP RETURN IF NOT A NUMBER
	JUMPN	T1,COMERP	;NUMBERS WHICH TERMINATE WITH NON-DIGITS ARE
				; NOT NUMBERS
	JRST	CPOPJ1##	;GIVE NUMBER FOUND RETURN
;SUBROUTINE TO DETERMINE WHETHER ADDRESS BREAK IS AVAILABLE TO USERS
;CALLING SEQUENCE:
;	PUSHJ	P,BRKAV
;NON-SKIP RETURN IF NOT AVAILABLE BECAUSE MEMORY
; INDICATORS ARE DISABLED OR ADDRESS BREAK IS BEING
; USED BY SYSTEM PROGRAMMERS FOR MONITOR DEBUGGING
;SKIP RETURN IF ADDRESS BREAK IS AVAILABLE TO USERS, COUNT OF THE NUMBER
;OF USERS USING ADDRESS BREAK HAS BEEN UPDATED
;PRESERVES T2

BRKAV:	PUSHJ	P,FDNJP		;FIND THE NULL JOB'S PDB
IFN FTMP,<
	PUSHJ	P,CP0RC##	;SEE IF THE JOB IS RUNNABLE ON CPU0
	  TLNN	P2,(OC.BCM)	;ITS NOT, BUT IF HE IS ENABLED FOR UUOS, SOME
>
				; MUST HAPPEN ON CPU0
	SKIPGE	.PDABS##(T1)	;HAS ADDRESS BREAK BEEN DISABGEED BY THE OPR?
	POPJ	P,		;YES, LOSE
IFN FTKI10&FTMP,<
	MOVSI	T4,(IP.MID)	;MI PROG DIS
	TDNN	T4,.C0APR##	;IS MI PROG DIS ON ON CPU0?
	PUSHJ	P,CP1AC##	;IF RUNNABLE ON CPU1, MI PROG DIS MUST BE OFF ON CPU1
	  POPJ	P,		;HE IS, IT ISN'T, SO LOSE
>
	.MOVE	T3,.PDABS##(W)	;GET HIS CURRENT ADDRESS BREAK SETTINGS
	TLNN	T3,(OC.ABE)	;IS HE ALREADY BREAKING?
	.AOS	.PDABS##(T1)	;NO, COUNT UP THE NUMBER OF USERS USING ADDRESS BREAK
	JRST	CPOPJ1##	;AND GIVE THE HAPPY RETURN

;SUBROUTINE TO DECREMENT THE COUNT OF THE NUMBER
; OF USERS USING ADDRESS BREAK

BRKDEC::.MOVE	T1,.PDABS##(W)	;GET HIS CURRENT BREAK SETTINGS
	TLNN	T1,(OC.ABE)	;IS HE ENABLED FOR ADDRESS BREAK?
	POPJ	P,		;NO, NOTHING TO DO
	PUSHJ	P,FDNJP		;FIND THE PDB FOR THE NULL JOB
	.SOS	.PDABS##(T1)	;DECREMENT THE COUNT OF USERS USING ADDRESS BREAK
	POPJ	P,		;AND RETURN

NOBRAK:	PJSP	T1,CONMES	;SORRY FOLKS!
	ASCIZ	/?Not available
/

;SUBROUTINE TO RETURN THE ADDRESS OF THE NULL JOB'S PDB IN T1
;PRESERVES T2-T4

FDNJP::	MOVEI	T1,0		;NULL JOB'S JOB NUMBER
	PUSHJ	P,FPDBT1##	;FIND THE NULL JOB'S PDB, RETURN ITS ADDRESS IN T1
	  JFCL			;IT MUST HAVE ONE
	POPJ	P,		;RETURN TO THE CALLER

>;END IFN FTKI10!FTKL10
	SUBTTL	SET COMMAND AND UUO -- PRIVILEGE WORDS

;HERE FOR UUO TO CHANGE PRIVILEGES

SETPRV:	HRRI	M,(T2)		;POINT TO FIRST ARGUMENT
	PUSH	P,J		;SAVE JOB NUMBER
	PUSHJ	P,GETWDU##	;PICK UP FUNCTION CODE
	SKIPL	T2,T1		;SEE IF NEGATIVE
	CAILE	T2,SPRVMX	;OR TOO LARGE
	JRST	[POP P,J	;BALANCE THE STACK
		 JRST ECOD0##]	;YES, ERROR RETURN
	ADDI	M,1
	PUSHJ	P,GTWST2##	;GET ARGUMENT INTO T1
	POP	P,J		;RESTORE JOB NUMBER
	JRST	@SPRVTB(T2)	;DISPATCH

SPRVTB:	EXP	SPRVWD		;(0) SET PRIVILEGE WORD
	EXP	SPRVON		;(1) SET BITS IN PRIV WORD
	EXP	SPRVOF		;(2) CLEAR BITS IN PRIV WORD
	EXP	SCAPWD		;(3) SET CAPABILITY WORD
	EXP	SCAPON		;(4) SET BITS IN CAPABILITY WORD
	EXP	SCAPOF		;(5) CLEAR BITS IN CAPABILITY WORD

	SPRVMX==.-SPRVTB-1	;HIGHEST FUNCTION

SPRVOF:	ANDCAB	T1,JBTPRV##(J)	;CLEAR REQUESTED BITS
	JRST	STOTC1##	;AND STORE RESULT

SPRVON:	IOR	T1,JBTPRV##(J)	;INCLUDE BITS HE ALREADY HAS
SPRVWD:	MOVE	T2,.PDCAP##(W)	;GET CAPABILITIES
	ANDCB	T2,JBTPRV##(J)	;GET BITS HE CAN'T GET
	TDNE	T1,T2		;TRYING TO SET BITS HE CAN'T HAVE?
	PUSHJ	P,PRVJ		;YES, BUT SEE IF PRIVILEGED
	  SKIPA			;OK TO SET BITS
	JRST	ECOD0##		;LOSE, ERROR RETURN
	MOVEM	T1,JBTPRV##(J)	;SET NEW PRIVILEGE WORD
	JRST	STOTC1##	;AND STORE FOR USER TO SEE

SCAPOF:	ANDCAB	T1,.PDCAP##(W)	;CLEAR REQUESTED BITS
	JRST	STOTC1##	;AND RETURN RESULT

SCAPON:	IOR	T1,.PDCAP##(W)	;INCLUDE BITS ALREADY OWNED
SCAPWD:	SETCM	T2,.PDCAP##(W)	;GET BITS HE CAN'T SET
	TDNE	T1,T2		;NOT SETTING ANY NEW BITS?
	PUSHJ	P,PRVJ		;OR IS PRIVILEGED USER?
	  SKIPA			;YES, OK
	JRST	ECOD0##		;NO, LOSES
	MOVEM	T1,.PDCAP##(W)	;SET NEW CAPABILITY WORD
	JRST	STOTC1##	;AND GIVE TO USER
;HERE FOR COMMANDS TO ENABLE OR DISABLE PRIVILEGES.
;ONLY THE WHOLE WORD CAN BE MODIFIED NOW.

DISABL::SETZM	JBTPRV##(J)	;CLEAR WORD
	POPJ	P,		;AND RETURN.

ENABLE::MOVE	T1,.PDCAP##(W)	;GET CAPABILITIES
	IORM	T1,JBTPRV##(J)	;ADD TO PRIVILEGE WORD
	POPJ	P,		;DONE
	SUBTTL	SET COMMAND AND UUO -- CDR

;ENTER HERE ON SET CDR UUO
SETSPI:	HRLOS	T2		;GET NAME, -1
	AOS	(P)		;AND SKIP COMMAND ENTRY AND FORCE SUCCESS RETURN
	JRST	SETCD2
;SET CDR COMMAND
SETCDR::PUSHJ	P,CTEXT1	;GET FILE NAME
	JUMPE	T2,NOTENF	;NONE SPECIFIED
	TRNE	T2,-1		;MORE THAN 3 CHARACTERS?
	JRST	COMERA		;YES. NO GOOD.
SETCD2:	HLLM	T2,JBTSPL##(J)	;SAVE NAME
	POPJ	P,		;AND RETURN



;HERE TO SET SPOOL BITS BY UUO
SETSPB:	SETCM	T3,T2		;-BITS HE WANTS ON
	ANDI	T3,.SPALL
	TDNN	T3,JBTSPL##(J)	;CLEARING SOME BITS FROM JBTSPL?
	JRST	SETSPC		;NO - OK
	MOVSI	T1,PVNSPL	;PRIV?
	TSNN	T1,STATES##	;OR SCHED BIT?
	PUSHJ	P,PRVBIT	;GO SEE
;NOTE THIS CODE DEPENDS ON PVNSPL=ST.NSP
IFN PVNSPL-ST.NSP,<PRINTX ST.NSP DOESN'T=PVNSPL>
	  JRST SETSPC		;YES. GO DO IT.
	JRST	ECOD0##		;NO. FAILURE RETURN
SETSPC:	DPB	T2,[POINT 5,JBTSPL##(J),35]	;YES, DO IT
	JRST	CPOPJ1##	;SUCCESS RETURN
>	;END CONDITIONAL ON FTSPL
;STILL IN CONDITIONAL ON FTSET
DSKSIL::PUSHJ	P,SETLGL	;LEGAL?
	  JRST	COMERA		;NO
	PUSHJ	P,CTEXT1	;YES, GET DRIVE NAME
	MOVE	T1,T2		;INTO T1
	CAMN	T2,[SIXBIT 'PDP11']	;DOES HE WANT TO STOP PDP-11 MESSAGE?
	PJRST	D76SIL##	;YES--GO SHUT HIM UP

	PUSHJ	P,TPMSIL##	;SEE IF A TAPE KONTROLLER
	  PJRST	CPOPJ1##	;YES - EXIT
IFN FTDBAD,<
	PUSHJ	P,DSKQUI##	;STOP MESSAGES FOR THIS DRIVE
	  JRST	COMERA		; NO SUCH UNIT, OR WRONG STATUS
	PJRST	CPOPJ1##	;OK
>
IFE FTDBAD,<
	JRST	COMERA
>
	SUBTTL	SET COMMAND AND UUO -- DISK STUFF

IFN FTDPRI,<
;SET DSKPRI N
DSKPRI::TLZA	P4,-1		;CLEAR LH(P4)
DSKPR2:	TLO	P4,-1		;MINUS, SET LH(P4)=-1
	PUSHJ	P,SKIPS		;GET FIRST CHAR
	  JRST	NOTENF
	CAIN	T3,"-"		;-?
	JUMPE	T2,DSKPR2	;YES, SET LH(P4), TRY AGAIN
	PUSHJ	P,DECIN1	;NO, GET THE NUMBER
	  JRST	NOTENF
	  JRST	COMERA
	SKIPGE	P4		;- SEEN?
	MOVNS	T2		;YES
	PUSHJ	P,PRICOM##	;CALL FILSER TO CHECK PRIUS
	  SKIPA
	POPJ	P,
>
IFN FTDPRI!FTHPQ,<
PRIERR::JSP	T1,ERRMES
	ASCIZ	/No privileges to set priority that high
/
>;END FTDPRI!FTHPQ
;SET DSKFUL PAUSE (ERROR)
FULSTP::PUSHJ	P,CTEXT
	MOVE	T1,[-2,,STPNST]	;LOOK AT ARGUMENT
	PUSHJ	P,FNDNAM
	  PJRST	COMERA
STPSET:	MOVEI	T2,JS.SFL
	XCT	STPXCT(T1)	;TURN THE PAUSE-BIT ON OR OFF
	PJRST	CPOPJ1##
STPNST:	SIXBIT	/PAUSE/
	SIXBIT	/ERROR/
STPXCT:	IORM	T2,JBTSTS##(J)
	ANDCAM	T2,JBTSTS##(J)
;SET DSKFUL UUO (0=PAUSE, 1=ERROR, OTHER=READ)
DSKFUL:	CAILE	T2,1		;SETTING?
	JRST	DSKFU1		;NO
	MOVE	T1,T2		;YES, T1=FUNCTION
	JRST	STPSET		;GO SET OR CLEAR THE BIT
DSKFU1:	MOVEI	T2,JS.SFL	;READING THE BIT
	TDNE	T2,JBTSTS##(J)	;IS HE SET TO PAUSE?
	TDZA	T1,T1		;NO - 0
	MOVEI	T1,1		;YES - 1
	PJRST	STOTC1##	;STOTAC, THEN CPOPJ1
;UUO TO SET PROGRAM TO RUN
SETPGM:	PUSHJ	P,PRVJ		;PRIV'D JOB?
	  JRST	SETPG1		;YES, ALLOW IT
	MOVE	T3,JBTLIM##(J)
	TLNN	T3,(JB.LBT)	; IN A BATCH JOB?
	TLNN	T3,(JB.LSY)	;FROM SYS: ?
	JRST	ECOD0##		;NO, ERROR
SETPG1:	HRR	M,T2		;COPY ADDRESS
	PUSH	P,J
	PUSHJ	P,GETWDU##	;GET THE WORD
	MOVE	J,(P)
	MOVEI	T2,JS.RPC	;CLEAR BIT
	ANDCAM	T2,JBTST2##(J)	; ..
	SKIPGE	T1		;WANT IT SET?
	IORM	T2,JBTST2##(J)	;YES
	PUSHJ	P,GETWD1##	;GET NAME
	POP	P,J
	PUSHJ	P,FNPDBS##
	MOVEM	T1,.PDPGM##(W)
	JRST	CPOPJ1##
	SUBTTL	SET COMMAND AND UUO -- ROUTINE TO READ DATE

;GTDATE-ACCEPTS DATE IN FORM 21-JAN-72 OR
;	JAN-21-72 OR 5-JAN OR JAN-5 GIVING
;	CREATION YEAR AS DEFAULT
;	STORES YEAR (E.G. 1972), MONTH (1-12), DAY (1-31) IN 3 WORD
;	VALVE BLOCK POINTED TO BY T1.
;
;CALL	T1:=ADDRESS
;	PUSHJ	P,GTDATE
;	ERROR, RETURN
;	SUCCESS RETURN


GTDATE::PUSHJ	P,SAVE2##	;SAVE POINTER
	MOVEI	P1,2		;SET LOOP COUNT
	MOVE	P2,T1
	SETZM	1(P2)		;NO MONTH TYPED YET
DATE01:	PUSHJ	P,CTEXT		;READ NEXT ARGUMENT
	MOVE	T1,[-MLEN,,MONTHS]
	PUSHJ	P,FNDNAM	;SCAN FOR A MONTH
	  JRST GTDAY
	ADDI	T1,1		;FORM MONTH INDEX
	MOVEM	T1,1(P2)	;STORE MONTH
	SOJG	P1,DATE01	;LOOP IF DAY NEXT
	JRST	GTYEAR

GTDAY:	JUMPN	T1,CPOPJ##	;ERROR, AMBIGOUS MONTH
	SETZM	T3		;CLEAR FOR SUM
DATE02:	SETZ	T1,
	LSHC	T1,6		;GET NEXT DIGIT
	JUMPE	T1,DATE03	;DONE, IT 0
	TRC	T1,20		;FORM OCTAL REPRESENTATION
	CAILE	T1,^D9
	POPJ	P,		;NOT A DIGIT
	IMULI	T3,^D10
	ADDI	T3,(T1)		;FORM SUM
	JRST	DATE02
DATE03:	SKIPN	1(P2)		;IF NO MONTH WAS TYPED,
	MOVEM	T3,1(P2)	; STORE IT AS MONTH ALSO SO OLD FORMAT WILL WIN
	MOVEM	T3,2(P2)	;STORE DAY
	SOJG	P1,DATE01	;LOOP IF MONTH NEEDED
GTYEAR:	PUSHJ	P,DECIN		;GET YEAR (IF TYPED)
	  SKIPA	T2,MONYER	;CREATION YEAR IF MONITOR
	  POPJ	P,		;BAD TERMINATOR
	CAIGE	T2,^D100	;IF JUST 2 CHAR'S TYPED
	ADDI	T2,^D1900	;  ADD 1900
	MOVEM	T2,(P2)		;STORE YEAR
	JRST	CPOPJ1##	;SUCCESS
DEFINE	.MONTH	(A),
	<IRP A
	<SIXBIT/A/>>

MONTHS:	.MONTH<JANUAR,FEBRUA,MARCH,APRIL,MAY,JUNE,JULY,AUGUST,SEPTEM,OCTOBE,NOVEMB,DECEMB>

MLEN==.-MONTHS
MONYER:	M.YEAR##		;YEAR OF MONITOR CREATION
	SUBTTL	SET COMMAND AND UUO -- ROUTINES TO PRINT WATCH INFO

;SUBROUTINE TO PRINT TIME OF DAY USER STARTS TO WAIT FOR RESPONSE
; IF HE HAS ENABLED IT WITH "WATCH DAY"
;CALL:	MOVE J,JOB NO.
;	PUSHJ P,WCHBEG
;	ALWAYS RETURN HERE

;THIS SUBROUTINE IS ALWAYS CALLED FROM THE COMMAND DECODER
;WHEN USER IS ABOUT TO WAIT FOR A RESPONSE

IFN FTWATCH,<

WCHBEG:	MOVE	T2,JBTWCH##(J)
	MOVE	T1,TIME##	;TIME OF DAY IN JIFFIES
	TLNE	T2,JW.WWT
	DPB	T1,JBYWCH##	;STORE FOR JOB
	TLNN	T2,JW.WDY	;DOES USER WANT TO SEE THIS?
	POPJ	P,		;NO.
	PUSHJ	P,PRLBK		;YES, PRINT LEFT BRACKET
	MOVE	T1,TIME##	;TIME OF DAY IN JIFFIES
	PUSHJ	P,PRTIM		;PRINT HH:MM:SS(NO CRLF)
				;FALL INTO PRRBKC
;SUBROUTINE TO PRINT RIGHT BRACKET,CRLF
>	;END FTWATCH

PRRBKC::PJSP	T1,CONMES
	ASCIZ	/]
/
;SUBROUTINE TO PRINT LEFT BRACKET


PRLBK::	PJSP	T1,CONMES
	ASCIZ	/[/

;SUBROUTINE TO PRINT RIGHT BRACKET


PRRBK::	PJSP	T1,CONMES	;PRINT AND RETURN
	ASCIZ	/]/
;SUBROUTINE TO PRINT SYSTEM RESPONSE STATISTICS EACH TIME
;USER FINISHES WAITING FOR SYSTEM
;PRINT INCREMENTAL RUN TIME, WAIT TIME, # DISK BLKS READ, #DISK BLKS WRITTEN
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,WCHEND
;	ALWAYS RETURN HERE

IFN FTWATCH,<

WCHEND:	MOVSI	T1,JW.WRN!JW.WWT!JW.WDR!JW.WDW	;USER WANT ANY RESPONSE DATA?
	TDNN	T1,JBTWCH##(J)	; ..
	POPJ	P,		;NO.
	PUSHJ	P,SAVE1##	;SAVE P1
	PUSHJ	P,PRLBK		;YES, PRINT LEFT BRACKET
	PUSHJ	P,FNPDBS##	;FIND PDB ADDRESS. HALT IF NONE
	MOVSI	P1,-WCHLEN	;LOOP THRU ALL RESPONSE DATA ITEMS
WCHLOP:	HLLZ	T1,WCHTAB(P1)	;GET BIT ASSOCIATED WITH THIS FIELD
	TDZE	T1,JBTWCH##(J)	;DOES USER WANT TO WATCH IT?
	PUSHJ	P,@WCHTAB(P1)	;YES, PRINT IT OUT
	AOBJP	P1,WCH1		;FINISHED ALL FIELDS?
	PUSHJ	P,PRSPC		;NO, PRINT A SPACE
WCH1:	JUMPL	P1,WCHLOP	;LOOP IF MORE BITS TO CONSIDER
	PJRST	PRRBKC		;APPEND RIGHT BRACKET, CRLF, AND RETURN

;TABLE OF ROUTINES TO PRINT RESPONSE DATA

WCHTAB:	XWD	JW.WRN,PRTWRN	;PRINT RUN TIME
	XWD	JW.WWT,PRTWWT	;PRINT WAIT TIME

IFN FTDSTT,<
	XWD	JW.WDR,PRTWDR##	;PRINT # DISK BLOCKS READ
	XWD	JW.WDW,PRTWDW##	;PRINT # DISK BLOCKS WRITTEN
>
				;ADD NEW DATA HERE
WCHLEN==.-WCHTAB
>	;END FTWATCH
;ROUTINE TO PRINT INCREMENTAL RUNTIME(NO CRLF)
;CALL:	MOVEI T1,0
;	PUSHJ P,PRTWRN

IFN FTWATCH,<

PRTWRN:	.EXCH	T1,.PDRTM##(W)	;CLEAR INCREMENTAL RUN TIME
	PJRST	PRTIM		;PRINT AS HH:MM:SS, MM::SS OR SS.HH (NO CRLF)

;ROUTINE TO PRINT WAIT TIME (NO CRLF)
;CALL:	PUSHJ P,PRTWWT


PRTWWT:	LDB	T1,JBYWCH##	;TIME OF DAY USER STARTED TO WAIT
	SUB	T1,TIME##	;-CURRENT TIME OF DAY = -WAIT TIME
	SKIPLE	T1		;IS IT REALLY MINUS?
	SUB	T1,MIDNIT##	;NO. MUST HAVE BEEN WAITING ACROSS MIDNIGHT
				; SO SUBTRACT A DAY TO GET IT NEGATIVE
	MOVNS	T1		;NOW MAKE IT PLUS WAIT TIME
	PJRST	PRTIM		;TYPE OUT TIME (NO CRLF)
>				;END FTWATCH


IFN FTWATCH,<
SETWTU:	HLRZ	T1,JBTWCH##(J)	;GET CLOCK OVERFLOW
	ANDI	T1,77		;(ENOUGH FOR 24.*60.*60.*60.)
	TRZ	T2,77		;CLEAR REQUEST JUNK
	IOR	T2,T1		;INCLUDE OVERFLOW
	HRLM	T2,JBTWCH##(J)	;SAVE WATCH BITS
	JRST	CPOPJ1##	;AND RETURN
>
MTADEN::PUSHJ	P,MTFIND	;GET THE REST OF COMMAND AND FIND MTA DDB
	  JRST	COMERR		;NOT NUMERIC
	MOVE	T1,[-DNTBLN,,DENTAB]
	MOVE	T3,0(T1)	;GET ENTRY FROM TABLE
	CAIE	T2,(T3)		;MATCH?
	AOBJN	T1,.-2		;NO - TRY NEXT
	JUMPGE	T1,COMERA	;ERROR IF NONE FOUND
	HLRZ	T1,T3		;GET CODE
	MOVEI	T3,TUCD20##	;Bit position of lowest density
	LSH	T3,-1(T1)	;Change density code into bit position
	HLRZ	T2,TDVUDB##(F)	;Get pointer to the UDB for this drive
	TDNE	T3,TUBCNF##(T2)	;Valid density for this drive?
	  JRST	MTADE1		;Yes, go put density in the DDB
	JSP	T1,ERRMES	;No, illegal density for this drive
				; so give user error message
	ASCIZ	\Illegal density for drive
\
MTADE1:	DPB	T1,TDYDN1##	;YES, STORE CODE IN DDB
IFN FTTLAB,<
	PUSHJ	P,SETODN##	;UPDATE DENSITY ON OTHER DDB
>
	JRST	CPOPJ1##	;RETURN (SKIP)

MTABLK::PUSHJ	P,MTFIND	;GET REMAINDER OF COMMAND AND FIND MTA DDB
	  JRST	COMERR		;NOT NUMERIC
	AOS	P2,T2		;COPY TO WHERE IT'S NEEDED
	PUSH	P,U		;SAVE U
	HLRZ	U,TDVUDB##(F)	;SET UP
	PUSHJ	P,TAPSBS##
	  SKIPA			;OUT OF RANGE
	JRST	UPOPJ1##	;DONE
	POP	P,U		;RESTORE U
	JRST	COMERR		;AND TELL USER
IFN FTDX10,<
MTARTY::PUSHJ	P,MTFIND	;GET REST OF COMMAND, SET UP F
	  HLRZS	T2		;NON-NUMERIC RETURN (NORMAL)
	MOVSI	T1,MTSNAR##	;NO AUTO-RECOVERY BIT
	CAIN	T2,'ON '	;CLEAR OR SET IF 'ON' OR 'OFF'
	JRST	[ANDCAM	T1,DEVIOS(F)
		 PJRST	CPOPJ1##]
	CAIE	T2,'OF '
	CAIN	T2,'OFF'
	JRST	[IORM	T1,DEVIOS(F)
		 PJRST	CPOPJ1##]
	JRST	COMERR		;NOT A LEGAL ARGUMENT
>
MTAMOD::PUSHJ	P,MTFIND	;GET REST OF COMMAND AND SET UP F
	  SKIPA	T1,[-MDTBLN,,MODTAB] ;SIXBIT ARGUMENT
	JRST	COMERR		;NUMERIC - LOSE
	PUSHJ	P,FNDNAM	;FIND THE ARGUMENT
	  JRST	COMERA		;SORRY, DON'T KNOW THAT ONE
	CAIE	T1,RB.MCD	;CORE-DUMP?
	JRST	MTAMD1		;NO
	HLRZ	T2,TDVUDB##(F)	;GET POINTER TO TUB
	MOVEI	T3,TUC7TK##
	TDNE	T3,TUBCNF##(T2)	;A 7-TRACK DRIVE?
	MOVEI	T1,RB.M7T	;YES. SET 7-TRACK CORE-DUMP
MTAMD1:	DPB	T1,TDYMD1##	;SAVE MODE IN DDB
	PJRST	CPOPJ1##	;AND TAKE GOOD RETURN

MTFIND:	TLO	M,CMWRQ##	;CAUSE SET COMMAND FORGETS
	PUSHJ	P,CTXDEV	;PICK UP DEVICE ARGUMENT
	SKIPE	T1,T2		;DEVSRG EXPECTS NAME IN T1
	PUSHJ	P,DEVSRG##	;SEARCH FOR DDB
	  PJRST MTFERR		;NO SUCH DEVICE
	LDB	T1,PJOBN##	;GET OWNER'S JOB NUMBER
	CAME	T1,J		;US?
	  PJRST MTFERR		;NO, LOSE!
	MOVE	T1,DEVMOD(F)
	MOVE	U,TTYTAB##(J)	;RESTORE U
	HRRZ	U,DDBLDB##(U)
	TLNN	T1,DVMTA	;IS DEVICE A MAGTAPE?
	  PJRST COMERP		;NO, LOSE!
	PUSHJ	P,DECIN1	;GET LAST ARGUMENT
	  PJRST NOTENP		;NO ARGUMENT FOUND
	  PJRST	CTEXT1		;NOT NUMERICAL, READ SIXBIT
	JRST	CPOPJ1##	;RETURN.
MTFERR:	MOVE	U,TTYTAB##(J)	;TTY DDB
	HRRZ	U,DDBLDB##(U)	;LDB BACK INTO LINE
	PJRST	COMERP		;TYPE ERROR MESSAGE

;TABLE OF VALID DENSITIES

DENTAB:	RB.D2,,^D200
	RB.D5,,^D556
	RB.D8,,^D800
	RB.D16,,^D1600
	RB.D62,,^D6250
DNTBLN==.-DENTAB

MODTAB:	SIXBIT	/SYSTEM/	;SYSTEM DEFAULT
	SIXBIT	/DUMP/		;CORE DUMP
	SIXBIT	/BYTE/		;BYTE MODE
	SIXBIT	/SIXBIT/	;SIXBIT
	SIXBIT	/ANSI/		;ANSI-ASCII
	SIXBIT	/??????/	;PLACE MARKER FOR 7-TRACK CORE DUMP
	SIXBIT	/INDUST/	;INDUSTRY COMPATABLE
MDTBLN==.-MODTAB
	SUBTTL	CONTINUE, CCONT AND JCONT

; "CONTC" - CONTINUE EXECUTION(TTY REMAINS IN COMMAND MODE)

CONTC::				;SAME AS CONT

; "CONT" - CONTINUE EXECUTION FROM WHERE LEFT OFF

CONT::	JUMPE	J,STARTE	;COMPLAIN IF NO JOB
	LDB	T1,JBYDEB##	;DEFERRED ECHO BITS
	...DPB	T1,LDPDEB##	;RESTORE FOR CONTINUE
	TLNN	P4,JERR		;IS JOB ERROR BIT SET?
	JRST	CONT1		;COMMAND DECODER WILL DO THE REST
	JSP	T1,ERRMES	;YES, PRINT CANT CONTINUE

	ASCIZ	/Can't continue
/
CONT1:
IFN FTMP,<
	MOVE	T1,USRPC##	;PC
	TLNE	T1,(XC.USR)	;USER MODE?
	PJRST	DPXST##		;YES, MAKE RUNNABLE ON ALL CPUS
>
	POPJ	P,		;*** NO

;JOB CONTINUE COMMAND
;FORCES A CONTINUE COMMAND FOR JOB Y

JCONT::	PUSHJ	P,GETJOB	;GET JOB TO CONTINUE
	  JRST	NOTENF		;MUST HAVE ARGUMENT
	TRNN	T3,JDCON	;JOB WAITING FOR CONT?
	JRST	JCERR2		;NO
	CAMN	T2,J		;SEE IF FOR US
	PJRST	FCONT		;YES, GO DO IT
	MOVE	T1,T2		;GET JOB # IN CORRECT AC FOR FCONRQ
	PUSHJ	P,FCONRQ	;GO REQUEST CONT BE FORCED FOR JOB
	POPJ	P,		;RETURN - SUCCESSFUL
	PJRST	SNDBSI		;NOT ENTERED - GO TYPE "BUSY"
;STILL IN FTJCON CONDITIONAL
;CALLED TO SET UP FORCED COMMAND FOR JOB CONTINUE
;JOB NUMBER IN T1
;SKIP RETURN IF COMMAND WAS NOT ENTERED BECAUSE ALREADY A
;FORCED COMMAND PENDING


FCONRQ::MOVEI	T2,TTFCXJ##	;INDEX FOR FORCED CONTINUE
;SUBROUTINE TO FORCE COMMAND
;ARGS	T1=JOB NUMBER
;	T2=INDEX OF FORCED COMMAND


COMFRC::PUSH	P,U		;SAVE THIS AC
	PUSH	P,J		;SAVE THIS JOB NUMBER
	MOVE	J,T1		;GET HIS JOB NUMBER
	PUSHJ	P,TTYSRC##	;SET UP LINE (LDB)
	  JRST	JCONDM		;SEE IF ATTACHED
	JRST	COMFR2
COMFRL::PUSH	P,U		;SAVE ACS
	PUSH	P,J
COMFR2:	JUMPE	U,JCONDM	;CAN'T FORCE TO DETACHED LINE.
	MOVSI	T1,LDBCMF##	;ANY FORCED COMMAND
	SCNOFF
	TDNE	T1,(U)		;FOR THIS JOB ALREADY
	JRST	JCONDL		;YES
	DPB	T2,LDPCMX##	;STORE COMMAND INDEX
	MOVSI	T1,LDBCMR##+LDBCMF## ;BITS FOR FORCE
	PUSHJ	P,COMSTF##	;WAKE COMCON (RETURNS WITH SCAN ON)
	POP	P,J		;RESTORE JOB
	PJRST	LPOPJ##		;RETURN

;HERE IF JOB ALREADY HAS FORCED COMMAND PENDING, DELAY THIS COMMAND

JCONDL:	SCNON
JCONDM:	POP	P,J		;RESTORE JOB NUMER
	JRST	LPOPJ1##	;CAN'T ENTER - SKIP RETURN
;HERE IF JOB NOT WAITING FOR CONTINUE

JCERR2:	JSP	T1,ERRMES
	ASCIZ	/Job not waiting/


;FORCED CONTINUE COMMAND
;NO TTY OUTPUT UNLESS COMMAND IS REALLY EXECUTED - IT WILL NOT BE
; IF USER HAS TYPED A COMMAND IN THE MEAN TIME.

FCONT::	MOVE	P4,JBTSTS##(J)	;GET JOB STATUS
	TLNN	P4,JERR		;CAN WE CONTINUE
	TRNN	P4,JDCON	;IS JOB WAITING
	POPJ	P,
	TLO	M,TTYRNW##	;SET FOR RESCHEDULE
	TLZ	M,NOCRLF##!NOMESS## ;RESET NOMESS
	PUSHJ	P,INLMES	;TELL USER HE'S CONT
	ASCIZ	/Cont by opr/
	POPJ	P,
	SUBTTL	CORE COMMAND

; "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
; "CORE" WITH NO ARG. WILL PRINT NO OF FREE BLOCKS LEFT
;	WITHOUT AFFECTING CURRENT ASSIGNMENT OF CORE
;	JOB NOT IN MIDDLE OF SWAPPING
;	EITHER ON DISK OR CORE OR NEITHER PLACE



CORE::	PUSHJ	P,CORARG	;GET HIGHEST RELATIVE ADDRESS USER SPECIFIED
	JRST	COR3		;NO ARG. SPECIFIED, JUST TYPE FREE BLOCK LEFT
	JUMPL	P4,[MOVEI T1,RUNERR	;RUNNING?
		JRST ERRMES]	;YES, LOOSE
	JUMPE	T1,COR5		;RELEASE DEVICES IF USER ASKING FOR 0 CORE
	TRNE	P4,JS.XO!JS.RUU	;SEE IF EXECUTE ONLY
	PJRST	ILLXO		;YES -- GO GIVE ERROR
	SKIPLE	T2,JBTSGN##(J)	;GET HI SEG # IF ANY
	JUMPG	T2,COR4		;YES - GO COMPUTE LO SEG SIZE
				;RETURN WITH HIGHEST REL. ADDR. OF LO SEG
COR5:	PUSH	P,T1
	SKIPE	T1
	SKIPN	JBTADR##(J)
	PUSHJ	P,GETMIN
	POP	P,T1
	JUMPE	T1,COR0
	SKIPE	JBTADR##(J)	;IF DIDN'T GET CORE IN CORE.
	JRST	COR5A
	LDB	T2,IMGOUT##	; DID!WE GET CORE ON DSK?
	JUMPE	T2,COR2		;ERROR IF NONE
	JRST	DLYCM
COR5A:
IFE FTMP,<
	PUSHJ	P,CORE0##	;TRY TO ASSIGN CORE (NONE OR SPY)
	  JRST	COR2		;CORE NOT AVAILABLE, GO PRINT MESSAGE
>
IFN FTMP,<
	PUSHJ	P,GETMM##	;GET THE MM
	  JRST	DLYCM		;NOT AVAILABLE, DELAY
	PUSHJ	P,CORE0##	;GET CORE
	  JRST	[PUSHJ P,GIVMM## ;NONE AVAILABLE
		 JRST COR2]
	PUSHJ	P,GIVMM##	;GIVE UP THE MM.
>
	LDB	T1,PJBSTS##
	CAIE	T1,NULQ##	;IN THE NO CORE Q?
	POPJ	P,		;NO
	MOVEI	T1,STOPQ##	;YES, OK RETURN, CORE ASSIGNED ON DISK OR MEMORY
	...DPB	T1,PJBSTS##	;PUT JOB IN THE STOP Q SINCE IT NOW HAS CORE
	PJRST	REQUE##
COR4:	HLRZ	T2,JBTADR##(T2)	;GET HI SEG SIZE
	SUBI	T1,1(T2)	;COMPUTE LO SEG SIZE
	JUMPGE	T1,COR5		;OK RETURN
	PUSHJ	P,INLMES	;TOO SMALL AN ARG.
ASCIZ	/?Try larger arg.
/

COR2:	MOVE	U,-1(P)		;RESTORE TTY LDB ADDRESS
	PUSHJ	P,PRQM		;TYPE ? FOR BATCH
	PUSHJ	P,COR3
	TLO	M,ERRFLG##	;SET ERROR FLAG
	POPJ	P,
;HERE TO GIVE CURRENT CORE SIZE FOR VM USER
COR3:	PUSHJ	P,FNDPDS##	;FIND PDB FOR JOB
	LDB	T1,[POINT 10,.PDMVL##(W),17]	;GET MVPL
	JUMPE	T1,COR3B	;SKIP FIRST LINE IF ZERO
	MOVEI	T1,[ASCIZ "Virt. mem. assigned "]
	PUSHJ	P,CONMES	;PRINT TITLE
	PUSHJ	P,VMSIZE##	;GET SIZE OF JOB
	JUMPE	T2,[PUSHJ P,PRCORE	;IF JUST A LOWSEG
		    JRST  COR3A]; PRINT ONLY 1 NUMBER
	PUSH	P,T2		;SAVE SIZE OF HISEG
	PUSHJ	P,RADX10##	;PRINT SIZE OF LOWSEG
	PUSHJ	P,PRTPLS
	POP	P,T1		;SIZE OF HISEG
	PUSHJ	P,PRCORE	;PRINT THAT
COR3A:	HLRZ	T4,.PDCVL##(W)	;GET CVPL
	PUSHJ	P,PRCXPL	;PRINT THAT
	LDB	T4,[POINT 10,.PDMVL##(W),17]	;GET MVPL
	SKIPN	T4
	MOVEI	T4,1000
	PUSHJ	P,PRMXPL	;PRINT THAT
	PUSHJ	P,INLMES	;ADD ) CRLF
	ASCIZ	/)
/
COR3B:	PUSHJ	P,INLMES
	ASCIZ	/Phys. mem. assigned /
	PUSHJ	P,PRTSEG	;PRINT LOWSEG SIZE
	SKIPLE	JBTSGN##(J)	;SKIP IF NO HISEG
	PUSHJ	P,PRTHGH##	;PRINT SIZE OF HISEG
	PUSHJ	P,PRPORK	;PRINT P OR K
	HRRZ	T4,.PDCVL##(W)	;GET CPPL
	TRZN	T4,400000
	JRST	[PUSHJ P,PRCPGL
		 JRST  .+2]
	PUSHJ	P,PRCXPL	;PRINT IT
	MOVEI	T4,0
	MOVSI	P1,PHONLY
	PUSH	P,.PDCVL##(W)
	MOVEI	T1,400000
	ANDCAM	T1,.PDCVL##(W)
	PUSHJ	P,PRMXPL	;PRINT IT
	POP	P,.PDCVL##(W)
;CONTINUED ON NEXT PAGE
	PUSHJ	P,INLMES	;ADD NOISE WORDS
	ASCIZ	/)
Swap space left: /
	MOVE	T1,VIRTAL##	;GET THAT NUMBER
	PUSHJ	P,PRCORE	;PRINT IN RADIX 10
	PJRST	CRLF		;ADD IN A CRLF AND RETURN



;ROUTINE TO PRINT CURRENT AND MAX LIMITS

PRCPGL:	MOVEI	T1,[ASCIZ " (Guideline: "]
	JRST	PRXXPL
PRCXPL:	SKIPA	T1,[[ASCIZ " (Current limit: "]]
PRMXPL:	MOVEI	T1,[ASCIZ " Max limit: "]
PRXXPL:	PUSH	P,T4
	PUSHJ	P,CONMES	;PRINT THE TITLE
	PUSHJ	P,CORBND##	;GET MAX CORE
	LSH	T1,W2PLSH##	;IN PAGES
	SKIPN	(P)		;ANYTHING GIVEN?
	MOVEM	T1,(P)		;CHOOSE GOOD MAX
	POP	P,T1		;RESTORE NUMBER
PRCORE:	PUSHJ	P,RADX10##	;PRINT IN DECIMAL
	PJRST	PRPORK		;GIVE UNITS

;ROUTINE TO PRINT ACCOUNT STRING
CACCT::	MOVEI	T1,.PDACS##(W)	;ADDRESS OF USER'S ACCOUNT STRING
	PUSHJ	P,CONMES	;TYPE IT
	PJRST	PCRLF		;<CRLF>
	SUBTTL	CONTROL-T PRINTOUT
IFN FTWATCH,<

;SUBROUTINE TO PRINT A 1 TO 3 LINE USE STATUS REPORT
;CALLED FROM USESTAT COMMAND IT PRINTS A 1 LINE
; STATUS REPORT OF THE FORM:
;	INCREMENTAL DAY TIME
;	INCREMENTAL RUN TIME
;	INCREMENTAL DISK READS
;	INCREMENTAL DISK WRITES
;	PROGRAM NAME
;	CORE SIZE
;	JOB STATE
;	PC
;
USECOM::TLNN	P4,JNA		;IS THIS A JOB?
	PJRST	ATT4		;NO--SAY "NOT A JOB"
	MOVEI	T1,[ASCIZ 'Day: ']
	PUSHJ	P,CONMES
	PUSHJ	P,PRTWWT	;INCREMENTAL DAYTIME
	MOVE	T1,TIME##	;RESET THE TIMER FOR
	DPB	T1,JBYWCH##	; THE NEXT TIME
	MOVEI	T1,[ASCIZ ' Run: ']
	PUSHJ	P,CONMES
	MOVEI	T1,0		;CLEAR INCREMENTAL RUNTIME
	.EXCH	T1,.PDRTM##(W)	; AND PICK UP OLD RUN TIME
	PUSHJ	P,PRTIM		;PRINT THAT
	MOVEI	T1,[ASCIZ ' Rd:']
	PUSHJ	P,CONMES
	PUSHJ	P,PRTWDR##	;DISK READS
	MOVEI	T1,[ASCIZ ' Wr:']
	PUSHJ	P,CONMES
	PUSHJ	P,PRTWDW##	;DISK WRITES
	PUSHJ	P,PRSPC		;ANOTHER SPACE
	MOVE	T2,JBTPRG##(J)	;PROGRAM NAME
	PUSHJ	P,PRNAME##	;PRINT THE NAME
	PUSHJ	P,PRSPC		;ANOTHER SPACE
	PUSHJ	P,PRTSEG	;LOW SEG SIZE
	PUSHJ	P,PRTHGH##	;HIGH SEG SIZE
	PUSHJ	P,PRPORK	;PRINT P OR K
	PUSHJ	P,PRSPC		;ANOTHER SPACE
;STILL IN FTWATCH
	MOVSI	T2,'^C'		;ASSUME CONTROL-C STATE
	JUMPG	P4,USECM1	;JUMP IF TRUE
	LDB	T1,PJBSTS##	;PICK UP JOB STATE
	IDIVI	T1,3		;DIVIDE BY 3 TO GET WORD NUMBER
	IMULI	T2,^D12		;MULTIPLY REMAINDER BY 12 TO GET POSITION
	MOVE	T3,STSTBL##(T1)	;PICK UP ENTRY
	ROT	T3,(T2)		;GET CORRECT THIRD
	MOVSI	T2,777700	;ONLY LOOK AT TOP 12 BITS
	AND	T2,T3		;COPY STATE
USECM1:	PUSHJ	P,PRNAME##	;PRINT THAT
IFN FTLOCK,<
	MOVEI	T3,"&"		;ASSUME LOCKED
	TLNE	P4,NSWP		;SEE IF LOCKED
	PUSHJ	P,PRCHR		;YES, LOCKED
>;END IFN FTLOCK
	MOVEI	T3,"*"		;ASSUME CURRENT JOB
	PUSHJ	P,ANYCPU##	;ARE WE THE CURRENT JOB?
	  PUSHJ	P,PRCHR		;YES--PRINT *
	PUSHJ	P,PRSPC		;ANOTHER SPACE
	MOVSI	T2,'SW '	;ASSUME SWAPPED
	TLNE	P4,SWP		;IS JOB IN CORE?
	PUSHJ	P,[SKIPE JBTADR##(J)	;ANY PHYS MEM?
		   MOVSI T2,'SW*'	;YES--ADD * TO MEAN SWAPPING
		   PJRST PRNAME##]	;PRINT SW OR SW*
	MOVEI	T1,[ASCIZ ' PC:']
	PUSHJ	P,CONMES
	HRRZ	T1,JBTPC##(J)	;GET CURRENT PC
	PUSHJ	P,OCTPNT##	;PRINT PC IN OCTAL
	SKIPN	JBTADR##(J)
	JRST	USECM3
	MOVSI	T1,SWP		;BIT INDICATING SWAPPED OR BEING SWAPPED
	SKIPE	.UPMP+.UPVRT	;VIRTUAL?
	TDNE	T1,JBTSTS##(J)	;AND IN CORE?
	JRST	USECM3		;NO, SKIP THIS
	MOVEI	T1,[ASCIZ /
Faults - IW: /]
	PUSHJ	P,CONMES	;PRINT THE TEXT
	MOVE	T1,.UPMP+.UPVCT	;REPORT INCREMEMTAL IN WORKING SET FAULTS
	SUB	T1,.UPMP+.UPICT
	HRRZS	T1
	PUSHJ	P,RADX10##
	MOVEI	T1,[ASCIZ / NIW: /]
	PUSHJ	P,CONMES	;PRINT TEXT
	MOVE	T1,.UPMP+.UPVCT	;REPORT INCREMENTAL NOT IN WORKING SET FAULTS
	SUB	T1,.UPMP+.UPICT
	HLRZS	T1
	PUSHJ	P,RADX10##
	MOVE	T1,.UPMP+.UPVCT	;UPDATE INCREMENTAL STATISTICS
	MOVEM	T1,.UPMP+.UPICT
	MOVEI	T1,[ASCIZ / Virt core: /]
	PUSHJ	P,CONMES	;PRINT TEXT
	LDB	T1,[POINT 9,JBTVRT##(J),35]
	PUSHJ	P,PRCORE	;REPORT LOW SEGMENT VIRTUAL CORE
	PUSHJ	P,PRTPLS	;PRINT A PLUS SIGN
	LDB	T1,[POINT 9,JBTVRT##(J),26]
	PUSHJ	P,PRCORE	;REPORT HIGH SEGMENT VIRTUAL CORE
	MOVEI	T1,[ASCIZ / Page rate: /]
	PUSHJ	P,CONMES	;PRINT TEXT
	HLRZ	T3,JBTVRT##(J)	;GET THE JOBS PAGING INTERVAL
	SETZB	T1,T2		;ASSUME A RATE OF ZERO
	JUMPE	T3,USECM2	;JUMP IF THE RATE IS ZERO
	MOVEI	T1,RTUPS##	;COMPUTE THE JOBS PAGING RATE
	IDIVI	T1,(T3)
	IMULI	T2,^D100
	IDIVI	T2,(T3)
USECM2:	PUSH	P,T2		;SAVE THE REMAINDER
	PUSHJ	P,RADX10##	;PRINT THE RATE
	PUSHJ	P,PRPER		;AND A DOT
	POP	P,T1		;RESTORE THE REMAINDER
	MOVEI	T3,"0"		;ASSUME THE REMAINDER IS IN HUNDREDTHS
	CAIG	T1,^D9		;IS IT?
	PUSHJ	P,PRCHR		;YES, PRINT A LEADING ZERO
	PUSHJ	P,RADX10##	;AND PRINT DIGITS FOLLOWING THE DECIMAL PLACE
USECM3:	HLRZ	F,JBTPC##(J)	;GET DDB ADDRESS
	JUMPE	F,USECM5	;ALL DONE IF NO DDB
IFN FTMP,<
	DDBSRL			;LOCK DDB SEARCH
	MAP	T1,(F)		;MAP DDB ADDRESS
	PUSHJ	P,FLTCHK##	;STILL AROUND?
	  JRST	USECM4		;NO
>
	MOVE	T1,JBTSTS##(J)	;GET STATUS
	CAMLE	F,SYSSIZ##	;DDB IN THE MONITOR?
	TLNN	T1,SWP		;NO, IS THE JOB IN CORE?
	TRNA			;YES, PROCEED
	JRST	USECM4		;NO, DON'T TRY TO REPORT DEVICE INFO
	MOVE	T3,DEVMOD(F)	;GET DEVICE TYPE FOR TEST
	TRNE	T1,JS.XO	;EXECUTE ONLY?
	TLNN	T3,DVDSK!DVDTA	;AND DISK OR DECTAPE?
	SKIPA	T2,DEVIOS(F)	;NO, TYPE DDB INFO
	JRST	USECM4		;YES TO BOTH, SKIP DDB PRINTOUT
	MOVEI	T1,[ASCIZ "
Input"]
IFN FTNUL,<
	TLNE	T3,DVTTY	;IS IT A TTY?
	 TLNE	T3,DVDSK	;AND NOT NUL:?
>
IFE FTNUL,<
	TLNN	T3,DVTTY	;A TTY?
>
	  JRST	USECMA		;NO, GO DO NORMAL DEVICE
	TLNE	T2,TTYOUW##	;OUTPUT DIRECTION?
	MOVEI	T1,[ASCIZ "
Output"]
	JRST	USECMB		;TYPE THE MESSAGE
USECMA:	TLNE	T2,IO		;OUTPUT DIRECTION?
	MOVEI	T1,[ASCIZ "
Output"]
USECMB:	PUSHJ	P,CONMES	;PRINT THE TEXT
	MOVEI	T1,[ASCIZ " wait for "]
	PUSHJ	P,CONMES
	PUSHJ	P,PRTDDB	;PRINT FILE SPEC
	MOVE	T1,DEVMOD(F)	;GET DEVICE BITS
	TLNE	T1,DVDSK	;IS THIS A DISK?
	PUSHJ	P,DSKCTT##	;YES -- PRINT GOOD STUFF
	MOVE	T1,DEVMOD(F)	;IS THIS A
	TLNE	T1,DVMTA	; TAPE?
	PUSHJ	P,TPMCTT##	;YES--PRINT FILE & RECORD
USECM4:
IFN FTMP,<
	DDBSRU			;UNLOCK DDB
>
USECM5:	HRRZ	F,LDBDDB##(U)	;GET DDB ADDRESS
	MOVE	T1,LDBDCH##(U)	;GET DEVICE BITS FOR TTY
	TLNE	T1,LDLCOM##	;COMMAND LEVEL?
	TLZ	M,NOPER##	;YES--PRINT A PERIOD
	MOVSI	T2,LDBCMF##	;ALWAYS CALL TTYSTR IF
	TDNE	T2,LDBDDB##(U)	;USESTAT COMMAND (NOT ^T)
	TRNN	T1,LDROSU##	;CONTROL-O IN EFFECT
	TLZ	M,NOMESS##	;NO--CLEAR NOMESS##
	POPJ	P,0		;RETURN
>;END FTWATCH
;SUBROUTINE TO PRINT A FILESPEC FOR A DDB
;CALL WITH:
;	F = DDB ADDRESS
;	U = LDB ADDRESS (OR FIX COMTOA)
;	PUSHJ	P,PRTDDB
;	RETURN HERE
;
PGMMRG:	SKIPA	T1,[[ASCIZ/Merged /]]
PGMFIL::MOVEI	T1,[ASCIZ/ from /]
	SKIPE	F,USRJDA##+0	;SEE IF DDB AND GET ADDRESS
	TLNN	F,INPB		;WAS AN INPUT DONE?
	POPJ	P,		;NO
	PUSHJ	P,CONMES
PRTDDB::PUSHJ	P,SAVE1##	;SAVE P1
	MOVE	P1,DEVMOD(F)	;GET DEVICE TYPE BITS
	MOVE	T2,DEVNAM(F)	;GET DEVICE NAME
	HRRZ	T3,DEVUNI##(F)	;UDB POINTER
	JUMPE	T3,PRTDD1	;NO UNIT IF A KNOWN SEGMENT
	TLNN	P1,DVDSK	;IS THIS A DISK?
	JRST	PRTDD1		;NO
	SKIPN	T2,UNILOG##(T3)	;YES, PART OF STR?
	MOVE	T2,UNINAM##(T3)	;NO
PRTDD1:	PUSHJ	P,PRNAME##	;PRINT IT
	MOVEI	T3,":"		;ADD A COLON
	PUSHJ	P,PRCHR		; ..
	TLNN	P1,DVDSK!DVDTA	;FILE AND EXT?
	JRST	PRTDD2		;NO
	MOVE	T2,DEVFIL(F)	;GET FILE NAME
	JUMPE	T2,CPOPJ##	;PUNT IF NO NAME
	HLRZ	T3,DEVEXT(F)	;IS THIS A UFD
	TLNE	P1,DVDSK	;ON DISK
	CAIE	T3,'UFD'
	JRST	PRTDD3		;NO
	PUSHJ	P,PRTPPN	;YES -- PRINT FILE NAME AS [M,N]
	JRST	PRTDD4		;AND NOT SIXBIT
PRTDD2:
IFE FTTLAB,<POPJ	P,>	;RETURN
IFN FTTLAB,<
	TLNE	P1,DVMTA	;IS THIS A MAGTAPE?
	SKIPN	%SITLP##	;AND IS TAPE LABELER RUNNING?
	POPJ	P,		;NO TO EITHER--RETURN
	PUSH	P,U		;SAVE U
	HLRZ	U,TDVUDB##(F)	;SET UP TUB POINTER
	LDB	T1,TUYLTP##	;GET LABEL TYPE
	POP	P,U		;RESTORE U
	JUMPE	T1,CPOPJ##	;RETURN IF NOT A LABELED TAPE
	SKIPN	T2,DEVFIL(F)	;ELSE GET FILE NAME
	POPJ	P,		;UNLESS THERE ISN'T ONE
> ;END IFN FTTLAB
PRTDD3:	PUSHJ	P,PRNAME##	;PRINT IT
PRTDD4:	PUSHJ	P,PRPER		;ADD IN A DOT
	HLLZ	T2,DEVEXT(F)	;GET EXTENSION
	PUSHJ	P,PRNAME##	;PRINT IT
	TLNE	P1,DVDSK	;IS THIS THE DISK?
	SKIPN	T2,DEVPPN(F)	;FALL INTO PRTPPN IF PPN
	POPJ	P,		;ELSE RETURN
	PJRST	PRTPTH		;PRINT PATH
;ROUTINE TO TYPE A PATH WITH SFD'S IF NEEDED

PRTPTH::PUSHJ	P,PRTPP1	;PROJ, PROG PART OF PATH
	HRRZ	P1,DEVSFD##(F)	;PATH POINTER
	JUMPE	P1,PRTRBK	;IF NO SFD'S
	PUSH	P,[0]		;MARK END OF PATH
PRTPT1:	PUSH	P,NMBNAM##(P1)	;SAVE THE SFD NAME
PRTPT2:	HLRZ	P1,NMBPPB##(P1)	;BACK ONE LEVEL
	TRZN	P1,NMPUPT##	;NAME SHOULD BE OUTPUT?
	JUMPN	P1,PRTPT2	;NO, GET NEXT LEVEL IF NOT AT END
	JUMPN	P1,PRTPT1	;YES, SAVE NAME AND GET NEXT LEVEL
PRTPT3:	POP	P,T2		;RESTORE SFD NAME
	JUMPE	T2,PRTRBK	;IF END, TYPE RIGHT BRACKET AND RETURN
	PUSHJ	P,PRCOM		;PRINT COMMA
	PUSHJ	P,PRNAME##	;PRINT THIS SFD NAME
	JRST	PRTPT3		;LOOP OVER WHOLE PATH

PRTPPN::PUSHJ	P,PRTPP1
	PJRST	PRTRBK

PRTPP1:	PUSH	P,T2		;SAVE PPN
	MOVEI	T3,"["		;PRINT [
	PUSHJ	P,PRCHR
	HLRZ	T1,(P)
	PUSHJ	P,PRTDI8##	;PROJECT
	PUSHJ	P,PRCOM		;COMMA
	HRRZ	T1,(P)
	PUSHJ	P,PRTDI8##	;PROG
	JRST	T2POPJ##

PRTRBK:	MOVEI	T3,"]"
	PJRST	P,PRCHR
	SUBTTL	SAVE, SSAVE AND GET - COMMAND SETUP

; "SSAVE DEVICE:FILNAM.EXT [PROJ,R] CORE"
;WORKS LIKE SAVE, EXCEPT THAT HIGH SEG IS SAVED AS SHARABLE(EXT=SHR)
;INSTEAD OF NON-SHARABLE(EXT=HGH)


; "SAVE DEVICE:FILE-NAME[PROJ.,PROG.] CORE" - SAVES JOB AREA ON RETRIEVABLE DEVICE
;ONLY A SAVE OR A GET IN PROGRESS FOR EACH JOB
;NO ATTEMPT IS MADE TO SAVE DEVICE ASSIGNMENTS, AC'S, OR PC
IFN FTEXE,<
NSAVE::	TLO	S,NSRBIT	;SET FLAG FOR SAVE
NSSAVE::MOVSI	T1,(JS.EXE)	;GET EXE BIT
	IORM	T1,JBTST2##(J)	;SET IT IN JOB STATUS WORD
	JRST	SSAVE2		; AND CONTINUE AS BEFORE
>	;END OF IFN FTEXE

SAVEO::TLO	S,NSRBIT	;OLD SAVE
	JRST	SSAVE1
CSAVE::	TLO	S,NSRBIT	;SET FLAG FOR NON-SHARABLE EXT(HGH)

SSAVE::
IFN FTEXE,<
	MOVE	T1,CNFST2##	;CHECK CONFIG BIT FOR EXE FILE SAVES
	TRNE	T1,1B21		;IF ON,...
	JRST	NSSAVE		;... PROCEED AS IN "NSAVE"
>
SSAVE1::
IFN FTEXE,<
	MOVSI	T1,(JS.EXE)	;GET EXE BIT
	ANDCAM	T1,JBTST2##(J)	;CLEAR IT JUST FOR SAFETY
SSAVE2:	TLO	P1,GTSAV	;FLAG THAT DOING A SAVE
>;END OF IFN FTEXE
	HRRI	S,SAVJOB	;SETUP TO RUN SAVJOB (S CLEARED BEFORE CALL)
	JRST	SGSETD


IFE FTEXE,< USAVE==:CPOPJ##>
IFN FTEXE,<

; SAVE UUO - CALLED LIKE RUN AND GETSEG UUOS

USAVE::	MOVE	T2,JBTSTS##(J)	;GET JOB STATUS
	TLNE	T2,JLOG		;LOGGED IN?
	 JRST	USAVE1		;YES, OK
	MOVEI	T1,NLIERR	;NOT LOGGED IN ERROR
	PUSHJ	P,SGRELE	;TRY TO TELL USER
	MOVEI	T1,LOGPLM	;ADDRESS OF ERROR TEXT
	JRST	PHOLD##		;START TTY AND STOP JOB
USAVE1:	MOVSI	T2,(JS.EXE)	;EXE-STYLE SAVE BIT
	IORM	T2,JBTST2##(J)	;SET FOR THIS USER
	TLO	P1,GTSAV	;DON'T KILL HISEG IF GETARG ABORTS
	PUSHJ	P,GETARG	;GET USER'S ARGUMENTS
	MOVE	T1,DEVMOD(F)	;GET DEVICE TYPE
	TLNN	T1,DVDSK	;IS IT A DISK?
	JRST	[MOVEI T1,ILUERR	;GET ERROR CODE
		 PUSHJ P,SGRELE	;TRY TO TELL USER
		 PJSP T1,PHOLD##	;GIVE UP
		 ASCIZ\SAVE. UUO only valid for disks\]
IFN FTNUL,<
	TLNE	T1,DVTTY	;IS IT NUL?
	JRST	[POP P,(P)	;POP OFF JUNK
		 JRST CPOPJ1]	;AND GIVE GOOD RETURN
>	;END IFN FTNUL
	GETPC	T1,.JDAT+JOBPD1## ;GET UUO RETURN ADDR
	TRNN	T1,^-17		;FROM THE ACS?
	 HRRZS	.JDAT+JOBPD1##	;YES, SAY NOT FROM USER
IFN FTMP,<
	PUSHJ	P,CLRJSP##	;ENSURE MONITOR RUNS ON MASTER CPU
>
	OPEN	0,SGAMOD	;OPEN THE SPECIFIED DEVICE
	 JRST	SGERRU		;DEVICE WENT AWAY
	SKIPL	.JDAT+JOBPD3##+IFN FTKLP,<1>	;DID USER SPECIFY SHARABLE?
	 TLO	S,NSRBIT	;NO, MAKE IT NONSHARABLE
	MOVEI	T2, 'EXE'	;GET THE LEGAL EXTENSION
	HRLM	T2,.JDAT+SGAEXT	;STORE IN ENTER BLOCK
	PUSHJ	P,SETEXT##	;AND SET UP SGALOW AND SGAHGH
	MOVE	T1,['SAVUUO']	;WHAT WE'RE DOING
	MOVEM	T1,.UPMP+.UPUAC+4 ;FOR THOSE WHO CARE
	GETPC	T1,.JDAT+JOBPD1## ;OUR NOMINAL RETURN ADDR
	MOVEM	T1,.UPMP+.UPUAC+6 ;SALT IT AWAY
	TLNN	T1,USRMOD	;WILL WE EVER RETURN?
	 JRST	USAVE2		;NO, SO SKIP THIS
	PUSH	P,.UPMP+.UPTMI	;SAVE SOME VM LOCS
	PUSH	P,.UPMP+.UPTMC
USAVE2:	HLRZ	T1,JBTADR##(J)	;GET HIGHEST ADDRESS IN LOW SEG
	HRRZS	T2,.JDAT+SGANEW	;CLEAR JUNK FROM LH (FOR COMPATABILITY)
	CAMGE	T1,T2		;COMPARE WITH USER STORED CORE ARG
	MOVE	T1,T2		;USER'S WAS LARGER, USE IT
	HRRM	T1,.JDAT+JOBCOR##	;AND SET UP JOBCOR.
	PUSHJ	P,RMVPFH##	;GET RID OF PFH
	PUSHJ	P,ADJCOR##	;SET UP GOOD CORE ARG
	PJRST	SAVEXE		;GO SAVE A FILE
>	;END OF IFN FTEXE
; "GET DEVICE:FILE-NAME[PROJ.,PROG.] CORE" - SETS UP JOB AREA FROM RETREIVABLE
;DEVICE AND ASSIGNS CORE.


GET::	HLLZ	T2,SYSTAP##	;SETUP DEFAULT DEVICE
	MOVEI	S,GJOB		;SETUP TO RUN GETJOB
	JRST	RUNCM
				; JOB DATA AREA FOR MONITOR JOB

LOGREF:	PUSHJ	P,ISOPCT	;SKIP IF OPR OR CTY
	  JRST	CLOG2A		;NO, REGULAR LOGIN
	SETZM	REFLAG##	;ONLY ONCE
	TDZA	T2,T2
LOGRF1:	MOVE	T2,[SIXBIT/SYSJOB/]
	MOVEM	T1,JBTPPN##(J)	;PRJ,PRG NRS. IN REFLAG
ifn stupid,<
	movem	t1,jbtlpn##(J)	;Remember to set up logged-in PPN too.
>;ifn stupid
	MOVEM	T2,.PDNM1##(W)
	PUSHJ	P,SETLOG##	;TURN ON JLOG
	HRROS	JBTPRV##(J)	;GIVE OPERATOR ALL DEC PRIVILEGES
	HRROS	.PDCAP##(W)	;...
	TLZ	M,-1		;CLEAR ALL FLAGS FOR COMRET
	MOVEI	T1,ACTSTL##	;LENGTH OF THE ACCOUNT STRING
	JUMPE	T1,LOGRF2	;ALL DONE, IF NONE
	HRRZ	T2,JBTPDB##+0	;NULL JOBS PDB
	MOVSI	T2,.PDACS##(T2)	;ADDRESS OF THE DEFAULT A.S.
	HRRI	T2,.PDACS##(W)	;ADDRESS OF JOBS A.S.
	BLT	T2,.PDACS##+ACTSTL##-1(W) ;FILL IN THE DEFAULT

LOGRF2:	MOVE	T1,[1000,,1000]	;MVPL,,MPPL
	PJRST	SETVLM##	;SET THEM

;SUBROUTINE TO CHECK IF LINE POINTS TO OPR OR CTY
;SAVES T1, USES T2
;RETURNS NONSKIP IF NOT OPR OR CTY, SKIP IF EITHER OPR OR CTY


ISOPCT:	HRRZ	T2,U		;T2=ADDR OF LINE DATA BLOCK
	CAMN	T2,OPRLDB##	;SKIP IF NOT OPR
	JRST	CPOPJ1##	;YES, IT IS OPR
	MOVE	T2,LDBDCH##(T2)	;T2=LINE CHARACTERISTICS
	TRNN	T2,LDRCTY##	;SKIP IF CTY
	POPJ	P,		;NO, NEITHER OPR NOR CTY
	JRST	CPOPJ1##	;YES, IT IS CTY
	SUBTTL	COMMANDS WHICH RUN PROGRAMS

MNTCOM::
IFN FTMDA,<
	SKIPN	%SIDOL##	;MDA RUNNING?
	JRST	RECALL		;NO. RUN UMOUNT
RUNMDA::MOVE	T1,[SIXBIT/MOUNT/]
	JRST	ARCOM
>
;FOR REMOTE USAGE OF FILE STORAGE SYSTEM
RECALL::SKIPA	T1,[SIXBIT .UMOUNT.]	;RUN UMOUNT
;IFE FTCCLX,<
;RECALL==COMERR
;>

CCLRUN::MOVE	T1,COMPIL##	;CUSP NAME
	JRST	ARCOM		;RUN IT


;"LOGIN" - LOGIN COMMAND

LOGDET:	JSP	T1,ERRMES
	ASCIZ	/Please KJOB or DETACH
/

CLOGIN::TLNE	P4,JLOG		;FORCE USER TO LOGOUT BEFORE
	JRST	LOGDET		; LOGGING IN ANEW.
	MOVE	T1,VIRTAL##	;AMOUNT OF FREE VIRTUAL CORE LEFT
	CAIGE	T1,LOGSIZ##	;IS THERE AT LEAST ENOUGH FOR LOGIN?
				; CUSTOMER CAN REDEFINE TO BE BIGGER THAN 2
				; WITH MONGEN DIALOG
	JRST	COR2		;NO--GO TELL USER AMOUNT OF CORE LEFT

	MOVE	T1,FFAPPN##	;1,2 IF LOGGING IN
	LDB	T2,LDPLNO##	;FRCLIN?
	CAIN	T2,FRCLIN##
	JRST	LOGRF1		;YES, LOG IN THE JOB WITHOUT RUNNING LOGIN
	SKIPE	T1,REFLAG##	;REFLAG SET NON-ZERO FOR AUTOMATIC LOGIN?
	JRST	LOGREF		;YES, LOG USER IN WITHOUT RUNNING CUSP
IFN FTLINK,<			;[link]
	PUSHJ	P,LNKBRK##	;[link] IN CCASE OF SNOOPS
>				;[link]
CLOG2A:
IFE FTCIMP,<			;[arpa]
	MOVSI	T1,LDLNEC##	;GO TO LOGIN, CLEAR ECHO
	IORM	T1,LDBDCH##(U)
>				;[arpa]
	MOVEI	T1,IOSNEC##	;ALSO IN DDB
	IORM	T1,DEVIOS(F)
IFN FTCIMP,<			;[arpa]
	MOVE	S,DEVIOS(F)	;[arpa] PUT THE BIT SETTINGS IN S
	PUSHJ	P,UUOLDB##	;[arpa]
>				;[arpa]
	JRST	RUNAME
CSESSN::MOVE	P2,LOGTXT##	;SIXBIT /LOGIN/
	JRST	RUNAME		;GO RUN IT

RUNQUE::MOVE	P2,QUEUE##	;SET CUSP NAME
	JRST	RUNAME		;GO RUN IT

IFN FTMIC,<

;HERE TO PROCESS PLEASE COMMAND (SEE IF USER IS RUNNING MIC)
RUNPLS::SKIPE	LDBMIC##(U)	;IS HE RUNNING UNDER MIC?
RUNMIC::MOVSI	P2,'MIC'	;YES - ITS A MIC PLEASE
	JRST	RUNAME		;NO - ITS A NORMAL ONE

>
IFN FTNET,<
RUNNET::NETDBJ			;WE MUST GET NETSER INTERLOCK
				; BECAUSE WE CALL CLRTTY
	MOVE	P2,[SIXBIT/NETLDR/]
	PUSH	P,[DLYCM2]
	  PUSH	P,T2
	PUSHJ	P,RUNAMC	;RUN NETLDR
	  JFCL
	AOS	(P)		;SKIP RTURN
	POP	P,(P)
	POP	P,(P)
	HRRZ	F,LDBDDB##(U)	;GET THE TTY'S DDB
	SKIPE	F
	PUSHJ	P,PTYDET##	;DETACH NETLDR
	PJRST	CLRTTY##	;FREE THE LDB
>;END FTNET

RUNNFT::MOVSI	P2,'NFT'	;RUN SYS:NFT
	JRST	RUNAME		;AT NORMAL START ADDRESS
RUNPIC::MOVSI	P2,'PIP'
RUNAMC::MOVEI	P1,1		;SET CCL START
;RUNAME--COMMAND WHICH RUNS CUSP OF SAME NAME
RUNAME::TLNE	P4,JLOG		;SEE IF LOGGED IN
	JRST	RUNAM1		;YES--PROCEED
	MOVE	T1,HLPPPN##	;GET P,PN FOR JOB
	MOVEM	T1,JBTPPN##(J)
	MOVSI	P4,JLOG!JNA	;CLEAR JLOG&JNA SO COMRET DOES ALL GOOD THINGS
	ANDCAB	P4,JBTSTS##(J)
RUNAM1:	PUSHJ	P,TTYATI##	;REATTACH TTY
	  JFCL
	MOVE	T1,P2		;GET CUSP NAME

; "R CUSPNAME CORE" - DOES "RUN SYS:CUSPNAME"

ARCOM:	MOVEI	T3,12		;MAKE SURE NO MORE ARGS SCANNED
	PUSHJ	P,CTISLC##	; BY MAKING LAST CHAR READ A BREAK
	MOVEM	T1,JBTPRG##(J)	;STORE FILE NAME
RCOM::	MOVSI	T2,(SIXBIT /SYS/)	;READ FROM SYS DEVICE
	JRST	RUNCO2
	subttl	Implied Run command

ifn FtIRun,<	;[ImplRun]

;[ImplRun] if the appropriate bit is set in JBTLcl, commands which are not
;[ImplRun]	found in the command table are treated as if the user had
;[ImplRun]	typed "run <command typed>".

;[ImplRun] dispatch entry for an implied run.
lclced:	xwd	runflg##,rucmdn	;[ImplRun] Local command error dispatch
	$low			;[ImplRun] To low segment
; this is non-zero
erract:	block	1		;[ImplRun] Error action field
	$high			;[ImplRun] Back to high segment

;[ImplRun] For an implied run on error we simply treat this the same as
;[ImplRun] and monitor command that runs a cusp. The only differences:
;[ImplRun]	1. We get the program from the users current path as in a RUN
;[ImplRun]	   command.
;[ImplRun]	2. The program name has been saved in P2 for us.
RUCMDN:
	MOVEI	T3,12		;[ImplRun] Stop scanning at this point
	PUSHJ	P,CTISLC##	;[ImplRun] BY MAKING LAST CHAR READ A BREAK
	MOVEM	P2,JBTPRG##(J)	;[ImplRun] Name of program to run
	JRST	RUNCOM		;[ImplRun] Go to the common run command processor
> ;[ImplRun] end of IFN FtIRun
; "RUN DEVICE:FILE[PROJ.,PROG.] (CORE)"
;DOES A CORE,GET,START ALL IN ONE
;IF CORE ARG IS MISSING, SIZE IN DIRECTORY IS USED
;JOB ON DISK OR IN CORE OR NO CORE, BUT NOT IN MIDDLE OF SWAP


RUNCOM::HLLZ	T2,SYSTAP##	;SET DEFAULT DEVICE DISK (DTA IN 10/40)
RUNCO2:	MOVEI	S,RUNJOB
RUNCM:
IFN FTFDAE,<
	PUSHJ	P,CHKXTM	;SEE IF AN "EXIT" MESSAGE SHOULD BE SENT
				; TO THE FILE DAEMON AND IF SO, SEND IT
>
	MOVSI	T1,JERR		;DON'T ALLOW CONTINUE
	IORM	T1,JBTSTS##(J)	; AFTER THE CORE IMAGE HAS BEEN WIPED OUT
	PUSHJ	P,GETMIN	;GET MINIMAL JOB AREA IN CORE OR DISK
	MOVSI	T1,(JS.BPR)	;ALLOWED DESPITE FORCED PGM TO RUN ?
	TDNE	T1,JBTST2##(J)
	JRST	[ANDCAM T1,JBTST2##(J)	;YES, CLEAR FLAG
		 JRST RUNCM1]	; AND RUN WHAT HE ASKED FOR
	PUSHJ	P,FNDPDB##	;SETUP W
	  JRST	RUNCM1		;NO PDB
	SKIPN	T1,.PDPGM##(W)	;PROGRAM FORCED?
	JRST	RUNCM1		;NO--CHARGE ON
	MOVEM	T1,JBTPRG##(J)
	MOVEI	T2,12		;STOP READING THE COMMAND
	PUSHJ	P,CTISLC##	; BY SAYING LAST CHAR WAS A <LF>
	MOVSI	T2,'SYS'
	MOVSI	P1,PHONLY	;INHIBIT LOG NAMES
RUNCM1:	JUMPN	R,SGSET		;WAS CORE ASSIGNED IN MEMORY? IF YES, GO SCANARGS
	LDB	T1,IMGIN##	;NO CORE IN CORE, CORE ON THE DISK?
	JUMPE	T1,COR2		;COMPLAIN IF NONE
	SKIPLE	VIRTAL##	;NO, CORE LEFT ON DISK?
	JRST	DLYCM		;YES, DELAY COMMAND UNTIL IN CORE
	JRST	COR2		;NO, PRINT "0K CORE LEFT"
	SUBTTL	ASSIGN, DEASSIGN AND REASSIGN COMMANDS

; "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME

ASSIGN::JSP	T2,SAVCTX##	;SAVE THE CONTEXT OF THE JOB
	PUSHJ	P,CTXDEV	;GET FIRST ARGUMENT TO T2 "DEV"
	JUMPE	T2,NOTENF	;NO ARGUMENT TYPED IF 0
IFN FTNET,<
	PUSHJ	P,NETASG##	;SEE IF IT'S A "NODE_DEV" FORM
				; AND IF IT IS TRANSLATE IT TO "GGGNNU"
	POPJ	P,		;BAD DEVICE NAME (ERROR MSG ALREADY PRINTED)
>;END IFN FTNET
	MOVE	P4,T2		;SAVE DEVICE NAME
	PUSHJ	P,SKIPS1	;FLUSH SPACES AND TABS
	JRST	ASSG1		;END-OF-LINE IS OK
	PUSHJ	P,CTEX		;NEXT CHAR MUST BE ALPHANUMERIC
	JRST	COMERA		;NOT, THAT'S AN ERROR
ASSG1:	PUSH	P,U		;SAVE TTY LDB
	MOVE	T1,P4		;DEVICE NAME IN T1
	PUSHJ	P,DEVSRC##	;LOOK FOR THE DEVICE (ALSO LOGICAL NAME)
	  JRST	ASSG3		;NOT A PHYSICAL NAME
	JRST	ASSG4		;A SPECIFIC PHYSICAL NAME
ASSG3:
IFN FTGSRC!FTNET,<
	SETZ	T3,		;ANY DEVICE EXIST
	PUSHJ	P,DVSRSP##
	  JRST	ASSFAL		;NO - ERROR
IFN FTSPL,<
	LDB	T3,DEYSPL##	;YES. SPOOL BIT
	SKIPE	DEVCHR(F)
	TDNE	T3,JBTSPL##(J)	;THIS DEV SPOOLED?
	JRST	ASSG3A		;YES, GO FAKE UP A DDB
>	;END CONDITIONAL ON FTSPL
	PUSH	P,F
	MOVEI	T3,ASSCON+ASSPRG	;FLAG ASSIGNED DEV AS UNACCEPTEABLE
	PUSHJ	P,DVASRC##	;SEARCH FOR GENERIC NAME
	  JRST	ASSG3B
	POP	P,(P)
ASSG3A:	MOVEI	T2,ASSCON	;SET ASSIGNED BY CONSOLE BIT
	PUSHJ	P,ASSASG##	;GO ASSIGN DEVICE
	  JRST	ASSER8	;DEVICE NOT AVAILABLE
	JRST	ASSFIN		;SUCCESS ON ASSIGN

;HERE IF SOME DEVICE OF THIS FLAVOR EXISTS
ASSG3B:	POP	P,F		;F POINTS TO THE DDB IF "DEVX"
	TRNE	T1,770000	;IS IT DEVX:
	TRNE	T1,7700
	TRZA	T1,-1		;NO, CLEAR RIGHT HALF GO TO ASSFAL
	JRST	ASSG4		;YES, TREAT AS PHYSICAL DEVICE
;STILL IN CONDITIONAL ON FTGSRC!FTNET
;HERE WHEN A GENERIC ASSIGN FAILS
;USES 3 FLAGS IN LH OF P3
	ASF.SP==1B0	;SOMETHING HAS BEEN PRINTED
	ASF.MJ==1B1	;AT LEAST 1 ASSIGNED TO MY JOB
	ASF.RD==1B2	;RESTRICTED DEVICE

ASSFAL:	POP	P,U		;RESTORE TTY LDB
	JUMPGE	T4,NOTDEV	;NO DEVICES FOUND - GO PRINT
				;NO-SUCH-DEVICE
IFN FTNET,<MOVE	P2,T2		;COPY NODE NUMBER>
	PUSHJ	P,CHKGEN##	;IS IT A VALID GENERIC NAME?
	  JFCL			;START AT DEVLST
				;(A BAD GENERIC DEVICE SHOULD BE...
				;...FOUND ABOVE AT ASSFAL+1!!!)
	PUSHJ	P,FXSNAM##	;FIX NAME IF 2-CHAR
	MOVEI	P3,-1		;NO FLAGS AND ILL JOB NUMBER
ASSFA1:	HLLZ	T4,DEVNAM(F)	;GET GENERIC PHYSICAL NAME
	CAMN	T1,T4		;SEE IF MATCH
	PUSHJ	P,ASSFA3	;YES--DO REST OF CHECKS
	PUSHJ	P,NXDDB##	;NO--GET NEXT DEVICE
	  SKIPE	F		;CONTINUE IF END OF CHAIN
	JRST	ASSFA1		;NOT END, CHECK NEXT
	TLO	M,ERRFLG##	;FLAG ERROR
	JUMPL	P3,ASSFA2	;DONE CHECK IF ANY RESTRICTED DEVICES SEEN
	MOVEI	T1,ASSMS3	;ASSUME EVERYTHING RESTRICTED
	TLNE	P3,(ASF.MJ)	;ALL ASSIGNED TO OUT JOB
	MOVEI	T1,[ASCIZ "Assigned to your job"]
	JRST	ASSER6		;PRINT MESSAGE AND RETURN

ASSFA2:	TLNN	P3,(ASF.RD)	;ANY RESTRICTED DEVICES SEEN?
	JRST	CRLF		;NO
	MOVEI	T1,[ASCIZ/, remainder of devices not assignable/]
	PUSHJ	P,CONMES	;PRINT THE MESSAGE
	PJRST	CRLF		; CR AND RETURN
;HERE WITH F POINTING TO A DDB WE MAY WANT TO LIST
ASSFA3:	PUSH	P,T1		;SAVE DEVICE NAME
	LDB	T1,PJOBN##	;GET JOB NUMBER
IFN FTNET,<
	LDB	T2,PDVSTA##	;GET STATION
	CAME	T2,P2		;CHECK MATCH
	JRST	TPOPJ##
>
	CAMN	T1,J		;ASSIGNED TO US?
	TLO	P3,(ASF.MJ)	;YES--SET FLAG
	CAME	T1,J		;YES--IS IT OTHER JOB?
	CAIN	T1,(P3)		;SEE IF SAME
	JRST	TPOPJ##		;  AS PREVIOUS
	JUMPE	T1,ASSFA5	;CHECK IF THIS IS FREE, RESTRICTED DEVICE
	HRR	P3,T1		;  NO-PRINT
;HERE WHEN T1= JOB NUMBER TO TYPE
	TLOE	P3,(ASF.SP)	;PRINTED ANYTHING YET?
	JRST	ASFA3A		;YES--JUST ADD A COMMA
	PUSH	P,T1		;SAVE GENERIC DEVICE
IFN FTNET,<PUSH P,P2>		;AND STATION
	PUSHJ	P,INLMES	;PRINT MESSAGE
	ASCIZ	/?Assigned to job /
IFN FTNET,<POP P,P2>		;RESTORE STATION
	POP	P,T1		;RESTORE GENERIC NAME
	JRST	ASSFA4		;SKIP COMMA
ASFA3A:	PUSHJ	P,PRCOM		;ISSUE COMMA
ASSFA4:	PUSHJ	P,RADX10##	;ISSUE JOB NUMBER
	JRST	TPOPJ##		;AND LOOP
ASSFA5:	MOVSI	T1,DEPRAS##	;GET RESTRICTED BIT ASSIGNMENT
	TDNE	T1,DEVSTA(F)	;DEVICE RESTRICTED?
	TLO	P3,(ASF.RD)	;YES -- SET BIT SAYING SO
	JRST	TPOPJ##		;RETURN
>	;END CONDITIONAL ON FTGSRC!FTNET
IFE FTGSRC!FTNET,<
	MOVEI	T2,ASSCON	;SET UP ASSIGNED BY CONSOLE BIT
	HLRZ	F,DEVLST##	;PREPARE TO SEARCH DDB'S
ASSG0:	MOVE	T1,DEVNAM(F)	;GET DEVICE NAME FROM DDB
	CAMN	P4,T1		;SKIP IF NOT DEVICE REQUESTED
	JRST	ASSG4		;TRY TO ASSIGN IT
ASSG1:	LDB	P3,PJOBN##	;OLD JOB # FOR THIS DEVICE
	TRZ	T1,-1		;COMPARE LEFT HALF ONLY (DTA,MTA)
	CAMN	T1,P4		;SKIP IF DOESN'T MATCH
	PUSHJ	P,ASSASG##	;MATCH, TRY TO ASSIGN DEVICE
	  JRST	ASSG2		;CAN'T ASSIGN, KEEP LOOKING
	JUMPE	P3,ASSFIN	;SUCCESS IF OLD JOB #0, DEVICE PREVIOUSLY UNASSIGNED
ASSG2:	PUSHJ	P,NXDDB##	;STEP TO NEXT DEVICE
	  JUMPE	F,NOTDV1	;NO SUCH DEVICE
	JRST	ASSG0		;KEEP LOOKING
>	;END CONDITIONAL ON FTGSRC!FTNET
;PHYSICAL NAME MATCHES IF HERE

ASSG4:	MOVE	T2,DEVMOD(F)	;DEVMOD WORD
	TLNN	T2,DVDSK	;IS THIS A DISK?
	JRST	ASSG5		;NO.
	POP	P,U		;RESTORE TTY LDB ADDRESS
	PUSH	P,F		;AND SAVE DEVICE'S DDB
	PUSH	P,T1		;SAVE PHYSICAL NAME
	PUSHJ	P,CTEXT1	;GET LOGICAL NAME ARGUMENT OF "ASSIGN DEV:NAME"
	MOVE	T1,T2		;COPY TO T1 FOR DEVLG
	JUMPE	T1,ASSG8	;NO LOGICAL NAME SPECIFIED, IF 0
	PUSHJ	P,LNMTST##
	  CAIA
	JRST	ASSER7
	PUSH	P,T2		;SAVE LOG. NAME
	PUSHJ	P,DEVLG##	;SEE IF LOGICAL NAME IN USE
	  JRST	ASSG4A		;NO
	CAME	F,-2(P)		;ASS LOGNAME LOGNAME?
	PUSHJ	P,ASSCHK	;YES, SEE IF WE CAN RECLAIM SPACE
	  MOVEI	T1,LOGERR
	PUSHJ	P,CONMES
ASSG4A:	POP	P,T2		;RESTORE LOG. NAME
	POP	P,T1		;GET PHYSICAL NAME BACK
	POP	P,F		;RESTORE DDB ADDRESS
	PUSH	P,T2		;SAVE LOGICAL NAME
	MOVEI	T2,ASSCON
	PUSHJ	P,ASSASG##	;ASSIGN BY CONSOLE
	  JRST	ASSER4		;NO MORE CORE FOR DISK DDB'S
	POP	P,T1		;RESTORE LOGICAL NAME
	  JRST	ASSF2		;FINISH LOGICAL ASSIGNMENT

ASSG5:	MOVEI	T2,ASSCON
	PUSHJ	P,ASSASG##	;TRY TO ASSIGN DEVICE
	JRST	ASSER5		;ALREADY ASSIGNED TO ANOTHER JOB
	JRST	ASSFIN		;SUCCESSFULLY ASSIGNED


ASSG8:	POP	P,T2		;REMOVE GARBAGE FROM PD LIST
	POP	P,F		;RESTORE POINTER TO PROTOTYPE DSK DDB
	JRST	ASSF6
;ALREADY ASSIGNED TO ANOTHER JOB

ASSER2:	LDB	T1,PJOBN##	;GET JOB NUMBER DEVICE ASSIGNED TO
	PUSH	P,T1		;SAVE JOB NO.
IFN FTLINK,<			;[link] 
	jumpn	T1,ASSERX	;[link] if not zero, don't check for failure
				;[link]  because the terminal was linked.
	MOVSI	T1,DVTTY	;[link] SEE IF IT'S A TERMINAL
	TDNN	T1,DEVMOD(F)	;[link] IS IT?
	  JRST	ASSERX		;[link] NOT A TTY SO NOT LINKED
	pop	p,t1		;[link] clear job number off stack.
	MOVEI	T1,[ASCIZ /Terminal is linked/]	;[link] tell what happened.
	jrst	AssEr6		;[link] type message and crlf.
ASSERX:				;[link] come here if not a linked tty.
>				;[link]
	MOVEI	T1,ASSMS2	;TYPE ERROR MESSAGE
	PUSHJ	P,CONMES
	TLO	M,ERRFLG##	;INDICATE ERROR
	POP	P,T1		;GET JOB NO. BACK
	JRST	DECLF		;AND TYPE IT

ASSER8:	TLOA	T2,(1B0)	;GOVE NOT ASSIGNABLE
ASSER4:	MOVEM	U,0(P)		;DISCARD LOGICAL NAME VIA NEXT POP INSTR.
ASSER5:	POP	P,U		;GET LDB ADDRESS
	JUMPGE	T2,ASSER2	;JUMP IF NOT RESTRICTED DEVICE
	MOVEI	T1,ASSMS3	;TYPE ERROR MESSAGE
ASSER6:	PUSHJ	P,ERRMES	;Y
	JRST	CRLF

ASSMS2:	ASCIZ	/?Already assigned to job /
ASSMS3:	ASCIZ	/Device not assignable/

ASSER7:	POP	P,(P)		;CLEAN UP STACK
	POP	P,(P)
	MOVEI	T1,ASSMS4
	PJRST	ASSER6		;TYPE ERROR MESSAGE
ASSMS4:	ASCIZ	/Disk logical name already exists/
;DEVICE ASSIGNED, GIVE IT A LOGICAL NAME
ASSFIN:	SETZM	DEVLOG(F)	;CLEAR LOGICAL NAME
	POP	P,U		;RESTORE TTY LDB ADDR
	PUSHJ	P,CTEXT1	;GET SECOND ARG, LOGICAL DEVICE NAME
IFN FTSPL,<
	SKIPGE	DEVSPL(F)	;IF A SPOOLING DDB,
	JUMPE	T2,[PUSH P,DEVNAM(F)	;SAVE DEVICE NAME BEFORE GIVING BACK DDB
		PUSHJ	P,CLRDDB##	;GIVE DDB BACK TO FREE STORAGE
					; SINCE NO LOGICAL NAME
		JRST	ASSF4]		;GO PRINT "SPOOLED"
>
	PUSH	P,F		;SAVE DEVICE'S DDB
	PUSH	P,T2		;SAVE LOGICAL NAME
	SKIPE	T1,T2		;IS THERE A LOGICAL NAME SPECIFIED?
	PUSHJ	P,DEVLG##	;YES, SEE IF IT IS ALREADY IN USE
				; BY THIS USER
	  JRST	ASSF3		;NO
	PUSHJ	P,ASSCHK	;YES, SEE IF WE CAN RECLAIM SPACE
	  MOVEI	T1,LOGERR	;YES, PRINT ERROR
	PUSHJ	P,CONMES
ASSF3:	POP	P,T1		;RESTORE LOGICAL NAME FOR THIS DEVICE
	POP	P,F		;DDB OF THE NEWLY ASSIGNED DEVICE
ASSF2:	MOVEM	T1,DEVLOG(F)	;STORE IN DEVICE DATA BLOCK
	PUSHJ	P,SETDVL##
	MOVSI	T2,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAB	T2,DEVMOD(F)	;SETUP T2 WITH DEVICE CHARACTERISTICS FOR ASGHGH
	PUSHJ	P,ASGHGH##	;GO CHECK IF THIS DEVICE HAS
				;  INITIALIZED ANY SHARED SEGMENTS
				;  IF YES, CLEAR SEG NAMES SO NO
				;  NEW SHARING (DTA,MTA ONLY)

IFE FTSPL,<			;NO SPOOLING?
	MOVE	T2,DEVNAM(F)	;PHYSICAL DEVICE NAME
>
ASSF6:
IFN FTSPL,<			;SPOOLING?
	PUSH	P,DEVNAM(F)	;SAVE PHYSICAL DEVICE NAME
	SKIPL	DEVSPL(F)	;IS THIS A SPOOLED DEVICE
	JRST	ASSF5		;NO
;HERE TO TELL USER HE HAS ASSIGNED A SPOOLED DEVICE
ASSF4:	PUSHJ	P,INLMES	;YES, TELL HIM (IN CASE HE DOESN'T KNOW)
	ASCIZ	/Spooled /
ASSF5:	POP	P,T2		;RESTORE PHYSICAL NAME
>				;END FTSPL
	PUSHJ	P,PRNAME##	;PRINT PHYSICAL NAME IT
	PJSP	T1,CONMES	;AND RETURN

	ASCIZ	/ assigned
/

LOGERR:	ASCIZ	/%Logical name was in use, /
;SUBROUTINE TO CLEAR THE LOGICAL NAME OF A DEVICE
;ENTER WITH F SET UP
;ZEROES DEVLOG, THEN CHECKS FOR DSK/SPOOL TYPE
;IF INIT'ED, CLEAR ASSCON
;IF NOT INIT'ED, CLEAR DDB
;ENTER AT ASSCK1 TO NOT ZERO DEVLOG
;CLOBBERS T2
ASSCHK:	SETZM	DEVLOG(F)	;CLEAR OLD NAME
ASSCK1::MOVE	T2,DEVMOD(F)	;GET MOD WORD
	TLNN	T2,DVDSK	;DISK?
	SKIPGE	DEVSPL(F)	;OR SPOOL?
	SKIPA			;YES, SKIP ALONG
	POPJ	P,		;NO, JUST RETURN
	TRNN	T2,ASSPRG	;INIT'ED?
	PJRST	[PUSHJ	P,CLRDVL##	;NO, CLEAR LOGICAL NAME TABLE ENTRY
		 JRST	CLRDDB##]  ; CLEAR DDB AND RETURN
	MOVEI	T2,ASSCON	;YES, TURN OFF ASSCON
	ANDCAM	T2,DEVMOD(F)	;...
	POPJ	P,		;AND RETURN
;"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE


DEASSI::JSP	T2,SAVCTX##	;SAVE THE CONTEXT OF THE JOB
	PUSHJ	P,CTXDEV	;GET DEVICE NAME
	JUMPE	T2,DEASTY	;NO ARG. IF 0, DEASSIGN ALL BUT TTY
	MOVE	T1,T2		;DEVICE NAME
	PUSHJ	P,DEVSRD##	;SEARCH FOR DEVICE
	  JRST	DEAER1		;NOT FOUND
DEASI1:	PUSHJ	P, DEASG	;FOUND, DEASSIGN IT
	  JRST	DEAER2		;NOT PREVIOUSLY ASSIGNED
	PJRST	TTYKLQ##	;KILL TTY DDB IF NOT NEEDED
				;DEVICE DEASSIGNED

NOTDEV::
DEAER1:	SKIPE	J		;IF NOT LOGGED IN (ATTACH FOO)
	PUSHJ	P,TTYFND##
	SKIPA			;RESTORE TTY LINE DATA BLOCK
NOTDV1::POP	P,U		;RESTORE U
	JSP	T1,ERRMES	;PRINT NO SUCH DEVICE

	ASCIZ	/No such device
/

DEAER2:	PUSH	P,F
	PUSHJ	P,TTYFND##	;RESTORE TTY LDB
	POP	P,F
	MOVE	T2,DEVNAM(F)	;PRINT PHYSICAL DEVICE NAME
	PUSHJ	P,PRNAMQ
	PUSHJ	P,TTYKLQ##	;REMOVE DDB
	JSP	T1,ERRMSN

	ASCIZ	/ wasn't assigned
/
;REASSIGN UUO
;CALL	MOVE AC,JOB NUMBER OR -1(SELF) OR 0(DEASSIGN)
;	MOVE AC+1,SIXBIT /DEVICE/
;	CALL AC,[SIXBIT /REASSIGN/]
;IF C(AC)=0, JOB HAS NOT BEEN INITIALIZED
;IF C(AC+1)=0, DEVICE NOT ASSIGNED TO THIS JOB OR DEVICE IS A TTY


REASSI::SKIPGE	T1		;SEE IF OUR JOB (-1)
	MOVE	T1,.CPJOB##	;YES--GET NUMBER
	PUSH	P,T1		;STACK JOB NUMBER TO BE REASSIGNED TO
	PUSHJ	P,GETWD1##
	MOVE	T2,T1		;DEVICE NAME
	JRST	REASS1

;"REASSIGN DEV:JOB" - REASSIGN DEVICE "DEV" TO JOB "JOB"


REASS::PUSHJ	P,CTXDEV	;GET DEVICE NAME
	JUMPE	T2,NOTENF	;NULL NAME?
	MOVE	F,T2		;SAVE IT
	PUSHJ	P,GETJOB	;GET NEW JOB NUMBER
	  MOVE	T2,J		;NONE SPECIFIED. ASSUME SELF
	PUSH	P,T2		;PUT JOB NUMBER ON STACK, DEVICE
	MOVE	T2,F		;NAME IN T2
;ROUTINE COMMON TO REASSIGN UUO AND COMMAND
;HERE WITH T2=DEVICE AND (P)=NEW JOB (0=DEASSIGN)


REASS1:	EXCH	P1,(P)		;SAVE P1 IN STACK, P1= NEW JOB NUMBER
	PUSH	P,U		;SAVE U
	MOVE	T1,P1		;T1 = NEW JOB NUMBER
	PUSH	P,T1
	PUSHJ	P,LGLPR1##	;IS JOB NUMBER OUT OF RANGE?
	  JRST	REASE1		;YES, DO NOT REASSIGN
	JUMPE	T1,REAS1A	;JUMP IF DEASSIGN
	MOVE	T1,JBTSTS##(T1)	;NEW JOB STATUS
	TLNN	T1,JNA		;DOES NEW JOB EXIST?
	JRST	REASE1		;NO.
REAS1A:	MOVE	T1,T2
	HLL	P1,-2(P)	;GET PH ONLY BIT FROM ORIGINAL P1
	PUSHJ	P,DVCNSG##	;SEARCH FOR DEV

	  JRST	REASE2		;NOT FOUND
	NOSCHEDULE
	TLZ	F,-1		;CLEAR SYSDEV
	CAIE	F,SWPDDB##

	CAIN	F,DSKDDB##	;TRYING TO REASSIGN DSK?
	JRST	REASE7		;YES, ERROR

	LDB	T2,PJOBN##
	CAME	T2,J		;ASSIGNED TO THIS JOB
	JRST	REASE9		;NO, ERROR IF SOME OTHER
REAS1B:	MOVE	T1,DEVMOD(F)
	LDB	T3,DEYSPL##	;SPOOL BIT
	TDNN	T3,JBTSPL##(J)	;THIS JOB SPOOL THESE?
	JRST	REAS1X		;NO. NO PROBLEM
	LDB	T3,PJOBN##	;YES. HE DOES
	CAME	T3,J		;TO THIS JOB?
	JRST	REASE7		;NO. CAN'T GET IT
REAS1X:	TLNE	T1,TTYATC	;IS IT THE CONSOLE TTY?
	JRST	REASE7		;YES. CAN'T BE REASSIGNED.
;CONTINUED ON NEXT PAGE
IFN FTMDA,<
	SKIPN	0(P)		;DEASSIGN?
	JRST	REAS1C		;YES
	SKIPE	%SIMDA##	;IS MDA RUNNING?
	CAMN	J,MDAJOB##	;YES, IS HE DOING THIS?
	  JRST	REAS1C		;DON'T CHECK
	MOVSI	T1,DVCMDA	;CONTROLLED BIT
	TDNE	T1,DEVCHR(F)	;CONTROLLED?
	JRST	REASE7		;NO CAN'T REASSIGN IT
>;END IFN FTMDA
REAS1C: SKIPE	(P)		;DEASSIGN,
	CAMN	J,(P)		;OR REASSIGN TO SELF?
	JRST	REAS1D		;YES--OK
	HRRZ	T1,F		;GET DDB ADDRESS
	CAIL	T1,.FPMC	;OUT OF FUNNY
	CAIL	T1,.LPMC	;SPACE RANGE?
	JRST	REAS1D		;YES--GO AHEAD
	JRST	REASE7		;NO--CAN'T DO REASSIGN
REAS1D:	MOVE	S,DEVMOD(F)	;SAVE DEVMOD WORD
	MOVEI	T1,ASSCON	;ASSIGN IT BY
	TDNE	T1,DEVMOD(F)	;SEE IF ASSIGNED
	JUMPE	T2,REASE3	;YES--IF TO 0, ERROR
	DPB	J,PJOBN##	;PUT IN OUR NUMBER
	SCHEDULE
	SKIPN	(P)		;SEE IF DEASSIGN
	JRST	REASS7		;YES--GO DO IT
IFN FTCIMP,<			;[arpa]
	PUSHJ	P,IMPDEV##	;[arpa] IS DEVICE AN IMP?
	 JRST	REAS3I		;[arpa] NO OR NO CONNECTIONS OPEN
	 JRST	REAS3I		;[arpa] YES, BUT NOT CONTROLLING A JOB
	JRST	REASE7		;[arpa] CONTROLLING A JOB - CAN'T REASSIGN
REAS3I:				;[arpa]
>				;[arpa]
	IORB	T1,DEVMOD(F)
	CAME	J,(P)		;IS IT TO SAME JOB?
	TRNN	T1,ASSPRG	;NO. IS DEVICE INITED?
	JRST	REASS3		;NO.
	JUMPG	M,REASS4	;YES. COMMAND LEVEL?
	HRL	F,(P)		;YES. SCHEDULE RELEASE
	MOVEM	F,.JDAT+JOBFDV##
	POP	P,T2
	POP	P,U
	POP	P,P1

	TLO	M,TTYRNC##	;SET TTYRNC## SO JOB WILL RUN
	PJSP	T2,MSTART##
	JSP	T1,MONSTR##
	PUSH	P,P1
	PUSH	P,U
	MOVE	J,.CPJOB##
	HLRZ	T1,.JDAT+JOBFDV##
	PUSH	P,T1
	HRRZ	F,.JDAT+JOBFDV##
REASS4:
IFN FTMSGSER,<
	PUSHJ	P,MPXDIS##
	  SKIPA
	JRST	REASS3
>
	HRRZ	T4,DEVSER(F)
	HRRZM	F,.JDAT+JOBFDV##
	MOVEI	P1,0
	PUSH	P,M		;SAVE M
REASS2:	PUSHJ	P,NXTCH##
	  JRST	REAS2A
	HRRZ	F,.JDAT+JOBFDV##
	CAIE	F,(T1)
	JRST	REASS2
	SOS	P1
	HRLM	P1,.UPMP+.UPCTA
	PUSHJ	P,JDAADP##
	MOVE	F,(T1)
	PUSHJ	P,RELEA1##
	AOJA	P1,REASS2	;INCREMENT CHANNEL AND LOOP
REAS2A:	POP	P,M		;RESTORE M
	MOVE	F,.JDAT+JOBFDV##
	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER

REASS3:	MOVSI	T1,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAM	T1,DEVMOD(F)	;..
	EXCH	J,(P)
	CAMN	J,(P)		;IS IT TO US?
	JRST	REASS6		;YES--JUST CLEAN UP
	NOSCHEDULE
	PUSH	P,F		;PRESERVE F
	TLZ	P1,PHONLY	;ENABLE LOGICAL SEARCH

	SKIPN	T1,DEVLOG(F)	;SEE IF LOGICAL NAME
				;INUSE BY THAT JOB
	  JRST REASS5		;NO (OR NO LOG. NAME)

	PUSHJ	P,DEVCHN##	;DOES JOB HAVE THIS LOGICAL NAME INUSE?
	  SKIPA	T1,-1(P)	;NO, PHYSICAL--GET CALLER'S JOB
	JRST	REASE8		;YES--ILLEGAL
	MOVE	T2,JBTPPN##(T1)	;GET HIS P,PN
	CAME	T2,FFAPPN##	;SEE IF PRIV.
	CAMN	T2,JBTPPN##(J)	;OR SAME GUY
	JRST	REASS5		;YES--IT'S OK
	JUMPL	M,REASE8	;IF COMMAND, THAT IS ONLY WAY
	MOVE	T2,JBTSTS##(T1)	;ELSE, SEE IF
	TLNE	T2,JACCT	;PRIV. PROGRAM
	JRST	REASS5		;YES--IT'S OK

REASE8:	POP	P,F		;RESTORE F
	SCHEDULE
	MOVEI	T2,ASSCON	;WAS IT ASSIGNED
	TDNN	T2,S		;BEFORE WE STARTED
	XORM	T2,DEVMOD(F)	;NO, MAKE SURE IT IS NOT ASSIGNED
	SETZ	T1,		;0 JOB #
	TDNN	T2,S		;AGAIN, WAS IT ASSIGNED?
	DPB	T1,PJOBN	;NO CLEAR OWNER
	JRST	REASE6		;GIVE ERROR
REASS5:	POP	P,F		;RESTORE F
	PUSHJ	P,SETDVL##	;PUT IN NEW JOB NUMBER AND ADD NAME TO LOG NAME TABLE
	HRRI	T1,MTSIZ##+1	;GET DEFAULT MAGTAPE BLOCK SIZE
	HLL	T1,DEVMOD(F)	;
	TLNN	T1,DVMTA	;MAGTAPE?
	JRST	REASS8		;NO,IGNORE
	DPB	T1,PBUFSZ##
	SETZ	T1,		;GET ZERO
	SKIPN	%SITLP##	;RUNNING PULSAR?
	DPB	T1,TDYDN1##	;RESET DENSITY TO SYSTEM DEFAULT
	DPB	T1,TDYMD1##	;CLEAR DEFAULT MODE
	DPB	T1,PBUFRM##	;RESET MAX FRAME-COUNT.
IFN FTDX10,<
	DPB	T1,PMTRTY##	;ENABLE AUTO ERROR-RETRY
>
REASS8:	SCHEDULE
REASS6:	POP	P,J
	POP	P,U		;RESTORE ADDR OF TTY LDB
	POP	P,P1		;RESTORE P1
	TLNN	M,FLMCLV##	;SEE IF UUO OR COMMAND LEVEL
	PJUMPL	M,ESTOP##	;UUO--STOP JOB
	POPJ	P,

REASS7:	PUSHJ	P,DEASG1	;DEASSIGN
	  JFCL			;IGNORE ERROR
	JRST	REASS6		;GO FINISH
REASE1:	POP	P,T1
	POP	P,U		;RESTORE ADDR OF TTY LDB
	POP	P,P1		;RESTORE P1
	TLNE	M,FLMCLV##	;SEE IF UUO OR COMMAND LEVEL
	JRST	ATT4		;COMMAND--ISSUE MESSAGE
	PJRST	RTZER##		;RETURN 0 IN AC

REASE2:	MOVEI	T1,NOTDEV	;NO SUCH DEVICE
REASE5:	POP	P,T2
	POP	P,U		;RESTORE ADDR OF TTY LDB
	POP	P,P1		;RESTORE P1
	JUMPL	M,(T1)		;JUMP IF COMMAND
	PJRST	RTM1##		;GIVE ERROR CODE OF -1 IN AC

REASE9:	JUMPN	T2,REASE3
IFN FTMDA,<
	SKIPN	%SIMDA##	;MDA RUNNING
	JRST	REAS9E		;CHECK RESTRICTED BIT
	CAMN	J,MDAJOB##	;YES, IS MDA DOING THIS?
	JRST	REAS1B		;YES
	MOVSI	T1,DVCMDA	;CONTROL BIT
	TDNE	T1,DEVCHR(F)	;CONTROLLED?
	JRST	REASE3		;YES, LOSE
>;END IFN FTMDA
REAS9E:	MOVSI	T1,DEPRAS	;IS DEVICE
	TDNN	T1,DEVSTA(F)	; RESTRICTED?
	JRST	REAS1B		;NO
REASE3:	SCHEDULE
	MOVEI	T1,DEAER2	;WASN'T ASSIGNED
	JRST	REASE5

REASE7:	SCHEDULE
	EXCH	J,(P)		;FUDGE CORRECT JOB ON STACK
REASE6:	PJSP	T1,REASE5	;RETURN TO USER IF UUO
	MOVE	J,T2		;RESTORE J IF COMMAND
	MOVE	T2,DEVNAM(F)	;GET DEVICE NAME
	PUSHJ	P,TTYFND##	;RESTORE TTY LDB
	PUSHJ	P,PRNAMQ
	PUSHJ	P,TSETBI##	;CLEAR TYPE AHEAD
	MOVEI	T1,REAS6M	;PICK UP MESSAGE
	TLNN	M,FLMCLV##	;SEE IF UUO OR COMMAND LEVEL
	PJRST	PHOLD##		;UUO--GO HOLD JOB
	JRST	ERRMSN		;TYPE MESSAGE IF NOT
REAS6M:	ASCIZ	/ can't be reassigned
/
	SUBTTL	ATTACH, DETACH AND EXCHANGE COMMANDS


;"ATTACH DEVNAM" -ATTACHES A PREVIOUSLY PARTITIONED DEVICE
;	NOTE-MUST BE LOGGED IN UNDER [1,2] TO DO THIS
; "ATTACH N [PROJ.,PROG.]" - ATTACH CONSOLE TO JOB N
;CHANGES ADDRESS OF TTY DEVICE DATA BLOCK STORED IN -2(P)
;BY THE COMMAND DECODER


ATTACH::PUSHJ	P,DECIN1	;GET JOB NO.
	  JRST	NOTENF		;NOT A NUMBER OR NONE SPECIFIED
	  JRST	DEVATT		;WANTS TO ATTACH A DEVICE
	PUSHJ	P,GETJB1	;VALIDATE
IFN FTLINK,<			;[link]
	PUSHJ	P,LNKBRK##	;[link] BLOCK SNOOPS
>				;[link]
	MOVE	T1,JBTPPN##(J)	;GET PPN OF CURRENT JOB
	TRNE	T3,JDC		;TARGET JOB WAITING FOR DAEMON?
	CAMN	T1,FFAPPN##	;YES, ATTACHING JOB [1,2]?
	CAIA			;YES, CONTINUE
	JRST	ATT3		;NO, DON'T ALLOW ATTACH
	MOVE	S,T2		;SAVE JOB NO.
	PUSHJ	P,PJPGNO	;GET PROJ.-PROG. NOS. ARG(IF ERROR, POP SUB LEVEL
				; OFF 1, PRINT ERROR, AND DO NOT RETURN HERE)

	SKIPN	P2,T2		;DID USER TYPE IN A PROJ,PROG # IN []'S?
	MOVE	P2,JBTPPN##(J)	;NO, ASSUME PROJ,PROG NUMBER FOR CURRENT JOB
				; SO USER CAN AVOID TYPEING PROJPROG NO. IF GOING
				; FROM 1 JOB TO ANOTHER UNDER SAME PROJ,PROG
	MOVEM	S,T2		;RESTORE
	CAME	P2,JBTPPN##(T2)	;IS THIS THE SAME PERSON WHO DETACHED FROM
				; THIS JOB NUMBER?
	JRST	ATT3		;NO-ERROR
	PUSH	P,U
	MOVE	S,F		;SAVE DDB ADDRESS
	MOVE	T3,T2		;SAVE TARGET JOB #
	MOVEI	T4,JOBMAX##	;UPPER LIMIT ON ITERATIONS
	LDB	T2,LDPLNO##	;UNIT # ON WHICH COMMAND APPEARED
	PUSHJ	P,CTLJB##	;IF UNIT IS A PTY, RETURN CONTROLLING JOB #
ATLCHK:	JUMPL	T1,ATTOK	;NOT A PTY, ITS COOL
	CAIN	T1,(T3)		;IS CONTROLLING JOB SAME AS TARGET JOB?
	JRST	ATT5		;YES, DISALLOW
	HRRZ	F,TTYTAB##(T1)
	PUSHJ	P,CTLJBD##	;NO, LOOK AT HIS CONTROLLER, IF ANY.
	SOJG	T4,ATLCHK	;ITERATE FOR ALL JOBS, IF NEED BE
	JRST	ATT5		;SHOULDN'T EVER GET HERE

ATTOK:	MOVE	T2,T3		;RESTORE TARGET JOB
	MOVE	F,S		;RESTORE DDB POINTER
	POP	P,U
	PUSH	P,J
	MOVE	J,T2		;CAN NEW TTY ATTACH TO NEW JOB?
	PUSHJ	P,TTYISA##
	  JRST ATT2A		;NO, NO DDB OR ANOTHER DDB ATTACHED AND NOT OPR
ifn FtMFE,<			;[mfe] support for NetMgr
	jumpe	t1,AttOk1	;[mfe] if no one's already attached, ok.
	;[mfe] check to make sure we aren't allowed to attached to an
	;[mfe]	attached job because we're running under NetMgr.
	move	t2,(p)		;[mfe] get our old job number back.
	move	t2,JbtPPn(t2)	;[mfe] get our PPN.
	camn	t2,FFAPPN##	;[mfe] are we legal on our own merits?
	  jrst	AttNL		;[mfe] yes.  no need to see if son of NetMgr.
	push	p,f		;[mfe] save F
	pushj	p,CtlJbU##	;[mfe] get controlling job again
	pop	p,f		;[mfe] recover F
	jumpl	t1,AttNL	;[mfe] no controler.  must have been us.
	;[mfe] PPn of our controller must be [1,2] or we wouldn't be here.
	move	t1,JbtPrg(t1)	;[mfe] get controlling program name
	came	t1,[sixbit \NetMgr\]	;[mfe] is it NetMgr?
	  jrst	AttNL			;[mfe] not NetMgr under [1,2].
					;[mfe]  no login needed.
	jrst	Att2a			;[mfe] under system NetMgr: not a
					;[mfe]  legal attach.
AttOk1:				;[mfe] here if pretty good attach.  decide
				;[mfe]  if we need login.
> ;[mfe] end of IFN FtMFE
ife FtMFE,<			;[mfe] this instruction is not needed
	JUMPN	T1,ATTNL	;IF THERE IS SOMEONE THERE MUST BE OPR TO BE OK
				;HENCE NO LOGIN REQUIRED
> ;[mfe] end of IFE FtMFE
	MOVE	T1,(P)		;OLD JOB NUMBER IN CASE NOT CTY OR OPR
	MOVE	T1,JBTPPN##(T1)	;PPN IF OLD JOB
	CAMN	T1,FFAPPN##	;NO SKIP IF [1,2]
	JRST	ATTNL		;[1,2] DOESN'T NEED LOGIN
	PUSHJ	P,ISOPCT
	  CAMN P2,T1		;SKIP IF CURRENT JOB NOT SAME PPN AS OBJECT JOB
	JRST	ATTNL		;YES, CURRENT JOB DOESN'T REQUIRE LOGIN
	POP	P,J		;OLD JOB #
	TLNE	P4,JLOG		;SKIP IF NO JOB CURRENTLY
	PUSHJ	P,DETAC1	;DETACH CURRENT JOB
	SETZ	J,		;CLEAR J SO LOGIN COMMAND WILL ASSIGN A NEW JOB
	POP	P,T2		;*** POP OFF WHAT WAS ON STACK (RETURN)
				;*** BECAUSE WILL SIMULATE LOGIN
	MOVE	U,(P)		;RESTORE LINE IN CASE IT WAS CLOBBERED
	MOVE	T2,LOGTXT##	;MAKE IT LOOK LIKE A LOGIN COMMAND
	MOVE	P3,[XWD UNQTAB,DISP##] ;P3=UNIQUENESS INFO PLUS LOC OF DISPATCH TABLE
	MOVE	P4,[XWD-DISPL##,COMTAB##] ;P4=LENGTH, LOC
	JRST	COM1A		;*** CALL LOGIN TO VALIDATE THE ATTACH
ATTNL:	PUSHJ	P,TTYATT##	;NO, ATTACH TTY
	  JRST	ATT2A		;ERROR CAN'T ATTACH
	EXCH	J,0(P)		;GET OLD JOB #
	MOVSI	T1,JNA		;IS JOB NUMBER
	TDNE	T1,JBTSTS##(J)	; ASSIGNED?
	PUSHJ	P,DETMSG	;NO. TYPE MESSAGE
	POP	P,J		;RESTORE J
	JRST	TTYFND##	;ATTACHED. GO SET UP OUTP. BYTE PTR.
DEVATT:	PUSHJ	P,SETLGL	;SEE IF OPR OR [1,2]
	  JRST	COMERA		;NOT LEGAL
	PUSHJ	P,CTXDEV	;GET DEVICE ARGUMENT
IFN FTMP,<
	PUSHJ	P,CPUFND##	;IS THE ARGUMENT A CPU NAME?
	  CAIA			;NO, DEVICE OR ERROR
	JRST	CPUATT##	;YES, ATTACH THE CPU
>
	MOVE	S,T2		;SAVE DEVICE NAME ACROSS CALL TO SAVCTX
	JSP	T2,SAVCTD##	;THIS MAY CALL NETSER, MUST BE A JOB.
	MOVE	T1,S		;YES-SET UP DEVICE NAME
	PUSHJ	P,DEVSRG##	;SEARCH FOR DEVICE
IFE FTDHIA&FTDUAL,<
	  JRST	NOTDEV		;NOT FOUND
>
IFN FTDHIA&FTDUAL,<
	  JRST	ATT7		;SEE IF DUAL-PORTED DISK
>
	MOVE	T2,DEVMOD(F)
IFN FTDHIA,<
	TLNE	T2,DVDSK	;DISK?
	JRST	ATT7		;YES, DO IT DIFFERENTLY
>
	SKIPN	DEVCHR(F)	;IS IT A "FAKE" DDB?
	PJRST	DTATSP		;YES, CAN'T ATTACH SPOOLED DEVICE
	TRNN	T2,ASSCON	;WAS DEVICE DETACHED?
	PJRST	ATT6		;NO ERROR
	LDB	T1,PJOBN##	;GET JOB NUMBER
	JUMPN	T1,ATT6		;IS IT = 0?
	SETZM	DEVLOG(F)
	DPB	J,PJOBN##	;SET JOB NUMBER
	HRRI	T1,MTSIZ##+1	;GET DEFAULT MAGTAPE BLOCK SIZE
	HLL	T1,DEVMOD(F)
	TLNN	T1,DVMTA	;MAGTAPE?
	JRST	DEVAT1		;NO, IGNORE
	DPB	T1,PBUFSZ##	;RESTORE DEFAULT BLOCK SIZE
	SETZ	T1,
	DPB	T1,TDYDN1##	;CLEAR USER SET DEFAULT DENSITY
	DPB	T1,TDYMD1##	;CLEAR DEFAULT MODE
	DPB	T1,PBUFRM##	;CLEAR MAX FRAME-COUNT
IFN FTDX10,<
	DPB	T1,PMTRTY##	;ENABLE AUTO ERROR-RETRY
>
DEVAT1:	POPJ	P,
ATT2A:	POP	P,J		;REMOVE JUNK FROM STACK
	MOVE	T2,DEVNAM(F)	;PRINT PHYSICAL NAME
	PUSHJ	P,PRNAMQ
	JSP	T1,ERRMSN
	ASCIZ	/ already attached
/

ATT5:	MOVE	F,S		;RESTORE DDB POINTER
	POP	P,U
ATT3:	JSP	T1,ERRMES
	ASCIZ	/Can't attach to job
/

ATT6:	JSP	T1,ERRMES
	ASCIZ	/Wasn't detached
/
IFN FTDHIA,<
;HERE TO ATTACH A DISK UNIT
ATT7:	PUSHJ	P,ATTDSK##	;TRY TO PUT IT ON-LINE
	  JRST	ATT8		;NOT DOWN OR NO SUCH UNIT
	  CAIA			;KONTROLLER BUSY? WAIT FOR AWHILE
	POPJ	P,		;UNITS IS NOW UP
	PUSH	P,T1		;SAVE DEVICE SPEC
	SETZ	T1,		; SLEEP FOR A JIFFY
	PUSHJ	P,SLEEPF##	; ZZZZ
	POP	P,T1		;RESTORE T1
	JRST	ATT7		;TRY AGAIN

ATT8:	TLZE	U,400000	;IS IT A DSK?
	JRST	NOTDEV		;NO, "NOT A DEVICE"
	JRST	COMERA		;YES, "ATTACH DEV?"

;"XCHNGE UNIT UNIT  - EXCHANGES THE 2 UNITS
XCHUNI::PUSHJ	P,XCHDSK##
	  JRST	COMERA		;SOME FLAVOR OF FOULUP
	POPJ	P,		;GOODNESS
>	;END FTDHIA
;GETJOB--ROUTINE TO SCAN COMMAND FOR JOB NUMBER
;RETURNS:	CPOPJ IF NULL WITH T2=THIS JOB (IF ANY) OR 0.
;	CPOPJ1 IF OK WITH T2=JOB SPECIFIED, T3=JOBSTS
;GIVES ERROR (NO RETURN) IF DECIMAL IMPROPER OR NOT A JOB.
GETJOB::PUSHJ	P,DECIN1	;READ DECIMAL
	  POPJ P,		;NULL--RETURN
	  JRST COMERP		;NOT DECIMAL--ERROR
	AOS	(P)		;GOOD--ADVANCE RETURN
GETJB1:	MOVE	T1,T2		;T1=JOB NUMBER
	PUSHJ	P,LGLPRC##	;SKIP IF LEGAL JOB NUMBER
	  JRST	ATT1P		;NO - FAIL
	MOVE	T3,JBTSTS##(T2)	;GET TARGET JOB STATUS
	TLNE	T3,JNA		;SEE IF JOB NUMBER
	POPJ	P,		;YES--RETURN
	POP	P,T1		;NO--CLEAN UP STACK
ATT4:	JSP	T1,ERRMES
	ASCIZ	/Not a job
/

ATT1P:	POP	P,T1		;CLEAN UP STACK
ATT1::	JSP	T1,ERRMES
	ASCIZ	/Illegal job number
/
;"DETACH" - DETACH CONSOLE FROM JOB
;"DETACH CPUNAM" - DETACHES CPU FROM THE SYSTEM SOFTWAREWISE
;"DETACH DEVNAM" - DETACHES DEVICE FROM THE SYSTEM SOFTWAREWISE

DETACH::PUSHJ	P,CTXDEV	;GET ARGUMENT
	JUMPE	T2,DETAC1	;ONLY "DET" TYPED
	MOVE	S,T2
	PUSHJ	P,SETLGL	;SEE IF OPR OR [1,2]
	  JRST	COMERA		;NOT LEGAL
	PUSHJ	P,SAVE1##	;SAVE P1
IFN FTMP,<
	MOVE	T2,S		;RESTORE ARGUMENT
	PUSHJ	P,CPUFND##	;SEE IF ARGUMENT IS A CPU NAME
	  CAIA			;NOT, A DEVICE OR AN ERROR
	JRST	CPUDET##	;A CPU, DETACH IT
>
	JSP	T2,SAVCTD##	;AMAY CALL NETSER
	MOVE	T1,S		;YES-SET UP DEVICE NAME
	PUSH	P,U		;SAVE ADDR OF TTY LDB
	PUSHJ	P,DEVPHY##	;SEARCH FOR DEVICE
IFE FTDHIA&FTDUAL,<
	  JRST	NOTDV1		;DEVICE NOT FOUND
>
IFN FTDHIA&FTDUAL,<
	JRST	DETAC3
>
	MOVE	T2,DEVMOD(F)	;CHECK TO SEE IF THIS IS DSK
	TRNE	T2,ASSPRG	;ASSIGNED BY PROGRAM?
	JRST	NOTDT1
IFN FTDHIA,<
	TLNE	T2,DVDSK	;TRYING TO TAKE DOWN A DISK?
	JRST	DETAC3		;YES, DO IT DIFFERENTLY
>
	TLNE	T2,DVDSK!DVTTY	;IS IT THE DSK OR A TTY?
	JRST	NOTDV1		;YES-PRINT ERROR MSG.
	MOVEI	T2,ASSCON	;FOUND-SET UP ASSIGNED BY CONSOLE
	PUSHJ	P,ASSASG##	;TRY TO ASSIGN
	JRST	ASSER5		;CAN'T ASSIGN
	SKIPGE	DEVSPL(F)	;SPOOLED?
	JRST	DETAC2		;YES
	TLNE	F,SYSDEV	;IS THIS SYSTEM DEVICE?
	JRST	NOTDV1		;YES-PRINT ERROR MSG.
	MOVEI	T1,0		;NO. SET JOB NUMBER TO ZERO
	DPB	T1,PJOBN##	; ..
	JRST	UPOPJ##		;RESTORE U AND RETURN SUCCESSFUL

DETAC1:	TLNN	P4,JLOG		;CAN'T DETACH
	JRST	ATT4		;IF NOT LOGGED IN
	PUSHJ	P,DETMSG
DETBYE:	HRRZ	F,LDBDDB##(U)	;IS THERE A JOB ATTACHED?
	JUMPE	F,CPOPJ##	;IF NONE, DONE NOW
	JRST	TTYDET##	;YES. GO DETACH IT FROM LINE

DETMSG:	PUSHJ	P,INLMES	;TELL USER WHERE HE WAS
	ASCIZ	/From job /
	PJRST	PJOB
DETAC2:	PUSHJ	P,DTATSP	;SAY DEVICE IS SPOOLED
	PUSHJ	P,CLRDDB##	;DEASSIGN THE DEVICE
	PJRST	UPOPJ##		;POP U AND RETURN
DTATSP:	PUSHJ	P,PRQM		;CAN'T DETACH/ATTACH A SPOOLED DEVICE
	MOVE	T2,DEVNAM(F)	;GET DEV NAME
	PUSHJ	P,PRNAME##	;TYPE IT
	PUSHJ	P,INLMES
	ASCIZ	/ is spooled/
	POPJ	P,
IFN FTDHIA,<
;HERE TO DETACH A DSK
DETAC3:	POP	P,U
	PUSHJ	P,DETDSK##	;TRY TO DETACH
	  JRST	NOTDEV		;NOT A DSK
	  JRST	COMERA		;CANT DETACH
	POPJ	P,		;WIN
>
NOTDT1:	POP	P,U		;RESTORE U
	PJSP	T1,ERRMES	;TYPE MESSAGE
	ASCIZ	/Device in use
/
	SUBTTL	DATASET CONNECT & SYSTEM START


;DATAPHONE RESPONSE COMMANDS PHONIED UP BY SCNSER ON DATAPHONE INTERRUPTS

BYECOM::TLNN	P4,JLOG		;LOGGED IN?
	  JRST	BYECM1		;NO-LEAVE ALONE
	LDB	T1,JBYLTM##	;GET JOBS TIME LIMIT
	JUMPN	T1,BYECM1	;JUMP IF ALREADY SET
	MOVEI	T1,M.DTLS##	;GET DEFAULT DETACH TIME LIMIT
	IMUL	T1,TICSEC##	;INTO JIFFIES
	DPB	T1,JBYLTM##	;STORE NEW LIMIT
	MOVSI	T1,(JB.LTL)	;GET DETACHED LIMIT SET
	IORM	T1,JBTLIM##(J)	;REMEMBER FOR LATER
BYECM1:	PJRST	DETBYE		;THEN DETACH IT



HELLO::

	MOVE	P2,INITIA##	;GO RUN THE
	PJRST	RUNAME		;HELLO PROGRAM



;SYSTEM RESTARTED MESSAGE - COMMAND PHONIED UP BY SCNSER WHEN
; CALLED FROM IOGO

RESTRT::PUSHJ	P,CRLF		;START A NEW LINE, AND
	MOVEI	T1,CONFIG##	;TYPE OUT CONFIGURATION NAME
	PUSHJ	P,CONMES	;"
	PUSHJ	P,PRSPC		;A SPACE
	PJRST	PRDTIM		;AND TIME OF DAY, CRLF.
	SUBTTL	DAYTIME COMMAND

;DAYTIME - PRINT DATE, TIME, CRLF

DAYTIM::PUSHJ	P,DATIME	;TYPE DATE AND TIME
	PJRST	CRLF		;ADD CRLF

;DATIME - PRINT DATE, TIME (NO CRLF)

DATIME::
IFN STUPID,<
	HLRZ	T1,DATE##	;Get day number.
	IDIVI	T1,7		;Get weekday.
	MOVE	T1,[
		EXP[	ASCIZ	"Wednesday "]
		EXP[	ASCIZ	"Thursday "]
		EXP[	ASCIZ	"Friday "]
		EXP[	ASCIZ	"Saturday "]
		EXP[	ASCIZ	"Sunday "]
		EXP[	ASCIZ	"Monday "]
		EXP[	ASCIZ	"Tuesday "]](T2)
	PUSHJ	P,CONMES	;Print day of week.
>;IFN STUPID
	MOVE	T1,LOCDAY##	;PRINT DAY
	PUSHJ	P,RADX10##
	MOVE	T1,LOCMON##
	MOVE	T1,MONTAB##-1(T1)	;MONTH
	DPB	T1,[POINT 21,DAMESS##,27]
	MOVEI	T1,DAMESS##
	PUSHJ	P,CONMES	;PRINT DAY
	MOVE	T1,LOCYER##
	SUBI	T1,^D1900
	PUSHJ	P,RADX10##	;PRINT YEAR
	PUSHJ	P,PRSPC
IFE STUPID,<
	PJRST	PRNOW		;PRINT TIME AS HH:MM:SS(NO CRLF)
>;IFE STUPID
IFN STUPID,<
	PUSHJ	P,PRNOW		;Print time as HH:MM:SS.
	MOVEI	T1,[	ASCIZ	" (GMT"]
	PUSHJ	P,CONMES	;Start printing time zone.
	MOVE	T1,TMZWRD##
	HLRE	T2,T1
	HRRE	T1,T1
	ADD	T2,T1
	MOVEI	T3,"+"
	SKIPGE	T2
	 MOVEI	T3,"-"
	PUSHJ	P,COMTYO##	;Print plus or minus.
	MOVM	T1,T2
	IDIVI	T1,^D3600	;Split into hour and seconds.
	PUSHJ	P,PRT2		;Print hour.
	MOVEI	T3,":"
	PUSHJ	P,COMTYO##
	MOVE	T1,T2
	IDIVI	T1,^D60		;Split into minutes and seconds.
	PUSHJ	P,PRT2		;Print minute.
	MOVEI	T3,")"
	JUMPE	T2,COMTYO##	;Skip seconds if zero.
	MOVEI	T3,":"
	PUSHJ	P,COMTYO##
	MOVE	T1,T2
	PUSHJ	P,PRT2		;Print second.
	MOVEI	T3,")"
	PJRST	COMTYO##
>;IFN STUPID

;SUBROUTINE TO PRINT TIME OF DAY, CRLF

PRDTIM::MOVE	T1,TIME##	;PRINT TIME OF DAY
PRTIME::PUSHJ	P,PRTIM		;PRINT TIME AS HH:MM:SS(NO CRLF)
	PJRST	CRLF		;AND ADD CRLF
;ROUTINE TO PRINT THE MONITOR NAME, SYSTEM UPTIME AND CURRENT
;DATE/TIME
;CALL:	MOVEI	U,LDB ADDRESS
;	PUSHJ	P,BIGBEN
;	<RETURN HERE ALWAYS>

BIGBEN::PUSHJ	P,INLMES
	ASCIZ/
Monitor /
	MOVEI	T1,CONFIG##
	PUSHJ	P,CONMES	;PRINT MONITOR NAME
	PUSHJ	P,CRLF		;END THE LINE
	PUSHJ	P,INLMES
	ASCIZ/System uptime /
	MOVE	T1,SYSUPT##	;GET SYSTEM UPTIME
	PUSHJ	P,PRTIME	;PRINT IT
	PUSHJ	P,INLMES
	ASCIZ .Current date/time .
	PUSHJ	P,DAYTIM	;PRINT DATE TIME
	PJRST	CRLF		;END LINE AND RETURN
	SUBTTL	RUNTIME ROUTINE (TIME## COMMAND)

;"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
;FOLLOWED BY KILO-CORE TICKS
;"TIME 0" IMPLIES RUNTIME FOR NULL JOB
;	IF NO JOB NO. GIVEN-TIME WILL BE FOR CURRENTLY LOGGEN IN JOB NO.


RUNTIM::PUSHJ	P,SAVJW##	;SAVE J (W GETS A RIDE)
	PUSHJ	P,GETJOB	;GET JOB NO. ARG.
	JRST	RUN1		;NO ARG. GIVEN - LOGGED IN?
	MOVE	J,T2		;SETUP DESIRED JOB NUMBER
	JRST	PRTTIM		;PRINT TOTAL RUN TIME+KIL-CORE-SEC
				; BUT DO NOT PRINT INCREMENTAL
RUN1:	MOVSI	T1,JLOG		;IS JOB LOGGED IN?
	TDZN	T1,JBTSTS##(J)	;TEST JOB STATUS BITS AND CLEAR T1 ALWAYS
	JRST	NOTENF		;NO, NEED MORE ARGUMENTS

	.EXCH	T1,.PDRTM##(W)	;CLEAR INCREMENTAL TIME
	PUSHJ	P,PRTIME	;PRINT TIME SINCE LAST TIME COMMAND PLUS CRLF
PRTTIM:	PUSHJ	P,FNDPDB##	;ADDRESS OF PDB FOR JOB
	  TDZA	T1,T1		;NO PDB -- GIVE 0
	.MOVE	T1,.PDTTM##(W)	;GET TOTAL ACCUMULATED TIME
	JUMPE	W,PRTIME	;EXIT IF NO PDB
	PUSHJ	P,PRTIME
	PUSHJ	P,INLMES	;PRINT "J*CPUSEG=
	ASCIZ	/kilo-core-sec=/
	.MOVE	T1,.PDKCT##(W)	;PRODUCT OF NO. OF J CORE* NO. OF JIFFIES RUN

;SUBROUTINE TO PRINT SECONDS, CRLF

	IDIV	T1,TICSEC##	;CONVERT TO SECONDS FROM JIFFIES
	PJRST	DECLF		;PRINT IN DECIMAL, ADD CRLF
	SUBTTL	SEND COMMAND


;ROUTINE TO SEND A LINE OF INFORMATION TO ANOTHER TTY, OR
; TO BROADCAST IT TO ALL TTY'S


SEND::	PUSHJ	P,SAVE2##
	PUSHJ	P,CTEXT1	;GET ARGUMENT DEVICE OF SEND
	JUMPE	T2,NOTENF	;MUST BE ONE
IFN FTNET,<
	SETZ	W,		;CLEAR NODE POINTER
	CAIE	T3,"_"		;TERMINATED BY _
	JRST	SEND0		;NO, CONTINUE NORMAL
	NETDBJ			;INTERLOCK THIS PART
	MOVE	T1,T2		;COPY THE NODE NAME
	PUSHJ	P,CVTOCT##	;CHECK FOR A NUMBER
	  MOVE	T1,T2		;MUST BE A NODE NAME
	SKIPE	T1		;NOT ZERO
	PUSHJ	P,SRCNDB##	;FIND THE NODE DATA BLOCK
	  JRST	[JSP	T1,ERRMES	;NODE DOES NOT EXIST
		 ASCIZ	/Node does not exist
/]
	HLRZ	W,(W)
	JRST	SENDA		;DO A PSEUDO SEND ALL
SEND0:> ;END IFN FTNET
	MOVE	S,T1		;SAVE WHAT USER TYPED
	MOVS	T1,T2		;GET IT SWAPPED FOR COMPARES
	CAIN	T1,(SIXBIT /JOB/)	;PARTICULAR JOB NUMBER?
	JRST	SENDJ		;YES. GO FIND IT
	CAIN	T1,(SIXBIT /ALL/)	;BROADCAST TO ALL TTY'S?
	JRST	SENDA		;YES.
	HRRZ	P1,T1		;SAVE WHAT WAS TYPED
	PUSH	P,U		;SAVE LINE ADDRESS OF SENDER
	MOVE	T1,T2		;GET DEVICE NAME TO SEARCH FOR
	PUSHJ	P,DEVNFS##	;TRY TO MAKE SENSE OF DEVICE NAME
	  JRST	SEND03		;NOT A DEVICE, TRY OCTAL LINE NUMBER
	MOVE	T2,DEVMOD(F)	;GET THE BITS WORDS
	TLNE	T2,DVTTY	;IS IT A TTY?
	TLNE	T2,DVDSK	;WATCH OUT FOR NUL:
	JRST	SENDE2		;TSK TSK NOT A TTY AT ALL
	HRRZ	U,DDBLDB(F)	;GET ADDRESS OF LDB
	PUSHJ	P,TTYKLQ##	;STOMP AN DDB IF NEED BE
	JUMPN	U,SENDT		;TO DO THE SEND
	JRST	SENDE2		;DUH? ON SECOND THOUGHT, DON'T DO THE SEND
;UNRECOGNIZABLE DEVICE, TRY FOR A STRAIGHT OCTAL LINE NUMBER

SEND03:	TRNE	T1,-1		;IF MORE THAN 3 CHARACTERS
	JRST	SENDE1		;THEN IT'S NO TTY THAT WE KNOW OF
	HLRZ	T1,T1		;POSITION "UNIT" NUMBER IN RH
	HRLI	T1,'TTY'	;GENERIC DEVICE TYPE
	PUSHJ	P,TTYALL##	;SEE IF IT MAKES ANY SENSE NOW
	  JRST	SENDE1		;USER MAKES NO SENSE WHATEVER
;	JRST	SENDT		;AH HA!  WE HAVE A VALID TTY
;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE
SENDT:
IFN FTNET,<
	SKIPGE	LDBREM##(U)	;IF UTM+ HOSTED AWAY
	JRST	SENDE1		;DON'T SEND
>;END IFN FTNET
	HRRZ	T1,0(P)		;SEE IF EITHER GUY IS THE OPR
	CAME	U,OPRLDB##	; ..
	CAMN	T1,OPRLDB##	; ..
	JRST	SENDT1		;YES. DONT BUSY CHECK
	MOVE	T1,LDBDCH##(U)	;NO. SEE IF DEST IS AT COMMAND LEVEL
	HLR	T1,LDBBY2##(U)	;OR HAS ALLOWED SENDS
	TDNE	T1,[LDLCOM##,,L2LSND##]	;OK TO SEND?
	JRST	SENDT1		;YES.  OK TO SEND
	EXCH	U,(P)		;RESTORE U
	PUSHJ	P,SETLGL	;DOESN'T WANT A SEND. OVERRIDE?
	  JRST	SNDBSY		;NO.  HE'S BUSY.
	EXCH	U,(P)		;POINT TOGETHER

SENDT1:
	SKIPN	%SIOPR##	;YES, IS ORION RUNNING?
	JRST	SENDT3		;NO, SEND TO OPR THE OLD WAY
	CAIE	P1,'OPR'	;SENDING TO OPERATOR?
	JRST	SENDT3		;NO, NORMAL SEND
	POP	P,U		;SAVE U
	JSP	T2,SAVCTD##	;AND SOME CONTEXT
	PUSHJ	P,SAVE4##	;AND SOME REGS
	MOVE	T2,LDBTIC##(U)	;GET NUMBER OF CHARS IN THE USER'S MESSAGE
	ADDI	T2,4+1		;ROUND OFF (PLUS 1 FOR BELL IN SNOTXS)
	IDIVI	T2,5		;	 TO # WORDS
	MOVSI	P4,1(T2)	;FIGURE TEXT BLOCK LENGTH
	MOVE	P1,T2		;GET # OF WORDS
	IMULI	P1,5		;FIGURE # OF CHARS THAT CAN FIT IN THOSE WORDS
	SOS	P1		;LEAVE ROOM FOR THE ASCIZ IN SNDTXS
	ADDI	T2,5+1+<1+1>+<1+1> ;5 - GALAXY HEADER, 1 - TEXT BLOCK HEADER
				;  2 - FUNCTION BLOCK,   2 - NODE BLOCK
	HRLZ	P2,T2		;SIZE OF THE BLOCK
	PUSHJ	P,GTFWDC##	;GET SOME FUNNY SPACE
	  JRST	[PUSH P,U	;CAN'T, SO SEND IT THE OLD WAY
		 JRST SENDT3]
	HRR	P2,T1		;SAVE ADDRS OF SPACE GOTTEN
	MOVSI	T2,(T1)		;FROM FIRST WORD OF SPACE
	HRRI	T2,1(T1)	;TO NEXT WORD OF SPACE
	HLRZ	T3,P2		;LENGTH OF THE SPACE
	ADDI	T3,(T1)		;WORD JUST PAST END OF SPACE
	SETZM	(T1)		;CLEAR THE FIRST WORD
	BLT	T2,-1(T3)	;AND CLEAR THE WHOLE MESSAGE
	HLLZ	T2,P2		;COPY THE MESSAGE LENGTH
	HRRI	T2,.IPCGM##	;SETUP THE MESSAGE TYPE
	MOVEM	T2,(T1)		;.MSTYP - LEN,,TYPE
	MOVSI	T2,(WT.SND)	;INDICATE SEND OPR
	CAMN	U,OPRLDB##
	IORM	T2,3(T1)	;IN MESSAGE TO ORION
	MOVEI	P3,5(T1)	;AIM P3 AT THE 'CURRENT' BLOCK
;
;	P2/	LEN,,ADRS OF THE MESSAGE
;	P3/	ADRS OF 'CURRENT' BLOCK
;
	DMOVE	T1,[XWD	2,.WTUFC ;GET THE FIRST DATA BLOCK HEADER
		   EXP	%QWTO##-.GTQFT##] ;A FUNCTION BLOCK - WTO FUNCTION
	DMOVEM	T1,0(P3)	;STORE 'EM
	ADDI	P3,2		;STEP TO NEXT BLOCK
	AOS	4(P2)		;COUNT THE ARGUMENT BLOCKS
IFN FTNET,<
	HLLZ	T1,S		;NODE NUMBER
	SKIPE	T1
	PUSHJ	P,CVTOCT##	;CONVERT
	  MOVE	T1,JBTLOC##(J)	;USE WHERE LOCATED
	PUSHJ	P,[NETDBJ
		   JRST NODE.S##]
	  JRST SENDT2		;NO NODE, DON'T INCLUDE A NODE BLOCK!
	HLRZ	T1,NDBSNM##(W)
	MOVE	T2,(T1)		;GET THE DESIRED NODE NAME
	MOVE	T1,[2,,.WTDES]	;AND THE ARGUMENT BLOCK HEADER WORD
	DMOVEM	T1,0(P3)	;MAKE THIS BLOCK
	ADDI	P3,2
	AOS	4(P2)		;ONE MORE ARG BLOCK
>
SENDT2:	HRRI	P4,.WTTXT
	MOVEM	P4,0(P3)
	MOVEI	P4,%SIOPR	;WHO GETS THE MESSAGE
	MOVEI	T4,1(P3)
	AOS	4(P2)		;ONE MORE ARG BLOCK
	JRST	SNDTXS

ifn newsend,<

isendx:	ldb	s,ldplno##	;Get local line #
ifn ftnet,<
	hrl	s,jbtloc##	;make node,,line
	move	t1,ldbdch##(U)	;Get word with LDRREM bit.
	trnn	t1,ldrrem##	;Is this a remote line?
	 jrst	isndx2		; No, we're done.
	ldb	s,ldprln##	;Get remote line #
	ldb	t1,ldprnn##	;Get remote node #
	hrli	s,(t1)		;Mung together.
isndx2:
>;ftnet
	pop	p,u		;Recover our LDB.
	jrst	isend

isenda:	seto	s,		;Mark wild receiver.
	jrst	isend

isend:	jsp	t2,savctd##	;preserve context.
	move	t2,ldbtic##(U)	;char count.
	addi	t2,4
	idivi	t2,5		;Compute # words needed.
	move	p1,t2
	imuli	p1,5
	subi	p1,1		;Compute # of chars that can be stored.
	addi	t2,7		;Compute total size of message.
	hrlz	p2,t2		;Keep size,,0.
	pushj	p,gtfwdc##	;Get free core.
	 jrst[	jsp t1,errmes	; Maybe do something better here...
		asciz "Can't send -- no core.
"]
	hrr	p2,t1		;keep size,,addrs
;Start setting up message:
	hllzm	p2,0(p2)	;Store size,,code.  (Function code 0).
	movem	j,1(p2)		;Store sender job #
	setzm	2(p2)		;Store sender TTY #  **********
	move	t1,jbtppn##(j)
	movem	t1,3(p2)	;Store sender PPN.
	dmove	t1,.pdnm1##(W)
	dmovem	t1,4(p2)	;Store sender user name.
	movem	s,6(p2)		;Store target.
	move	p3,[point 7,7(p2)]
isnd.2:	pushj	p,comtyi##	;Get next char.
	idpb	t3,p3		;store
	caie	t3,12		;Check for end of line.
	 cain	t3,3
	  tdza	p1,p1
	   sojg	p1,isnd.2
	idpb	p1,p3		;Finish off with nul.
	movei	t1,%sisnd##	;Message to [system]sender
	move	t4,p2		;len,,addrs
	pjrst	sndffc##	;Send msg, and deallocate memory.

>;newsend hack
;HERE TO DO THE 'OLD STYLE' SEND OPR COMMAND
SENDT3:
ifn newsend,<
	skipe	%sisnd##	;[SYSTEM]SENDER set up?
	 jrst	isendx		; Yes, handle this in another way.
>;newsend hack
	PUSHJ	P,SENDHD	;SEND HEADER (CRLF, SEMI, TTY NAME)

SEND1:	PUSHJ	P,SNDTYI	;GET CHARACTER TO SEND OUT
	  JRST SEND2		;END OF LINE
	PUSHJ	P,COMTYO##	;SEND IT (DEST IN LINE)
	JUMPN	T3,SEND1	;LOOP FOR MORE

SEND2:	PUSHJ	P,SNDEOL	;SEND CRLF, MAYBE DOT TO DEST
				;RESTORE STACK, GET SENDER LDB
	PJRST	UPOPJ##		;AND RETURN FROM SEND COMMAND

;STILL IN FTTALK CONDITIONAL
;MORE OF SEND COMMAND


SENDJ:	PUSHJ	P,GETJOB	;GET DESIRED JOB NUMBER
	  JRST NOTENF		;MUST HAVE AN ARG
	PUSH	P,U		;OK. SAVE SENDER'S LDB
	HRRZ	F,TTYTAB##(T2)	;GET TTY DDB OF DEST JOB
	JUMPE	F,SENDE1	;MUST BE ONE
	HRRZ	U,DDBLDB##(F)	;GET LDB ADDRESS
	JUMPN	U,SENDT		;AND GO SEND IT (IF NOT DETACHED)
SENDE1:	POP	P,U		;OOPS. NO SUCH GUY. GET SENDER
	JSP	T1,ERRMES	;AND GIVE HIM THE BAD NEWS
	ASCIZ	/No such tty
/

SENDE2:	POP	P,U
	JSP	T1,ERRMES	;RESTORE THE STACK
				; AND GRIPE AT THE USER
	ASCIZ	/Not a tty
/
SENDA:	PUSHJ	P,SETLGL	;LEGAL? (OPR OR [1,2])
	  JRST	COMERA		;NOT LEGAL
ifn newsend,<
	skipe	%sisnd##	;[system]sender there?
	 jrst	isenda		; Yep, new way then.
>;newsend hack
	SKIPE	SNDCTR		;SKIP IF SEND BUFFER IS FREE
	JRST	DLYCM1		;NOT FREE, DELAY THE COMMAND
	PUSH	P,U		;YES. STACK LDB ADR OF OPR
	MOVE	T1,SNDPTR	;PICK UP POINTER
	MOVEM	T1,SNDTMP	;SAVE IN TEMP
	MOVEI	T1,SNDTYO	;INTERCEPT TYPEOUT
	MOVEM	T1,.CPTOA##	;..
ife stupid,<
	MOVEI	T1,^D85		;PRESET QUOTA
>;end ife stupid
ifn stupid,<
	movei	t1,^d160	;need higer quota
>;end ifn stupid
	MOVEM	T1,SNDCNT	; SO WE DON'T WIPE
				; COMCON
	PUSHJ	P,SENDHD	;SEND THE HEADER
	MOVEI	T1,CCTYO##	;RESTORE
	MOVEM	T1,.CPTOA##	;.CPTOA
ife stupid,<
	MOVEI	P1,^D85
>;end ife stupid

SENDA3:	PUSHJ	P,SNDTYI	;GET A CHAR FROM SENDER
	  JRST SENDAX		;NO MORE.
	MOVE	T1,T3		;COPY CHAR
ife stupid,<
	SOSL	P1
>;end ife stupid
	PUSHJ	P,SNDTYO	;SEND TO ALL LINES
	JRST	SENDA3		;LOOP TILL END OF LINE

SENDAX:	MOVEI	T1,FLLFLG##	;MARK SPOT FOR
	IDPB	T1,SNDTMP	;CRLF
	MOVSI	T1,LPLSAP##	;SEND ALL PENDING
	IDPB	T1,SNDTMP	;MAKE ASCIZ
	MOVNI	U,1		;LOOP OVER ALL LINES
	JRST	SENDX1		;..
SENDX2:	LDB	U,LDPLNO##	;GET NEXT LINE
	CAIL	U,TTPLEN##-1	;DONE?
	JRST	UPOPJ##		;YES.
SENDX1:	HRRZ	U,LINTAB##+1(U)	;NO--GET NEXT LDB
	MOVE	T1,LDBDCH##(U)	;GET BITS
	PUSHJ	P,SHDSND	;SHOULD WE DO A SEND?
	  SKIPA	T2,SNDPTR	;YES, SET UP POINTER
	JRST	SENDX2		;NO--TRY NEXT LINE
	MOVSI	T1,LPLSAP##	;SET UP FLAG
	SCNOFF			;NO INTERRUPTS HERE
	SKIPN	LDBFLP##(U)	;POINTER SET UP?
	JRST	[PUSHJ P,SETFPT## ;NO-SET NEW POINTER
		 JRST SENDX3]	;SETFPT DOES A SCNON
	IORM	T1,LDBPAG##(U)	;YES--SET FLAG
	AOS	SNDCTR
	SCNON
SENDX3:	PUSHJ	P,TOPOKE##	;START TTY
	JRST	SENDX2		;LOOP FOR MORE

;STILL IN FTTALK CONDITIONAL
;MORE OF SEND COMMAND

;SUBROUTINE TO GET CHARACTER FROM SENDER, WHOSE LDB IS ON STACK

SNDTYI:	EXCH	U,-1(P)		;GET SENDER'S LDB
	PUSHJ	P,COMTYI##	;GET HIS CHARACTER AND ITS BITS
	EXCH	U,-1(P)		;RESTORE LINE OF SENDEE
	TLNE	T1,CHBRK##	;IS THIS AN END OF LINE?
	POPJ	P,0		;YES. NON-SKIP RETURN FROM SNDTYI
	CAIE	T3,"H"-100	;FILTER ^H
	TLNE	T1,CHUAE##	;NO. IS IT A LOSING CONTROL CHAR?
	JRST	SNDTYI		;YES. FILTER IT OUT
	JRST	CPOPJ1##	;NORMAL CHAR. SKIP RETURN

SENDHD:	PUSHJ	P,INLMES	;SEND START OF SEND MESSAGE
ife stupid,<
	BYTE(7)15,12,7,";",";",0	;CR,LF,BELL
>;end ife stupid
ifn stupid,<
	byte(7)15,12,7,"F","r","o","m"," ",0
>;end ifn stupid
	EXCH	U,-1(P)		;GET SENDER'S LDB ADR
	MOVE	T1,J		;SET UP T1 FOR FIRST TIME THROUGH
	HRRZS	T3,U		;SAVE U IN CASE OF ERROR
ifn stupid,<
	hrl	t3,t1		;save job number
>;end ifn stupid
	MOVEI	T4,^D20		;MAX DEPTH
SENDH1:	MOVE	T2,JBTLIM##(T1)	;IS SENDER A
	TLNE	T2,(JB.LBT)	;BATCH SUBJOB?
	JRST	SENDH3		;YES, NEVER SAY OPR
	PUSHJ	P,CTLJBU##	;FIND CONTROL JOB
ifn stupid,<
	skiple	t1		;save the job number, if we found a
	 hrl	t3,t1		; controling job.
>;end ifn stupid
	JUMPE	U,SENDH2	;DETACHED JOB
	JUMPL	T1,SENDH3	;FOUND A TTY
	MOVE	F,TTYTAB##(T1)	;CONTROLLING TTY
ifn FtMFE,<			;[mfe] make sends under NetMgr not notice
				;[mfe]	NetMgr.
	ldb	u,PJobN##	;[mfe] get controlling job number
	MOVE	U,JBTPRG##(U)	;[mfe] GET CONTROLLING JOB NAME
	CAMN	U,['NETMGR']	;[mfe] IS IT NETMGR?
	  jrst	[		;[mfe] yes.  give job number
		 MOVE	U,-1(P)		;[mfe] RESTORE RECIPIENT
		 MOVEM	T3,-1(P)	;[mfe] PUT PTY POINTER ON STACK
		 PUSHJ	P,INLMES	;[mfe] print "Job <n>:"
		 ASCIZ	/Job /		;[mfe]
		 MOVE	T1,J		;[mfe] GET JOB NUMBER
		 PUSHJ	P,RADX10##	;[mfe]  AND PRINT IT IN DECIMAL	
		 jrst	SendH4		;[mfe] finish the header.
		]		;[mfe]
> ;[mfe] end of IFN FTMFE
	HRRZ	U,DDBLDB##(F)	;HIS LINE
	SOJG	T4,SENDH1	;LOOK FOR NEXT PTY
ife stupid,<
SENDH2:	MOVE	U,T3		;RESTORE U
SENDH3:	PUSH	P,T3		;SAVE POINTER TO PTY LDB

	PUSHJ	P,TTYNAM##	;CONVERT TO REAL NAME IN SIXBIT
	POP	P,T3

	CAMN	U,OPRLDB##	;IS IT THE OPR?
	MOVSI	T2,(SIXBIT /OPR/)	;YES. SAY OPR INSTEAD
	HRRZ	T1,LINTAB##+FRCLIN##	;GET LDB ADDRESS FOR FRCLIN
	CAIN	T1,(U)		;IS IT FROM THAT LINE
	MOVE	T2,[SIXBIT/SYSTEM/]	;YES, USE SYSTEM
	MOVE	U,-1(P)		;RESTORE RECIPIENT
	MOVEM	T3,-1(P)	;PUT PTY POINTER ON STACK

	PUSHJ	P,PRNAME##	;OUTPUT THE NAME TO SENDEE
ifn FtMFE,<			;[mfe]
SendH4:				;[mfe] here after printing "Job <n>"
>				;[mfe]
	PUSHJ	P,INLMES	;AND SPACER
	ASCIZ	/: - /		; ..
	POPJ	P,0		;RETURN FROM SENDHD

>;end ife stupid
IFN STUPID,<
SENDH2:	HRRZ	U,T3		;Restore U.
SENDH3:	PUSH	P,U		;Save LDB of real sender.
	MOVE	U,-2(P)		;Restore receiver.
	HRRZM	T3,-2(P)	;Save LDB of sending terminal.
	HLRZ	T3,T3		;Extract job number.
	JUMPE	T3,SENDH6	;Skip if no job number.
	MOVE	T4,JBTSTS##(T3)	;Get job status and skip if not logged in.
	TLNE	T4,JLOG
	 SKIPN	T4,JBTPDB##(T3)	;Get a pointer to the PDB.
	  JRST	SENDH6
	PUSH	P,T3		;Save the job number.
	SKIPN	T2,.PDNM1##(T4)	;Skip if no user name.
	 SKIPE	.PDNM2##(T4)
	  SKIPA
	   JRST	SENDH5
	SKIPN	.PDNM2##(T4)	;Print trailing spaces when neccessary.
	 JRST	SENDH4
	PUSHJ	P,PRSIXB##	;Print first part of user name.
	MOVE	T2,.PDNM2##(T4)
SENDH4:	PUSHJ	P,PRNAME##	;Print user name, followed by a space.
	PUSHJ	P,PRSPC
SENDH5:	POP	P,T4		;Get the job number back.
	MOVE	T2,JBTPPN##(T4)	;Get the PPN.
	PUSHJ	P,PRTPPN	;Print it.
	JRST	SENDH7
SENDH6:	PUSHJ	P,INLMES	;Special message for not logged in.
	ASCIZ	"not logged in"
SENDH7:	PUSHJ	P,INLMES
	ASCIZ	" on "
IFN FTNET,<
	MOVE	T2,STANAM##	;Print the node name.
	PUSHJ	P,PRNAME##
	PUSHJ	P,INLMES	;Followed by an underline.
	ASCIZ	"_"
> ;End of IFN FTNET
	EXCH	U,(P)		;Get the name of the terminal.
	PUSHJ	P,TTYNAM##
	HRRZ	T1,LINTAB##+FRCLIN##
	CAIN	T1,(U)		;Change to SYSTEM if FRCLIN.
	 MOVE	T2,[SIXBIT "SYSTEM"]
	EXCH	U,(P)
	PUSHJ	P,PRNAME##	;Print the terminal name.
IFN FTNET,<
	MOVE	T1,(P)		;Check if remote terminal.
	MOVEI	T2,LDRREM##
	TDNN	T2,LDBDCH##(T1)
	 JRST	SENDH9		;Don't print same thing twice if local.
	PUSHJ	P,INLMES
	ASCIZ	" ("
	EXCH	U,(P)		;Get the node number.
	LDB	T1,LDPRNN##
	EXCH	U,(P)
	PUSHJ	P,SENDHN	;Try to convert to node name.
	 JRST	SENDH8		;Failed, print node number instead.
	PUSHJ	P,PRNAME##
	SKIPA
SENDH8:	PUSHJ	P,PRTDI8##
	PUSHJ	P,INLMES	;Print underscore and TTY number.
	ASCIZ	"_TTY"
	EXCH	U,(P)		;Get the line number.
	LDB	T1,LDPRLN##
	EXCH	U,(P)
	PUSHJ	P,PRTDI8##	;Print it.
	PUSHJ	P,INLMES
	ASCIZ	")"
SENDH9:
> ;End of IFN FTNET
	POP	P,T1		;Get rid of real sender's LDB pointer.
	PUSHJ	P,INLMES
	ASCIZ	" at "
	MOVE	T1,TIME##	;Get the current time and print it.
	IDIV	T1,TICMIN##
	IDIVI	T1,^D60
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	":"
	MOVE	T1,T2
	PUSHJ	P,PRT2
	PJRST	CRLF		;Finish off with an end of line.
IFN FTNET,<
SENDHN:	PUSHJ	P,SAVJW##	;Save accumulators over call.
	NETDBJ			;Network interlock.
	PUSHJ	P,SRCNDB##	;Find the NDB of this node.
	 POPJ	P,		;Failed.
	HLRZ	T2,NDBSNM##(W)	;Get the pointer to the node name.
	JUMPE	T2,CPOPJ##	;No node name, return.
	MOVE	T2,(T2)		;Get the node name.
	AOS	(P)		;Indicate success and return.
	POPJ	P,
> ;End of IFN FTNET
> ;End of IFN STUPID

SNDEOL:	PUSHJ	P,CRLF		;SEND CR LF TO LINE IN U
	MOVE	T1,LDBDCH##(U)	;SEE IF DEST IS AT COM LEVEL
ife stupid,<
	TLNE	T1,LDLCOM##	; ..
	PUSHJ	P,PRPER		;YES. SEND A DOT TOO
	POPJ	P,0		;RETURN FROM SNDEOL
>;end ife stupid
ifn stupid,<
	tlnn	t1,ldlcom##	;See if dest is at comand level
	 popj	p,		;no just return
;***  Here we shold set up w and j for the target job ***
	pjrst	prompt		;Yes, then we supply the prompter.
>;end ifn stupid

SHDSND:	SKIPL	LDBOFL##(U)	;SKIP IF OFF LINE?
	TRNE	T1,LDRPTY##	;DON'T SEND TO A PTY
	JRST	CPOPJ1##	;WHICH THIS IS
IFN FTNET,<
	JUMPE	W,SHDND2	;ANY PARTICULAR NODE SPECIFIED
	CAME	W,JBTLOC##	;CHECK FOR THE LOCAL NODE
	JRST	SHDND0		;REMOTE LINE
	TRNN	T1,LDRREM##	;LOCAL NODE IS THIS A LOCAL LINE
	JRST	SHDND1		;YES, CONTINUE
SHDND0:	LDB	T4,LDPRNN##	;GET THE NODE NUMBER OF THE REMOTE LINE
	JUMPE	T4,CPOPJ1##	;UNASSIGNED LINE
	CAIE	T4,(W)		;IS THIS LINE ON THAT NODE
	JRST	CPOPJ1##	;NO, RETURN
	JRST	SHDND1		;YES CONTINUE
SHDND2:	MOVSI	T4,LRLCON##	;TTY
	TDNE	T4,LDBREM##(U)	;  CONNECTED?
	JRST	SHDND1		;YES CONTINUE
	TRNE	T1,LDRREM##	;NO IS IT A REMOTE LINE
	JRST	CPOPJ1##	;YES, GO AWAY
SHDND1:	SKIPGE	LDBREM##(U)	;IF UTM + HOSTED AWAY
	JRST	CPOPJ1##	;YES, GO AWAY
>;END IFN FTNET
IFN FTMP,<
	LDB	T4,LDPCPU##	;CPU OWNING THE TERMINAL
	CAIN	T4,7		;GENERIC BOOT CPU
	MOVE	T4,BOOTCP##	;YES, GET CPU NUMBER
	LSH	T4,.CPSOF##	;TO CDB OFFSET
	SKIPL	.C0OK##(T4)	;CPU RUNNING
	JRST	CPOPJ1##	;NO, DON'T SEND
>
	PUSH	P,T1		;SAVE T1
	LDB	T1,LDPLNO##	;GET LINE # INTO T1
IFN FTKS10,<
	CAIE	T1,KLILIN##	;KLINIK LINE?
	JRST	SHSND0		;NO
	MOVEI	T4,KLIINI	;KLINIK INITED?
	TDNN	T4,KLIIWD
	JRST	TPOPJ1##	;NO,DON'T SEND
SHSND0:>
	PUSHJ	P,XTCTTY##	;CHECK ON DA-28 LINE
	  PJRST	TPOPJ1##	;INACTIVE LINE - SKIP RETURN
	  JFCL			;ACTIVE LINE - OK
	POP	P,T1		;NORMAL RETURN - RESTORE T1
	HRRZ	T4,LDBDDB##(U)	;GET DDB ADDRESS
	JUMPE	T4,SHSND1	;JUMP IF NO DDB
	MOVE	T4,DEVIOS(T4)	;GET IN IT MODE
	TRNE	T4,I!PIMMOD	;IMAGE MODE OR PACKED IMAGE MODE?
	JRST	CPOPJ1##	;YES--DO NOT SEND
SHSND1:	MOVE	T4,LDBBY2##(U)	;GET GAG FLAG
	TLNE	T1,LDLSLV##	;IF NOT SLAVE
	TLNE	T4,L2LSND##	;OR NOT GAGGED
	POPJ	P,		;OK
	JRST	CPOPJ1##	;DON'T SEND TO GAGGED SLAVE


SNDTYO:	PUSHJ	P,PEVEN8##	;ADD PARITY
	SOSL	SNDCNT		;SKIP IF NO ROOM
	IDPB	T3,SNDTMP	;STORE BYTE
	POPJ	P,		;RETURN
	$LOW
ife stupid,<
SNDCNT::EXP	^D85
>;end ife stupid
ifn stupid,<
SNDCNT::EXP	^d160
>;end ifn stupid
SNDCTR::EXP	0

SNDTMP::POINT	9,SNDTXT	;ACTIVE POINTER
SNDPTR::POINT	9,SNDTXT	;VIRGIN POINTER
ife stupid,<
SNDTXT:	BLOCK	^D85/4+1	;BUFFER
>;end ife stupid
ifn stupid,<
sndtxt:	block	^d160/4+1	;need more buffer space
>;end ifn stupid
SNDMXL==:<.-SNDTMP-1>B26
	$HIGH


SNDBSY:	POP	P,T1		;REMOVE SENDEE FROM STACK
SNDBSI:	JSP	T1,ERRMES	;TYPE ERROR AND RETURN
	ASCIZ	/Busy
/
	SUBTTL	VERSION COMMAND & PRVERS SUBROUTINE

IFN	FTVERS,<
;"VERSION" -- COMMAND TO PRINT LOW+HISEG NAME+VERSION
;FORMAT IS:  LOWNAM LOWVER[+[HINAM HIVER]]
;HISEG STUFF ONLY IF VERSION DIFFERENT OR NAME NON-ZERO
;	AND DIFFERENT
;IF HISEG NAME ZERO, HINAM IS OMITTED
;IF NO HISEG, "+" IS OMITTED
;VERSION IS ALWAYS IN FORM VER LET(EDIT)-CUST.
VERCOM::
VERBTH::MOVE	T2,JBTNAM##(J)	;GET LOW NAME
	PUSHJ	P,PRNAME##	;PRINT IT
	PUSHJ	P,PRSPC		;AND SPACE
	MOVE	T1,.JDAT+.JBVER##	;GET LOW VERSION
	PUSHJ	P,PRVERS	;PRINT IT
VERHGH::PUSHJ	P,SAVE2##
	SKIPG	P1,JBTSGN##(J)	;GET HI-SEG
	POPJ	P,		;NONE--ALL DONE
	PUSHJ	P,INLMES	;INDICATE HI-SEG
	ASCIZ	/ + /
	EXCH	J,P1
	LDB	T1,JBYHSO##	;GET START PAGE OF SEG
	EXCH	J,P1		;RESTORE J
	LSH	T1,P2WLSH##	;START ADR
	PUSHJ	P,FLTST##	;IN CORE?
	  JRST	[LSH T1,W2PLSH##;COULD BE ALLOCATED BUT ZERO
		 PUSHJ P,GTPME##;GET MAP CONTENTS
		 CAIE T2,PM.ZER	;IS IT?
		 CAME P2,VERTXT## ;ONLY ON A VERSION COMMAND
		 POPJ P,
		 JSP T2,SAVCTX##;GET TO UUO LEVEL
		 MOVE P1,JBTSGN##(J) ;GET HIGH SEGMENT NUMBER BACK
		 EXCH P1,J	;HIGH SEGMENT NUMBER TO J
		 LDB T1,JBYHSO##;HIGH SEGMENT ORGIN
		 EXCH P1,J	;RESTORE
		 PUSHJ P,[PUSHJ P,SETASA ;GET THE PAGE INTO CORE AND ACCESSIBLE
			  PUSHJ P,PAGIA
			    CAIA
			  AOS (P)
			  PUSHJ P,TTYFUW##
			  JRST CLRASA]
		   POPJ P,	;AND AFTER ALL THAT WORK
		 JRST .+1]	;CONTINUE
	SKIPN	T2,JBTNAM##(P1)	;GET HI NAME
	MOVE	T2,.VJDT+.JBHNM## ;BLANK--USE SAVE
	SKIPE	T1,.VJDT+.JBHVR## ;GET HIGH VERSION
	CAMN	T1,.JDAT+.JBVER##	; COMPARE TO LOW IF PRESENT
	CAME	T2,JBTNAM##(J)	;COMPARE TO LOW NAME
	JRST	VERHG1		;DIFFERENT--PRINT
	JRST	VERHG2
VERHG1:	PUSHJ	P,PRNAME##	;PRINT HI HAME
	PUSHJ	P,PRSPC		;AND SPACE
	MOVE	T1,.VJDT+.JBHVR## ;GET HI VERSION
	PUSHJ	P,PRVERS	;PRINT VERSION #
VERHG2:	MOVE	T1,JBTSTS##(P1)	;GET HISEG FLAGS
	TLNE	T1,SHRSEG	;SHARE SEG?
	POPJ	P,0		;YES
	PJSP	T1,CONMES	;NO--WARN USER
	ASCIZ	" Not sharable "
;PRINT VERSION FROM T1		;FALL HERE

PRVERS:	PUSHJ	P,SAVE1##
	PUSH	P,T1		;SAVE FOR LATER
	LSH	T1,-^D24	;POSITION MAJOR VERSION
	ANDI	T1,777		;CLEAR JUNK
	SKIPE	T1		;IF NON-ZERO,
	PUSHJ	P,PRTDI8##	;  PRINT IN OCTAL
	HLRZ	T1,(P)		;GET MINOR VERSION
	ANDI	T1,77		;CLEAR JUNK
	JUMPE	T1,PRVER2	;IF NON-ZERO,
	SUBI	T1,1		;
	IDIVI	T1,^D26		;  PRINT IN ALPHA
	JUMPE	T1,PRVER1	;  ONE OR TWO
	PUSH	P,T2		;  CHARACTERS
	MOVEI	T3,"A"-1(T1)	;  ..
	PUSHJ	P,COMTYO##	;  ..
	POP	P,T2		;  ..
PRVER1:	MOVEI	T3,"A"(T2)	;  ALSO, SECOND ONE
	PUSHJ	P,COMTYO##	;  ..
PRVER2:	HRRZ	T1,(P)		;GET EDIT NUMBER
	JUMPE	T1,PRVER3	;IF NON-ZERO,
	PUSHJ	P,INLMES	;  PRINT (
	ASCIZ	/(/
	HRRZ	T1,(P)		;  GET EDIT NUMBER
	PUSHJ	P,PRTDI8##	;  PRINT IN OCTAL
	PUSHJ	P,INLMES	;  PRINT )
	ASCIZ	/)/
PRVER3:	POP	P,P1		;GET CUST. NUMBER
	LSH	P1,-^D33	;POSITION
	JUMPE	P1,CPOPJ##	;IF NON-ZERO,
	PUSHJ	P,INLMES	;  PRINT -
	ASCIZ	/-/
	MOVEI	T3,"0"(P1)	;  GET DIGIT
	PJRST	COMTYO##	;  PRINT AND RETURN

>	;END	FTVERS
	SUBTTL	EXAMINE AND DEPOSIT COMMAND


;"EXAMINE LOC" - LOOKS A CONTENTS OF LOC AND PRINTS IN OCTAL
;IF LOC IS MISSING, NEXT LOC IS PRINTED
;IF PREVIOUS WAS E COMMAND, SAME LOC IF PREVIOUS WAS D COMMAND
;TAB. IS PRINTED INSTEAD OF CRLF(LIKE DDT)


ECOM::	SKIPGE	.JDAT+JOBEXM##	;WAS PREVIOUS D OR E COMMAND, A D COMMAND?
	AOS	.JDAT+JOBEXM##	;NO, IT WAS AN E, INCREMENT IN CASE HE TYPES NO ARG
	HRROS	.JDAT+JOBEXM##	;YES, FLAG THAT E HAPPENED LAST(LH=-1)
	PUSHJ	P,OCTIN1	;GET OCTAL LOCATION
	SKIPA	T2,.JDAT+JOBEXM##	;NONE SPECIFIED, USE LAST LOC OF D OR NEXT OF E
	JRST	COMERA		;ILLEGAL CHARACTER
	PUSHJ	P,DEAT		;CHECK FOR AC REFERENCE AND STORE JOBEXM
	PUSHJ	P,FLTTC##	;WILL DOING AN EXAMINE CAUSE A PAGE FAULT?
	  JRST	ECOMA		;NO, BUT OUT OF BOUNDS
	  PUSHJ	P,DEGETP	;OUT, GET IT IN
	HRR	M,T2		;IGNORE LH
	MOVEI	T1,0		;ASSUME ALLOCATED BUT ZERO PAGE
	CAIN	T4,PM.ZER	;PAGE ALLOCATED BUT ZERO?
	JRST	ECOM2		;YES, PRINT 0
	PUSHJ	P,GETWRD##	;GET WORD FROM LOW OR HIGH SEG
	JRST	ECOMA		;ERROR, OUT OF BOUNDS
ECOM2:	PUSH	P,T1		;SAVE CONTENTS OF LOC TO BE PRINTED
	HRRZ	T1,.JDAT+JOBEXM##	;PRINT LOC BEING EXAMINED
	PUSHJ	P,OCTPNT##
	PUSHJ	P,INLMES	;PRINT SLASH TAB
	ASCIZ	*/	*
	HLRZ	T1,(P)		;PRINT LEFT HALF
	PUSHJ	P,OCTPNT##
	PUSHJ	P,INLMES	;PRINT SPACE
	ASCIZ	/ /
	HRRZ	T1,(P)		;PRINT RIGHT HALF
	PUSHJ	P,OCTPNT##
	PUSHJ	P,INLMES	;PRINT FINAL TAB
	ASCIZ	/	/
	PUSHJ	P,CLRASA	;CLEAR AC'S IN SHADOW AREA FLAG
	JRST	TPOPJ##		;POP P,T1,POPJ P,
;"DEPOSIT LH RH LOC" - DEPOSITS XWD LH,RH IN LOCATION LOC
;IF LOC IS MISSING, ASSUME NEXT LOC IF PREVIOUS D, SAME LOC IF PREVIOUS E

DCOM::	PUSHJ	P,SAVE1##
	PUSHJ	P,OCTIN1	;GET LH
	JRST	NOTENF		;NOT ENOUGH ARGUMENTS
	JRST	COMERA		;ILLEGAL CHARACTER
	HRLM	T2,S		;SAVE LH
	PUSHJ	P,OCTIN1	;GET RH
	JRST	NOTENF		;NOT ENOUGH ARGUMENTS
	JRST	COMERA		;ILLEGAL CHARACTER
	HRRM	T2,S		;SAVE RH
	MOVE	P1,.JDAT+JOBEXM## ;WAS PREVIOUS D OR E AN E COMMAND?
				; LH=-1 IF E, LH=0 IF D
	JUMPL	P1,DCOM1	;JUMP IF YES
	AOS	P1,.JDAT+JOBEXM## ;NO, INCREMENT IN CASE USER TYPED NO THIRD ARG
				; FOR SUCCESSIVE D'S
DCOM1:	HRRZS	.JDAT+JOBEXM##	;FLAG THAT A D WAS DONE LAST(LH=0)
	PUSHJ	P,OCTIN1	;GET LOC
	  SKIPA	T2,P1		;NOT SPECIFIED, USE LAST OF E OR NEXT OF D
	JRST	COMERA		;ILLEGAL CHARACTER
	PUSHJ	P,CHKMED##	;CHECK TO SEE IF HIGH SEG IS SHARABLE
				; IF YES, SET USER-MODE WRITE PROTECT (UWP) ON
				; FOR THIS USER, AND SET MEDDLE FOR THIS USER
				; SO HE CANNOT TURN UWP OFF
	PUSHJ	P,DEAT		;CHECK FOR AC REFERENCE
	PUSHJ	P,FLTTC##	;WILL DOING A DEPOSIT CAUSE A PAGE FAULT?
	  JRST	ECOMA		;NO, BUT OUT OF BOUNDS
	  PUSHJ	P,DEGETP	;OUT, GET IT IN
	HRR	M,T2		;IGNORE LH
	CAIN	T4,PM.ZER	;PAGE ALLOCATED BUT ZERO?
	PJRST	CREPAG##	;YES, MAKE IT COME TO LIFE
	MOVE	T1,S		;SETUP UP ARG TO PUTWRD
	PUSHJ	P,PUTWRD##	;TRY TO STORE THE WORD IN THE USER'S AREA
	  JRST	ECOMA		;OUT OF BOUNDS
	PJRST	CLRASA		;CLEAR AC'S IN SHADOW AREA FLAG
DEAT:	TLZ	T2,-1		;CLEAR LH IN CASE THIS IS A SUCCESSIVE E WITH NO ARG
	HRRM	T2,.JDAT+JOBEXM## ;STORE FOR NEXT TIME, DO NOT TOUCH LH(D OR E LAST)
				; YES, WAS JOB STOPPED IN USER MODE?
	CAIL	T2,20		;IS IT AN AC?
	POPJ	P,		;NO
	CAME	J,.CPJOB##	;CURRENT JOB?
	PUSHJ	P,SETASA	;NO, INDICATE AC'S ARE IN THE SHADOW AREA
	POPJ	P,		;RETURN


ECOMA:	PUSHJ	P,CLRASA	;CLEAR AC'S IN SHADOW AREA FLAG
	JSP	T1,ERRMES	;OUT OF BOUNDS
OUTBMS::ASCIZ	/Out of bounds
/

;ROUTINE TO GET A PAGE IN AND MAKE IT ACCESSIBLE FOR D/E COMMANDS
DEGETP:	MOVEM	S,.JDAT+JOBFDV##;SAVE S FOR THE CALLER
	POP	P,S		;CALLER'S PC
	JSP	T2,SAVCTX##	;GET TO UUO LEVEL
	PUSH	P,S		;SAVE CALLER'S PC FOR RETURN
	HRRZ	T1,.JDAT+JOBEXM## ;ADDRESS IN QUESTION
	LSH	T1,W2PLSH##	;PAGE IN QUESTION
	PUSHJ	P,SETASA	;SO UUO ARGUMENTS ARE FETCHED CORRECTLY
	PUSHJ	P,PAGIA		;PAGE IT IN, TURN ON ACCESS ALLOWED
	  JRST	[POP P,(P)	;SHOULDN'T HAPPEN BUT PRETEND OUT OF BOUNDS
		 PUSHJ P,TTYFUW## ;PAGIA CLOBBERED U
		 JRST ECOMA]
	PUSHJ	P,TTYFUW##	;FIND THE TTY
	MOVE	S,.JDAT+JOBFDV##;RESTORE CALLER'S S
	MOVE	T2,.JDAT+JOBEXM## ;WHERE TO GET/PUT WORD
	SETZ	T4,		;SO DOESN'T LOOK LIKE AN ABZ PAGE
	JRST	CPOPJ##		;RETURN
;"SCHEDULE" TYPES OUT RH OF STATES, LEGAL FOR ALL.


SKEDUL::HRRZ	T1,STATES##	;SCHEDULE WITH NO ARGUMENTS.
	PUSHJ	P,OCTPNT##	;PRINT RH OF STATES.
	JRST	CRLF		;AND RETURN WITH A CRLF

;"BLANK" OR NO ALPHA NUMERIC BEFORE BREAK CHAR COMMAND
;DISPATCHED TO LIKE ANY OTHER COMMAND(0 IN COMMAND TABLE)



CBLANK::REPEAT	1,<		;WAIT FOR NEXT BATCON AND 5.07
	PUSHJ	P,CTIGLC##	;GET LAST CHARACTER SCANNED
	CAIE	T3,12		;WAS BREAK A LINE-FEED?
	PJRST	COMERA		;NO--ERROR
>
	POPJ	P,		;YES--NULL COMMAND
	SUBTTL	TTY COMMAND AND SET TTY COMMAND

;TTY [DEV[:]] [NO] WORD	;SETS OR CLEARS BITS IN LDBDCH FOR TTY LINE
;DEV ARGUMENT LEGAL ONLY IF ASSIGNED TO YOU OR YOU ARE OPR


TTYCMD::PUSHJ	P,SAVE2##	;SAVE P1
	PUSH	P,U		;SAVE TYPING TTY'S LDB
	HRRZ	P1,U		;ASSUME HIS WILL BE OBJECT
	PUSHJ	P,CTEXT1	;GET AN ARGUMENT
IFN FTNET,<
	CAIE	T3,"_"		;START OF NODE_LINE?
	JRST	TTYC0		;NO, CHECK IF DEVICE
	POP	P,U		;FIX STACK FOR CO-ROUTINING
	NETDBJ			;INTERLOCK THIS PART
	MOVE	T1,T2		;PUT IN RIGHT PLACE FOR NETSER
	PUSH	P,U		;SAVE OUR LINE AGAIN
	PUSHJ	P,SRCNDB##	;FIND THE NODE BY NAME
	 JRST	[JSP	T1,TTYCF	;NODE DOES NOT EXIST
		 ASCIZ	/Node does not exist
/]
	MOVE	P1,T1		;SAVE THE STATION NAME
	PUSHJ	P,CTEXT		;GET THE DEVICE NAME
	JUMPE	T2,NOTENP	;ILLEGAL ARG LIST
	MOVE	P2,T2		;SAVE THE DEVICE NAME
	TRNE	T2,505050	;MUST BE NUMERIC GGGU
	JRST	NOTDV1		;ERROR RETURN
	TLNE	P2,505050	;IS LH A NUMBER?
	JRST	TTYC0B		;NO, CONTINUE NORMALLY
	MOVSS	P2		;FLIP HALVES OF ARGUMENT
TTYC0A:	TRNE	P2,77		;IS RIGHTMOST DIGIT ZERO?
	JRST	TTYC0C		;NO, DONE
	LSH	P2,-6		;SHIFT RIGHT ONE DIGIT
	JRST	TTYC0A		; AND TRY AGAIN
TTYC0C:	TRO	P2,202020	;MAKE IT ALL DIGITS
	HRLI	P2,(SIXBIT/TTY/); AND MAKE LH SAY TTY
TTYC0B:	MOVE	T2,P2		;RESTORE DEVICE NAME
	HLRZ	P1,NDBNNM##(W)	;GET NODE #
	CAMN	P1,JBTLOC##	;LOCAL NODE?
	JRST	TTYC0D		;YES, JUST RETURN
	MOVEI	P1,(W)		;SAVE THE NDB POINTER
	HLRZ	T1,P2		;GENERIC NAME ONLY FROM THE LEFT HALF
	CAIE	T1,'TTY'	;IS IT A TTY?
	JRST	[JSP	T1,TTYCF	;NO. COMPLAIN.
		 ASCIZ	/Not a TTY/]
	HRLZ	T1,P2		;GET THE REMOTE LINE NUMBER
	PUSHJ	P,CVTOCT##	;CONVERT IT TO OCTAL
	  JRST	NOTDV1		;NON NUMERIC LINE NUMBER
	HLL	T1,NDBNNM(W)	;GET THE NODE NUMBER
	PUSHJ	P,GTXTN##	;AND TRY TO CONVERT THE PAIR TO "TTYNNN"
	 JRST	[JSP	T1,TTYCF	;NOT IMMEDIATELY AVAILABLE
		 ASCIZ	/Not connected/]
	MOVE	T2,T1		;COPY THE DEVICE NAME
	JRST	TTYC0D		;WE SUCCEDED.  T2 := DEVICE NAME

TTYC0:
> ;END IFN FTNET
	CAIE	T3,":"		;DEVICE?
	JRST	TTYC1		;NO. A WORD.
	MOVE	T1,T2		;GET THE DEVICE.
TTYC0D:	PUSHJ	P,DEVNFS##	;FIND THE DEVICE
	  JRST	TTYCE		;NO SUCH DEVICE
	MOVE	T2,DEVMOD(F)	;GET DEVICE TYPE BITS
	TLNE	T2,DVTTY	;IS IT A TTY?
	TLNE	T2,DVDSK	;  AND NOT NUL?
	JRST	TTYCE		;NO, ERROR
	HRRZ	U,DDBLDB##(F)	;GET LDB ADDRESS
	PUSHJ	P,TTYKLQ##	;GIVE BACK TTY DDB IF NECESSARY
	JUMPE	U,TTYCE		;MAKE SURE WE GOT AN LDB ADDRESS
	HRRZ	P1,U		;STORE AS OBJECT OF COMMAND
	MOVE	U,0(P)		;RESTORE LDB FOR TYPER
	PUSHJ	P,SKIPS		;DISCARD THE COLON
	  JRST TTYCE		;SHOULDNT BE END OF LINE
	HRRZ	P2,U		;SEE IF THIS IS OPR
	PUSHJ	P,SETLGL	;SKIP IF OPR
	CAIN	P2,(P1)		;HIS OWN TTY?
	JRST	TTYCL		;YES. OK.
	LDB	T2,PJOBN##	;NO. WHO OWNS THE TTY IN QUESTION
	JUMPE	T2,TTYCE	;LOSE IF NOBODY
	CAIE	T2,(J)		;OK IF US
	JRST	TTYCE		;OTHERWISE FAIL

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

TTYCL:	MOVE	U,0(P)		;RESET LINE TO TYPER
	PUSHJ	P,SKIPS1	;SEE IF ANY MORE ON LINE.
	  JRST	[MOVE   U,P1	;POINT TO TARGET
		 PUSHJ	P,SETCHP##
		 JRST   UPOPJ##];RESTORE U AND RETURN
	PUSHJ	P,CTEXT1	;YES. SEE WHAT IT IS
TTYC1:	MOVE	T1,[-TTCWDN,,TTCWDT]	;POINT TO NAMES
	PUSHJ	P,FNDNAM	;FIND ABBREV.
	  JRST	TTYC4		;ERROR
	HRRZ	T2,TTCWDD(T1)	;GET RESULT
	HRRZ	T3,TTCDAT(T1)	;GET FLAGS FOR COMMAND
TTYC2:	HRRZ	T4,LINTAB##+FRCLIN## ;GET LDB ADDRESS OF FRCLIN
	CAIN	T4,(P1)		;IS TARGET FRCLIN?
	TRNN	T3,TT.CIF	;YES, IS THIS FUNCTION ILLEGAL?
	PUSHJ	P,(T2)		;DISPATCH TO ROUTINE
	  JRST	TTYCE		;ERROR
	JRST	TTYCL		;LOOK FOR MORE
TTYC4:	MOVE	T1,[-TTTWDN,,CTTWDT] ;AOBJN POINTER TO TYPES TABLE
	PUSHJ	P,FNDNAM	;SEE IF RECOGNIZED TERMINAL TYPE
	  JRST	TTYCE		;NO, CALL AN ERROR
	MOVEI	T2,TTUTYX	;DISPATCH ADDRESS TO PROCESS TERMINAL TYPE
	MOVEI	T3,TT.CIF	;THIS FUNCTION IS ILLEGAL ON FRCLIN
	HRRZ	U,P1		;SETUP TARGET LDB
	JRST	TTYC2		;GO DISPATCH
TTYCE:	POP	P,U		;RESTORE LINE FROM STACK
	JRST	COMERR		;AND GO COMPLAIN.
TTYCF:	POP	P,U		;RESTORE LINE FROM STACK
	PJRST	ERRMES		;AND GIVE OUR MESSAGE
;TABLE FOR SET TTY COMMAND
;MACRO HAS 5 ARGUMENTS:
;	NAME  -  WORD USED IN TTY COMMAND
;	DISP  -  DISPATCH LOCATION TO PROCESS WORD
;	OFST  -  OFFSET WITHIN LDB WHERE ANSWER IS STORED
;	DATA  -  18 BITS OF DATA USED BY PROCESSING ROUTINE
;	BITS  -  FLAGS FOR THIS COMMAND

	TT.CIF==1B18		;THIS COMMAND IS ILLEGAL ON FRCLIN

	DEFINE	TTNAME,<
	TT	ALTMODE,TTCCLR,LDBPAG##,LPLALT##,0
IFN FTTBLK,<
	TT	BLANKS,TTCCLR,LDBPAG##,LPLBLK##,0
> ;END FTTBLK
	TT	COPY,TTCESC,"_","^",0
	TT	CRLF,TTCCLR,LDBDCH##,LDLNFC##,0
IFN FT2741,<
	TT	DEBREAK,TTCSET,LDBISR##,LILDBK##,0
> ;END FT2741
	TT	DEFER,TTRSET,LDBBYT##,L1RDEM##,0
	TT	DISPLAY,TTCSET,LDBPAG##,LPLDIS##,0
	TT	ECHO,TTCCLR,LDBDCH##,LDLLCP##,0
IFN FT2741,<
	TT	ELEMENT,TTCELE,0,0,0
>;IFN FT2741
 ;	TT	FFHOME,TTCSET,LDBPAG##,LPLFFH##,TT.CIF
 ;	TT	FFSIMU,TTCSET,LDBPAG##,LPLFFF##,TT.CIF
IFN FTTPAG,<
 ;	TT	FFSTOP,TTCSET,LDBPAG##,LPLFFS##,TT.CIF
> ;END FTTPAG
	TT	FILL,TTCNUM,LDPFLC##,3,0
ifn stupid,<TT	flowcontrol,ttcset,ldbqzb##,lqlflc##,0>
	TT	FORM,TTCSET,LDBDCH##,LDLFRM##,0
	TT	GAG,TTCCLR,LDBBY2##,L2LSND##,0
	TT	HOLD,TTCESC,"\",<"[">,TT.CIF
	TT	IGNORE,TTCIGN,0,0,TT.CIF
	TT	LC,TTCCLR,LDBDCH##,LDLLCT##,TT.CIF
IFN FTTPAG,<
	TT	LENGTH,TTCNUM,LDPLNB##,^D255,TT.CIF
> ;END FTTPAG
IFN FTLINK,<				;[link] allow or disallow links.
	TT	LINK,TTCCLR,LDBLNK##,LNKREF,TT.CIF	;[link]
>							;[link]
IFN FTCIMP,<					;[arpa]
	TT	LOCAL,TTCIMC,LDBQUO##,2,TT.CIF	;[arpa] set local escape char
	TT	NETWORK,TTCIMC,LDBQUO##,3,TT.CIF;[arpa] set network escape char
	TT	N,TTCNO,0,0			;[arpa] make N still equal NO
>						;[arpa]
ifn stupid,<TT	meta,ttcset,ldbqzb##,lqlmet##,0>
	TT	NO,TTCNO,0,0,0
IFN FTTPAG,<
	TT	PAGE,TTCPAG,LDPSTB##,^D255,TT.CIF
> ;END FTTPAG
IFN FTCIMP,<					;[arpa]
	TT	QUOTE,TTCIMC,LDBQUO##,0,TT.CIF	;[arpa] set network quote char
>						;[arpa]
ifn stupid,<TT	quiet,ttcset,ldbqzb##,lqlqui##,0>
	TT	RTCOMP,TTCSET,LDBISR##,LILRTC##,0
	TT	REMOTE,TTCREM,LDBDCH##,LDRRMT##,TT.CIF
IFN FTCIMP,<					;[arpa]
	TT	SHIFT,TTCIMC,LDBQUO##,1,TT.CIF	;[arpa] set net shift char
>						;[arpa]
IFN FTTPAG,<
	TT	SBELL,TTCSET,LDBPAG##,LPLSBL##,TT.CIF
> ;END FTTPAG
	TT	SLAVE,TTCSLV,LDBDCH##,LDLSLV##,TT.CIF
	TT	SPEED,TTCSPD,0,0,TT.CIF
IFN FTTPAG,<
	TT	SSTOP,TTCSST,LDPSTB##,^D255,TT.CIF
	TT	STOP,TTCSTP,LDPSTB##,^D255,TT.CIF
> ;END FTTPAG
	TT	subtyp,ttcsub,0,0,0
	TT	TABS,TTCSET,LDBDCH##,LDLTAB##,0
	TT	TAPE,TTCTAP,LDBBY2##,L2LTAP##,TT.CIF
IFN FT2741,<
	TT	TIDY,TTCSET,LDBISR##,LILTDY##,0
>	TT	TYPE,TTCTYP,0,0,TT.CIF
	TT	UC,TTCSET,LDBDCH##,LDLLCT##,TT.CIF
	TT	WIDTH,TTCNUM,LDPWID##,<^D17*^O1000+^D255>,0
	TT	XONXOF,TTCSET,LDBPAG##,LPLXNF##,0
IFN FTPATT,<
	TT	.PATCH,TTYCL,0,0
> ;END FTPATT
> ;END TTNAME MACRO
	XALL
	DEFINE	TT(NAME,DISP,OFST,DATA,BITS),<
	<SIXBIT	/NAME/>
	>
	$LOW
TTCWDT::TTNAME
TTCWDN==.-TTCWDT
TTCMXL==:<TTCWDN-1>B26
	$HIGH
$HIGH
	DEFINE	TT(WORD,DISP,OFST,DATA,BITS)<
	XWD	OFST,DISP
>

TTCWDD:	TTNAME
	DEFINE	TT(WORD,DISP,OFST,DATA,BITS)<
	XWD	DATA,BITS
>

TTCDAT:	TTNAME



	SALL
;here to process terminal subtype comand.
ttcsub:	pushj	p,ctext1	;get argument, if any
	movem	t2,ldbqzs##(p1)	;LDB pointer in right half of p1, beware
	jrst	cpopj1##	;skip return

;HERE TO PROCESS 'TTY SPEED'
TTCSPD:	PUSHJ	P,NUMARG	;GO GET A NUMBER
	  POPJ	P,		;MUST BE ONE
	PUSHJ	P,TTCSP1	;FIND SPEED IN TABLE
	  POPJ	P,		;NOT THERE
	PUSH	P,P2		;SAVE RECEIVE SPEED
	CAIN	T3,","		;ENDED WITH A COMMA?
	PUSHJ	P,COMTYS	;YES, SKIP IT
	PUSHJ	P,NUMARG	;GO GET NEXT NUMBER
	  JRST	[MOVE P2,0(P)	;NONE, USE RECEIVE SPEED
		 JRST TTCSP0]	;AND SKIP TABLE LOOKUP
	PUSHJ	P,TTCSP1	;CHECK TRANSMIT SPEED IN TABLE
	  JRST	TPOPJ		;NOT THERE, ERROR
TTCSP0:	MOVE	U,P1		;SETUP TARGET LDB
	DPB	P2,LDPTSP##	;SAVE XMIT SPEED
	POP	P,P2		;RESTORE RECEIVE SPEED
	DPB	P2,LDPRSP##	;SAVE RECEIVE SPEED
	JRST	CPOPJ1##	;GIVE GOOD RETURN

TTCSP1::MOVSI	P2,-LSPLEN	;LENGTH OF TABLE
	CAME	T2,LSPTAB(P2)	;IS THIS IT?
	AOBJN	P2,.-1		;NO--KEEP LOOKING
	JUMPL	P2,CPOPJ1##	;FOUND
	POPJ	P,0		;LOST
	RADIX	10
LSPTAB::	EXP	0,50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,1,2
LSPLEN==:.-LSPTAB
	RADIX	8
IFN FT2741,<
;HERE TO PROCESS 'TTY ELEMENT'
SET987:	SKIPA	T2,[EXP ^D987]
SET988:	MOVEI	T2,^D988
	MOVE	P1,U
	JRST	TTCEL1
TTCELE:	PUSHJ	P,NUMARG	;GO GET THE NUMBER
	  POPJ	P,0		;MUST BE ONE
TTCEL1:	MOVE	T3,T2		;SETUP CORRECT AC
IFN FTNET,<
	MOVEI	T1,LDRREM##	;GET REMOTE BIT
	TDNE	T1,LDBDCH##(P1)	;CHECK IT
	JRST	TTCEL2		;YES, CONTINUE
>
	SKIPL	LDBISR##(P1)	;IS THIS A DC76 LINE?
	JRST	CPOPJ1##	;NO--MAKE A NO OP
IFN FTNET,<
TTCEL2:
>
	EXCH	U,P1		;D76ELE USES LDPLNO
	MOVEI	T1,ISRELE##	;FUNCTION
	PUSHJ	P,@LDBISR##(U)	;CALL ISR
	  SOS	(P)		;PASS ON NON-SKIP
	EXCH	P1,U		;RESTORE AC'S
	JRST	CPOPJ1##	;RETURN
>;IFN FT2741
;HERE TO PROCESS TTY IGNORE
TTCIGN:	MOVE	U,P1		;COPY LDB ADDRESS
	LDB	T1,LDPTSP##	;GET TRANSMIT SPEED
	SKIPL	P1		;SKIP IF 'NO'
	SETZM	T1		;NO--CLEAR T1
	DPB	T1,LDPRSP##	;SET TO RECEIVE SPEED
	TLZ	P1,-1		;CLEAR YES/NO FLAG
	JRST	CPOPJ1##	;RETURN
;HERE TO PROCESS 'TTY REMOTE'
TTCREM:	JUMPGE	P1,TTRSET	;ANYONE CAN THROW AWAY GOODNESS
				; (AND ONLY GOOD GUYS CAN GET GOOD TTY'S)
	PUSHJ	P,PRVJ		;BUT SETTING GOODNESS REQUIRES GOODNESS
	JRST	TTRSET		;TYPER IS ADEQUATELY PRIVILEGED
	POPJ	P,		;PRIVILEGED COMMAND BUT NO PRIVILEGES
IFN FTCIMP,<	;[arpa]

;[arpa] HERE TO PROCESS SPECIAL IMP CHARACTER SETTINGS

;[arpa] COMMANDS ARE:

;[arpa] SET TTY (NO) QUOTE	;INITIAL SETTING: CTRL-Q
;[arpa] SET TTY (NO) SHIFT	;NO INITIAL SETTING
;[arpa] SET TTY (NO) LOCAL	;(LOCAL ESCAPE) INITILAL SETTING: CTRL-BACKARROW
;[arpa] SET TTY (NO) NETWORK	;(NETWORK ESCAPE) NO INITIAL SETTING

;[arpa]   NULL ARGUMENT IS EQUIVALENT TO (NO). ARGUMENT IS A SINGLE CHARACTER,
;[arpa]   WHICH MUST NOT BE ALPHABETIC, BLANK, ESCAPE OR RUBOUT (QUOCHK IN
;[arpa]   SCNSER CHECKS THIS). ALSO, IT MUST NOT ALREADY BE IN USE AS A
;[arpa]   SPECIAL CHARACTER . SEE IMP HELP ESCAPE/CONTROL FOR MORE INFORMATION.

TTCIMC:	PUSH	P,T1		;[arpa] PRESERVE AGAINST THE MORROW
	SETZ	T3,		;[arpa] ASSUME CLEARING
	JUMPL	P1,TTCIM1	;[arpa] INSTRUCTION IS (NO)
	PUSHJ	P,SKIPS		;[arpa] RETURNS NEXT NON-BLANK CHAR IN T3
	 JFCL			;[arpa] IGNORE CRLF RETURN
TTCIM1:	HRRZ	U,P1		;[arpa] GET LDB BEING AFFECTED
	MOVE	T1,(P)		;[arpa] RECOVER T1 JUST TO BE SURE
	HLRZ	T4,TTCDAT(T1)	;[arpa] GET CODE: 0=QUOTE, 1=SHIFT, 2=LOCAL, 3=NET
	PUSHJ	P,QUOCHK##	;[arpa] CHECK IT OUT AND STORE IF OK
	 JRST	TTCIME		;[arpa] BLEW IT
	POP	P,T1		;[arpa] RETURN OF THE NATIVE SON
	MOVSI	T4,LQLDWN##	;[arpa] IF TTY SHIFT, CLEAR DOWNSHIFT FLAG
	HLRZ	T2,TTCDAT(T1)	;[arpa] CODE AGAIN, PLEASE
	CAIN	T2,1		;[arpa] IS IT SHIFT?
	 ANDCAM	T4,LDBQuo##(u)	;[arpa] CLEAR DOWNSHIFT
	JUMPE	T3,CPOPJ1##	;[arpa] IF NO ARG, RETURN
	PUSHJ	P,COMTYS	;[arpa] CLEAN UP ANY EXTRA
	PJRST	CPOPJ1##	;[arpa] DEPART

TTCIME:	POP	P,T1		;[arpa] BAD CHARACTER - ADJUST STACK AND PRINT MSG
	JSP	T1,ERRMES	;[arpa]
	ASCIZ	/Illegal value or character in use
/
> ;[arpa] END IFN FTCIMP
;HERE TO DO 'TTY PAGE'
IFN FTTPAG,<
TTCPAG:	PUSH	P,T1		;SAVE INDEX
	MOVEI	T1,LDBPAG##(P1)	;ADDRESS OF WORD
	MOVSI	P2,LPLXNF##+LPLSTP##	;PAGE BIT
	PUSHJ	P,TTCST1	;GO SET OR CLEAR IT
	  JFCL			;CAN NOT MISS
	PUSHJ	P,NUMARG	;GO READ IN ANY NUMERIC ARGUMENT
	 JRST	TPOPJ1##	;NO CHANGE IN PAGE SIZE
	POP	P,T1		;RESTORE INDEX
	PUSHJ	P,TTCNUP	;PROCESS THE NUMBER
	 POPJ	P,		;OUT OF RANGE
	EXCH	U,P1		;POINT U TO THE LDB
	DPB	T2,LDPLNB##	;ALSO SET TERMINAL LENGTH
	EXCH	P1,U		;RESTORE U
	JRST	CPOPJ1##	;SUCCESSFUL RETURN

;HERE TO DO 'TTY STOP'
TTCSTP:	PUSH	P,T1		;SAVE INDEX
	MOVEI	T1,LDBPAG##(P1)	;ADDRESS OF PAGING CONTROL
	MOVSI	P2,LPLSTP##	;AUTO STOP BIT
	JRST	TTCSS2		;COMMON CODE

;HERE TO DO 'TTY 'SSTOP'
TTCSST:	PUSH	P,T1		;SAVE INDEX
	MOVEI	T1,LDBPAG##(P1)	;ADDRESS OF PAGING CONTROL
	MOVSI	P2,LPLSTP##+LPLSST##  ;AUTO STOP BITS
TTCSS2:	PUSHJ	P,TTCST1	;GO SET/CLEAR BITS
	 JFCL			;DUH?
	PUSHJ	P,NUMARG	;SEE IF ANY NUMERIC ARGUMENT
	 JRST	TTCSS5		;NO, SEE IF NEED TO DEFAULT STOP SIZE
	POP	P,T1		;RESTORE INDEX
	PUSHJ	P,TTCNUP	;YES, PROCESS IT
	 POPJ	P,		;OUT OF RANGE
	JRST	CPOPJ1##	;SUCCESSFUL RETURN

TTCSS5:	POP	P,T1		;RESTORE INDEX
	EXCH	U,P1		;POINT U TO THE LDB
	LDB	P2,LDPSTB	;GET SIZE OF STOP BASE
	JUMPN	P2,TTCSS6	;IF SET THEN DON'T DEFAULT IT
	LDB	P2,LDPLNB	;PICK UP TTY LENGTH
	DPB	P2,LDPSTB	;AND USE IT FOR THE TTY STOP VALUE
TTCSS6:	EXCH	P1,U		;RESTORE U
	JRST	CPOPJ1##	;SUCCESSFUL RETURN
> ;END FTTPAG
;HERE TO DO 'TTY SLAVE'
TTCSLV:	PUSH	P,T1		;SLAVE INDEX
	PUSH	P,U		;CLEAR
	MOVEI	U,(P1)		;TARGET'S INPUT
	PUSHJ	P,TSETBI##	;CLEAR INPUT BUFFER
	POP	P,U
	POP	P,T1		;RESTORE INDEX
	SKIPL	P1		;WANT TO CLEAR?
	JRST	TTCSET		;NO--LEAVE LDLCOM ALONE
	MOVSI	P2,LDLCOM##	;YES--SET LINE INTO
	IORM	P2,LDBDCH##(P1)	; COMMAND MODE
	PJRST	TTCSET		;GO SET SLAVE BIT

;HERE TO SET A RIGHT HALF WORD BIT
TTRSET:	HLRZ	P2,TTCDAT(T1)
	JRST	TTCST2

;HERE TO SET/CLEAR BITS IN THE LDB
TTCCLR:	TLC	P1,-1		;COMPLEMENT THE SENSE
TTCSET:	HLLZ	P2,TTCDAT(T1)	;PICK UP FLAG
TTCST2:	HLRZ	T1,TTCWDD(T1)	;PICK UP OFFSET
	ADD	T1,P1		;GET ACTUAL ADDRESS
TTCST1:	SKIPL	P1		;WANT TO CLEAR?
	SKIPA	T2,[IORM P2,(T1)]	;NO--GO SET
	MOVSI	T2,(ANDCAM P2,(T1))	;YES--CLEAR
	XCT	T2
	HRRZ	P1,P1		;CLEAR FLAG
	PJRST	CPOPJ1##	;SKIP RETURN

;HERE ON THE WORD NO
TTCNO:	TLC	P1,-1		;COMPLEMENT FLAG
	JRST	CPOPJ1##	;SKIP RETURN

;HERE TO SEND AN ESCAPE SEQUENCE
TTCESC:	PUSH	P,T1		;SAVE T1
	MOVE	U,P1		;COPY LDB ADDRESS
	MOVEI	T3,33		;SEND OUT AN
	PUSHJ	P,COMTYO##	; ESCAPE
	POP	P,T1		;RESTORE INDEX
	HLRZ	T3,TTCDAT(T1)	;ASSUME NORMAL COMMAND
	SKIPGE	P1		;DID HE SAY NO?
	HLRZ	T3,TTCWDD(T1)	;YES--GET ALTERNATE BYTE
	PUSHJ	P,COMTYO##	;SEND TO TTY
	JRST	CPOPJ1##	;GOOD RETURN
;HERE TO PROCESS A NUMBER
TTCNUM:	PUSH	P,T1		;SAVE INDEX
	PUSHJ	P,NUMARG	;GO READ A NUMBER
	  MOVEI	T2,0		;NONE THERE DO DEFAULT
	POP	P,T1		;RESETORE INDEX
TTCNUP:	LDB	P2,[POINT 9,TTCDAT(T1),8]	;IS NUMBER BELOW
	CAMGE	T2,P2		;THE MIN VALUE
	POPJ	P,0		;YES
	LDB	P2,[POINT 9,TTCDAT(T1),17]	;IS NUMBER ABOVE
	CAMLE	T2,P2		;THE MAX
	POPJ	P,0		;YES -- ERROR
	HLRZ	T1,TTCWDD(T1)	;ADDRESS OF BYTE POINTER
	EXCH	U,P1
	...DPB	T2,(T1)		;STORE
	EXCH	U,P1
	TLZ	P1,-1		;CLEAR THE "CLEAR" FLAG
	JRST	CPOPJ1##	;SKIP RETURN

;HERE TO PROCESS SET TTY (NO) TAPE COMMAND
;ROUTINE REMEMBERS TO CLEAR L2RXON
TTCTAP:	MOVEI	T2,L2RXON##	;GET REAL STATUS BIT
	SKIPGE	P1		;IS THIS NO TAPE?
	ANDCAM	T2,LDBBY2##(P1)	;YES, CLEAR BIT
	PJRST	TTCSET		;THEN GO DO L2LTAP

;HERE TO PROCESS TTY TYPE COMMAND
TTCTYP:	PUSHJ	P,CTEXT1	;GET TERMINAL TYPE
	HRRZ	U,P1		;GET LDB ADDRESS
TTUTYP::MOVE	T1,[-TTTWDN##,,CTTWDT##] ;AOBJN POINTER TO TYPES TABLE
	PUSHJ	P,FNDNAM	;FIND THE TERMINAL TYPE
	  POPJ	P,		;FAT FINGERS
TTUTYX:	SUBI	T1,TTTWDT##-CTTWDT## ;TYPE
	setzm	ldbqzs##(u)	;update subtype too
	AOS	(P)		;SUCCESS
	JRST	SETTTC##	;SET DEFAULT CHARACTERSITICS
	SUBTTL	FINISH AND CLOSE COMMANDS

; "FINISH DEVICE" - CLOSES,RELEASE AND DEASSIGNS DEVICE
;JOB MUST HAVE CORE

CFINI::	TDZA	T1,T1		;FINISH - SET T1=0
CLSCOM::SETO	T1,		;CLOSE - T1=-1
	MOVEM	T1,.JDAT+JOBFDV## ;SAVE WHICH COMMAND IN JOBDAT
	PUSHJ	P,SETASA	;SET JS.ASA
	PUSHJ	P,CTXDEV	;GET DEVICE NAME
	JUMPE	T2,FINALL	;ALL DEVICES IF NO OTHER ARG
	MOVE	T1,T2		;PUT NAME IN RIGHT AC
	PUSH	P,U		;SAVE ADDR OF TTY LDB
	PUSHJ	P,DEVSRG##
	  JRST	NOTDV1		;PRINT NOT A DEVICE
	HRRM	F,.JDAT+JOBFDV##  ;STORE DDB ADR. IN JOB DATA AREA
	POP	P,U		;RESTORE ADDR OF TTY LDB
	MOVEI	T1,[ASCIZ /Not legal for disk-like devices
/]
	MOVE	T2,DEVMOD(F)	;IS IT A DISK?
	TLNE	T2,DVDSK
	JRST	ERRMES		;YES,MIGHT BE SEVERAL DDBS,DON'T TRY
	PJSP	T2,MSTART##	;SETUP MONITOR JOB AND RETURN
				; RETURN HERE AT UUO LEVEL WHEN SCHEDULED
	JSP	T1,MONSTR##	;SETUP ACS,R,P
	HRRZ	F,.JDAT+JOBFDV##  ; AND R
	MOVEI	T1,ASSPRG	;SEE IF
	TDNN	T1,DEVMOD(F)	; OPEN
	JRST	[SKIPGE	.JDAT+JOBFDV##	;SEE IF FIN
		JRST	.+1	;NO -- DO IT ANYWAY
		TLZ	M,NOPER##!NOCRLF##!TTYRNU##
		TLO	M,CMWRQ## ;FIX FLAGS FOR DEASSIGN
		PUSHJ	P,DEASI1 ;DEASSIGN
		JRST	CFINIX]	;STOP JOB
	PUSHJ	P,CFIN		;DO THE ACTUAL FIN (OR CLOSE)
	JRST	CFINIX		;STOP JOB SO HE CANNOT CONTINUE
;SUBROUTINE TO DO ACTUAL FIN
CFIN:	PUSHJ	P,SAVE1##	;SAVE P1
	MOVEI	P1,0		;START AT CHANNEL 0
FDVI:	PUSHJ	P,NXTCH##	;GET NEXT DEVICE
	  JRST	FDV3
	HRRZ	F,.JDAT+JOBFDV## ;GET DEV TO RELEASE
	CAIE	F,(T1)		;IS THIS WHAT WE WANT TO CLOSE?
	JRST	FDVI		;NO, CONTINUE
	PUSHJ	P,WAIT1##	;WAIT FOR INACTIVE DEVICE
	MOVSI	T2,DVTTY	;SET UP TTY BIT
	SKIPN	.UPMP+.UPVRT	;IF VIRTUAL JOB
	TDNE	T2,DEVMOD(F)	;OR IF I/O TO A TTY
	SETZM	DEVBUF(F)	;THEN FORGET BUFFERS
	SKIPN	.UPMP+.UPVRT	;IF VIRTUAL JOB
	JRST	FDV2		;NOT THE CASE
	MOVSI	T3,0		;SET UP
	PUSHJ	P,RTIEVM##	;TELL MONITOR ABOUT BUFFERS
	MOVSI	T3,0
	PUSHJ	P,RTOEVM##
FDV2:	PUSH	P,DEVMOD(F)
	PUSH	P,.JDAT+SGANEW
	PUSH	P,.JDAT+SGAHGH
	MOVE	T1,[1,,SGAHGH]
	MOVSI	T2,-1(P1)
	HRRI	T2,7
	SKIPL	.JDAT+JOBFDV##
	HRRI	T2,23
	DMOVEM	T1,.JDAT+SGANEW
	FILOP.	SGANEW,
	  JFCL
	POP	P,.JDAT+SGAHGH
	POP	P,.JDAT+SGANEW
	POP	P,T1
	TRNN	T1,ASSCON
	POPJ	P,
FDV3:	MOVE	J,.CPJOB##	;GET JOB NUMBER
	SKIPL	F,.JDAT+JOBFDV##  ;RESET F, SKIP IF NOT FIN
	PUSHJ	P,DEASG		;DEASSIGN DEVICE IF FIN
	  POPJ	P,		;IGNORE IF NOT ASSIGNED BY CONSOLE
	POPJ	P,
;HERE TO FIN ALL DEVICES JOB OWNS
FINALL:	PJSP	T2,MSTART##	;SETUP MONITOR JOB, RETURN AT UUO LEVEL
	JSP	T1,MONSTR##	;SETUP R, R,P
	HLRZ	F,DEVLST##	;START OF DDB CHAIN
FINAL1:	LDB	T1,PJOBN##	;JOB WHICH OWNS DEVICE
	HRRM	F,.JDAT+JOBFDV## ;SAVE DDB ADDR IN CASE CFIN IS CALLED
	CAMN	T1,.CPJOB##	;THIS JOB OWN DEVICE?
	PUSHJ	P,CFIN		;YES, FIN (OR CLOSE) IT
	PUSHJ	P,NXDDB##	;STEP TO NEXT DDB
	  SKIPE	F		;DONE IF 0
	JRST	FINAL1		;TEST NEXT
CFINIX:	HRRZS	JBTPC##(J)	;NOT IN ANY I/O WAIT ANYMORE
	PUSHJ	P,CLRASA	;CLEAR JS.ASA
	PUSHJ	P,TTYFNU##	;DONE. FIND TTY LINE FOR JOB
	PJRST	HOLD##		;STOP JOB
;"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK


FREDEV::PUSHJ	P,SAVE2##	;SAVE P1=P2
	PUSHJ	P,DSKRES##	;PRINT DISK INFO
	HLRZ	P1,DEVLST##	;GET DDB POINTER
	MOVEI	P2,0		;SET DEVICE NAME 0 FOR FIRST COMPARE
LOP01:	MOVE	T1,DEVMOD(P1)	;DEVICE CHARACTERISTICS
	TRNN	T1,ASSCON!ASSPRG	;DEVICE ASSIGNED BY CONSOLE OR PROGRAM?
	TLNE	T1,DVTTY!DVDSK	;NO, IS IT A TTY OR DSK?
	JRST	LOP02		;YES DO NOT PRINT
	HLRZ	T1,DEVNAM(P1)	;GET NAME OF NEXT DEVICE IN CHAIN
	SKIPE	DEVNAM(P1)	;DON'T PRINT COMMA IF NO NAME
	CAIN	T1,(SIXBIT /PTY/)	;A PSEUDO TELETYPE?
	JRST	LOP02		;YES. DONT MENTION IT.
	JUMPE	P2,LOP01B	;SUPPRESS LEADING COMMA
	PUSHJ	P,PRCOM		;PRINT COMMA
LOP01B:	MOVS	P3,DEVNAM(P1)	;GET DEVICE NAME
	HLLZ	T2,P3		;ASSUME SAME TYPE AS LAST ONE, PRINT
				; ONLY RH OF NAME (UNIT NUMBER)
	CAIN	P2,0(P3)	;IS IT REALLY THE SAME?
	JRST	LOP01A		;YES. PRINT THE UNIT NUMBER.
	MOVS	T2,P3		;NO. MUST PRINT WHOLE NAME,
	HRRZ	P2,P3		; AND GET THE NEW DEVICE IN FLAG AC.
LOP01A:	PUSHJ	P,PRNAME##	;AS BEING FREE
LOP02:	HLRZ	P1,DEVSER(P1)	;GET NEXT DEVICE IN CHAIN
	JUMPN	P1,LOP01	;IS THERE ONE?
	JRST	CRLF		;NO. DONE. PRINT CR, LF AND THEN POPJ
	SUBTTL	SUBROUTINES -- COMMAND SETUP
;ROUTINE TO CHECK FOR ACTIVE DEVICES
;NEVER GET HERE DURING SWAP IN OR OUT
;SINCE COMMAND TABLE SHOULD HAVE NOTRAN BIT ON

RUNCHK:	JUMPE	R,RUNCH1	;DOES JOB HAVE CORE IN MEMORY?
IFN FTMP&FTKL10,<
	PUSHJ	P,CHKCSH##	;MAKE SURE CPU1'S CACHE HAS BEEN
				; SWEPT FOR THIS JOB
>
	  PUSHJ	P,ANYACT##	;YES, ARE DEVICES ACTIVE?
	  JRST	RUNCK2		;YES, DELAY COMMAND.
RUNCH1:	HRRZ	F,LDBDDB##(U)	;RESTORE F
	POPJ	P,

RUNCK2:	POP	P,(P)		;POP OFF RETURN ADDRESS (WE AREN'T GOING TO RETURN)
	JRST	CHKDLY		; AND DELAY THE COMMAND
;ROUTINE TO DELAY A COMMAND

;DELAYS COMMAND TO BE EXECUTED WHEN JOB IN CORE MEMORY
;AND CAUSES JOB TO BE SWAPPED IN(COMMAND WAIT BIT IS SET IN JBTSTS)
;AND POPS LEVEL UP ONE.


DLYCM::	PUSHJ	P,DLYCOM##	;SET COMMAND WAIT BIT IN JOB STATUS AND PUT
				; JOB IN COMMAND WAIT QUEUE
				; SO JOB IS NOT RUNNABLE ANY MORE
;ROUTINE TO DELAY A COMMAND IF A SWAP OUT OR IN IS IN PROGRESS
;DIFFERS FROM DLYCM IN THAT JOB IS NOT MADE TO BE SWAPPED IN
;REQUIRED FOR DELAYING COMMAND IF SYSTEM
;TAPE USER TYPES ^C (HALT COMMAND)

DLYCM1:	AOS	LINSAV##	;INCR. COMMAND POINTER SO NEXT CALL
				; BY COMMAND DECODER CALL START SCANNING
				; WITH LINE AFTER DELAYED COMMAND.
DLYCM2:	AOSN	.CPISF##	;IF .CPISF IS -1
	SOSA	.CPISF##	; DONT PUT THAT IN P
	SOS	P,.CPISF##	;GET INITIAL PDL POINTER BACK
IFN FTRSP,<	TLNE	M,TTYRNC##!TTYRNU##	;WILL THIS COMMAND CAUSE JOB TO BE RUN?
	PUSHJ	P,SETRSP##	; RESPONSE, IF NOT ALREADY SET
>
	NTGIVE			;GIVE UP THE INTERLOCK IF IT WAS A NETWORK COMMAND
	JRST	T2POPJ##	;TTY LINE #
				;THEN EXIT FROM COMMAND DECODER.

ABORTC::MOVE	P,.CPISF##	;HERE TO GET OUT OF A COMMAND (CLEAN'S UP THE STACK)
	JRST	COMRET		;GO TELL SCNSER THE COMMAND IS DONE
	SUBTTL	SUBROUTINES -- GET A WORD


;ROUTINE TO RETURN NEXT ALPHANUMERIC STRING
; IN COMMAND LINE (SIXBIT)
;CALL:	PUSHJ P, CTEXT
; SIXBIT STRING RETURN LEFT JUSTIFIED IN AC T2


CTEXT::	PUSHJ	P,COMTYS	;SKIP CHAR
CTEXT1::PUSHJ	P,SKIPS1	;SKIP LEAD SPACES,TABS,NULLS AND CLEAR T2
	  POPJ P,0		;NOTHING THERE.
	PUSHJ	P,SAVE1##	;SAVE P1
	SKIPA	P1,[POINT 6,T2]
CTEX0:	PUSHJ	P,COMTYS	;ROUTINE IN SCNSER TO PICK UP CHAR.
	PUSHJ	P,CTEX		;IS IT ALPHANUMERIC
	  POPJ P,0		;NO
	TRC	T3,40		;CONVERT TO SIXBIT
	TLNE	P1,770000	;SIX CHARS YET?
	IDPB	T3,P1		;NO. BUILD WORD
	JRST	CTEX0		;LOOP FOR MORE
;SCAN FOR ALPHANUMERIC CHAR IN T3
CTEX:	CAIL	T3, "0"
	CAILE	T3, "Z"		;LETTERS ARE LARGER THAN NOS.
	POPJ	P,0		;NEITHER
	CAILE	T3, "9"
	CAIL	T3, "A"
	AOS	(P)		;LETTER OR NUMBER RETURN
	POPJ	P,0		;NOT-LETTER/NUMBER RETURN

CTXDEV::PUSHJ	P,CTEXT1	;GET A WORD
	CAIN	T3,":"		;AND IF TERM IS A COLON,
	PUSHJ	P,COMTYS	;DISCARD IT
	POPJ	P,0		;RETURN FROM CTXDEV
	SUBTTL	SUBROUTINES -- GET CHARACTER

;ROUTINE TO IGNORE LEADING SPACES, TABS,
;ALSO CLEARS T2
;CALL:	PUSHJ P,SKIPS1	;TO CONSIDER CURRENT CHARACTER
;	PUSHJ P,SKIPS		;TO DISCARD CURRENT CHARACTER
;NON-SKIP RETURN MEANS END OF LINE
;SKIP RETURN MEANS SOMETHING THERE, IN T3 AND .CPMCH



;ROUTINE TO IGNORE LEADING SPACES AND TABS. ALSO, CLEARS T2
;FOR USE BY ANYRIN AND CTEXT

SKIPS::	PUSHJ	P,COMTYS	;DISCARD CURRENT CHARACTER
SKIPS1::
	CAMN	P2,PLNTXT##	;USER-DEFINED COMMAND?
	POPJ	P,		;YES, LEAVE THE REST OF LINE ALONE
	MOVEI	T2,0		;NO, CLEAR ANSWER FOR NUMERIC AND TEXT INPUTS
	PUSHJ	P,CTIGLC##	;GET LAST CHAR SCANNED
	CAIE	T3,11		;TAB?
	CAIN	T3,40		;OR SPACE?
	JRST	SKIPS		;YES. DISCARD IT
	CAIL	T3,40		;BREAK CHARACTER?
	AOS	0(P)		;NO. SKIP RETURN
	POPJ	P,0		;RETURN.


;COMTYS - ROUTINE TO READ COMMAND AND STOP ON COMMENT
;CALL:	PUSHJ P,COMTYS
;RETURN WITH CHARACTER IN T3 (12 IF ; OR !)

COMTYS::PUSHJ	P,COMTYI##	;GET CHARACTER
	CAIL	T3,"A"+40	;LOWER CASE?
	CAILE	T3,"Z"+40
	SKIPA
	TRZ	T3,40		;YES, CONVERT TO UPPER CASE
	CAIE	T3,"!"		;SEE IF EXCLAMATION
	CAIN	T3,";"		;SEE IF SEMI-COLON
	MOVEI	T3,12		;YES, CHANGE TO LINEFEED
	PUSHJ	P,CTISLC##	;SAVE AS LAST CHAR SCANNED
	POPJ	P,
	SUBTTL	SUBROUTINES -- TYPE OUT ROUTINES
;ROUTINE TO APPEND A "?" TO INPUT STRING AND SET AS OUTPUT
;CALLED FROM OCTIN, RETURNS TO SECOND LEVEL ON PDL
;CALL:	MOVE T1, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ P, COMERA


COMERP::POP	P,0(P)		;REMOVE SUB. RETURN BEFORE CALLING COMERA
COMERA::PUSHJ	P,COMTYI##	;SKIP ONE MORE CHARACTER

;ROUTINE TO TYPE ALL OF A COMMAND ACCEPTED, FOLLOWED BY
;A QUESTION MARK
;CALL:	PUSHJ P, COMERR




;COMMAND NOT IN COMMAND DIRECTORY

NOCOM::

COMERR::PUSH	P,T2
	PUSHJ	P,CTIGBP##	;GET THE INPUT BYTE POINTER
	PUSH	P,T1		;SAVE ERROR POSITION ON THE STACK
	PUSHJ	P,TRESCN##	;BACK UP TO START OF COMMAND
	PUSHJ	P,PRQM		;TYPE ? FOR BATCH
COMERL:	PUSHJ	P,COMTYI##	;GET A CHAR FROM COMMAND
	CAIN	T3,3		;^C?
	JRST	COMER1		;BETTER LEAVE OR KAF
	PUSHJ	P,CTIGBP##	;GET THE BYTE POINTER
	SKIPE	T1		; IF IT'S NULL, WE'RE DONE
	CAMN	T1,0(P)		; ..
	JRST	COMER1		;YES
	PUSHJ	P,USEARO##	;NO. TYPE CHAR, IN ARROW MODE
	CAIE	T3,12
	JRST	COMERL		;LOOP FOR MORE

COMER1:	POP	P,T1		;REMOVE OLD POSITION FROM STACK
	POP	P,T2
	PUSHJ	P,PRQM		;APPEND ? TO ERRONEOUS WORD
	TLO	M,ERRFLG##	;SET ERROR FLAG
	PJRST	CRLF		;ADD CRLF

;ROUTINE TO PRINT ?DEVICE NAME

PRNAMQ:	PUSHJ	P,PRQM
	TLO	M,ERRFLG##	;SET ERROR FLAG
	PJRST	PRNAME##
; ROUTINE TO PRINT A CRLF, THEN AN ERROR MESSAGE
ERRCRL::PUSH	P,T1		;SAVE ADDRESS OF TEXT
	PUSHJ	P,CRLF		;TYPE A CRLF
	POP	P,T1		;RESTORE TEXT
;	PJRST	ERRMES		;TYPE "?ERROR-TEXT" AND RETURN

;ROUTINE TO PRINT A COMMAND ERROR MESSAGE
;SAME CALL AS CONMES

ERRMES::PUSHJ	P,PRQM

ERRMSN:	TLO	M,ERRFLG##	;INDICATE AN ERROR
	PUSHJ	P,CONMES	;PRINT MESSAGE
	MOVEI	J,0		;CLEAR JOB NUMBER TO INDICATE ERROR

;ROUTINE TO PRINT CARRIAGE RETURN-LINE-FEED
;CALL:	MOVE U,LDB ADDRESS OF TTY
;	PUSHJ P,CRLF


PCRLF::				; COMERR SKIPS TO HERE(SEE ABOVE)
CRLF::	MOVEI	T1,[ASCIZ /
/]

;ROUTINE TO MOVE ASCIZ CHAR. STRING TO CONSOLE OUTPUT BUFFER
; CALL:	MOVE U,LDB ADDRESS OF TTY
;	MOVEI T1,  ADDRESS OF ASCIZ MESSAGE
;	PUSHJ P, CONMES
; STRING TERMINATED BY NULL


CONMES::HRLI	T1,440700	;FORM ASCIZ BYTE POINTER
	PUSH	P,T1		;SAVE BYTE POINTER
CON0:	ILDB	T3,(P)		;GET NEXT CHAR.
	JUMPE	T3,TPOPJ##	;IS IT NULL?(IF YES, DO POP T1, POPJ)
	PUSHJ	P,COMTYO##	;NO, STORE TTY OUTPUT BUFFER
	JRST	CON0		;KEEP GOING
;ROUTINE TO PRINT INLINE ASCIZ MESSAGE
;CALL:	PUSHJ P,INLMES
;	ASCIZ /THE MESSAGE/
;RETURN TO NEXT LOC AFTER MESSAGE
INLMES::POP	P,T1		;SETUP PRINT ADRESS FOR CONMES
	PUSHJ	P,CONMES
	JRST	1(T1)		;RETURN TO NEXT LOC AFTER MESSAGE

;ROUTINE TO TYPE COMMA
;PRESERVES T1
PRCOM::	MOVEI	T3,","
	PJRST	PRCHR
;ROUTINE TO APPEND ? TO ERROR MESSAGE
;CALL	PUSHJ P,PRQM
;	RETURN
PRQM::	MOVEI	T3,"?"
PRCHR:	PUSH	P,T1
	PUSHJ	P,COMTYO##
	PJRST	TPOPJ##

;SUBROUTINE TO PRINT 3 SPACES
PR3SPC::PJSP	T1,CONMES
	ASCIZ	/   /

;SUBROUTINE TO PRINT A SPACE
PRSPC::	PJSP	T1,CONMES
	ASCIZ	/ /

;SUBROUTINE TO PRINT A PLUS
PRTPLS::PJSP	T1,CONMES
	ASCIZ	/+/

;ROUTINE TO PRINT "TOO FEW ARGUMENTS"
;CALL:	MOVE U,BYTE POINTER
;	PUSHJ P,NOTENF
NOTENP:	POP	P,(P)		;REMOVE SUBROUTINE CALL BEFORE CALLING NOTENF
NOTENF::JSP	T1,ERRMES

ASCIZ /Too few arguments
/

;ROUTINE TO PRINT A PERIOD
;CALL:	PUSHJ P,PRPER
PRPER::	JSP	T1,CONMES
	ASCIZ	/./
;ROUTINE TO PRINT A SLASH
PRSLSH::JSP	T1,CONMES
	ASCIZ	./.
;ROUTINE TO RETURN HIGHEST RELATIVE ADDRESS SPECIFIED BY
; THE USER'S CORE ARGEMENT
;CALLING SEQUENCE:
;	PUSHJ	P,CORARG
;	RETURN HERE IF NO ARGUMENT WAS SPECIFIED
;	RETURN HERE - T1=HIGHEST RELATIVE ADDRESS REQUESTED
;NEVER RETURNS IF ARGUMENT IS ILLEGAL
CORARG::PUSHJ	P,SKIPS1	;SKIP LEADING BLANKS, ETC.
CORAR1:	POPJ	P,K2WLSH##	;NO ARGUMENT SPECIFIED
	CAIE	T3,"K"		;DON'T ALLOW "P" OR "K"
	CAIN	T3,"P"		; WITHOUT A PRECEEDING #
	JRST	COMERP		; SINCE AMBIGUOUS
	PUSHJ	P,DECIN1	;GET THE ARGUMENT
	  POPJ	P,		;NULL RETURN
	  JRST	CORAR2		;SEE IF "P" OR "K"
	CAIE	T3,"-"		;IF HYPHEN
	CAIN	T3,"("		;OR L. PAREN.
	MOVEI	T3,0		;SET E.O. LINE
	LSH	T2,K2WLSH##
	CAILE	T3,40		;AN ARG. WAS TYPED, DELIMITER OKAY?
	JRST	COMERP		;BAD DELIMITER
	JRST	CORAR3
CORAR2:	CAIE	T3,"K"		;CORE ARGUMENT IN # OF K?
	CAIN	T3,"P"		; OR NUMBER OR PAGES
	SKIPA	T1,CORAR1
	JRST	COMERP		;NO, DON'T ALLOW A,B,C, ETC.
	CAIN	T3,"P"		;DID USER TYPE "P"?
	SOS	T1		;YES
	LSH	T2,(T1)		;CONVERT TO WORDS
	PUSHJ	P,COMTYS	;DISCARD "P"OR"K"
CORAR3:	SOSL	T1,T2		;CONVERT TO HIGHEST RELATIVE ADDR.
	JRST	CPOPJ1##	;GIVE ARG FOUND RETURN
	AOJA	T1,CPOPJ1##	;MAKE ZERO BACK INTO ZERO

;SUBROUTINE TO PRINT "P" OR "K" AFTER A CORE TYPE OUT
;CALLING SEQUENCE:
;	PUSHJ	P,PRPORK
;	ALWAYS RETURN HERE

PRPORK:	MOVEI	T3,"P"		;KI10, TELL NUMBER OF PAGES

	PJRST	PRCHR		;PRINT "P" OR "K"
;ROUTINE TO DEASSIGN A DEVICE EXCEPT CONTROLLING TTY
;CALL:	MOVE F, DEVICE DATA BLOCK
;	MOVE J, JOB NUMBER
;	PUSHJ P, DEASG
;	ERROR NOT PREVIOUSLY ASSIGNED
;	OK RETURN WITH DEVICE DEASSIGNED, EXCEPT CONTROLLING TELETYPE (LOGICAL NAME CLEARED)


DEASG:	SKIPN	DEVCHR(F)	;PROTOTYPE SPOOL DDB?
	JRST	CPOPJ1##	;YES
	LDB	T1,PJOBN##	;WAS DEVICE ASSIGNED TO THIS JOB?
	CAME	T1,J
	POPJ	P,		;NO, RETURN
DEASG1::PUSH	P,J		;SAVE JOB NUMBER
IFN FTCIMP,<			;[arpa]
	MOVSI	T2,JLOG		;[arpa] MAY BE NEEDED FOR LATER TEST
	PUSHJ	P,IMPDEV##	;[arpa] IS DEVICE AN IMP?
	 JRST	DEASG3		;[arpa] NO OR NO CONNECTIONS OPEN
	 JRST	DEASG4		;[arpa] YES, BUT NOT CONTROLLING A JOB
	TDNN	T2,JBTSTS##(J)	;[arpa] YES...IS JOB GOING AWAY?
	  PUSHJ	P,CLRDVL##	;[arpa] ASSIGN TO JOB 0
	PJRST	IPOPJ1##	;[arpa] DON'T ASSIGN, BUT GIVE GOOD RETURN

DEASG4:	TDNE	T2,JBTSTS##(J)	;[arpa] JOB LOGGING OUT?
	  PJRST	IPOPJ1##	;[arpa] NO - DON'T DEASSIGN
DEASG3:				;[arpa]
>				;[arpa]
	MOVSI	T2,DVDIRI	;CLEAR DIRECTORY IN CORE BIT
	ANDCAB	T2,DEVMOD(F)	;SET DEVICE CHARACTERISTICS FOR TEST
				; AND ASGHGH
	SETZM	DEVLOG(F)	;CLEAR LOGICAL NAME
	TLNE	T2,TTYATC	;CONTROLLING TTY?
	JRST	IPOPJ1##	;YES, CAN'T DEASSIGN THAT!
	TRNE	T2,ASSCON	;IS DEVICE ASSIGNED BY CONSOLE?
	AOS	-1(P)		;YES, DO OK RETURN
	PUSHJ	P,ASGHGH##	;IF DTA OR MTA, CLEAR ANY HIGH SEGMENT NAMES
				; FROM THIS DEVICE SO NO NEW SHARING
				; DEVMOD SETUP IN T2 ON CALL
	MOVEI	T2,ASSCON	;SETUP ASSIGNED BY CONSOLE BIT FOR RELEA6
	PUSHJ	P,RELEA6##	;CLEAR JOB NO. IN DDB IF DDB NOT NEEDED
	PUSHJ	P,TTYKLQ##	;BE SURE TO CLEAN UP ASSIGNED TTY'S
	JRST	IPOPJ##		;RESTORE JOB NUMBER AND RETURN

;DEASTY--ROUTINE TO DEASSIGN ALL DEVICES EXCEPT CONTROLLING (ATTACHED) TTY
;CALL:	MOVE J, JOB NUMBER
;	PUSHJ P, DEASTY



DEASTY:	PUSH	P,F		;SAVE TTY DDB ADDRESS
	HLRZ	F,DEVLST##	;SEARCH ALL DDB'S
DEA1:	PUSHJ	P,DEASG		;TRY TO DEASSIGN IT
	JFCL			;IGNORE IF CAN'T
	PUSHJ	P,NXDDB##
	  JUMPE	F,FPOPJ##	;RESTORE TTY DDB AND EXIT
	JRST	DEA1		;TRY NEXT
;SUBROUTINE TO READ A DECIMAL NUMBER. THIS ROUTINE DIFFERS FROM
; DECIN IN THAT IF THERE IS NO NUMBER TO READ THE CURSOR
; IS NOT MOVED.
;CALL WITH:
;	PUSHJ	P,NUMARG
;	  RETURN HERE IF NO NUMBER (NOTHING CHANGED)
;	RETURN HERE NUMBER IN T2
;
NUMARG:	PUSHJ	P,CTIGBP##	;GET THE BYTE POINTER
	PUSH	P,T1		; AND SAVE THAT
	PUSHJ	P,CTIGLC##	;GET THE "LAST CHAR"
	PUSH	P,T3		;  AND SAVE THAT TOO.
	PUSHJ	P,DECIN1	;READ THE NUMBER
	  JRST	NUMAR1		;NO ARGUMENT
	  JRST	NUMAR1		;ILLEGAL CHARACTER
NUMAR0:	SUB	P,[2,,2]	;REMOVE JUNK FROM STACK
	JRST	CPOPJ1##	;GOOD RETURN
NUMAR1:	POP	P,T3		;GET CHAR TO RETURN
	EXCH	T1,(P)		;SAVE T1, GET BYTE POINTER
	PUSHJ	P,CTISBP##	;STORE THE BYTE POINTER
	PUSHJ	P,CTISLC##	;  AND THE "LAST CHAR READ"
	JRST	TPOPJ##		;RESTORE T1 AND RETURN
;SUBROUTINE TO READ AN ARGUMENT, CALL FNDNAM
;IF NOT FOUND BY FNDNAM CURSOR IS NOT MOVED
;CALL WITH T1=AOBJN WORD FOR TABLE
;RETURNS SKIP IF FOUND BY FNDNAM, T1=INDEX
;RETURNS NON-SKIP IF NOT FOUND (NOTHING CHANGED)
TXTARG::PUSH	P,T1		;SAVE T1
	PUSHJ	P,CTIGBP##	;GET THE BYTE POINTER IN T1
	PUSHJ	P,CTIGLC##	;  THE LAST CHAR IN T3
	EXCH	T1,(P)		;SAVE BYTE POINTER, RESTORE T1
	PUSH	P,T3		;SAVE THE LAST CHAR.
	PUSH	P,T1		;SAVE AOBJN WORD
	PUSHJ	P,CTEXT1	;GET THE ARGUMENT
	POP	P,T1
	JUMPE	T2,NUMAR1
	PUSHJ	P,FNDNAM	;IN TABLE?
	  JRST	NUMAR1		;NO
	JRST	NUMAR0		;YES, CLEAN UP STACK AND GIVE FOUND RETURN
;ROUTINES TO READ NUMBERS FROM COMMAND STRING
;CALL:	MOVE P1,DESIRED INPUT RADIX
;	PUSHJ P, ANYRIN
;	NO ARG. TYPED RETURN, T2=0
;	ILLEGAL CHARACTER RETURN
;	NORMAL EXIT	;AC T2 CONTAINS NUMBER
;SCAN STOPS ON FIRST CR,DASH,SPACE,OR TAB OR ILLEGAL CHAR.
;SKIPS LEADING SPACES AND TABS


DECIN::	PUSHJ	P,COMTYS	;SKIP CHAR
DECIN1::PUSHJ	P,SAVE2##	;PRESERVE P1
	MOVEI	P1,12		;DECIMAL INPUT
	JRST	ANYRIN

OCTIN::	PUSHJ	P,COMTYS	;SKIP CHAR
OCTIN1::PUSHJ	P,SAVE2##	;PRESERVE P1  ;;WARNING -- SEE AOS -3(P) BELOW
	MOVEI	P1,10		;OCTAL INPUT
ANYRIN:	PUSHJ	P,SKIPS1	;SKIP LEADING SPACES, TABS, NULLS
	  POPJ	P,0		;NOTHING LEFT. RETURN.

	MOVEI	P2,0		;CLEAR DECIMAL ACCUMULATOR
	CAIE	T3,"#"		;SEE IF OCTAL FOCED
	JRST	ANYRI1		;NO--PROCEED
	MOVEI	P1,10		;YES--SET OCTAL RADIX
	TLO	P1,400000
	PUSHJ	P,COMTYS	;GET NEXT CHARACTER
ANYRI1:	PUSHJ	P,ANYR2		;SEE IF NULL FIELD
	  JRST .+2		;NOT END, SEE IF DIGIT
	  POPJ P,		;END--RETURN NULL
OCT0:	CAIL	T3,"0"		;IS CHARACTER .GE. A ZERO?
	CAIL	T3,"0"(P1)	;AND WITHIN RADIX BOUNDS?
	JRST	[CAIL	T3,"0"	;NO. NOT A LEGAL DIGIT
		CAILE	T3,"9"
		JRST	ANYR1
		JUMPL	P1,ANYR1
		TLO	P1,200000
		JRST	.+1]
	JFCL	17,.+1
	IMULI	T2,(P1)		;YES. SCALE INPUT SO FAR
	ADDI	T2,-"0"(T3)	;AND ADD IN THIS DIGIT
	IMULI	P2,^D10		;MULTIPLY DECIMAL INPUT
	JOV	ANYR1		;ON OVERFLOW, FIVE ILLEGAL CHARACTER RET
	ADDI	P2,-"0"(T3)	;INCLUDE THIS DIGIT
	PUSHJ	P,COMTYS	;GET ANOTHER CHARACTER
	CAIE	T3,"."		;SEE IF FORCING DECIMAL
	JRST	OCT0		;AND LOOP FOR MORE.
	MOVE	T2,P2		;YES--GET DECIMAL VALUE
	JUMPL	P1,ANYR1
	PUSHJ	P,COMTYS	;GET SEPARATOR
	TLZ	P1,200000
ANYR1:	AOS	-3(P)		;POINT TO ILLEGAL CHARACTER RETURN
	TLNE	P1,200000
	POPJ	P,
	CAILE	T3,40		;CHECK FOR LEGAL TERMINATORS
ANYR2:	CAIN	T3,","		;USED IN VARIOUS ROUTINES
	JRST	CPOPJ1##	;OK
	CAIE	T3,"["		;MORE
	CAIN	T3,"]"		; ..
	JRST	CPOPJ1##	;OK.
	CAIE	T3,"<"		;MORE
	CAIN	T3,">"		; ''
	JRST	CPOPJ1##	;OK.
	CAIE	T3,"("		;L. PAREN?
	CAIN	T3,"-"		;HYPHEN?
	JRST	CPOPJ1##	;OK.
	POPJ	P,CPOPJ1##	;NO GOOD. GIVE "BAD CHARACTER RETURN"
; ROUTINE TO INPUT TIME SINCE MIDNIGHT
; LEGAL FORMATS ARE HH:MM[AM,PM] OR HH:MM:SS[AM,PM]
; THE COLONS, "AM", OR "PM" ARE ALL OPTIONAL
; CALL:	PUSHJ	P,RDTIM
;	  <ERROR>		;T1 POINTS TO ERROR TEXT
;	<NORMAL>		;T1 CONTAINS TIME IN SECONDS SINCE MIDNIGHT
;
; AC USAGE: T1 - T4
;
RDTIM::	PUSHJ	P,SAVE2##	;SAVE P1 AND P2
	SETZB	P1,T4		;INIT INTERMEDIATE RESULT AND COUNTER
	SETZ	P2,		;CLEAR A FLAG

RDTIM0:	IMULI	P1,^D100	;ADVANCE TO NEXT RESULT
	PUSHJ	P,DECIN		;GET NEXT SUPER-DIGIT
	  TDZA	T2,T2		;MAY HAVE TYPED HH::SS WHICH IS OK
	  JUMPL	T2,RDTIM7	;ERROR IF NEGATIVE
	CAIL	T2,^D60		;RANGE CHECK
	JUMPN	T4,RDTIM6	;TOO BIG FOR MINUTES OR SECONDS
	ADD	P1,T2		;ADD TO ACCUMULATOR
	CAIE	T3,":"		;SEE IF MORE TO COME
	JRST	RDTIM1		;NO--GO CONVERT RESULT
	CAIGE	T4,2		;TOO MAY FIELDS?
	AOJA	T4,RDTIM0	;NO--LOOP BACK FOR MORE
	JRST	RDTIM7		;ILLEGAL FORMAT

RDTIM1:	JUMPN	T4,RDTIM2	;JUMP IF NORE THAN ONE ARGUMENT
	CAILE	P1,^D2359	;A REASONABLE NUMBER FOR HH:MM?
	MOVEI	T4,2		;NO
RDTIM2:	CAIGE	T4,2		;TWO OR LESS ARGUMENTS?
	IMULI	P1,^D100	;YES--HAKE IT HH:MM:00
	CAILE	P1,^D235959	;STILL REASONABLE?
	JRST	RDTIM6		;HH GREATER THAN 23
	PUSHJ	P,RDTIM3	;CONVERT TO TIME IN SECONDS
	JUMPL	P1,CPOPJ##	;RETURN IF FAILURE
	SETZ	P2,		;INIT FLAG
REPEAT 0,<
	PUSHJ	P,AMPM		;CHECK FOR AM OR PM
	  JRST	RDTIM8		;NO GOOD--ILLEGAL FORMAT
>
	MOVE	T1,P1		;GET RESULT
	JRST	CPOPJ1##	;AND RETURN
RDTIM3:	MOVE	T2,P1		;GET RESULT SO FAR
	MOVEI	P1,0		;CLEAR RESULT
	MOVEI	T1,3		;INITIALIZE TO ALLOW THREE FIELDS
	MOVE	P2,P		;SAVE P INCASE OF ERRORS
RDTIM4:	IDIVI	T2,^D100	;SEPARATE TYPEIN
	PUSH	P,T3		;STORE LEAST DIGIT AWAY
	JUMPE	T2,RDTIM5	;JUMP IF ALL DONE
	SOJLE	T1,RDTIM7	;GIVE AN ERROR IF TOO MANY FIELDS
	PUSHJ	P,RDTIM4	;IF NOT, DO SOME MORE
RDTIM5:	POP	P,T1		;GET BACK HIGHEST DIGIT
	IMULI	P1,^D60		;MAKE ROOM IN RESULT
	ADD	P1,T1		;INCLUDE RESULT
	CAILE	T1,^D60		;SEE IF ERROR
	JRST	RDTIM6		;COMPLAIN IF COMPONENT TOO BIG
	POPJ	P,		;RETURN

RDTIM6:	JSP	T2,RDTIM9	;TIME COMPONENT TOO LARGE
RDTIM7:	JSP	T2,RDTIM9	;ILLEGAL FORMAT IN TIME SPECIFICATION
RDTIM8:	JSP	T2,RDTIM9	;ILLEGAL USE OF AM/PM CONSTRUCT
RDTIM9:	SUBI	T2,RDTIM6	;GET ERROR CODE
	TLZ	T2,777777	;STRIP OFF PC FLAGS OR SECTION NUMBER
	MOVE	T1,RDTIMM-1(T2)	;GET ADDRESS OF ERROR TEXT
	MOVNI	P1,1		;SET P1 NEGATIVE TO INDICATE FAILURE
	SKIPE	P2		;CALLED FROM WITHIN RDTIM3?
	MOVE	P,P2		;YES--FIX UP STACK TO AVOID STOPCODES
	POPJ	P,		;AND RETURN

RDTIMM:	[ASCIZ	|Time component too large|]
	[ASCIZ	|Illegal format in time specification|]
	[ASCIZ	|Illegal use of AM/PM construct|]


; CHECK FOR AM OR PM APPENDED TO TIME
AMPM:	MOVE	T1,[-AMPMLN,,AMPMTB] ;AOBJN POINTER TO LEGAL ARGS
	PUSHJ	P,TXTARG	;SEE WHAT WE'VE GOT
	  JRST	CPOPJ1##	;NOTHING
	CAILE	P1,^D12*^D60*^D60 ;GREATER THAN 12:00:00
	  POPJ	P,		;YES--ILLEGAL FORMAT
	SKIPE	T1		;SKIP IF AM
	ADDI	P1,^D12*^D60*^D60 ;OFFSET FOR PM
	JRST	CPOPJ1##	;AND RETURN

AMPMTB:	SIXBIT	/AM/
	SIXBIT	/PM/
AMPMLN==.-AMPMTB
;GET PROJECT-PROGRAMMER NUMBERS
;CALL:	MOVE T1,INPUT BYTE POINTER
;	PUSHJ P,PJPGNO
;
;(T2)LH _ PROJECT NUMBER
;(T2)RH _ PROGRAMMER NUMBER
;(T2) = 0 IF NO [ ]'S TYPED
;THE TERMINAL ] IS OPTIONAL

PJPGNO:	PUSH	P,P1
	MOVEI	P1,0		;PRESET A 0 JUST IN CASE
	PUSHJ	P,SKIPS1
	  JRST	PP2		;NOTHING ON LINE
	CAIE	T3,"["		;IS IT A "[" ?
	CAIN	T3,"<"		;OR 2741 EQUIV.
	SKIPA			;YES
	JRST	PP2		;EXIT.......

	PUSHJ	P,OCTIN		;GET FIRST ARG.-PROJ. NO.
	  JRST	[CAIN T3,"-"	;SEE IF [-]
		JRST	[PUSHJ	P,SKIPS ;YES -- SKIP -
			  JRST	COMERP  ;NOTHING LEFT
			 CAIE	T3,"]"  ;MINUS SIGN MUST BE FOLLOWED
			CAIN	T3,">"  ; BY A LEGAL BRACKET
			JRST	PP1A  ;THEN RETURN 0
			JRST	PP3] ;ELSE ERROR
		HLRZ T2,JBTPPN##(J)  ;NO ARG, DEFAULT TO LOGGED IN
		JRST	.+2]	;AND CONTINUE
	  JRST	PP3		;ILLEGAL OCTAL CHARACTER GIVEN
	TLZ	T2,-1
	JUMPE	T2,PP3		;BOMB IF 0
	HRL	P1,T2		;ENTER
	CAIE	T3,","
	JRST	PP3		;PPN MUST HAVE COMMA
	PUSHJ	P,OCTIN		;GET SECOND ARG.-PROG. NO.
	  JRST	[HRRZ T2,JBTPPN##(J)  ;NO ARG, DEFAULT TO LOGGED IN
		 JRST	.+2]	;AND CONTINUE
	  JRST	PP3		;
	TLZ	T2,-1
	JUMPE	T2,PP3		;BOMB IF 0
	HRR	P1,T2		;ENTER
PP1A:	JUMPL	P1,PP3		;BOMB USER IF INVALID
PP2:	MOVE	T2,P1		;RESULT IN T2
	JRST	P1POPJ##	;RETURN TO CALLER
PP3:	POP	P,P1
	PJRST	COMERP		;LOSE
;ROUTINE TO PRINT TIME AS HOURS,MINUTES,SECONDS, AND HUNDRETHS (NO CRLF)
;FORMAT IS HHMM:SS.HH, MM:SS, OR SS.HH IF HH AND MM ARE 0
;CALL:	MOVE T1,TIME IN JIFFIES(60THS,50THS OR MILLISECONDS)
;	PUSHJ P,PRTIM
;				;CALL PRTIME (ABOVE) TO GET CRLF AFTER TIME
;SCALEING IS DONE USING THE FOLLOWING GLOBAL SYMBOLS DEFINED IN COMMON
;THUS ANY INSTALLATION MAY HAVE ANY RATE CLOCK


;JIFMIN=NO. OF JIFFIES(CLOCK TICKS) PER MINUTE
;JIFSEC=NO. OF JIFFIES PER SECOND
;JIFSC2=1/2*JIFSEC(USED FOR ROUNDING)


PRNOW:	MOVE	T1,TIME##	;GET CURRENT TIME OF DAY
PRTIM::	CAMGE	T1,TICMIN##	;IF LESS THAN A MINUTE
	JRST	PR1		;IN USE DIFFERENT FORMAT
	MOVE	T2,TICSEC##	;ADD 1/2 TICKS/SEC FOR ROUNDING
	LSH	T2,-1
	ADD	T1,T2
	IDIV	T1,TICMIN##	;FORM MINUTES
	PUSH	P,T2		;SAVE REMAINDER IN JIFFIES
	IDIVI	T1,^D60		;HOURS, MINUTES IN T1,T2
	JUMPE	T1,PR0		;SUPPRESS 0 HOURS
	PUSHJ	P,RADX10##
PR0:	PUSHJ	P,INLMES	;PRINT "HH:" OR "H:"
	ASCIZ	/:/
	MOVE	T1,T2		;GET MINUTES
	PUSHJ	P,PRT2		;PRINT "MM:"
	PUSHJ	P,INLMES
	ASCIZ	/:/
	POP	P,T1		;RESTORE SECONDS (IN JIFFIES)
	PJRST	PR2		;PRINT AND RETURN (NO CRLF)

PR1:	IDIV	T1,TICSEC##	;JIFFIES PER SECOND
	PUSHJ	P,RADX10##	;PRINT SECONDS
	PUSHJ	P,PRPER		;PRINT PERIOD
	MOVE	T1,T2		;NO OF JIFFIES(HUNDRETHS)
	IMULI	T1,^D100	;CONVERT TO HUNDRETHS
PR2:	IDIV	T1,TICSEC##
PRT2:	MOVEI	T3,"0"
	PUSH	P,T1		;SAVE T1 OVER I/O
	CAIGE	T1,^D10
	PUSHJ	P,COMTYO##	;PUT LEADING 0 IF LESS THAN 10
	POP	P,T1		;RESTORE T1
	JRST	RADX10##	;PRINT REST OF NUMBER
;ROUTINE TO PRINT SIZE OF LOGICAL SEGMENT (LOW OR HIGH)
;CALL:	MOVE J, HIGH OR LOW SEG NUMBER
;	PUSHJ P,PRT SEG
;	RETURN
;CALLED AT CLOCK LEVEL FROM CORE (UUO ARG) COMMAND AND SEGCON


PRTSEG::PUSHJ	P,SEGSIZ	;T2=SIZE OF HIGH OR LOW SEG
	MOVE	T1,T2		;RADX10 WANT DEC. NO. IN T1
	JRST	RADX10##	;PRINT DECIMAL

;ROUTINE TO RETURN SIZE OF HIGH OR LOW SEG
;CALL:	MOVE J,LOW OR HIGH SEG NUMBER
;	PUSHJ P,SEGSIZ
;	RETURN WITH SIZE IN K IN T2


SEGSIZ::CAILE	J,JOBMAX##	;LOW SEGMENT?
	JRST	SEGSZ0		;NO, GET HI SEG SIZE
	SKIPLE	T2,JBTSGN##(J)	;IS THERE A REAL HI SEG?
	TLNE	T2,SHRSEG	;YES, IS IT NON-SHARABLE?
	JRST	SEGSZ0		;NO
IFN FTKLP,<
	HRRZS	T2		;CLEAR JUNK
>
	HLRZ	T2,JBTSWP##(T2)
	MOVNS	T2		;HI SEG SIZE
	ADD	T2,JBTSWP##(J)	;INCLUDED IN LOW SEG SIZE
	ANDI	T2,777		;CLEAR JUNK
	JRST	SEGSZ2		;ADD UPMP SIZE AND RETURN
SEGSZ0:	LDB	T2,IMGIN##	;SEGMENT SIZE
	JUMPN	T2,SEGSZ1	;GO IF NON-ZERO
	HLRZ	T2,JBTSWP##(J)	;MAYBE A NON-SHARABLE HI SEG
	JUMPE	T2,CPOPJ##	;RETURN IF NO CORE

SEGSZ1:	CAIG	J,JOBMAX##	;IS THIS A LOW SEGMENT?
SEGSZ2:	ADDI	T2,UPMPSZ##	;YES, ACCOUNT FOR UPMP SIZE
	POPJ	P,		;AND RETURN
;ROUTINE TO ASSIGN A MINIMAL CORE AREA (2000 WORDS)
;CALLED FROM CORE, KJOB, AND RUN COMMANDS
;CALL:	PUSHJ P,GETMIN
;	RETURN R=0 IF UNSUCCESSFUL OR CORE ASSIGNED ON DISK


GETMIN::
IFN FTMP,<
	PUSHJ	P,GETMM##	;TRY TO GET THE MEMORY MANAGEMENT RESOURCE
	  JRST	DLYCM1		;FAILED, TRY AGAIN NEXT TIME
>
	PUSH	P,U		;SAVE TTY LDB ADDRESS
	PUSH	P,T2		;SAVE DEVICE NAME(GET)
	PUSH	P,S		;SAVE DISPATCH ADDRESS(ANYACT USES S)
	PUSHJ	P,KILHGH##	;KILL HIGH SEG
IFN FTKL10&FTMP,<
	PUSHJ	P,CLCSN##	;CLEAR SWEEP SERIAL NUMBER FOR JOB
				; SO WE DON'T SWEEP FOR NOTHING
>;END IFN FTKL10&FTMP
IFN FTPEEKSPY,<
	PUSHJ	P,CLRSPG##	;GET RID OF SPY PAGES
>
	MOVEI	T1,PAGSIZ##-1	;BASIC UNIT OF CORE MEMORY
	PUSHJ	P,CORE0##	;ASSIGN 2000 WORDS ON DISK OR MEMORY
	  JFCL			;IGNORE IF CANT(R=0)
IFN FTMP,<
	PUSHJ	P,GIVMM##	;RETURN MM RESOURCE
>
	POP	P,S
	POP	P,T2		;RESTORE PUSHED ACS
	PJRST	UPOPJ##		;RESTORE U AND RETURN

;SUBROUTINE TO GET A MINIMAL AMOUNT OF CORE IN CORE
GETCIC::PUSHJ	P,GETMIN	;TRY TO GET CORE IN CORE
	SKIPN	JBTADR##(J)	;DID WE SUCCEED?
	PJRST	DLYCM		;NO
	POPJ	P,		;YES, RETURN TO CALLER
;FNDNAM--ROUTINE TO SEARCH FOR ABBREV. NAME IN TABLE
;CALL	MOVE	T1,AOBJN POINTER TO LIST OF NAMES
;	MOVE	T2,SIXBIT ABBREVIATION
;	PUSHJ	P,FNDNAM
;NON-SKIP IF UNKNOWN (T1=0) OR DUPLICATE (T1 .NE. 0)
;SKIP RETURN IF FOUND WITH T1=INDEX IN TABLE


FNDNAM::PUSHJ	P,SAVE3##	;SAVE P1,P2,P3
	MOVN	P1,T2		;FIND THE RIGHTMOST
	AND	P1,T2		;NON-ZERO BIT IN COMMAND
	JFFO	P1,.+1		;AND ITS CARDINALITY
	IDIVI	P2,6		;FIND W HERE IN SIXBIT BYTE THE BIT IS
	LSH	P1,-5(P3)	;RIGHT-JUSTIFY THE BIT WITHIN THE BYTE
	SOJ	P1,		;MAKE MASK OF TRAILING BLANKS
	SETZB	T4,P2		;INITIALIZE MATCH POINTER AND COUNT
	MOVE	P3,T1		;SAVE POINTER
FNDNM2:	MOVE	T3,(T1)		;GET NEXT CANDIDATE
	XOR	T3,T2		;COMPARE
	JUMPE	T3,FNDNMW	;WIN
	ANDCM	T3,P1		;MASK IT
	JUMPN	T3,FNDNM3	;LOOSE
	MOVE	T4,T1		;WIN--SAVE POINTER
	ADDI	P2,1		;COUNT SUCCESS
FNDNM3:	AOBJN	T1,FNDNM2	;LOOP FOR ALL ENTRIES
FNDNM4:	MOVE	T1,T4		;RESTORE POSSIBLE WINNER
	SOJN	P2,CPOPJ##	;JUMP IF UNSUCCESSFUL
FNDNMW:	SUB	T1,P3		;COMPUTE INDEX
	TLZ	T1,-1		;REMOVE JUNK
	JRST	CPOPJ1##	;SKIP RETURN
;FNDABV--ROUTINE TO SEARCH FOR ABBREV. NAME IN LIST
;CALL	MOVE	T1,FLAGS
;	MOVE	T2,SIXBIT ABBREVIATION
;	MOVSI	P3,UNQTAB	;POINTER TO UNIQNESS BITS COMPRESSED TABLE
;	MOVE	P4,AOBJN POINTER TO NAMES
;	PUSHJ	P,FNDABV
;	 DIDN'T FIND IT OR DUPLICATE
;	FOUND IT, T1/ FLAGS,,OFFSET
;T2 AND P ACS ARE PRESERVED
;NON-SKIP IF UNKNOWN (T1=0) OR DUPLICATE (T1.NE.0)
;

FNDABV:	PUSHJ	P,SAVE4##	;SAVE P1,-P4
	PUSHJ	P,SAVR##	;NEED YET ANOTHER AC
	PUSH	P,T2		;SAVE FOR A MOMENT
	MOVNS	T2		;NEGATE NAME
	AND	T2,(P)		;FIND RIGHTMOST NON-ZERO BIT
	JFFO	T2,.+1		;IN THE COMMAND
	IDIVI	T3,6		;FIND WHERE IN THE SIXBIT BYTE IT IS
	LSH	T2,-5(T4)	;RIGHT JUSTIFY THE BIT WITHIN THE BYTE
	SOS	T3,T2		;MAKE MASK OF TRAILING BITS
	POP	P,T2		;AND RESTORE THE COMMAND NAME
	MOVSI	P2,(POINT 6,)	;MAKE A SIXBIT BYTE POINTER
	HLR	P2,P3		;RIGHT HALF POINTER TO UNQTAB
	SETZB	P1,P3		;NO MATCHES FOUND YET (WE HAVEN'T LOOKED!)
FNDAB1:	MOVE	R,P4		;COPY THE STARTING AOBJN POINTER
FNDAB2:	MOVE	T4,(P4) 	;GET NEXT CANDIDATE
	XOR	T4,T2		;COMPARE
	JUMPE	T4,FNDAWN	;WIN
	ANDCM	T4,T3		;MASK IT
	JUMPN	T4,FNDAB4	;LOSE
	ILDB	T4,P2		;GET UNIQUENESS INFO
	JUMPE	T4,FNDAB3	;NO UNIQUENESS INFO
	TRNE	T4,UNIQ.1##	;UNIQUE AT 1 CHAR?
	JRST	FNDAWN		;THEN WE HAVE IT
	TRNN	T4,UNIQ.2##	;UNIQUE AT 2 CHARS?
	JRST	.+3		;NO
	TLNN	T3,7700		;DID WE HAVE AT LEAST 2 CHARS
	JRST	FNDAWN		;YES, SO WE HAVE IT
	TRNN	T4,UNIQ.3##	;UNIQUE AT 3 CHARS
	JRST	.+3		;NO
	TLNN	T3,77		;YES
	JRST	FNDAWN		;YES
	TRNN	T4,UNIQ.4##	;UNIQUE AT 4 CHARS?
	JRST	.+3		;NO
	TRNN	T3,770000	;DID WE HAVE AT LEAST 4 CHARS?
	JRST	FNDAWN		;YES
FNDAB3:	HRR	P3,P4		;POSSIBLE WIN--SAVE POINTER
	HLL	P3,T1		;COPY FLAGS AS WELL.
	AOJA	P1,FNDAB5	;COUNT SUCCESS
FNDAB4:	IBP	P2		;ADVANCE
FNDAB5:	AOBJN	P4,FNDAB2	;LOOP FOR ALL ENTRIES
	TLZE	T1,1		;ARE WE IN USER-DEFINED COMMAND TABLE?
	JRST	[SKIPE P3	;DO WE HAVE A POTENTIAL WINNER?
		SUBI P3,(R)	;YES, CONVERT TO OFFSET NOW.
		MOVE P4,[XWD -DISPL##,COMTAB##] ;WE SEARCHED USER COMMANDS,
		MOVE P2,[POINT 6,UNQTAB##]	;NOW SEARCH SYSTEM
		JRST FNDAB1]			;COMMANDS TABLE
FNDAB6:	SOJN	P1,CPOPJ##	;MAKE SURE WE ONLY GOT A SINGLE COMMAND.
	TLNN	P3,1		;WAS THIS FROM A PREVIOUS TABLE SEARCH?
	 SUBI	P3,(R)		;NO, CONVERT IT TO AN OFFSET NOW.
	MOVE	T1,P3		;LEAVE WHERE CALLERS CAN FIND IT
	JRST	CPOPJ1##	;AND RETURN SUCCESS

;WIN BY VIRTUE OF UNIQNESS BITS. SEARCH NO MORE.
FNDAWN:	SUBI	P4,(R)		;COMPUTE INDEX TO RETURN
	HRR	T1,P4		;COPY OFFSET, LEAVE FLAGS ALONE
	JRST	CPOPJ1##	;AND RETURN SUCCESS
	SUBTTL	SAVGET -- PARAMETERS


;SAVGET LOWER CORE LOCATIONS USED FOR UUOS TO MONITOR
;USED IN SAVGET IN APRSER AND SAVGET IN SEGCON
;THESE LOCATIONS ARE DEFINED TO BE IN THE USERS UUO ACS

;FOR LOOKUP,ENTER UUOS:
	XP	SGANAM,0
			;FILE NAME
	XP	SGAEXT,SGANAM+1
			;FILE EXTENSION
	XP	SGADAT,SGANAM+2
			;FILE CREATION DATE+TIME
	XP	SGALEN,SGANAM+3
			;LH=-LENGTH,RH=FIRST LOC-1 DUMPED

			; OR PROJECT-PROGRAMMER NUMBER(DISK)
	XP	SGAEND,SGALEN+1
			;LAST WORD OF DUMP COMMAND LIST=0(SAVE AND GET)
	XP	SGAREN,SGAEND
			; ALSO FIRST WORD FOR RENAME USED AS DELETE
	XP	SGAPPN,SGAREN+3
			;FOURTH WORD-PLACE TO SAVE PROJECT-PROGRAMMER

			; NUMBER USER TYPED

;FOR OPEN UUOS:
	XP	SGAMOD,10
			;S MODE WORD FOR OPEN UUO
	XP	SGADEV,SGAMOD+1
			;DEVICE NAME
	XP	SGAHED,SGAMOD+2
			;INPUT-OUTPUT BUFFER HEADER ADDRESSES=0

;MISC. DATA LOCATIONS:

	XP	SGACOR,13
			;AC FOR CORE UUO'S(HIGHEST USER LOC DESIRED)
	XP	SGADMP,14
			;DUMP COMMAND IOWD
IFN FTEXE,<SGASAV==:SGADMP>
	XP	SGANEW,15
			;NEW CORE ASSIGNMENT AS SPECIFIED BY THIRD ARG
	XP	SGAHGH,16
			;LH=EXT TO USE FOR SAVING HIGH SEG

			; RH=EXT TO DELETE(IE SHRHGH OR HGHSHR)
	XP	SGALOW,17
			;LH=EXT WHICH USER TYPED FOR SAVE OR GET COMMAND

			; OR .SAV IF HE DIDN'T TYPE AN ARG WITH LEADING PERIOD

			; RH=0
	SUBTTL	SAVGET -- COMMAND SCAN

;ROUTINE TO SCAN COMMAND STRING ARGUMENTS FOR SAVE,GET,RUN AND R
;COMMANDS AND STORE THEM IN JOB DATA AREA WHICH MUST BE IN CORE
;WHEN SGSET IS CALLED FROM COMMAND DECODER
;CALL:	MOVE T2,SIXBIT DEVICE NAME
;	MOVE J,JOB #
;	MOVE U,LDB ADDRESS
;	MOVE S,ADR. OF MONITOR JOB(SAVJOB,GETJOB,RUNJOB)
;	MOVE R, ADR. OF JOB AREA
;	PUSHJ P,SGSET


SGSETD:	HLLZ	T2,SYSTAP##	;SET DEFAULT DEVICE OF DISK
SGSET:	MOVEM	P1,.UPMP+.UPUAC+6
	MOVEM	P2,.UPMP+.UPUAC+4 ;SAVE COMMAND FOR GET
	PUSHJ	P,SETASA	;TURN ON THE EXEC MODE UUO FLAG
	MOVSI	T1,(JS.SAC)
	SKIPL	.PDSAC##(W)
	TDNE	T1,JBTST2##(J)
	PUSHJ	P,TTYCTX
	HRRZS	.PDSAC##(W)
	MOVEM	T2,.JDAT+SGADEV	;STORE DEFAULT DEVICE NAME
	MOVEM	P1,.JDAT+SGAMOD	;SAVE PHYSICAL/LOGICAL BIT FOR LATER
	SETZM	.JDAT+SGAPPN	;INDICATE NO DEFAULTING DONE
	CAMN	P2,PLNTXT##	;USER-DEFINED COMMAND?
	JRST	SGSETC		;YES, COPY STUFF FROM BLOCK RATHER THAN COMMAND
	HRRZ	P3,S		;COMMAND
IFN FTEXE,<
	CAIN	P3,MRGJOB	;MERGE COMMAND?
	JRST	SGSETE		;YES
>
	CAME	T2,[SIXBIT/SYS/] ;R COMMAND?
	CAIN	P3,SAVJOB	;OR SAVE COMMAND?
	JRST	SGSETE		;YES, USE OLD DEFAULTS
	MOVSI	T1,(PD.UDS)	;WAS A SAVE COMMAND THE LAST
	TDNE	T1,.PDDFL##(W)	; COMMAND DONE?
	PUSHJ	P,SGSEND	;OR WERE ARGUMENTS TYPED?
	  JRST	SGSETE		;YES, OLD STYLE DEFAULTING
	SKIPN	T1,.PDNAM##(W)	;NAME FROM PREVIOUS GET OR RUN
	JRST	SGSETE		;USE JBTPRG
	MOVEM	T1,.JDAT+SGANAM	;STORE NAME
	MOVEM	T1,JBTPRG##(J)
	MOVE	T1,.PDSTR##(W)	;FILE STRUCTURE
	MOVEM	T1,.JDAT+SGADEV
	MOVE	T1,.PDDIR##(W)	;DIRECTORY
	MOVEM	T1,.JDAT+SGAPPN
	MOVSI	T1,.PDSFD##(W)	;AND SFD'S
	HRRI	T1,.JDAT+JOBUAL##+3
	BLT	T1,.JDAT+JOBUAL##+MAXLVL##+2
	JRST	SGSETG		;GO PROCESS GET OR RUN
SGSETE:	PUSHJ	P,CTEXT1	;GET DEVICE OR NAME
	CAIE	T3,":"		;SEE IF DEVICE
	JRST	SGSETF		;NO--SET FILE NAME
	MOVEM	T2,.JDAT+SGADEV	;YES--SAVE IT
	PUSHJ	P,CTEXT		;AND GET FILE NAME
SGSETF:
IFN FTEXE,<
	CAIN	P3,MRGJOB	;MERGE COMMAND?
	JRST	SGSTFA		;YES, A FILE NAME IS REQUIRED
>
	SKIPN	T2		;SEE IF FILE TYPED IN
	MOVE	T2,JBTPRG##(J)	;NO--GET DEFAULT IF ANY
	MOVEM	T2,JBTPRG##(J)	;SAVE FILE NAME FOR SYSTAT COMMAND
SGSTFA:	JUMPE	T2,NOTENF	;THERE MUST BE A FILE NAME
	MOVEM	T2,.JDAT+SGANAM	;STORE FILE NAME
	SETZB	T2,.JDAT+JOBUAL##+3  ;ASSUME USER DID NOT SPECIFY AN EXTENSION OR SFD'S
				; 0 WILL BE TURNED INTO SAV OR DMP
	CAIN	T3,"."		;IS AN EXTENSION SPECIFIED
	PUSHJ	P,CTEXT		;YES. GET EXTENSION
	HLRZS	T2		;SEE IF THE USER
	CAIE	T2,(SIXBIT /SHR/) ;HAS SPECIFIED AN
	CAIN	T2,(SIXBIT /HGH/) ;IMPROPER LOW EXTENSION
SGSETG:	MOVEI	T2,0		;YES--IGNORE IT
	HRLZM	T2,.JDAT+SGAEXT	;STORE IT FOR LOOKUP
IFN FTEXE,<
	MOVSI	T1,(JS.EXE)
	CAIN	T2,(SIXBIT /SAV/)
	ANDCAM	T1,JBTST2##(J)
>
				; LOOKUP OR ENTER
	PUSHJ	P,SETEXT##	;SET HIGH EXTENSION(SGAHGH) TO .SHR IF SSAVE OR GET
				; ,HGH IF SAVE(LH S=NSRBIT).

	SETZM	.JDAT+SGADAT	;SET DATE(E+2) TO 0, SO MONITOR WILL USE TODAYS
	SKIPN	T2,.JDAT+SGAPPN ;PPN DEFAULTED?
	PUSHJ	P,PJPGNO	;GET PROJ. PROG. NO.
	MOVEM	T2,.JDAT+SGAPPN	;STORE 0 IF NO []'S TYPED BY USER
	SETO	P1,
	CAIE	T3,","		;COMMA TYPED?
	JRST	[JUMPE T2,SGSET4 ;(N0) IF NO PPN, ALL IS OK
		 JRST SGSETS]
	JUMPE	T2,COMERA	;(YES) ERROR IF SFD WITHOUT PPN
	SETZ	P1,		;SET SFD FLAG
SGSETS:	MOVSI	T1,(SIXBIT/SYS/)
	CAME	T1,.JDAT+SGADEV	;DID HE ASK FOR "SYS" BY MISTAKE?
	JRST	SGSETH		;NO, ALL IS OK
	PUSH	P,T3		;SAVE PUNCTUATION
	PUSHJ	P,DEVLG##	;IS "SYS" A LOGICAL NAME?
	  SKIPA			;NO, CHANGE IT TO "DSK"
	JRST	SGSETI		;YES, NO CHANGES (HE KNOWS
				;  WHAT HE IS DOING)
	MOVSI	T1,(SIXBIT /DSK/)
	MOVEM	T1,.JDAT+SGADEV	;HE TYPED .R FOO[N,N]
				;SO CHANGE "SYS" TO "DSK"
SGSETI:	POP	P,T3		;RESTORE PUNCTUATION
SGSETH:	JUMPN	P1,SGST0B	;JUMP IF NO PATH SPECIFIED
	MOVEI	P2,JOBUAL##+.JDAT+3  ;WHERE TO STORE SFD'S
SGSET0:	PUSHJ	P,CTEXT		;GET NEXT SFD
	JUMPE	T2,NOTENF
	MOVEM	T2,(P2)		;STORE SFD IN LOOKUP/ENTER BLOCK
	AOS	P2		;NEXT SFD SLOT
	SETZM	(P2)
	CAIE	T3,","		;WAS ANOTHER SFD TYPED?
	JRST	SGST0B		;NO
	CAIGE	P1,MAXLVL##-1	;EXCEED MAXIMUM NUMBER OF SFD'S?
	AOJA	P1,SGSET0	;NO, GO READ THE NEXT SFD
	JRST	COMERA		;TO MANY SFD'S
SGST0B:	SKIPN	.JDAT+JOBUAL##+3 ;A PATH TYPED OR DEFAULTED?
	JRST	SGSET4		;NO
	MOVEI	T1,JOBUAL##	;ADDRESS OF THE PATH
	EXCH	T1,SGAPPN+.JDAT	;STORE PATH AND GET THE PPN
	MOVEM	T1,JOBUAL##+.JDAT+2  ;STORE THE PPN
	SETZM	.JDAT+JOBUAL##+1  ;SO FILSER WILL SCAN IF THE SCAN SWITCH IS ON
SGSET4:				;< SO ANGLE BRACKETS MATCH
	CAIE	T3,">"		;IS 2741 ENDING?
	CAIN	T3,"]"		;OR USUAL "]"?
	PUSHJ	P,COMTYS	;YES, DISCARD CHARACTER
	PUSHJ	P,CORARG	;AMOUNT OF CORE (OPTIONAL THIRD ARG.)
	  JRST	SGSET1		;RETURN HERE IF NO ARG.
	TLNE	T2,-1		;USER ARG EXCEED MAX. SIZE OF CORE?
	JRST	COMERR		;YES, PRINT COMMAND ERROR
SGSET1:	HRRZM	T2,.JDAT+SGANEW	;STORE FOR RUN AND SAVE
	PUSHJ	P,SGSEND
	  JRST	COMERR		;NO--ERROR
	HRRZS	T2,S		;SCHEDULE MONITOR JOB
				; GUARRANTEE LH OF PC WORD IS 0, SINCE IT WILL
				; BE ADDED TO STARTING ADDRESS(IF RUN COM)
	SUBI	S,SAVJOB
	MOVSI	T1,(PD.UDS)	;ASSUME RUN,GET COMMAND (REMEMBER DEFAULTS)
	IORM	T1,.PDDFL##(W)
	SKIPN	S		;IS IT?
	ANDCAM	T1,.PDDFL##(W)	;NO, FORGET DEFAULTS
IFN FTEXE,<
	PUSHJ	P,CHKEXE	;IS THIS AN EXE SAVE?
	  JRST	SGST1A		;YES, MAKE AN EXE FILE
				;NO, FALL THRU TO REGULAR SAVES
>	;END OF IFN FTEXE
	SKIPN	.UPMP+.UPREL	;IF NON-CONTIGUOUS CORE IMAGE
	SKIPE	.UPMP+.UPVRT	;OR VIRTUAL (1+I SEA)
SGST1A:	JUMPE	S,SGSET2	;GO ELSEWHERE IF SAVE
SGST1B:
IFN FTMP,<
	PUSHJ	P,CLRJSP##	;CLEAR JBTSPS TO ENSURE MONITOR JOB RUNS ON MASTER
>
	PJRST	MSTART##	;START JOB WITH PC IN MONITOR MODE
SGSET2:	HLRZ	T1,JBTADR##(J)	;GET HIGHEST ADDRESS IN LOW SEG
	CAMGE	T1,.JDAT+SGANEW	;COMPARE WITH USER STORED CORE ARG
	MOVE	T1,.JDAT+SGANEW	;USER'S WAS LARGER, USE IT
	HRRM	T1,.JDAT+JOBCOR##	;AND SET UP JOBCOR.
IFN FTEXE,<
	PUSHJ	P,CHKEXE	;NSAVE OR NSSAVE?
	  JRST	SGST1B		;YES, SAVE AN EXE FILE
>	;END OF IFN FTEXE
	PUSHJ	P,CLRASA
	JRST	COMERA		;LOSE SINCE MONITOR CAN'T DO IT ANYWAY

SGSEND:	PUSHJ	P,SKIPS1	;SKIP SPACES
	  JRST	CPOPJ1##	;EOL
	CAIE	T3,"("		;SEE IF USER ARGUMENTS
	CAIN	T3,"-"		;DITTO (THE OLD WAY)
	JRST	CPOPJ1##	;YES, END OF COMMAND LINE
	POPJ	P,		;NO, MORE TO PROCESS
;COPY USER-DEFINED COMMAND INFORMATION TO SGAXXX.
SGSETC:
	SE1ENT			;DO THIS IN SECTION 1 (IN CASE GFWNZS)
	SETZM	.JDAT		;CLEAN OUT THE ACS.
	MOVE	T1,[.JDAT,,.JDAT+1] ;BLT POINTER
	BLT	T1,.JDAT+17	;SINCE WE AREN'T TOO CAREFULL.
	PUSHJ	P,SETEXT##	;SETUP EXTENSION
	HLRZ	T4,P3		;GET POINTER TO OUR BLOCK
;MAYBE	SSX	T4,MDSEC2	;POINT TO PROPER SECTION
	MOVE	T1,(T4)		;GET NUMBER OF WORDS IN OUR BLOCK
	SOJLE	T1,SGSCER	;IF THIS BLOWS UP, WE HAVE A PROBLEM.
	MOVE	T2,1(T4)	;GET DEVICE NAME
	MOVEM	T2,.JDAT+SGADEV	;SAVE AS DEVICE NAME FOR RUN UUO
	SOJLE	T1,SGSCER	;IT MUST CONTAIN AT LEAST THE NAME
	MOVE	T2,2(T4)	;GET NAME OF PROGRAM TO RUN
	MOVEM	T2,.JDAT+SGANAM	;SAVE AS FILENAME FOR RUN UUO
	SOSLE	T1
	SKIPA	T2,3(T4)	;GET EXTENSION
	SETZ	T2,
	MOVEM	T2,.JDAT+SGAEXT
	SOJLE	T1,[SETZM .JDAT+SGAPPN ;NO PPN
		JRST SGSCEX]	;AND FALL INTO COMMON CODE
;PPN AND SFDS
	MOVEI	T2,JOBUAL##	;WHERE WE ARE GOING TO PUT A PATH BLOCK
	MOVEM	T2,.JDAT+SGAPPN	;POINTER TO PATH BLOCK
	SETZM	.JDAT+JOBUAL##+1 ;ZERO PATH FLAGS
	XMOVEI	T2,4(T4)	;POINTER TO START OF BLOCK TO COPY
	XMOVEI	T3,.JDAT+JOBUAL##+2 ;WHERE TO.
	CAILE	T1,MAXLVL+1	;MAKE SURE WE WILL FIT
SGSCER:	STOPCD	CPOPJ,DEBUG,CBB, ;++COMMAND BLOCK BAD
	PUSHJ	P,XBLTAT##	;COPY THE DATA
	SETZM	(T3)		;ADD IN A TERMINATING ZERO
SGSCEX:
	SETZM	.JDAT+SGAMOD	;ALLOW LOGICAL NAMES
	HRRZ	T2,S		;GET ADDRESS TO DISPATCH TO
	TLO	M,NOCRLF	;DO IT LIKE REAL COMMANDS
	PJRST	MSTART##	;AND GET THE MONITOR TO RUN AT UUO LEVEL
	SUBTTL	SAVGET -- RUN AND GETSEG UUO'S

;ROUTINE TO PICKUP ARGUMENTS FOR RUN AND GETSEG UUOS
;THIS ROUTINE DOES SAME THING AS SGSET, EXCEPT THAT ARGUMENTS ARE
;OBTAINED FROM USER UUO ARGUMENTS INSTEAD OF FROM CONSOLE COMMAND
;THE USERS ARG ARE MOVED TO USER ACS(SGA...), THEREBY CLOBBERING HIS ACS
;USER AC FIELD AND START PC OFFSET(RUN UUO) ARE SAVED ON PD LIST AT JOBPD3
;THEN LOWER CORE IS SET UP(SG2 CALLED) RESET IS NOT DONE (FOR GETSEGUUO)
;JBTPRG NOT SET FOR LOW SEG, SINCE GETSEGUUO SHOULD NOT
;CALL:	MOVE T1,CONTENTS OF USER AC(ADR. OF 3 WORD ARG LIST)
;	MOVE R,JOB RELOCATION
;	PUSHJ P,GETARG
;	RETURN


GETARG::HRR	M,T1		;MOVE ADR. OF ARG LIST TO UUO
	EXCH	T1,(P)		;AND PUT ON PD LIST
	PUSH	P,T1		;MOVE RETURN PC UP ONE IN PD LIST
	LDB	T1,PUUOAC##	;USER AC FIELD IN RUN OR GETSEG UUO
	HRRM	T1,-1(P)	;SAVE IN CASE OF ERROR RETURN
	PUSHJ	P,GETWDU##	;GET FIRST ARG FROM USER AREA
	MOVEM	T1,.JDAT+SGADEV	;STORE DEVICE NAME
	PUSHJ	P,GETWD1##	;GET NEXT ARG FROM USER AREA
	MOVEM	T1,.JDAT+SGANAM	;STORE FILE NAME FOR LOOKUP (DO NOT STORE FOR LOWSEG)
	PUSHJ	P,GETWD1##	;GET THIRD ARG(EXTENSION WORD E+1)
	MOVEM	T1,.JDAT+SGAEXT	;STORE EXTENSION AND RH FROM USER
	PUSHJ	P,GETWD1##	;GET FOURTH ARG(DATE WORD)
	MOVEM	T1,.JDAT+SGADAT
	PUSHJ	P,GETWD1##	;GET FIFTH USER ARG FROM USER AREA
	MOVEM	T1,.JDAT+SGAPPN	;STORE PROJECT,PROGRAMMER NO. OR 0
	PUSHJ	P,GETWD1##	;SIXTH ARG FROM USER
	MOVEM	T1,.JDAT+SGANEW	;STORE CORE ARG, PAGE RANGE, OR 0(HIGHEST LOC DESIRED)
	HLRZ	T2,.JDAT+SGAEXT	;PUT ARG IN T2, SO SAME AS SGSET RETURN FROM CTEXT
	CAIE	T2,'SHR'	;SEE IF THE USER
	CAIN	T2,'HGH'	; GAVE A BAD EXT
	MOVEI	T2,0		;YES--IGNORE IT
	PUSHJ	P,SETEX1##	;SAVE EXT AGAIN IN SGALOW
				; SETUP EXT FOR HIGH SEG(SGAHGH="SHR")
				; SETUP EXTENSION FOR LOW SEG(SGALOW="SAV")
	JRST	SG2A		;GO SET UP LOWER CORE AND RETURN
				; DO NOT DO A RESET
	SUBTTL	SAVGET -- SAVE A JOB

;THIS JOB SAVES A JOB AREA ON RETRIEVABLE STORAGE
;THIS JOB RUNS IN EXEC MODE AND CALLS IO ROUTINES USING REGULAR UUOS
;NO ATTEMPT IS MADE TO SAVE STATUS OF IO DEVICES, JOBPDP, OR AC'S
;IN FACT THE ONLY USEFUL THING WHICH MAY BE DONE WITH A JOB AREA
;AFTER IT HAS BEEN SAVED IS TO START EXECUTION OVER AT THE STARTING
;ADDRESS
SAVJOB::JSP	T2,SG1		;SET UP ACS R,P,J, RESET DEVICES
	PUSHJ	P,CLRTAB	;CLEAR BITS AND TABLES
	PUSH	P,[0]		;STORE ZERO IN JOBPD1
				; SO THAT SGRELE CAN
				; TELL SAVE IS IN PROGRESS
	PUSHJ	P,RMVPFH##
	PUSHJ	P,ADJCOR##	;COMPUTE AMOUNT OF CORE FOR BOTH LO+HI SEGS
				; FROM USER'S CORE ARG(IF ANY)

	HLRE	T2,.JDAT+SGADMP	;-NO. OF WORDS TO WRITE
	PUSHJ	P,CKIOWD	;CHECK USER'S CORE ARG(IF ANY) WITH AMOUNT TO WRITE
				; RETURN ONLY IF 0 OR NOT SMALLER
	HRRM	T1,.JDAT+JOBCOR## ;STORE MAX OF SIZE OF FILE OR CORE ARG
				; FOR ASSIGNING INITIAL CORE WHEN FILE GOTTEN
	SETOM	.JDAT+JOBSV##	;FLAG LOW SEGMENT AS NOT COMPRESSED SO
				; WILL NOT TRY TO EXPAND IT IF I/O DOES NOT
				; GO TO COMPLETION
	PUSHJ	P,SGOPEN##	;OPEN THE DEVICE
IFN FTEXE,<
	MOVE	T1,DEVMOD(F)	;DEVICE BITS
IFN FTNUL,<
	TLNE	T1,DVTTY	;IF DVTTY IS ON, IT IS NUL:
	PJRST	SAVFIN		; SO WE'RE DONE
>
	MOVSI	T2,(JS.EXE)	;BIT WHICH SAYS SAVE IN EXE FORMAT
	TLNE	T1,DVMTA	;A MAGTAPE
	SKIPN	.UPMP+.UPREL	; AND VIRTUAL ?

	TLNE	T1,DVDTA	; OR A DECTAPE ?
	ANDCAM	T2,JBTST2##(J)	;YES, SAVE IN THE OLD OFRMAT
	PUSHJ	P,CHKEXE	;EXE FILE SAVE?
	  JRST	SAVEXE		;YES, GO TO SPECIAL CODE
>	;END OF IFN FTEXE
	PUSHJ	P,SAVHGH##	;INIT DEV,SAVE HIGH SEG, IF ANY, RETURN IF OK
	  JRST	SAVFIN		;HIGH SAVED, BUT NO DATA IN LOW SEG, SO DO
				; NOT WRITE LOW FILE
				; SKIP RETURN IF LOW SEG TO BE WRITTEN

				; SGALEN, AND SGAEXT RESTORED
	OPEN	0,SGAMOD	;RE INIT DEVICE, SO UGETF WILL SET FIRST FREE
				; BLOCK BECAUSE NO LOOKUP OR ENTER DONE
	  JRST	SGERRA		;DEVICE NOT AVAILABLE
	SETZM	.JDAT+SGADAT	;CLEAR DATE, SO GET TODAY FOR CREATION
	UGETF	0,SGAHED	;TELL DECTAPE SERVICE TO START AT FRONT
	MOVEI	T1,-2		;FLAG THAT CORE HAS BEEN COMPRESSED
	HRLM	T1,USRHCU##	;KEEP LH NEG. COMMAND DECODER WILL EXPAND
				; CORE ON START ,DDT,SAVE, REENTER,SSAVE IN CASE
				; THIS SAVE IO DOES NOT GO TO COMPLETION. (CONTROL C
				; OR DEVICE FULL, SO THAT CORE DOES NOT GET EXPANDED)
	ENTER	0,SGANAM	;ENTER FILE NAME IN DIRECTORY
	JRST	SAVERR		;DIRECTORY FULL OR PROTECTION FAILURE
	MOVE	T1,.JDAT+JOB41## ;SAVE USER UUO HANDLING JSR
	MOVEM	T1,.JDAT+JOBS41##	;IN UPPER PART OF JOB DATA AREA
	SETZM	.JDAT+JOBEXM##	;CLEAR MEMORY OF EXAMINE

	SETZM	.JDAT+JOBFDV##	;CLEAR MEMORY OF FIN
	MOVE	T1,.JDAT+JOBDDT## ;SAVE DDT STARTING ADDRESS HIGHER UP IN JOB DATA AREA
	MOVEM	T1,.JDAT+JOBSDD## ;SO COMPRESS ALWAYS MOVES CODE DOWN
	HRRZ	T3,.JDAT+JOBSA## ;SAV START ADDRESS FOR 10DMP
	MOVEI	T1,JOBSV##	;POINT TO 1ST DATA WORD
	MOVEI	T2,JOBSDD##	;IT STARTS AT JOBSDD
	HLRE	J,.JDAT+SGADMP	;IOWD FOR THIS SIZE CORE(-LENGTH TO WRITE)
	MOVNS	J		;POSITIVE LENGTH
	ADDI	J,JOBSVM##	;ADD IN FIRST LOC-1 TO WRITE=HIGHEST LOC TO WRITE
				; TO MAKE END TEST
	HLL	J,T2		;USE R FOR RELOCATION IF KA
CMPLP1:	MOVEM	T1,U		;SAVE 1ST LOC FOR IOWD
	CAMLE	T2,J		;SEARCH FOR 1ST NON-0 WORD
	AOJA	T1,CMPTHR	;THROUGH
	EXCTUX	<SKIPN @T2>	;THIS A DATA WORD?
	AOJA	T2,.-3		;NO. KEEP LOOKING
	MOVNI	P1,1		;YES. P1 WILL BE AN IOWD
	HRLI	P1,-1(T2)	;1ST LOCATION - 1
CMPLP2:	EXCTUU	<PUSH T1,@T2>	;SAVE A DATA WORD
	AOS	T2
	CAMGE	T2,J		;AT TOP?
	EXCTUX	<SKIPN @T2>	;NO. NEXT WORD NON-0?
	JRST	.+2		;NO. THROUGH THIS BLOCK
	SOJA	P1,CMPLP2	;COUNT THE WORD AND CHECK NEXT
	EXCTUU	<MOVSM P1,(U)>	;SAVE IOWD IN FRONT OF BLOCK
	AOJA	T1,CMPLP1	;LOOK FOR NEXT NON-0 BLOCK
;HERE WHEN THE CORE IMAGE IS ZERO COMPRESSED
CMPTHR:	HRLI	T3,254000	;SET A JRST C(JOBSA)
	EXCTXU	<MOVEM T3,-1(T1)>	;AT END OF FILE
	SUBI	T1,JOBSV##	;COMPUTE WORD COUNT
	MOVNS	T1		;MAKE AN IOWD
	HRL	T1,.JDAT+SGADMP	;START ADDRESS
	MOVSM	T1,.JDAT+SGALEN	;IOWD FOR THE OUTPUT UUO
				; ENTER USES NEGATIVE USRCHU TO SET RIBVER
	PUSHJ	P,SGDOA		;DO OUTPUT,RELEASE,FIND TTY
	OUTPUT	0,SGALEN	;OUTPUT UUO EXECUTED BY SGDO
				; RETURN HERE ONLY IF NO ERRORS
SAVFIN:
IFN FTEXE,<
	MOVE	J,.CPJOB##		;GET JOB NUMBER
	MOVSI	T1,(JS.EXE)	;GET EXE FILE STATUS BIT
	ANDCAM	T1,JBTST2##(J)	;CLEAR BIT IN JOB STATUS WORD
	MOVSI	T1,USRMOD	;USER-MODE BIT
	TDNE	T1,.JDAT+JOBPD1## ;WAS THIS A UUO?
	 JRST	USVFIN		;YES, GO HANDLE
>
	PUSHJ	P,SGREL		;RELEASE DEVICE AND FIND TTY
	MOVE	T2,.JDAT+SGANAM	;GET JOB NAME
	PUSHJ	P,PRNAME##	;PRINT IT
	JSP	T1,PHOLD##	;PRINT MESSAGE AND STOP JOB
	ASCIZ	/ saved/

IFN FTEXE,<
USVFIN:	POP	P,.UPMP+.UPTMC	;RESTORE VM LOCS
	POP	P,.UPMP+.UPTMI
	PUSH	P,.JDAT+JOBPD1## ;DUPLICATE RETURN ADDRESS
IFN FTKLP,<
	PUSH	P,.JDAT+JOBPD1##+1	;DITTO
>
	AOS	(P)		;INCREMENT
	PUSHJ	P,SGREL		;RELEASE DDB
	MOVSI	T1,.JDAT	;RESTORE USER ACS
	EXCTXU	<BLT T1,17>	;FROM SHADOW AREA
IFN FTMP,<
	PUSHJ	P,DPXST##	;SET UP PROPER RUNNABLE BITS FOR THIS JOB IN JBTSPS
>
	JRST	USRXIT##	;GIVE SKIP RETURN FOR UUO
> ;END OF IFN FTEXE

SAVERR::
IFN FTEXE,<
	MOVE	J,.CPJOB##		;GET JOB NUMBER
	MOVSI	T1,(JS.EXE)	;GET EXE FILE STATUS BIT
	ANDCAM	T1,JBTST2##(J)	;CLEAR BIT IN JOB STATUS WORD
	TLO	P1,GTSAV	;REMEMBER THIS IS A SAVE
>
	HRRZS	USRHCU##	;CLEAR SAVE IN PROGRESS FLAG
	MOVEI	T1,PRTERR	;ERROR CODE IN CASE RUN UUO(PROTECTION ERROR)
	PUSHJ	P,SGRELL	;CHANGE TO DISK ENTER ERROR CODE IF DSK
				; RELEASE DEVICE AND RETURN TO USER(IF RUN UUO)
				; OR FIND TTY+PRINT ?CRLF
	PJSP	T1,LKENFL	;PRINT MESSAGE AND STOP JOB
	ASCIZ	/Enter error /
	SUBTTL	SAVGET -- "EXE" SAVE FILES

IFN FTEXE,<
;THIS ROUTINE DOES A "SAVE" FOR USERS RUNNING
; UNDER A VIRTUAL MEMORY SYSTEM. THE SAVE FILE IS IN THE NEW FORMAT
; (I.E. A VARIABLE-LENGTH DIRECTORY AND A VARIABLE NUMBER OF
; FILE PAGES FOLLOWING IT).

;FLAG BITS USED IN THE LEFT HALF OF P1
SV%SAV==NSRBIT		;USER ISSUED AN "SAVE" COMMAND
;SV%SHR==(1B1)		;THIS BIT MEANS WE SAW A SHARABLE HIGH SEG.
			;IT IS DEFINED IN S AND MUST NOT CHANGE
SV%FUL==(1B2)		;USER HAD MAX ALLOWABLE CORE, PAGE WAS WRITTEN OUT
SV%PGO==(1B3)		;PHYSICAL LIMIT REACHED, PAGE WAS PAGED OUT
SV%DWO==:(1B4)		;DON'T WRITE OUT DIRECTORY (USED FOR 1ST PASS THRU DIR)
GT%DAF==:(1B5)		;DIRECTORY ALREADY FLUSHED (OCCURS IF
			; THE LAST PAGE TO BE READ IN OVERWRITES THE
			; DIRECTORY PAGE.)
GT%PLE==:(1B6)		;PHYSICAL LIMIT WAS EXCEEDED ON A GET
GTHGH==:(1B7)		;GET HIGH SEGMENT (PARAMETER TO GETNEW)
GTLOW==:(1B8)		;GET LOW SEGMENT (PARAMETER TO GETNEW)
GTBTH==:GTHGH+GTLOW	;GET BOTH HIGH AND LOW SEGMENTS
GT%GTH==:(1B9)		;A HIGH SEGMENT WAS FOUND AND READ IN (FOR VEST.
			; JOB DATA AREA SET-UP)
GT%S1S==:(1B10)		;SAW A SHARABLE PAGE IN THE COURSE OF THIS GET
GT%DW1==:GT%S1S+SV%DWO+GT%GTH ;THESE BITS ARE CLEARED WHEN ROTATING DIRECTORIES
GTMRG==:(1B11)		;MERGE EXE FILE WITH CURRENT CORE IMAGE
GTSAV==:(1B12)		;DOING A SAVE (AS OPPOSED TO RUN, MERGE, OR GETSEG)

;IN SAVEXE, P1-P4 ARE USED FOR SCRATCH AC'S. THEIR CONTENTS ARE:
;
;P1 - 	LH=FLAGS
;	RH=MOVING POINTER TO DIRECTORY PAGE
;
;P2 - 	LH=COUNTER OF # OF DIRECTORY PAGES
;	RH=CURRENT FILE PAGE # FOR DIRECTORY ENTRY
;
;P3 -	USED TO HOLD CURRENT PAGE #'S WHEN PASSING OVER THE PAGE MAP
;
;P4 -	LH=ACCESS BITS OF THE PAGE (IF ANY) WHICH HAD
;		TO BE WRITTEN OUT TO THE DISK TO MAKE ROOM FOR
;		THE DIRECTORY PAGE. THESE BITS ARE SAVED BECAUSE
;		THEY ARE NEEDED FOR THE DIRECTORY, BUT AT THAT TIME,
;		THE PAGE WHICH THEY REPRESENT IS WRITTEN OUT
;		AND CAN'T BE BROUGHT BACK IN UNTIL THE DIRECTORY IS
;		RELEASED.
;	RH = DISK ADDRESS OF PAGE WHICH WAS WRITTEN OUT, OR
;	     THE PAGE NUMBER OF A PAGE WHICH HAD TO BE PAGED OUT
;	     BECAUSE THE CREATION OF THE DIRECTORY CAUSED THE USER'S
;	     PHYSICAL LIMIT TO BE EXCEEDED.
;
;P4 (NON-VM ONLY) - SCRATCH AC
;
;
REPEAT 0,<
	***** EXPLANATION OF THE NSAVE PROCESSING *****


The NSAVE processing is fairly straightforward with a couple
of  exceptions.   First,  a  free  page  is acquired and the
directory is created in it.  Next, the directory is  written
out  and  its  core is released.  Finally, the core image is
written out, one page at a time for the low seg, and in  one
fell swoop for the high seg.

The only minor problem involved in the use of the  directory
is  that  before the 1st entry is created, the length of the
entire directory must be known (in order  to  set  the  file
page  #  field).   This  is  accomplished  by  creating  the
directory as if it were one  page  long,  but  not  actually
writing  it  out  as it is being created.  The end result of
this operation is a valid directory if it is one page  long,
or  the  last  page  of the directory if it is more than one
page long.  In the latter case, the current file page number
is adjusted to be one more than the length of the directory,
and the whole process is repeated with each  directory  page
being   written  out  as  it  is  created.   This  technique
penalizes   only   those   wierdos   with   extremely   long
directories.

Another problem occurs in VM systems when  the  user's  core
image  is  sufficiently  large  that  there are no available
pages to use as a directory.  In this case a random page  is
written  to  disk  and  deleted from the page map.  The disk
address of the page is saved so the page can be read back in
later.   Also,  the  directory  access bits for the page are
computed and stored before the page is written out  so  that
it  won't  have  to  be  read  back in at the point when its
directory entry is being created.

The last problem  in  VM  systems  occurs  when  the  user's
physical  core limit will not allow the directory page to be
actually  created.   In  such  a  case,  a  random  page  is
paged-out  (as distinguished from the previous case) and the
directory is then created.  If the second attempt to  create
the  directory  page  fails, a STOPCD results.  This page is
then later paged back in so that user's may not go "virtual"
inadvertantly.

For all systems, zeroes are  compressed  on  a  page-by-page
basis.  However, on non-VM systems, if the user's core image
is equal to CORMAX##, (i.e.   there  is  no  place  to  put  a
directory), then the directory is created in the user's AC's
and zero-compression is not done.  This implies  that  under
certain  extreme conditions, an EXE file may vary greatly in
size  depending  upon  the  value  of  CORMAX.

>;END OF REPEAT 0
;
;COME HERE TO BEGIN THE SAVE OF A VM SYSTEM CORE IMAGE..
;WE MUST FIRST INIT THE DEVICE AND ENTER THE
; .EXE FILE IN THE USER'S DIRECTORY
;



SAVEXE:	SKIPN	T1,.JDAT+SGALOW	;GET USER EXTENSION, IF ANY
	MOVSI	T1,'EXE'	;SET UP EXTENSION OF "EXE"
	MOVEM	T1,.JDAT+SGAEXT	;STORE IN USER'S AREA
	HRROS	USRHCU##	;SET SAVE IN PROGRESS FLAG IN MONITOR
	ENTER	0,SGANAM	;ENTER THE FILE-NAME IN THE DIRECTORY
	  JRST	SAVERR		;ERROR, ABORT WITH ERROR MESSAGE
	MOVSI	P1,GTSAV	;SET UP TO GET FLAGS
	HLRZ	T1,.JDAT+SGAHGH	;GET EXTENSION SET UP BY SG3
	CAIE	T1,'SHR'	;WAS THIS A NSSAVE?
	TLO	P1,SV%SAV	;NO, SET NON-SHARABLE BIT
	PUSHJ	P,COPVJD##	;COPY NUMBERS FROM JOBDAT TO VESTIGIAL JOBDAT
				; (ONLY NECESSARY FOR GETSEG OF UNKNOWN SEGMENTS)

;FALL THRU TO NEXT PAGE.....

;STILL IN IFN FTEXE CONDITIONAL
;WE MUST NOW SEARCH THRU THE USER'S PAGE MAP TO FIND A FREE
; PAGE THAT WE CAN USE AS THE DIRECTORY PAGE. IF WE FIND
; ONE, THEN THERE'S NO PROBLEM. HOWEVER, IF THE USER'S MAP
; IS FULL, WE MUST TEMPORARILY WRITE ONE OF THE USER'S
; PAGES OUT TO SECONDARY STORAGE AND USE THAT PAGE AS THE
; SCRATCH PAGE. EVEN IF WE FIND A FREE PAGE, WE MAY EXCEED
; THE USER'S PHYSICAL LIMIT BY ATTEMPTING TO CREATE IT, SO WE
; MAY HAVE TO PAGE OUT SOME OTHER PAGE IN ORDER TO CREATE
; THE DIRECTORY PAGE.

	SKIPN	VIRTAL##	;MUST BE ENOUGH VIRTUAL CORE TO CREATE 1 PAGE
	JRST	NEED1P##	;GIVE UP NOW
	PUSHJ	P,GTFREP	;TRY TO FIND A FREE PAGE
	  SKIPA	P3,[XWD 0,PAGSIZ##-1]	;COULDN'T, START AT PAGE 777
	JRST	[MOVE	P3,T1	;GOT ONE, PUT ITS NUMBER IN P3
		 JRST	PAGFRE]
				; NOW FIND ONE TO OUTPUT TEMPORARILY
	MOVE	J,.CPJOB##		;SET UP JOB NUMBER
SAV2:	MOVE	T1,P3		;GET THE PAGE #
	PUSHJ	P,TPAHS##	;TEST FOR SHARABLE HISEG
	  SOJA	P3,SAV2		;CAN'T USE THIS ONE, TRY NEXT LOWER PAGE
				; WE MUST FIND A PAGE THAT ISN'T IN THE
				; SHARABLE HI SEG SO EVENTUALLY, WE
				; WILL SKIP
	JUMPE	P3,NEED1P##	;IF IT'S PAGE 0, WE LOSE
	PUSHJ	P,CMPBIT	;COMPUTE THE SAVE-FILE BITS FOR THIS PAGE
	  JRST	BRCSTP		;ISSUE FATAL STOPCD IF NON-EXISTENT
	TLNE	T1,SV%ABZ	;DON'T REMOVE AN ABZ PAGE
	SOJA	P3,SAV2		;DECREMENT PAGE #
	HLLZ	P4,T1		;SAVE THESE BITS FOR LATER
	HRRZ	T1,P3		;GET THE PAGE #
	PUSH	P,P3		;SAVE P3
	SETZ	P3,		;FLAG NOT REALLY IPCF
	PUSHJ	P,IPCRMV##	;REMOVE PAGE FROM LOG. ADR. SPACE
	 JRST	[POP	P,P3	;RESTORE P3
		 JRST	SVABRT]
	POP	P,P3		;RESTORE P3
	PUSHJ	P,IPCPAG##	;WRITE PAGE OUT (RETURN WITH T2=PAGE #
				; OR DISK ADDRESS)

	JRST	SVABRT		;ERROR
	HRR	P4,T2		;SAVE ADDRESS WHERE WE PUT IT ON DISK
	TLO	P1,SV%FUL	;REMEMBER THAT WE DID THIS

	;FALL INTO PAGFREE

;STILL IN IFN FTEXE CONDITIONAL
;COME HERE WHEN WE HAVE FOUND A FREE PAGE TO USE AS THE DIRECTORY

PAGFRE:	MOVE	J,.CPJOB##	;JOB NUMBER
	MOVSI	T1,NSWP!NSHF	;GET LOCKED BITS
	TDNN	T1,JBTSTS##(J)	;JOB LOCKED?
	JRST	PAGFR1		;NO
	MOVEI	T1,SNSERR	;GET LOCKED ERROR CODE
	PUSHJ	P,SGRELE	;RELEASE DEV, RETURN ERROR CODE IF UUO
	PUSHJ	P,EXONLY	;PRESERVE XO BIT
	JSP	T1,PHOLD##	;PRINT MESSAGE AND STOP JOB
	ASCIZ	/ Illegal to save a locked core image/
PAGFR1:	MOVE	T1,CORMAX##	;GET MAX PHYSICAL LIMIT FOR SYSTEM
	LSH	T1,W2PLSH##	;MAKE CORMAX INTO PAGE NUMBER
	HRLI	T1,^D512	;MAKE HIM HAVE A VERY HIGH VIRTUAL LIMIT
	PUSH	P,.PDCVL##(W)	;REPLACE HIS NEW VIRTUAL LIMIT
	PUSH	P,.PDMVL##(W)	;AND SAVE HIS OLD ONE
	MOVEM	T1,.PDCVL##(W)
	MOVEM	T1,.PDMVL##(W)
	MOVEI	T1,^D512-1
	PUSH	P,JBTLIM##(J)
	DPB	T1,JBYLCR##
PGFRE2:	MOVE	T1,P3		;GET SAVED PAGE NUMBER
	PUSHJ	P,CRPAGE	;CREATE THE PAGE
	  SKIPA	T1,[1]		;PHYS LIM EXCEEDED, START LOOKING
				; FOR PAGE TO PAGE OUT AT PAGE 1.
	JRST	GOTDIR		;SUCCESS, WE HAVE OUR DIRECTORY
PGFRE3:	PUSHJ	P,PAGOUT	;TRY TO PAGE IT OUT
	  AOSA	T1		;BUMP PAGE #
	JRST	PGFRE4		;OK
	CAIE	T1,PAGSIZ##	;THRU UPMP?
	JRST	PGFRE3		;NO, KEEP GOING
	STOPCD	.,STOP,PGL,
				;++PAGES GOT LOST
PGFRE4:	TLOE	P1,SV%PGO	;REMEMBER WE DID IT (DONE IT BEFORE?)
	STOPCD	.,STOP,PAO,
				;++PAGE ALREADY OUT
	HRR	P4,T1		;SAVE PAGE # THAT WAS SENT OUT
	JRST	PGFRE2		;TRY TO CREATE DIRECTORY AGAIN
;COME HERE WHEN WE HAVE CREATED THE DIRECTORY PAGE
GOTDIR:	LSH	P3,PXWLSH	;CONVERT TO ADDRESS
	HRRI	P1,1(P3)	;P1 POINTS TO 2ND WORD OF THE DIRECTORY
	MOVEI	P2,1		;P2=DIR PAGE COUNT,,FILE PAGE #
	TLO	P1,SV%DWO	;DON'T ACTUALLY WRITE DIRECTORY, JUST COMPUTE IT
	TDZA	P3,P3		;START LOOKING AT PAGE 0 FOR USER'S PAGES
GOTDR2:	AOS	P3		;BUMP PAGE #
	PUSHJ	P,MKNTRY	;MAKE A DIRECTORY ENTRY FOR THIS PAGE
	  JRST	THRUDR		;DIRECTORY IS OVER, GO CHECK ITS LENGTH
	JRST	GOTDR2		;MORE TO GO, GET NEXT PAGE #


;STILL IN IFN FTEXE CONDITIONAL
;COME HERE WHEN THE DIRECTORY IS FINISHED
;IF THE DIRECTORY IS ONE PAGE LONG, THEN THE FULL DIRECTORY
; IS ALREADY SET UP AND READY TO BE OUTPUT. IF IT'S MORE THAN
; ONE PAGE LONG, ONLY THE LAST PAGE IS SET UP (WHICH OBVIOUSLY
; IS WORTHLESS NOW) AND NO PREVIOUS PAGES HAVE BEEN OUTPUT.
; IN THAT CASE, WE MUST GO THRU THE WHOLE PROCEDURE AGAIN,
; EXCEPT THIS TIME, WE WILL ACTUALLY WRITE OUT EACH PAGE
; AS WE GO.

THRUDR:	MOVNI	T1,EXESIZ
	HRLM	T1,.JDAT+SGALEN	;SET UP LENGTH
	MOVE	T1,[SV.END,,LN.END]	;STORE END BLOCK
	PUSHJ	P,PTDIRW	;..
	TLZ	P1,SV%DWO	;CLEAR "DON'T WRITE OUT" FLAG
	HRRZ	T1,P1		;GET DIRECTORY POINTER
	ANDI	T1,EXESIZ-1	;FIND OFFSET INTO LAST PAGE
	HLRZ	T2,P2		;GET # OF DIR PAGES-1
	LSH	T2,PXWLSH	;FIND LENGTH OF PREVIOUS PAGES
	ADD	T1,T2		;=TOTAL LENGTH OF DIRECTORY
	SUBI	T1,LN.END	;SUBTRACT LENGTH OF END-BLOCK
				;**NOTE**IF NEW BLOCKS ARE ADDED TO
				; THE FILE DIRECTORY, THEIR LENGTHS
				; SHOULD BE SUBTRACTED HERE
	HRLI	T1,SV.DIR	;SET UP 1ST WORD OF DIRECTORY
	TRZ	P1,EXESIZ-1	;SET POINTER TO TOP OF DIR PAGE
	PUSHJ	P,PTDIRW	;STORE IT AND BUMP POINTER
	TLNN	P2,-1		;WERE THERE MORE THAN 1 DIR PAGE?
	JRST	RELDIR		;NO (HOORAY!), WE CAN JUST OUTPUT PAGE
	HLRS	P2		;YES, SET FILE PAGE # TO BE THE
				; 1ST PAGE AFTER THE DIRECTORY PAGES
	AOS	P2		;MAKE IT ONE MORE THAN LAST DIR PAGE
	TDZA	P3,P3		;START OVER AGAIN AT PAGE 0
THRU2:	AOS	P3		;BUMP PAGE #
	PUSHJ	P,MKNTRY	;FORM A DIRECTORY ENTRY
	  SKIPA	T1,[SV.END,,LN.END]	;THRU, PUT OUT END BLOCK
	JRST	THRU2		;LOOP UNTIL PAGE 777
	PUSHJ	P,PTDIRW	;STORE IN DIRECTORY

;FALL THRU TO NEXT PAGE...

;STILL IN IFN FTEXE
;WE HAVE NOW FINISHED CREATING THE DIRECTORY.
;WE MUST GET RID OF THE DIRECTORY PAGE, RESTORE ANY
; PAGES THAT HAD TO BE WRITTEN OUT EARLIER,
; AND CREATE THE REST OF THE FILE.

RELDIR:	TRZE	P1,EXESIZ-1	;IS THERE A PARTIAL PAGE LEFT TO OUTPUT?
	PUSHJ	P,PUTDIR	;YES, SEND IT OUT
	HRRZ	T1,P1		;GET PAGE ADDRESS OF DIRECTORY
	PUSHJ	P,ZAPPAG	;DESTROY IT
	  STOPCD	RELDR9,DEBUG,DPN, ;++DIRECTORY PAGE NON-EXISTENT
	TLNE	P1,SV%FUL	;DID WE WRITE OUT A PAGE?
	PUSHJ	P,GTSAVP	;YES, GET IT BACK AGAIN
	TLNN	P1,SV%PGO	;DID WE HAVE TO PAGE OUT A PAGE?
				; (WAS PHYS LIMIT EXCEEDED?)
	JRST	RELDR1		;NO
	HRRZ	T1,P4		;YES, GET ITS PAGE #
	PUSHJ	P,PAGIN		;BRING IT IN
	  CAIA			;ERROR
	JRST	RELDR1		;OK
RELDR9:	POP	P,JBTLIM##(J)	;
	POP	P,.PDMVL##(W)
	POP	P,.PDCVL##(W)	;RESTORE VIR,PHY LIMITS
	JRST	SVABRT		;I/O ERROR--ABORT
;THIS IS THE MAIN LOOP FOR AN EXE FILE SAVE
;EACH PAGE IS WRITTEN OUT INDIVIDUALLY TO INSURE DEVICE AND
; SYSTEM COMPATABILITY

RELDR1:	POP	P,JBTLIM##(J)
	POP	P,.PDMVL##(W)
	POP	P,.PDCVL##(W)	;RESTORE VIR,PHY LIMITS
	SETO	P3,		;WE WILL START LOOKING AT PAGE 0
	SKIPLE	J,JBTSGN##(J)	;IS THERE A HI SEG
	PUSHJ	P,SETHRL##	;YES, SET LH(JOBHRL)
	MOVE	J,.CPJOB##	;RESET J
RELDR2:	AOS	T1,P3		;BUMP PAGE #
	CAIL	T1,EXESIZ	;THRU UPMP?
	JRST	[HRRZS	USRHCU## ;YES, CLEAR SAVE IN PROGRESS FLAG
		 JRST	SAVFIN] ; WE'RE FINALLY THRU!!!
	PUSHJ	P,CMPBIT	;COMPUTE DIRECTORY BITS
	  JRST	RELDR2		;NON-EXISTENT PAGE
	TLNE	T1,SV%ABZ	;ALLOCATED-BIT-ZERO?
	JRST	RELDR2		;YES, DON'T SAVE IT
	MOVE	T1,P3		;GET PAGE #
	PUSHJ	P,YANKIT	;BRING PAGE IN, IF IT'S OUT
	  JFCL			;SHOULDN'T BE ABZ
	MOVE	T1,P3		;GET PAGE #
	TLNN	T2,(PA.AA)	;ACCESS ALLOWED?
	PUSHJ	P,SETAA		;NO, SET IT

;FALL THRU TO NEXT PAGE....
	MOVE	T1,P3		;GET PAGE NUMBER
	LSH	T1,PXWLSH	;CONVERT TO ADDRESS
	SOS	T1		;=START OF PAGE-1
	HRRM	T1,.JDAT+SGALEN	;STORE IN IOWD
	PUSH	P,P1		;SAVE P1
	OUTPUT	SGALEN		;WRITE OUT THIS PAGE
	POP	P,P1		;RESTORE IT
	PUSHJ	P,SGIOCK	;CHECK FOR ERRORS
	JRST	RELDR2		;NO, GO BACK FOR MORE






;STILL IN  FTEXE CONDITIONAL
;SUBROUTINE TO PERFORM A PAGE. UUO
;CALL:
;	MOVE	T1,[FUNCTION CODE,,0]
;	MOVE	T2,PAGE #
;	PUSHJ	P,PAGUUO
;	  RETURN HERE IF ERROR RETURN FROM PAGE. UUO
;	GOOD RETURN
;
;
;ON EXIT, T1 CONTAINS THE PAGE NUMBER
PAGUUO::MOVEI	T3,1		;LENGTH OF THE ARGUMENT BLOCK
PAGUUN::PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSH	P,T2		;SAVE PAGE # TO RETURN TO CALLER
	HRRI	T1,SGASAV+1	;POINT TO ARGUMENT BLOCK
	PUSH	P,.JDAT+SGAHGH	;SAVE SGAHGH
	PUSH	P,.JDAT+SGANEW	; AND SGANEW
	MOVEM	T2,.JDAT+SGAHGH	;STORE PAGE NUMBER FOR UUO
	MOVEM	T1,.JDAT+SGASAV ;STORE IN USER AREA
	MOVEM	T3,.JDAT+SGANEW ;STORE LENGTH OF ARGUMENT BLOCK
	PAGE.	SGASAV,		;DO THE UUO
	  SOS	-3(P)		;ERROR
	POP	P,.JDAT+SGANEW
	POP	P,.JDAT+SGAHGH
	MOVE	F,USRJDA##+0	;IOWAIT CLOBBERS F
	JRST	TPOPJ1##	;RESTORE PAGE # AND RETURN

;STILL IN IFN FTEXE CONDITIONAL

;SUBROUTINE TO SET ACCESS ALLOWED BIT FOR PAGE
;	(BIT MUST BE OFF)
;CALL:
;	MOVE	T1,PAGE#
;	PUSHJ	P,SETAA
;	HERE ALWAYS
SETAA:	HRRZ	T2,T1		;MOVE PAGE #
	MOVSI	T1,.PAGAA	;GET FUNCTION CODE
	PUSHJ	P,PAGUUO	;DO THE PAGE UUO
	  STOPCD	CPOPJ##,DEBUG,CSA,	;++CAN'T SET ACCESS ALLOWED
	POPJ	P,
;SUBROUTINE TO PAGE OUT THE USER'S LOW SEGMENT ON A GETSEG
;THIS IS ONLY CALLED IF THE CURRENT USER IS "VIRTUAL".
;
;CALL:
;	PUSHJ	P,PAGLOW
;	HERE ALWAYS
;
PAGLOW::MOVEI	T1,1		;START AT PAGE 0
	PUSH	P,F		;PAGOUT CLOBBERS F
PGLOW2:	PUSHJ	P,GTPME##	;GET THE MAP ENTRY
	JUMPE	T2,PGLOW3	;IF NON-EXISTENT, JUMP
	PUSHJ	P,CKDIRP	;IS THIS A DIR PAGE?
	  AOJA	T1,PGLOW2	;YES, DON'T PAGE IT OUT
	PUSHJ	P,PAGOUT	;TRY TO PAGE THIS PAGE OUT
	  JFCL			;COULDN'T
	AOJA	T1,PGLOW2	;GET NEXT PAGE
PGLOW3:	SKIPN	.UPMP+.UPREL	;DOES HE HAVE A NON-CONTIGUOUS CORE IMAGE?
	PJRST	FPOPJ##		;NO, WE MUST HAVE COME TO END OF LOW SEG
	CAIGE	T1,PAGSIZ##-1	;YES, ARE WE THRU ALL OF CORE?
	AOJA	T1,PGLOW2	;NO
	PJRST	FPOPJ##		;YES, EXIT

;STILL IN FTEXE CONDITIONAL
;SUBROUTINE TO MAKE A SINGLE DIRECTORY ENTRY FOR A GIVEN PAGE
;CALL:
;	MOVE	P1,DIRECTORY POINTER
;	MOVE	P2,CURRENT FILE PAGE #
;	MOVE	P3,PAGE #
;	PUSHJ	P,MKNTRY
;	  RETURN HERE IF PAGE # IS TOO HIGH (.GTE. PAGSIZ)
;	RETURN HERE OTHERWISE
;
;THIS ROUTINE EXPECTS THE "LAST" DIRECTORY ENTRY TO BE IN
; T3 AND T4. IT COMPUTES THE DIRECTORY FOR THE PAGE # IN P3,
; AND DETERMINES IF THIS NEW PAGE CAN BE INCLUDED IN THE
; DIRECTORY ENTRY FOR THE LAST GROUP OF PAGES. IF SO,
; THE REPEAT COUNT (IN T4) IS BUMPED AND CONTROL IS RETURNED.
; IF THIS PAGE NEEDS A NEW ENTRY, THE "OLD" ENTRY IS OUTPUT
; TO THE DIRECTORY, THE CURRENT FILE PAGE NUMBER IS UPDATED,
; AND THE NEW DIRECTORY ENTRY REPLACES THE OLD ONE IN T3,T4
;
;
MKNTRY:	CAIL	P3,EXESIZ	;TOO HIGH?
	JRST	NEWENT		;YES, OUTPUT LAST ENTRY AND EXIT
	PUSHJ	P,CMPBIT	;COMPUTE FLAG BITS FOR THIS PAGE
	  JRST	CPOPJ1##	;NON-EXISTENT PAGE, EXIT AND IGNORE
	JUMPE	P3,[MOVE	T3,T1	;IF THIS IS THE 1ST PAGE,..
		    SETZ	T4,	;MAKE IT THE LAST PAGE
		    JRST	CPOPJ1##]
				;PLEASE NOTE---THIS LAST CHECK ASSUMES
				;THAT PAGE ZERO IS THE 1ST PAGE CHECKED.
				;IF THIS IS NOT TRUE (I.E. IF THE DIRECTORY
				; IS FORMED BY STARTING WITH PAGE 777
				; AND PROCEDING BACKWARDS), THEN THIS
				; ALGORITHM MUST BE CHANGED.
	CAME	T1,T3		;ARE THE FLAG BITS THE SAME AS THE LAST PAGE
	JRST	NEWENT		;NO, FORM A NEW DIR ENTRY
	LDB	T2,[POINT 9,T4,8]	;GET LAST REPEAT COUNT
	ADDI	T2,1(T4)	;FIND # OF NEXT CONTIGUOUS PAGE
	CAME	T2,P3		;IS THIS IT?
	JRST	NEWENT		;NO, FORM A NEW ENTRY FOR THIS PAGE
	ADD	T4,[1000,,0]	;YES, BUMP LAST REPEAT COUNT
	JRST	CPOPJ1##	;RETURN
;STILL IN IFN FTEXE CONDITIONAL..
;COME HERE TO FORM A NEW DIRECTORY ENTRY
NEWENT:	TLZE	T3,SV%ABZ	;ALLOCATED BUT ZERO PAGE?
	JRST	NWENT2		;YES
	HRR	T3,P2		;NO, GET CURRENT FILE PAGE #
	LDB	T2,[POINT 9,T4,8]	;GET LAST REPEAT COUNT
	ADDI	P2,1(T2)	;COMPUTE NEW FILE PAGE #
NWENT2:	HRRZ	T2,P3		;GET THIS PAGE #
	EXCH	T1,T3		;GET 1ST WORD OF LAST ENTRY
	EXCH	T2,T4		;GET 2ND WORD
	PUSHJ	P,PTNTRY	;STORE IT IN DIRECTORY
	CAIGE	P3,EXESIZ	;LAST PAGE?
	AOS	(P)		;NO, SKIP RETURN
	POPJ	P,		;YES, GIVE NON-SKIP RETURN


;STILL IF IFN FTEXE CONDITIONAL...
;SUBROUTINE TO PAGE OUT A PAGE
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,PAGOUT
;	HERE IF CAN'T PAGE IT OUT
;	HERE IF CAN AND DID
;
;T1 IS PRESERVED

PAGOUT::MOVE	J,.CPJOB##	;JUST FOR SAFETY
	HRRZ	T2,.JDAT+.JBPFH## ;GET PFH START ADDRESS
	LSH	T2,W2PLSH	;GET PAGE PFH STARTS IN
	SKIPE	.JDAT+.JBPFH	;IF NO PFH, OR
	 CAIGE	T1,(T2)		;THIS PAGE IS BELOW PFH'S STARTING PAGE
	  JRST	PAGOU0		;WE'RE SAFE, PAGE THIS ONE OUT
	HLRZ	T2,.JDAT+.JBPFH## ;GET END ADDRESS OF PFH
	LSH	T2,W2PLSH	;GET PAGE PFH ENDS IN
	CAIG	T1,(T2)		;IS PAGE WE WANT PAST PFH?
	 POPJ	P,		;NOPE - THIS PAGE HAS PFH, ERROR RETURN
PAGOU0:	HRRZ	T2,.JDAT+JOBINT## ;GET START OF INTERRUPT BLOCK
	TRZ	T2,PAGSIZ##-1	;FIND START OF PAGE
	CAIN	T2,(T1)		;IS THIS THAT PAGE?
	 POPJ	P,		;ERROR RETURN
	PUSH	P,T1		;SAVE PAGE #
IFN FTPI,<
	PUSHJ	P,PSIIVR##	;FIND RANGE OF PAGES FOR PSI VECTOR
	HLRZ	T2,T1		;GET ENDING PAGE
	TLZ	T1,-1		;MAKE IT STARTING PAGE ONLY
	CAML	T1,0(P)		;ARE WE BELOW RANGE OF PSI VECTOR
	 CAMLE	T2,0(P)		;OR ABOVE IT?
	  SKIPA	T1,0(P)		;WE ARE GOLDEN, GET PAGE FOR GETPAG
	 JRST	TPOPJ##		;PAGE CONTAINS PSI VECTOR, LEAVE IT ALONE
 >
	PUSHJ	P,GETPAC##	;GET PAGE ACCESSABILITY
	TLNE	T1,(PA.CPO!PA.NXP) ;CAN IT BE PAGED OUT?
	JRST	TPOPJ##		;NO, RESTORE T1 AND EXIT
	MOVE	T2,(P)		;GET PAGE #
	TLO	T2,(1B0)	;SET DESTORY BIT
	MOVSI	T1,.PAGIO	;GET FUNCTION CODE
	PUSHJ	P,PAGUUO	;DO THE UUO
	  JRST	TPOPJ##		;I/O ERROR
	JRST	TPOPJ1##	;IT'S OUT

;STILL IN FTEXE CONDITIONAL...
;SUBROUTINE TO PAGE IN A PAGE
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,PAGIN
;	  ERROR RETURN
;	OK RETURN

PAGIN::	PUSH	P,T1		;SAVE PAGE #
	HRRZ	T1,.PDCVL##(W)	;GET USER'S PHYSICAL LIMIT/GUIDELINE
	LDB	T2,IMGIN##	;AND HOW MANY PAGES ARE IN CORE
	TRZ	T1,400000	;CLEAR LIMIT BIT
	CAML	T2,T1		;EXCEEDING LIMIT?
	  JRST	PAGIN2		;YES. GO PAGE OUT A PAGE
PAGIN1:	POP	P,T2		;GET PAGE #
	MOVSI	T1,.PAGIO	;GET FUNCTION CODE
	PUSHJ	P,PAGUUO	;PAGE. UUO
	  SKIPA	T2,.JDAT+SGASAV	;SOMETHING HAPPENED, GET THE ERROR
				; CODE WHICH WAS RETURNED IN USER AC'S
	JRST	CPOPJ1##	;SUCCESS
	CAIE	T2,PAGLE%	;LIMIT EXCEEDED IS OK
	POPJ	P,		;ANYTHING ELSE IS FATAL
	PUSH	P,T1		;SAVE PAGE-IN PAGE #
PAGIN2:	MOVEI	T1,1		;TRY TO PAGE OUT SOME PAGES
PAGIN3:	PUSHJ	P,CKDIRP	;A DIRECTORY PAGE?
	  CAIA			;YES, CAN'T PAGE IT OUT
	PUSHJ	P,PAGOUT	;TRY TO PAGE IT OUT
	  JRST	[CAIE	T1,PAGSIZ##-1	;THRU ALL PAGES?
		 AOJA	T1,PAGIN3	;NO, TRY AGAIN
		 JRST	PAGIN1]		;YES, FATAL ERROR
	POP	P,T1		;GET PAGE BACK
	JRST	PAGIN		;TRY AGAIN TO PAGE IT IN


;STILL IN IFN FTEXE  CONDITIONAL
;ROUTINE TO READ IN A PAGE THAT HAD TO BE OUTPUT EARLIER
;CALL:
;	MOVE	P4,DISK-ADDRESS-OF-PAGE
;	MOVE	P1,PAGE-ADDRESS
;	PUSHJ	P,GTSAVP
;	RETURN HERE ALWAYS IF OK

GTSAVP:	HRRZ	T2,P4		;GET DISK ADDRESS
	HRRZ	T1,P1		;GET PAGE ADDRESS
	LSH	T1,W2PLSH##	;MAKE INTO A PAGE NUMBER
	PUSHJ	P,IPCINS##	;CREATE PAGE
	  STOPCD CPOPJ##,DEBUG,DPL,	;++DIRECTORY PAGE LOST
	POPJ	P,


;SUBROUTINE TO GET A FREE PAGE FROM USER'S PAGE MAP
;CALL:
;	PUSHJ	P,GTFREP
;	  HERE IF COULDN'T
;	HERE IF DID, PAGE # IN T1
;
;IF THIS ROUTINE IS ENTERED AT GTFREP, IT WILL START SEARCHING
; AT PAGE 777.
;IF ENTERED AT GTFRE2, IT WILL START SEARCHING AT THE PAGE # IN T1.
;
GTFREP::MOVEI	T1,PAGSIZ##-1	;START AT PAGE 777
GTFRE2::PUSHJ	P,GTPME##	;GET MAP ENTRY
	JUMPE	T2,CPOPJ1##	;IF NON-EXISTENT, ITS OK
	SOJG	T1,GTFRE2	;DECREMENT PAGE # AND TRY AGAIN
	POPJ	P,		;COULDN'T


;STILL (YES, STILL) IN IFN FTEXE CONDITIONAL...
;SUBROUTINE TO CHECK IF A GIVEN PAGE IS A DIRECTORY PAGE
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,CKDIRP
;	HERE IF THIS PAGE IS A DIRECTORY
;	HERE IF NOT
;
;ON RETURN, T3 POINTS TO WHERE THE DIRECTORY PAGE
;   POINTER IS BEING KEPT (P1, SGANAM, OR SGAEXT)
;T1,T4 PRESERVED
;T2 DESTROYED

CKDIRP::JUMPE	P1,CPOPJ1##	;NOT A DIRECTORY PAGE IF FROM PAGIA
	PUSH	P,T1		;SAVE PAGE NUMBER
	LSH	T1,P2WLSH##	;MAKE INTO AN ADDRESS
	HRRZ	T2,P1		;GET CURRENT DIRECTORY POINTER
	TRZ	T2,PAGSIZ##-1	;CLEAR OFFSET
	MOVEI	T3,P1		;ASSUME ITS' THERE
	CAMN	T1,T2		;IS THIS A DIR PAGE?
	JRST	TPOPJ##		;YES, RESTORE PAGE # AND EXIT
	MOVEI	T3,.JDAT+SGANAM	;ASSUME IT'S HERE
	CAMN	T1,.JDAT+SGANAM	;IS IT?
	JRST	TPOPJ##		;YES, RESTORE T1 AND EXIT
	CAMN	T1,.JDAT+SGAEXT	;IS IT THIS ONE?
	AOJA	T3,TPOPJ##	;YES
	AOJA	T3,TPOPJ1##	;NO, SKIP RETURN

;SUBROUTINE TO PAGE IN A PAGE, IF IT'S OUT
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,YANKIT
;	  RETURN HERE IF PAGE ALLOCATED BUT ZERO (T1=PAGE NUMBER)
;	RETURN HERE WITH PAGE BITS IN T2
YANKIT::PUSH	P,T1		;SAVE PAGE BITS
	PUSHJ	P,GETPAC##	;GET PAGE BITS
	MOVE	T2,T1		;MOVE BITS
	POP	P,T1		;GET PAGE # BACK
	TLNE	T2,(PA.ZER)
	POPJ	P,
	PUSH	P,T2		;SAVE BITS
	TLNE	T2,(PA.OUT)	;IS IT OUT?
	PUSHJ	P,PAGIN		;YES, BRING IT IN
	  JFCL			;NOT OUT
	JRST	T2POJ1##	;RESTORE PAGE BITS
;SUBROUTINE TO GET A PAGE INTO CORE AND MAKE IT ACCESSIBLE
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,PAGIA
;	  HERE ON FAILURE
;	HERE ON SUCCESS, PAGE IS IN CORE WITH ACCESS ALLOWED ON
;SETS WS SCRAMBLED BIT IF IT DOES ANYTHING, WORRYS ABOUT LIMITS

PAGIA::	PUSHJ	P,SAVE2##	;SAVE WORKING ACS
	HRRZ	P2,T1		;PAGE TO DOITTOIT
	PUSHJ	P,GETPAC##	;GET PAGE ACCESSIBILITY
	TLNN	T1,(PA.OUT)	;PAGE OUT?
	JRST	PAGIA1		;NO, THEN THIS IS SIMPLIER
	MOVEI	P1,0		;FOR CKDIRP
	HRRZ	T1,P2		;PAGE NUMBER
	PUSHJ	P,PAGIN		;GO PAGE IT IN
	  POPJ	P,		;SIGH
	TLO	P2,400000	;REMEMBER THAT THE WORKING SET HAS BEEN DIDDLED
	PUSHJ	P,GETPAC##	;GET CURRENT ACCESSIBILITY
PAGIA1:	TLNE	T1,(PA.AA)	;ACCESS ALLOWED ON?
	JRST	PAGIA2		;YES, THEN ESSENTIALLY DONE
	HRRZ	T1,P2		;NO, GET PAGE NUMBER AGAIN
	PUSHJ	P,SETAA		;TURN ON AA
	TLO	P2,400000	;AND INDICATE WS HAS CHANGED
PAGIA2:	JUMPGE	P2,CPOPJ1##	;JUMP IF LENGTHY NOOP
	MOVSI	T1,(UP.WHC!UP.WSS) ;NOTE CHANGE IN WORKING SET FOR PFH
	IORM	T1,.UPBTS	;SO IT DOESN'T GET CONFUSED
	JRST	CPOPJ1##	;GOOD RETURN
;ROUTINE TO COMPUTE THE FLAG BITS FOR THE DIRECTORY ENTRY
;CALL:
;	MOVE	P3,PAGE #
;	PUSHJ	P,CMPBIT
;	  RETURN HERE IF PAGE WAS NON-EXISTENT
;	RETURN HERE OTHERWISE
;
;ON RETURN, T1 WILL HAVE THE FLAG BITS SET UP PRECISELY AS THEY
; SHOULD APPEAR IN THE DIRECTORY ENTRY (I.E. IN THE LEFT-MOST BITS)
;IF THE PAGE IS ALLOCATED-BUT-ZERO, THE "SV%ABZ"
; BIT WILL BE SET ALSO.
; THIS BIT IS LATER TRANSFORMED INTO A FILE PAGE NUMBER OF ZERO.
;
;NOTE THAT THE DIRECTORY PAGE IS TREATED AS BEING
; NON-EXISTENT, EXCEPT IN NON-VM SYSTEMS WHEN
; WE ARE NOT ZERO-COMPRESSING (THE DIRECTORY IS USER AC'S).

CMPBIT:	PUSH	P,T3		;SAVE T3 (T3 AND T4 ARE CURRENT DIRECTORY ENTRY)
	PUSH	P,T4		;SAVE T4
	MOVE	T1,P3		;GET PAGE #
	PUSHJ	P,GETPAC##	;GET PAGE MAP ACCESSABILITY BITS
	MOVE	T2,T1		;SAVE BITS
	POP	P,T4		;RESTORE OLD DIR ENTRY
	POP	P,T3
IFN FTPEEKSPY,<
	TLNN	T2,(PA.GSP)	;A SPY PAGE? IF SO TREAT AS NON EX
>
	TLNE	T2,(PA.NXP)	;PAGE EXIST?
	POPJ	P,		;NO, EXIT
	SETZ	T1,		;CLEAR BITS FOR ENTRY
	TLNE	T2,(PA.WRT)	;CAN IT BE WRITTEN?
	TLO	T1,SV%WRT	;YES, SET BIT
	TLNE	T2,(PA.ZER)	;ALLOCATED BUT ZERO?
	TLO	T1,SV%ABZ	;YES, SET THAT BIT IN FLAGS
	SKIPN	.UPMP+.UPHSS	;IS THERE A HISEG?
	JRST	CMP2		;NO
	MOVE	T2,P3		;YES, GET PAGE #
	LSH	T2,P2WLSH##	;MAKE INTO AN ADDRESS
	CAML	T2,.UPMP+.UPHSS	;MUST BE GREATER THABN HISEG START
	CAMLE	T2,.UPMP+.UPHSE	; AND LESS THAN END
	JRST	CMP2		;ITS NOT IN THE HIGH SEG
	TLO	T1,SV%HIS	;SET HISEG BIT
	TLNN	P1,SV%SAV	;WAS THIS AN "SAVE" COMMAND?
	TLO	T1,SV%SHR	;NO, SET SHARABLE BIT TOO
	MOVE	J,.CPJOB##		;GET JOB #
	SKIPG	JBTSGN##(J)	;SPY SEG?
	POPJ	P,		;YES, IGNORE IT
	MOVEI	T2,JS.XO	; AND EXECUTE ONLY BIT
	TDNE	T2,JBTSTS##(J)	;IS IT SET?
	TLO	T1,SV%CON	;YES, MUST BE CONCEALED
	JRST	CPOPJ1##	;RETURN SINCE DIR CAN'T BE IN HIGH SEG
CMP2:	PUSH	P,T3		;SAVE OLD ENTRY
	PUSH	P,T4
	PUSHJ	P,CHKABZ	;IS THIS PAGE ALL ZEROES?
	  TLO	T1,SV%ABZ	;YES, SET BIT
	POP	P,T4		;RESTORE IT
	POP	P,T3
	HRRZ	T2,P1		;GET ADDRESS OF DIRECTORY PAGE
	LSH	T2,WXPLSH	;CONVERT TO PAGE #
	CAIE	T2,(P3)		;IS THIS THE DIRECTORY PAGE?
	JRST	CPOPJ1##	;NO, RETURN TO CALL+2
	TLNN	P1,SV%FUL	;YES, DID WE HAVE TO WRITE OUT
	POPJ	P,		; A PAGE EARLIER?..EXIT IF NO
				; AND TREAT THE DIRECTORY PAGE AS NON-EXISTENT
	HLLZ	T1,P4		;YES, GET SAVED BITS FOR WRITTEN-OUT
	JRST	CPOPJ1##	; AND EXIT AS IF THIS WERE THAT PAGE
;COME HERE FOR A VARIETY OF USER SINS
GTABRT::
SVABRT:	MOVE	J,.CPJOB##		;GET JOB NUMBER
	MOVSI	T1,(JS.EXE)	;GET EXE SAVE FILE BIT
	ANDCAM	T1,JBTST2##(J)	;CLEAR IT
	MOVSI	T1,USRMOD	;GET USER-MODE BIT
	TDNN	T1,.JDAT+JOBPD1## ;UUO?
	 JRST	SVABRU		;NO, DON'T RESTORE
	POP	P,.UPMP+.UPTMC	;YES, RESTORE VM LOCS
	POP	P,.UPMP+.UPTMI
SVABRU:	HRRZS	USRHCU##	;CLEAR SAVE IN PROGRESS FLAG
	MOVEI	T1,TRNERR	;GET APPROPRIATE ERROR CODE
	PUSHJ	P,SGRELE
	JSP	T1,PHOLD##
	ASCIZ	#I/O error for EXE file#



;COME HERE IF A BAD RETURN FROM "CMPBIT" OCCURED:
BRCSTP:	STOPCD	SAVERR,DEBUG,BRC,	;++BAD RETURN FROM CMPBIT


;ROUTINE TO CHECK IF THIS USER IS TRYING TO SAVE A NEW-STYLE (.EXE)
; SAVE FILE
;
;CALL:
;	MOVE	J,JOB-NUMBER
;	PUSHJ	P,CHKEXE
;	  HERE IF YES
;	HERE IF NO
;
;ALL AC'S PRESERVED
;
CHKEXE::PUSH	P,T1		;SAVDDL NEEDS T1 SAVED
	MOVE	T1,JBTST2##(J)	;GET JOB STATUS WORD
	TLNE	T1,(JS.EXE)	;IS THE "EXE" BIT SET? (WHICH
				; MEANS THAT WE ARE DOING A
				; SAVE OF AN EXE FILE)
	JRST	TPOPJ##		;YES, RESTORE T1 AND EXIT
	JRST	TPOPJ1##	;NO, EXIT AT CALL+2
;SUBROUTINE TO CHECK IF A PAGE IS ALL ZEROES TO ENABLE IT
; TO BE COMPRESSED
;CALL:
;	MOVE	P3,PAGE # TO CHECK
;	PUSHJ	P,CHKABZ
;	RETURN HERE IF PAGE IS ALL ZEROES
;	HERE OTHERWISE
;
; T2 IS DESTROYED
;
CHKABZ:	PUSH	P,T1		;SAVE T1
	MOVE	T1,P3		;SET PAGE #
	PUSHJ	P,YANKIT	;IF OUT, BRING IT IN
	  JRST	TPOPJ##
	TLNN	T2,(PA.AA)
	PUSHJ	P,SETAA
	MOVE	T2,P3		;FETCH PAGE #
	LSH	T2,PXWLSH	;MAKE INTO AN ADDRESS
	HRLI	T2,-EXESIZ	;FORM AOBJ WORD
ABZ2:	EXCTUU	<SKIPE	(T2)>	;IS THIS LOCATION ZERO?
	JRST	TPOPJ1##	;NO, SKIP RETURN
	AOBJN	T2,ABZ2		;LOOP THRU ENTIRE PAGE
	JRST	TPOPJ##		;PAGE MUST BE ALL ZERO, NON-SKIP RETURN
;SUBROUTINE TO PUT OUT 1 DIRECTORY ENTRY
;CALL:
;	MOVE	T1,1ST WORD OF DIRECTORY ENTRY
;	MOVE	T2,2ND "	"
;	PUSHJ	P,PTNTRY
;	RETURN HERE
;
;
PTNTRY:	PUSH	P,T2		;SAVE T2 IN CASE PAGE MUST BE WRITTEN OUT
	PUSHJ	P,PTDIRW	;OUTPUT THIS WORD
	POP	P,T1		;RESTORE 2ND WORD TO ENTRY AND
;	PJRST	PTDIRW		; STORE IT




;SUBROUTINE TO STORE A WORD IN THE DIRECTORY
;CALL:
;	MOVE	P1,ADDRESS-TO-PUT-WORD
;	MOVE	T1,WORD-TO-PUT
;	PUSHJ	P,PTDIRW
;	RETURN HERE
;
PTDIRW:	HRR	M,P1		;GET CURRENT DIRECTORY POINTER
	PUSHJ	P,PUTWDU##	;STORE WORD IN USER AREA
	AOS	P1		;BUMP POINTER
	TRNE	P1,EXESIZ-1	;DID WE OVERLAP ONTO A NEW PAGE?
	POPJ	P,		;NO
	SUBI	P1,EXESIZ	;YES, BUMP POINTER BACK TO LAST PAGE
;	PJRST	PUTDIR		;OUTPUT DIRECTORY (MAYBE)
;SUBROUTINE TO OUTPUT THE CURRENT DIRECTORY PAGE
;CALL:
;	HRLI	P2,DIRECTORY-PAGE-COUNTER
;	MOVE	P1,ADDRESS-OF-THIS-PAGE
;	PUSHJ	P,PUTDIR
;	RETURN HERE ALWAYS

PUTDIR:	PUSHJ	P,SAVT##	;AT LEAST T3 AND T4 ARE IMPORTANT
	ADD	P2,[1,,0]	;BUMP # OF DIRECTORY PAGES
	MOVEI	T1,-1(P1)	;GET ADDRESS-1 OF I/O
	MOVEI	T2,SGALEN	;SAVE ADDR OF IOWD
	HRRM	T1,.JDAT+SGALEN	;STORE IN IOWD
	PUSH	P,P1		;SAVE P1 (OUTPUT KILLS IT)
	PUSH	P,P4		;SAVE P4 TOO
	TLNN	P1,SV%DWO	;DO WE REALLY WANT TO WRITE IT OUT?
	OUTPUT	(T2)		;YES, DO SO
	POP	P,P4		;GET P4 BACK
	JRST	P1POPJ##	;RESTORE P1 AND RETURN
;ROUTINE TO SET UP AN IOWD IN SGALEN
;
;CALL:
;	MOVE	T1,ADDRESS-OF-I/O
;	PUSHJ	P,STIOWD
;	HERE ALWAYS
;
;T2 IS DESTORYED

STIOWD::HRRM	T1,.JDAT+SGALEN	;STORE ADDRESS
	SOS	.JDAT+SGALEN	;=LOC-1
	MOVNI	T2,EXESIZ	;GET SIZE OF I/O (PAGE ASSUMED)
	HRLM	T2,.JDAT+SGALEN	;STORE IN IOWD
	POPJ	P,		;RETURN


;SUBROUTINE TO DESTROY A PAGE
;CALL:
;	MOVE	T1,PAGE-ADDRESS
;	PUSHJ	P,ZAPPAG
;	HERE IF ERROR
;	HERE IF OK

ZAPPAG::LSH	T1,W2PLSH##	;CONVERT TO PAGE #
	TLO	T1,(1B0)	;SET DESTORY BIT
;	PJRST	CRPAGE		;DO THE PAGE. UUO


;ROUTINE TO CREATE A PAGE
;
;CALL:
;	MOVE	T1,PAGE #
;	PUSHJ	P,CREPAG
;	  COULDN'T
;	COULD AND DID
;
;T1 IS PRESERVED

CRPAGE::MOVE	T2,T1		;MOVE IT INTO ANOTHER AC
	MOVSI	T1,.PAGCD	;SET UP FUNCTION CODE FOR PAGE.
	PUSHJ	P,PAGUUO	;DO THE PAGE. UUO
	  SKIPA	T2,.JDAT+SGASAV	;ERROR--GET THE ERROR CODE
	JRST	CPOPJ1##	;SUCCESSFUL..GIVE SKIP RETURN
	CAIE	T2,PAGNV%	;DID WE TRY TO CREATE AN ALLOCATED-BUT-ZERO
				; PAGE BUT WE WEREN'T VIRTUAL?
	POPJ	P,		;NO, GIVE FATAL ERROR RETURN
	HRRZS	T1		;YES, SO GET JUST PAGE # AGAIN
				; (WITHOUT "CREATE ON DISK" BIT) AND
	JRST	CRPAGE		; TRY TO CREATE IT AGAIN.

>;END OF IFN FTEXE (WHICH BEGAN AT SAVEXE)
	SUBTTL	SAVGET -- GET AND RUN COMMANDS

;THIS JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO RESTORE STATUS OF IO DEVICES, PC, OR AC'S
;JOBPC IS SET TO STARTING ADDRESS OF JOB
;CORE MUST ALREADY HAVE BEEN ASSIGNED AND THE FOLLOWING LOC. SETUP IN
;JOB DATA AREA:
;JOBPDP, JOBREL

GJOB:	JSP	T2,SG1		;SETUP ACS, SETUP LOWER CORE(SGALEN,SGADMP)
	PUSHJ	P,CLRTAB	;CLEAR OUT LAST PROGRAM FROM PDB
	PUSHJ	P,RMVPFH##
	PUSH	P,[0]		;CLEAR PC FLAGS SINCE THEY ARE MEANINGLESS
	MOVEI	T1,JS.RUU	;BIT TO SET
	IORM	T1,JBTSTS##(J)	;SO CAN READ XONLY FILES
	PUSHJ	P,GJOBX		;GET THE JOB
	MOVEI	T1,JS.RUU	;GET THE BIT
	ANDCAM	T1,JBTSTS##(J)	;BACK TO NORMAL PROTECTION CHECKING
	JSP	T1,PHOLD##	;RETURN ONLY IF EVERYTING OK
	ASCIZ	/Job setup/

;THIS JOB GETS A JOB AREA FROM A RETRIEVAL DEVICE AND STARTS IT UP
;JOB HAS JUST A JOB DATA AREA ASSIGNED WHEN CONTROL GETS HERE
;THIS MONITOR JOB GETS A JOB AREA FROM A RETREIVABLE DEVICE
;ASSIGNS CORE AND START

RUNJOB:	JSP	T2,SG1		;SETUP ACS, SETUP LOWER CORE(SGALEN,SGADMP)
	PUSHJ	P,CLRTAB	;CLEAR OUT LAST PROGRAM NAME
	PUSH	P,P1		;PUSH A FAKE WORD SO GETBTB CAN CLEAR LH JOBPD1
	PUSHJ	P,RMVPFH##
	HRLZ	T1,P1		;RH P1 = STARTING ADDRESS INCREMENT
	PUSH	P,T1		;FAKE UP BEGINNING OF RUN UUO PD LIST
	JRST	URUN1		;GO FINISH UP AS IF RUN UUO
IFN FTEXE,<
UMERGE::PUSHJ	P,GETARG
	PUSHJ	P,MERGE
	JRST	TPOPJ1##
CMERGE::SETZB	P1,P2
	JSP	S,SGSETD
MRGJOB:	JSP	T1,MONSTR##
	PUSHJ	P,RMVPFH##
	PUSHJ	P,SG2A
	PUSH	P,.JDAT+SGANAM
	PUSHJ	P,MERGE
	POP	P,T2
	PUSHJ	P,PRNAME##
	JSP	T1,PHOLD##
	ASCIZ	/ merged/
MERGE:	MOVSI	T1,'EXE'
	MOVEM	T1,.JDAT+SGAEXT
	PUSHJ	P,SGOPEN##
	MOVEI	T1,JS.XOR!JS.XO	;XONLY RUN
	AND	T1,JBTSTS##(J)	;ARE ANY SET IN JBTSTS##?
	ANDCAM	T1,JBTSTS##(J)	;WELL, CLEAR THEM IF SO
	PUSH	P,T1		;SAVE THE BITS
	LOOKUP	0,SGANAM	;LOOKUP AND SET JS.XOR IF EXEC ONLY FILE
	  JRST	MERBAD
	MOVEI	T1,JS.XOR!JS.XO
	TDNE	T1,JBTSTS##(J)	;DID XONLY GET SET WITH THIS LOOKUP?
	  JRST	MERBAD		;YES, DON'T ALLOW MERGE OF XONLY FILE
	POP	P,T1		;GET BACK PREVIOUS XOR BIT
	IORM	T1,JBTSTS##(J)	;SET XOR IF IT WAS SET BEFORE
	MOVSI	T1,(UP.MPF)	;MERGING PFH?
	TDNE	T1,.USBTS	;ARE WE?
	TLNE	F,SYSDEV	;AND DID THIS PFH COME FROM SYS:?
	TRNA			;KOSHER
	PUSHJ	P,CHKMED##	;MERGING PFH FROM USER AREA, MEDDLE.
	MOVSI	P1,GTLOW+GTMRG
	PUSHJ	P,GETEXE##
IFN FTWATCH & FTVERS,<
	MOVE	J,.CPJOB##
	PUSHJ	P,VERWAT	;SEE IF WATCHING
	  JRST	MERGE1		;NO -SKIP IT
	PUSHJ	P,PGMMRG	;YES--PRINT FILESPEC
	PUSHJ	P,PRRBKC	;PRINT RIGHT BRACKET
>
MERGE1:	PJRST	SGREL

MERBAD:	MOVEI	T1,JS.XOR!JS.XO	;XONLY FLAGS
	ANDCAM	T1,JBTSTS##(J)	;CLEAR 'EM
	POP	P,T1		;RESTORE ORIGINAL XONLY FLAGS
	IORM	T1,JBTSTS##(J)	;AND RESTORE THEM TO JBTSTS
	MOVSI	P1,GTMRG	;FLAG MERGE BEING DONE
	JRST	NOFILE		;AND RETURN ERROR CODE
>
	SUBTTL	SAVGET -- RUN UUO

;CALL:	MOVE AC,[XWD N,D]
;	CALL AC,[SIXBIT /RUN/]
;	ERROR RETURN		;UNLESS LH=HALT(PRINT CONSOLE MESS. IF YES)
;	IK OK, TRANSFER TO C(JOBSA)+N FOR NEW PROGRAM
;	USERS ACS CLOBBERED SO CANNOT PASS DATA TO NEW PROGRAM

;WHERE:	D/	DEVICE NAME
;	D+1/	FILE NAME
;	D+2/	FILE EXT OR 0 (LH SIXBIT)
;	D+3/	DATE ETC
;	D+4/	PROJECT,PROGRAMMER NO OR 0(CURRENT UFD OR DTA,MTA)
;	D+5/	HIGHEST LOC DESIRED(OR 0) ANALOGOUS TO RUN COMMAND
;		LH IS IGNORED(RATHER THAN ASSIGNING CORE TO HIGH SEG)


URUN::
;plat was here
;	MOVSI	T1,JLOG		;IS THIS JOB
;	TDNE	T1,JBTSTS##(J)	;LOGGED IN?
;	JRST	URUN1A		;YES, OK
;	MOVEI	T1,NLIERR	;NO, GIVE HIM
;	PUSHJ	P,SGRELE	;AN ERROR
;	MOVEI	T1,LOGPLM	;SET Y ERROR MESSAGE
;	JRST	PHOLD##		;START TTY + STOP JOB
URUN1A:
IFN FTFDAE,<
	PUSHJ	P,CALLF
	  PUSHJ	P,SNDFXM
>

	PUSHJ	P,RESET##	;RELEASE DEVICES
				; WARNING! THIS GOES VERY DEEP IN
				; PUSHDOWN. SEE MCO 518
				; (AC M PRESERVED IN RESET)
	PUSHJ	P,SAVE1##	;SAVE P1,P2
	PUSHJ	P,GETWDU##	;RESTORE CONTENTS OF USER'S CALLING AC
	PUSHJ	P,GETARG	;GET 6 ARGS FROM USER AND STORE
				; SAVE STARTING ADDRESS INCREMENT(LH OF T1)
				; AND USER AC NUMBER(IN CASE OF ERROR RETURN)
				; SETUP ACS,F TO U
	HRRZS	.JDAT+SGANEW 	;CLEAR JUNK(FOR COMPATABILITY)
	MOVEI	P1,0		;CLEAR FLAGS
	MOVE	T1,['RUNUUO']	;NEED TO KNOW IF WE RUN GET
	MOVEM	T1,.UPMP+.UPUAC+4
	MOVS	T1,(P)
	MOVEM	T1,.UPMP+.UPUAC+6

;HERE ON R OR RUN COMMAND
URUN1:	MOVEI	T1,JS.RUU	;BIT TO SET
	IORM	T1,JBTSTS##(J)	;SO CAN READ XONLY FILES
	PUSHJ	P,GJOBX		;GET BOTH LOW AND HIGH SEGMENTS
				;RETURN FILE NAME IF FROM REAL SYS, ELSE 0 IN T1
	HLRZ	T2,(P)		;GET STARTING ADDRESS INCREMENT
				; SUPPLIED BY USER (0 IF RUN COM.)
	CAILE	T2,1		;IS IT GREATER THAN 1 (REGULAR OR CCL
	JRST	URUN2		; ENTRY POINT?)
				;YES, DO NOT CHECK FOR SPECIAL CUSP FROM SYS
				; SINCE IT WILL NOT BE ENTERED PROPERLY
	MOVSI	T2,(JB.LSY)	;PREPARE TO SET FLAG
	JUMPE	T1,URUN3	;  IF IT CAME FROM SYS:
	IORM	T2,JBTLIM##(J)	;  FOR BATCON

	PUSHJ	P,PRVPG
	  JRST	URUN3
IFN FTCIMP,<			;[arpa] IMP CUSPS GET JACCT ONLY IF NOT LOGGED IN
	HRRZS	T2		;[arpa] CLEAR LH OF POINTER
	CAIGE	T2,PRVNLG##	;[arpa] SO CAN SEE IF CUSP IS ALWAYS JACCT
	 JRST	URUNJA		;[arpa] YES IT IS
	MOVSI	T2,JLOG		;[arpa] LOGGED IN?
	TDNE	T2,JBTSTS##(J)	;[arpa] ....
	 JRST	URUN3		;[arpa] YES...YOU LOSE
URUNJA:				;[arpa]
>				;[arpa]
	CAME	T1,LGONAM##	;IS THIS THE LOGOUT CUSP?
	JRST	URUN4		;NO
	SETZM	.PDCVL##(W)	;YES, MAKE SURE IT HAS ENOUGH CORE TO RUN
IFN FTMPB,<
	SKIPE	%SIQSR		;SKIP IF QUASAR NOT RUNNING
>
	PUSHJ	P,CLRJLG##	;AND CLEAR JLOG
URUN4:	MOVSI	T2,JACCT	;SET PRIVILEGED PROG. BIT
	MOVE	T3,JBTPPN##(J)
	CAME	T3,FFAPPN##	;OPR IS NEVER XCT ONLY
	HRRI	T2,JS.XO
IFN FTMPB,<
	CAME	T1,QUENAM##	;IS IT QUEUE?
	JRST	URUN4A		;NO, SKIP CHECK
	SKIPE	%SIQSR##	;YES, QUASAR RUNNING?
	SETZ	T2,		;YES, NO JACCT
>	;END IFN FTMPB
URUN4A:	IORM	T2,JBTSTS##(J)	;SO NO CONTROL C AND ALL ACCESS
				; TO FILES
	JRST	URUN3		;GO START IT UP
URUN2:	PUSHJ	P,CHKMED##	;SET MEDDLE IF SHARABLE

	MOVEI	T1,JS.XO	;SEE IF EXECUTE ONLY
	TDNE	T1,JBTSTS##(J)	;  IF SO, CLEAR OFFSET
	SETZM	(P)		;  TO PROTECT JOB
URUN3:	HLRZ	T2,(P)		;GET STARTING ADDRESS INCREMENT(0 IF RUN COM)

	ADD	T2,.JDAT+JOBSA## ;NOW ADD STARTING ADDRESS
;HERE FROM VMSER TO START DDT AFTER GETTING DDT
STARTU::TRNN	T2,777700	;SEE IF LEGITIMATE START ADDRESS
	JRST	URUNSA		;NO--GIVE THE USER AN ERROR
IFN FTKLP,<
	PUSH	P,[XC.USR+XC.PUB]
	TLZ	T2,-1
	PUSH	P,T2
>
IFE FTKLP,<
	HRLI	T2,USRMOD	;SET USER MODE BIT IN PC
	PUSH	P,T2		;PUT ON PD LIST
>
IFN FTMP,<
	PUSHJ	P,DPXST##	;SET UP PROPER RUNNABLE BITS FOR THIS JOB IN JBTSPS
>
	MOVE	T1,[JERR,,JS.RUU] ;BITS TO CLEAR FOR FILSER
	ANDCAM	T1,JBTSTS##(J)	; AND FOR CTRL-C TRAPPING
	JRST	USRXIT##	;AND GO TO RETURN TO USER AS IF FROM UUO

URUNSA:	PUSHJ	P,SGRLE2	;RELEASE DEVICE, GET TTY, TYPE ?
URUNSB::MOVEI	T1,MESNSA	;SETUP MESSAGE
	PJRST	PHOLD##		;TYPE MESSAGE

;SUBROUTINE TO DETERMINE IF THE CUSP BEING RUN IS PRIVILEDGED
; ENTER WITH T1=NAME OF THE CUSP BEING RUN
; EXIT CPOPJ IF NOT PRIVILEDGED, CPOPJ1 IF IT IS
;PRESERVES T4
PRVPG::	MOVSI	T2,-PRVTBL##	;NO. OF PRIVILEDGED CUSPS
	CAME	T1,PRVTAB##(T2)	;MATCH?
	AOBJN	T2,.-1		;NO, KEEP LOOKING, FINISHED?
	JUMPL	T2,CPOPJ1##	;JUMP IF FOUND
	POPJ	P,		;NO MATCH
IFN FTFDAE,<
SNDFXM:	MOVEI	T2,MAXLVL##+5
	PUSHJ	P,GTFWDC##
	  POPJ	P,
	MOVEI	T2,.FDXIT
	MOVEM	T2,(T1)
	MOVE	T2,.PDSTR##(W)
	MOVEM	T2,1(T1)
	MOVE	T2,.PDNAM##(W)
	MOVEM	T2,2(T1)
	MOVSI	T2,.PDDIR##(W)
	HRRI	T2,4(T1)
	BLT	T2,MAXLVL##+3(T1)
	MOVE	T4,JBTPPN##(J)
	PUSH	P,T1
	PUSHJ	P,SENDFD##
	  JFCL
	MOVEI	T1,MAXLVL##+5
	POP	P,T2
	PJRST	GVFWDS##

;SUBROUTINE TO SEE IF FILE DAEMON SHOULD BE CALLED ON EXIT
;CALLING SEQUENCE:
;	MOVE	J,JOB NUMBER
;	PUSHJ	P,CALLF
;RETURNS CPOPJ IF FILE DAEMON SHOULD BE CALLED CPOPJ1 IF NOT
;PRESERVES T3,T4

CALLF:	MOVSI	T1,(JS.CFX)
	TDNN	T1,JBTST2##(J)
	AOSA	(P)
	ANDCAM	T1,JBTST2##(J)
	POPJ	P,

;SUBROUTINE TO SEE IF AN EXIT MESSAGE SHOULD BE SENT TO THE FILE DAEMON
; IF SO, DELAY THE COMMAND UNTIL THE MESSAGE IS SENT
CHKXTM:	POP	P,T4		;RETURN ADDRESS
	PUSHJ	P,CALLF		;NO, SHOULD FILE DAEMON BE CALLED ?
	  CAIA			;YES
	JRST	(T4)		;NO, JUST DO THE COMMAND
	MOVSI	T1,LDBFDX##	;INDICATE PROCESSING FILDAE EXIT MESSAGE
	IORM	T1,LDBDDB##(U)	;SO COMRET WILL LEAVE LDBCMF ALONE JUST CLEARING
				; LDBCMR
	TLO	M,RUNFLG##+NOMESS## ;SO COMRET WILL LET US RUN (SUPPRESS WATCH STATS)
	PJSP	T2,MSTART##	;START THE MONITOR JOB
	JSP	T1,MONSTR##	;SETUP ACS
	PUSHJ	P,SNDFXM	;SEND THE "EXIT" MESSAGE TO THE FD
	PUSHJ	P,TTYFUW##	;FIND THE TTY
	MOVSI	T1,LDBFDX##	;CLEAR
	ANDCAM	T1,LDBDDB##(U)	;SO FORCED COMMANDS IF ANY GET DONE NOW
	PUSHJ	P,CNCMOD##	;TTY TO MONITOR MODE
	PUSHJ	P,COMSET##	;MAKE THE ORIGINAL COMMAND VISABLE
	PJRST	ESTOP##		;STOP THE JOB

> ;END IFN FTFDAE
;SUBROUTINE TO SAVE CURRENT CONTEXT DATA WHEN ESTABLISHING AN ALTERNATE CONTEXT
JBTCTL==^D15
PUSHBL==JBTCTL+SCNDDS##
PUSHCT:	HRRZ	T1,.PDSAC##(W)
	JUMPN	T1,PUSHC1
	MOVEI	T2,PUSHBL
	PUSHJ	P,GETWDS##
	  POPJ	P,
	HRRM	T1,.PDSAC##(W)
PUSHC1:	SUBI	T1,1
	PUSH	T1,JBTSTS##(J)
	PUSH	T1,JBTSWP##(J)
	SETZM	JBTSWP##(J)
	PUSH	T1,JBTSGN##(J)
	SETZM	JBTSGN##(J)
	PUSH	T1,JBTPDB##(J)
	PUSH	T1,JBTCHK##(J)
	PUSH	T1,JBTNAM##(J)
	SETZM	JBTNAM##(J)	;ONLY FOR ^T
	PUSH	T1,JBTPC##(J)
	SETZM	JBTPC##(J)
	PUSH	T1,.PDNAM##(W)
	PUSH	T1,.PDSTR##(W)
	PUSH	T1,.PDDIR##(W)
	HRLI	T1,.PDSFD##(W)
	AOS	T2,T1
	BLT	T1,MAXLVL##-1(T2)
	JRST	CPOPJ1##

;SUBROUTINE TO SAVE THE TTY DDB WHEN ESTABLISHING AN ALTERNATE CONTEXT
TTYCTX:	HRLZ	T1,F
	HRR	T1,.PDSAC##(W)
	ADDI	T1,JBTCTL
	MOVE	T3,.PDSAC##(W)
	BLT	T1,PUSHBL-1(T3)
	POPJ	P,

;SUBROUTINE TO RESTORE PREVIOUS CONTEXT WHEN CURRENT CONTEXT IS DESTROYED
POPCTX::HRRO	T1,.PDSAC##(W)
	ADDI	T1,JBTCTL-MAXLVL##-1
	POP	T1,.PDDIR##(W)
	POP	T1,.PDSTR##(W)
	POP	T1,.PDNAM##(W)
	POP	T1,JBTPC##(J)
	POP	T1,JBTNAM##(J)
	POP	T1,JBTCHK##(J)
	POP	T1,JBTPDB##(J)
	POP	T1,JBTSGN##(J)
	POP	T1,JBTSWP##(J)
	POP	T1,JBTSTS##(J)
	MOVSI	T1,JBTCTL-MAXLVL##+1(T1)
	HRRI	T1,.PDSFD##(W)
	BLT	T1,.PDSFD##+MAXLVL##-1(W)
	HRRZ	T1,.PDSAC##(W)
	MOVSI	T1,JBTCTL(T1)
	HRR	T1,F
	SKIPL	.PDSAC##(W)
	BLT	T1,SCNDDS##-1(F)
POPCT1:	MOVEI	T1,PUSHBL
	HRRZ	T2,.PDSAC##(W)
	SETZM	.PDSAC##(W)
	PJRST	GIVWDS##
CPUSH::	SKIPN	.PDSAC##(W)
	JRST	CPUSH1
;UPDATE/CHECK? TOTAL VIRTUAL CORE IN USE
	MOVEI	T2,PUSHBL
	PUSHJ	P,GTFWDC##
	  JRST	NEED1P##
	HRRM	T1,.UPMP+.UPLST
	HLR	T1,.PDSAC##(W)
	HRRZ	T2,T1
	BLT	T1,PUSHBL-1(T2)
CPUSH1:	MOVSI	T1,400000	;RETURN, COMDIS WILL DO THE REST ON THE NEXT
	IORM	T1,.PDSAC##(W)	; COMMAND WHICH REQUIRES CORE IN CORE
	POPJ	P,

CPOP::	SKIPN	T1,.PDSAC##(W)
	JRST	CPOP1
	JUMPL	T1,POPCT1
	TLO	M,RUNFLG
	JSP	T2,MSTART##
	JSP	T1,MONSTR##
	MOVSI	T1,JLOG
	ANDCAM	T1,JBTSTS##(J)
	PUSHJ	P,JOB1
	PUSHJ	P,POPCTX
	JRST	HOLD0##

CPOP1:	JSP	T1,ERRMES
	ASCIZ	/No previous context/
	SUBTTL	SAVGET -- GETSEG## UUO

;UUO TO GET JUST HIGH SEG AND RETURN TO USER
;CALL IS THE SAME AS FOR RUN UUO EXCEPT THAT OK RETURN IS SKIP RETURN
;IF ERROR RETURN HAS HALT IN LH, STANDARD CONSOLE MESSAGE IS PRINTED AND JOB STOPPED

UGTSEG::MOVE	T2,['GETSEG']
	MOVEM	T2,.UPMP+.UPUAC+4
	MOVE	T2,.JDAT+JOBPD1##
	MOVEM	T2,.UPMP+.UPUAC+6
	MOVE	T2,JBTSTS##(J)	;GET JOB STATUS
	TLNE	T2,JACCT	;IS JACCT ON
	TLO	P1,PHONLY	;YES, GETSEG MUST BE PHYSICAL ONLY
	JRST	UGETHI##	;IN SEGCON

UGTERR::MOVEI	T1,ILUERR	;ILLEGAL UUO ERROR CODE
	PUSHJ	P,SGRELE	;SEE IF USER WANTS ERROR
	JRST	UUOERR##	;NO, PRINT ILLEGAL UUO
	SUBTTL	SAVGET -- COMMON CODE

;ROUTINE TO SETUP ACS, RESET IO, AND SETUP LOWER CORE LOCATIONS
;FOR SAVE AND GET(SGALEN SET TO IOWD OR PP IF DTA OR DSK)
;SGADMP SET TO IOWD FOR THIS SIZE CORE
;CALL:	JSP T2,SG1
;	ALWAYS RETURN HERE, UNLESS DEVICE NOT FOUND
;	F SETUP TO DEVICE DATA BLOCK(BUT NOT INITED)
;	SO THAT INIT NOT NECESSARY IF SEG ALREADY KNOWN(NO DTA QUEUEING)
;	DEVICE CHARACTERISTICS WORD(DEVMOD) RETURNED IN AC T2
;	IF DISK SYSTEM


SG1:	JSP	T1,MONSTR##	;SETUP R,P,R,J=JOB NUMBER
				; PUT T2 ON END OF PD LIST(EXEC MODE PC,
				; SO ERROR MESSAGES WILL ALWAYS PRINT(SEE SGRELE)
	PUSHJ	P,RESET##	;RELEASE ALL DEVICES
	MOVE	P1,.JDAT+SGAMOD	;RESTORE PHYSICAL/LOGICAL BIT
SG2A:	MOVEI	T1,DR		;DUMP MODE 16(DUMP BY RECORDS
				; IN CASE THIS IS MAGTAPE)
	TLNE	P1,PHONLY	;SEE IF PHYSICAL DEVICE
	TLO	T1,(1B0)	;YES -- SET FOR PHYSICAL OPEN


	MOVEM	T1,.JDAT+SGAMOD	;STORE FOR OPEN UUO
	SETZM	.JDAT+SGAREN+1	;FOR DELETE
	SETZM	.JDAT+SGAREN+2	;FOR DELETE
	HLLZS	.JDAT+JOBCOR##	;0 THIRD ARG IN JOBDATA AREA(SO CHKARG WILL
				; WORK ON FIRST CALL(SAVE AND GET)
	SETZM	.JDAT+SGAHED	;CLEAR BUFFER HEADER ARG. FOR OPEN UUO
	MOVE	T1,.JDAT+SGADEV	;PHYSICAL OR LOGICAL DEVICE NAME
	PUSHJ	P,DEVSRG##	;FIND DEVICE AND SETUP F TO DDB
				; DO NOT INIT DEV SINCE IO MAY NOT BE NECESSARY
				; DO NOT WANT TO WAIT IN DTA SYSTEM
				; TAPE QUEUE IN 10/40 SYS
	  JRST	SGERRA		;NOT AVAILABLE
				;DEVICE INITED(OR FOUND)
	SETZM	.JDAT+SGAEND	;0 END OF DUMPE MODE COMMAND LIST
;COMMON EXIT FROM SAVHGH AND GETHGH ROUTINES(HIGH SEG SAVE AND GET)
;SO THAT SGA... LOCATIONS ARE RESTORED TO ORIGINAL VALUES FOR LOW SEG

SG3::	SKIPN	T1,.JDAT+SGAEXT	;DID USER SPECIFY AN EXTENSION ?
	MOVSI	T1,SAVDMP##	;NO, USE .SAV OR .DMP
	MOVEM	T1,.JDAT+SGAEXT	;AND STORE FOR LOOK UP OR ENTER

	MOVE	T1,.JDAT+JOBFF## ;FIRST FREE LOC IN JOB(SET FROM LH OF
				; JOBSA WHICH IS SET BY LOADER
	MOVEI	T1,-1(T1)	;MAKE LAST LOC TO SAVE OR GET(MAKE 0=777777)
	SKIPN	USRDDT##	;USER DDT IN USE(IF YES, SAVE ALL OF CORE
				; SO HIS SYMBOLS WILL BE INCLUDED
	PUSHJ	P,IADRCK##	;NO, ADDRESS TOO SMALL OR TOO LARGE?
	  MOVE	T1,.JDAT+.JBREL## ;YES, DUMP ALL OF CORE RATHER THAN GIVE
				; ADDRESS CHECK MESSAGE-HIGHEST REL.ADR.
	MOVNS	T1		;-HIGHEST ADR TO SAVE OR GET
	ADDI	T1,JOBSVM##	;LOWER CORE NOT DUMPED
	HRLI	T1,JOBSVM##	;IE FIRST LOC-1 TO BE DUMPED
	MOVSM	T1,.JDAT+SGADMP	;STORE IOWD WORD OF THIS SIZE CORE

;ROUTINE TO SET-UP E+3 FOR ENTER
;ENTER:	MOVS T1,DTA IOWD.
;USES T2

SG4::	PUSHJ	P,SETASJ	;SET EXEC MODE UUO FLAG

	MOVE	T2,DEVMOD(F)	;RETURN DEVICE CHARACTERISTICS(IF DISK SYS)
	TLNE	T2,DVDSK	;IS THIS DEVICE A DISK?
	MOVS	T1,.JDAT+SGAPPN	;YES, MAKE SURE FOURTH WORD IS PROJ,R NO.

	MOVSM	T1,.JDAT+SGALEN	;NO, MAKE SURE FOURTH WORD IS IOWD FOR DECTAPE
				; SINCE DECTAPE USES RH TO COMPUTE LENGTH IN K
				; FOR BOTH SAVE AND GET
	POPJ	P,
;ERROR ON INIT OR DEVICE SEARCH


SGERRU:	TLO	P1,GTSAV	;FLAG TO KEEP HISEG
	PUSHJ	P,SGRELE	;RETURN TO USER IF UUO (WITH ERROR IN T1)
	MOVE	T1,.JDAT+SGADEV	;GET DEVICE AGAIN
	PUSHJ	P,DEVSRG##	;SEE IF EXISTS
	 JFCL			;IGNORE NON-SKIP (SHOULD GIVE ERROR RET)
SGERRA::JUMPE	F,SGERR1	;WAS DEVICE FOUND, BUT JUST UNAVAILABLE?
	MOVEM	F,(P)		;YES, SAVE DDB ADDRESS FOR MESSAGE(ERNAM)
	MOVEI	T1,DNAERR	;ERROR CODE IN CASE RUN UUO(DEVICE NOT AVAILABLE)
	PUSHJ	P,SGRELE	;RETURN TO USER IF RUN UUO
				; OR FIND TTY AND PRINT ?CRLF
	PUSHJ	P,ERNAM##	;PRINT DEVICE NAME USING (P)
	JSP	T1,PHOLD##	;START TTY AND STOP JOB
	ASCIZ	/ not available/

SGERR1:	MOVEI	T1,NSDERR	;ERROR CODE IN CASE RUN UUO(NO SUCH DEVICE)
	PUSHJ	P,SGRELE	;RETURN TO USER IF RUN UUO
				; OR FIND TTY AND PRINT ?CRLF
	JSP	T1,PHOLD##	;START TTY AND STOP JOB
	ASCIZ	/No such device/
	SUBTTL	SAVGET -- GET FILE FROM DEVICE (R,RUN,GET,GETSEG)

;ROUTINE TO GET FILE FROM DEVICE(LOW AND/OR HIGH)
;CALL:	ACS R,P,F SETUP
;	MOVE J,JOB NUMBER
;	MOVE T2,DEVMOD(F)	;DEVICE CHAR.
;	PUSHJ P,GETJB
;	RETURN ONLY IF ALL OK
;	VALUE IN T1 = FILE NAME IF FROM REAL SYS, ELSO0., J PRESERVED
;


GJOBX:	HRRZS	JBTVRT##(J)	;RESET PAGING RATE
	PUSHJ	P,SETASA	;SET EXEC MODE UUO FLAG
	MOVSI	T1,(JB.LSY)	;CLEAR GOTTEN FROM SYS: FLAG
	ANDCAM	T1,JBTLIM##(J)	; ..

	MOVEI	T1,JS.XOR	;CLEAR XO-STATUS
	HRLI	T1,JACCT	; AND JACCT
	ANDCAM	T1,JBTSTS##(J)	;  ..
	MOVSI	T1,(UP.CXO)
	ANDCAM	T1,.USBTS	;AND XO CORE IMAGE
IFN FTFDAE,<
	MOVSI	T1,(JS.FXO)
	ANDCAM	T1,JBTST2##(J)
>
	PUSHJ	P,GETHGH##	;SEE IF HIGH SEG ALREADY EXISTS AND BEING SHARED
				; IF NOT, TRY TO LOOKUP AND READ IN HIGH FILE
				; IF .SHR DOESN'T EXIST, TRY .HGH,
				; IF NEITHER-SKIP RETURN
				; T2=DEVMOD(F) IF DISK(DEV CHAR.)
	  JRST	GJOB1		;HIGH SEG NOW IN CORE AND NO LOW FILE NEEDED

IFN FTEXE,<
	SKIPA	T1,.JDAT+SGAPPN ;LOW FILE NEEDED
				; EITHER BECAUSE NO HIGH SEG OR HIGH SEG ALSO
				; NEEDS LOW FILE
	JRST	GJOB5B		;RETURN HERE IF ENTIRE FILE
				; (HIGH AND LOW SEGS) HAVE BEEN
				; INPUT AND ARE READY TO GO.
>;END OF IFN FTEXE CONDITIONAL
	CAIE	T1,JOBUAL##	;DON'T WIPE OUT THE PPN RETURNED BY PATH
	MOVEM	T1,.JDAT+JOBUAL##+2 ;IN CASE MUST GET GET
	PUSHJ	P,LUKFIL	;LOOKUP LOW FILE
	  JRST	NOFILE		;GO PRINT FILE.EXT NOT FOUND
	HLRE	T2,.JDAT+SGALEN	;-NO. OF WORDS IN FILE
	JUMPE	T2,GETERR	;IF 0, GIVE ERROR MESSAGE
	JUMPL	T2,GJOB5	;GO IF NUMBER OF WORDS
	LSH	T2,BLKLSH##	;NO. OF BLOCKS, CONVERT TO WORDS
	MOVNS	T2		;MINUS NO. OF WORDS
	HRLM	T2,.JDAT+SGALEN
GJOB5:	PUSHJ	P,CKIOWD	;CHECK USER'S SUPPLIED CORE ARG TO MAKE SURE NOT
				; TOO SMALL, RETURN LARGER OF FILE SIZE OR CORE ARG
	PUSH	P,T1		;SAVE CORE REQUIRED
	PUSHJ	P,MINGET	;REDUCE TO ONE PAGE IF VIRTUAL
	POP	P,T1		;RESTORE CORE ARG

	PUSHJ	P,GETCOR	;OK, TRY TO GET CORE
	MOVE	T2,DEVMOD(F)	;DEVICE CHARACTERISTICS
	MOVNS	T1
	ADDI	T1,JOBSVM##	;-WORD COUNT FOR ALL USERS CORE
	TLNE	T2,DVMTA	;MAG TAPE?
	HRLM	T1,.JDAT+SGALEN	;YES, USE USER-SPECIFIED CORE ARGUMENT
	HRRZS	.JDAT+JOBPD1##	;TURN OFF USER MODE PC FLAG IN CASE THIS
				; IS A RUN UUO,SO ERRORS WILL NOT TRY TO RETURN TO USER
	PUSHJ	P,SGDO		;READ IN FILE INTO LOW SEGMENT
	  INPUT	0,SGALEN	;EXECUTED FROM SGDO
IFN FTEXE,<
	HLRZ	T1,.JDAT+JOBSVM##-3	;GET 1ST WORD OF FILE
	CAIN	T1,SV.DIR	;IS THIS AN EXE FILE?
	JRST	EXESAV##	;YES, GIVE ERROR MESSAGE
>	;END OF IFN FTEXE
	MOVE	T1,.JDAT+JOBS41## ;RESTORE USER UUO JSR LOC
	MOVEM	T1,.JDAT+JOB41## ;SAVED BY SAVE
GJOB5B:	PUSH	P,F		;SAVE SYSDEV BIT
	SKIPN	.UPMP+.UPREL	;NO LOWFIN IF NON-CONTIGUOUS
	PUSHJ	P,LOWFIN	;MAKE SURE GOT ALL REQUESTED CORE
	POP	P,F		;NOW RESTORE F
	JRST	GJOB2		;GO RELEASE DEVICES AND RETURN
;HERE IF HIGH SEG SAYS NO LOW SEG(AND USER DID NOT TYPE AN EXT)
GJOB1:  SETZM	.JDAT+JOBBPT
	PUSH	P,F		;SAVE F SINCE IF NO LOOKUP WAS DONE IT IS
				; NOT STORED IN USRJDA
	PUSHJ	P,MINGET
	PUSH	P,.CPREL##	;MAX WHICH MUST BE CLEARED
	PUSHJ	P,LOWFIN	;INCREASE OR DECREASE SIZE
	POP	P,T1		;RESTORE PREVIOUS SIZE
	POP	P,F		;RESTORE F
	CAMLE	T1,.CPREL##	;SMALLER YET?
	MOVE	T1,.CPREL##	;
	MOVEI	T2,MJOBDA##(T1)	;NO. OF WORDS TO CLEAR(-JOB DATA AREA)
	ADDM	T2,CLRWRD##	;INCREASE TOT. NO. WORDS CLEARED BY SYSTEM

	MOVEI	T2,JOBDA##+1	;FIRST ABSOLUTE LOC+1 TO CLEAR(JOB DATA
				; AREA+2)=BLT DESTINATION ADR.
	EXCTUU	<SETZM -1(T2)>	;CLEAR THE FIRST WORD
	HRLI	T2,-1(T2)	;SET UP FIRST BLT SOURCE ADR(JOB DATA
				; AREA+1)
	EXCTUU	<BLT T2,(T1)>	;CLEAR FROM 140 TO TOP OF LOW SEG
GJOB2:	PUSHJ	P,HSVAD##	;GET HIGHEST RELATIVE ADDRESS IN THE HI SEG
	HRRM	T1,.JDAT+JOBHRL##	;SET HIGHEST RELATIVE LOC FOR USER

	MOVE	T1,.JDAT+SGANAM	;FILE NAME OF FILE OR SEGMENT
	PUSH	P,T1		;SAVE POSSIBLE RETURN AS VALUE
	TLNN	F,SYSDEV	;IS DEVICE THE REAL SYS(AS OPPOSED TO LOGICAL)
	SETZM	(P)		;NO, SET FILE NAME TO 0 FOR RETURN
	MOVEM	T1,JBTPRG##(J)	;LOW SEG NAME FOR SYSTAT
	PUSHJ	P,EXONLY	;IF EXECUTE ONLY, PROTECT THE CORE IMAGE
	MOVSI	T1,(UP.CXO)
	TDNE	T2,JBTSTS##(J)	;IF XO HERE,
	IORM	T1,.USBTS	; MARK THE ENTIRE CORE IMAGE AS XO
	TDNE	T2,JBTSTS##(J)	;IS IT EXECUTE ONLY?
	PUSHJ	P,MAPHGH##	;YES, MAKE SURE THE MAP REFLECTS THAT
	PUSHJ	P,FNDPDS##	;FIND THE PDB OR STOP
	MOVE	T1,JBTNAM##(J)	;STORE THE NAME OF THE PROGRAM
	MOVEM	T1,.PDNAM##(W)	; SINCE IT CAN BE CHANGED WITHOUT
				; CHANGING THE CONTENTS OF THE CORE IMAGE
	MOVSI	T3,.JDAT+JOBUAL##+3 ;WHERE THE SFD'S ARE STORED
	HRRZ	T1,F		;IF (F)
	CAIE	T1,DSKDDB##	;=DSKDDB, NO LOOKUP DONE
	JRST	GJOB6		;LOOKUP WAS DONE
	MOVE	J,.CPJOB##	;JOB NUMBER
	MOVE	T1,JBTSGN##(J)	;HIGH SEGMENT NUMBER
	MOVE	T2,JBTPPN##(T1)	;DIRECTORY AND
	MOVE	T1,JBTDEV##(T1)	;STR WHERE PROGRAM CAME FROM
	TLNE	T2,-1		;A PATH TO THE HIGH SEGMENT?
	JRST	GJOB7		;NO, STORE A ZERO AS FIRST SFD
	MOVSI	T3,1(T2)	;WHERE SFD'S ARE STORED
	MOVE	T2,(T2)		; AND THE PPN
	JRST	GJOB7		;STORE THEM
GJOB6:	CAIN	T1,SWPDDB##	;VIRTUAL PROGRAM?
	MOVE	F,USRJDA	;YES, INSURE F IS SETUP
	PUSHJ	P,NAMSTR##	;STR
	  SKIPA	T1,DEVNAM(F)	;NOT A DSK, DEVICE NAME
	SKIPA	T2,DEVPPN(F)	;YES, GET DIRECTORY
	MOVEI	T2,0		;NO, NO DIRECTORY
GJOB7:	MOVEM	T1,.PDSTR##(W)	;STORE STR OR DEVICE NAME
	MOVEM	T2,.PDDIR##(W)	;AND DIRECTORY
	HRRI	T3,.PDSFD##(W)	;WHERE TO STORE PATH
	BLT	T3,.PDSFD##+MAXLVL##-1(W) ;STORE PATH
IFN FTWATCH&FTVERS,<
	PUSHJ	P,VERWAT	;SEE IF VERSION WATCHING
	  JRST	GJOB8		;NO
	MOVSI	T2,'S: '	;YES -- PRESET SYS FLAG
	SKIPE	(P)		;SEE IF FROM SYS:
	PUSHJ	P,PRNAME##	;YES -- TYPE IT
	PUSHJ	P,VERBTH	;PRINT BOTH SEGMENTS
	PUSHJ	P,PGMFIL
	PUSHJ	P,PRRBKC	;PRINT RIGHT BRACKET <CRLF>
>
GJOB8:	PUSHJ	P,SGREL		;RELEASE DDB
	MOVSI	T1,.JDAT
	EXCTXU	<BLT T1,17>	;SETUP USER'S ACS FROM SG AREA

	JRST	TPOPJ##		;RETURN WITH T1 = FILE NAME ONLY
				; IF FROM REAL SYS,ELSE 0
;ROUTINE TO LOOKUP A LOW-SEGMENT FILE
;
;CALL:
;	PUSHJ	P,LUKFIL
;	  HERE IF NOT FOUND
;	HERE IF FOUND
;
LUKFIL::MOVE	T1,DEVMOD(F)	;DEVICE CHARACTERISTICS
	SKIPLE	T2,JBTSGN##(J)	;WAS THERE A HIGH SEGMENT?
	TLNN	T1,DVDSK	;YES, AND DID IT COME FROM THE DISK
	JRST	LUKFI3		;NO, JUST DO THE LOOKUP
	SKIPN	T1,DEVPPN(F)	;PPN FROM WHENCE THE HIGH SEGMENT CAME
	MOVE	T1,JBTPPN##(T2)	;NO LOOKUP WAS DONE FOR THE HI SEG
	TLNE	T1,-1		;PATH TO THE HI SEG STORED?
	JRST	[SKIPE DEVPPN(F) ;NO, USE PPN OR PATH FROM HI SEG LOOKUP
		 JRST LUKFI1
		 JRST LUKFI2]
	HRLI	T1,.JDAT+JOBUAL##+2 ;YES, USE PATH TO THE HI SEG
	MOVSS	T1		; TO LOOKUP THE LOW SEG
	BLT	T1,.JDAT+JOBUAL##+MAXLVL##+2
LUKFI1:	MOVEI	T1,JOBUAL##	;ADDRESS OF THE PATH
LUKFI2:	MOVEM	T1,.JDAT+SGALEN ;STORE IT FOR THE LOOKUP
LUKFI3:	LOOKUP	0,SGANAM	;LOOKUP LOW SEG FILE(EXT=SAV.DMP OR LOW(IF HIGH SEG
				; REQUIRES LOW SEG AND USER DID NOT TYPE EXT)
				; MODE=SAVMOD SO DECTAPE SERVICE WILL RETURN
				; IOWD IN E+3(TEMPORARY)
	  POPJ	P,		;NOT FOUND
	JRST	CPOPJ1##	;FOUND, SKIP RETURN


;ROUTINE TO CHECK VIRTUAL LIMITS ON A GET.
;
;CALL:
;	MOVE	T1,WORDS-NEEDED
;	PUSHJ	P,CKVLIM
;	  HERE IF NO ROOM
;	HERE IF OK
;
CKVLIM:	LSH	T1,W2PLSH##	;PAGE #
	HLRZ	T2,.PDCVL##(W)	;GET VIRTUAL LIMIT
	MOVSI	T3,(UP.GET)	;CHECK GET BIT
	TDNN	T3,.UPMP+.UPBTS
	CAIL	T1,(T2)		;WANT MORE THAN THAT?
	POPJ	P,		;YES
	JRST	CPOPJ1##	;NO
IFN FTWATCH&FTVERS,<
;VERWAT -- START VERSION WATCH IF ON
;RETURN CPOPJ IF NOT OR DETACHED
;SKIP IF SO WITH U SETUP AND LEFT BRACKET TYPED

VERWAT::MOVSI	T1,JW.WVR	;SEE IF WATCHING
	TDNN	T1,JBTWCH##(J)	;  ..
	POPJ	P,		;NO
	PUSHJ	P,TTYFND##	;GET LDB
	JUMPE	U,CPOPJ##	;NONE
	PUSHJ	P,PRLBK		;PRINT LEFT BRACKET
	JRST	CPOPJ1##	;SKIP RETURN
>

;SUBROUTINE TO DETERMINE IF JOB OR SEGMENT WAS READ FROM AN EXECUTE
; ONLY FILE. IF SO PROTECT THE CORE IMAGE BY SETTING THE EXECUTE
; ONLY BIT. IF NOT CLEAR EXECUTE ONLY.

EXONLY::MOVE	J,.CPJOB##	;GET THIS JOB NUMBER
	MOVE	T1,[JACCT,,JS.XOR]
	MOVEI	T2,JS.XO
	MOVE	T3,[IORM T2,JBTSTS##(J)]
IFN FTFDAE,<
	MOVSI	T4,(JS.FXO)
	TDNE	T4,JBTST2##(J)
	JRST	EXONL1
>
	MOVE	T4,JBTPPN##(J)
	CAME	T4,FFAPPN##	;DONT SET EXEC.ONLY FOR [1,2]
	TDNN	T1,JBTSTS##(J)	;EXEC.ONLY FILE?
	HRLI	T3,(ANDCAM T2,(J))
EXONL1:	MOVEI	T1,JS.RUU
	TDNN	T1,JBTSTS##(J)
	CAME	T3,[ANDCAM T2,JBTSTS##(J)]
	XCT	T3		;SET OR CLEAR EXECUTE ONLY CORE IMAGE
	POPJ	P,		;RETURN
;SUBROUTINE TO REDUCE LOW SEGMENT SIZE TO ONE PAGE
; IF THE PROGRAM IS VIRTUAL. THIS IS NECESSARY
; (ONLY IN THE CASE OF A RUN UUO - RUN COMMAND
; CALLED GETMIN) TO MAKE SURE THAT THE MAP
; CONTAINS NO DISK ADDRESSES AND TO REMOVE PFH
; IF IT IS CONTAINED IN THE CORE IMAGE

MINGET:	SKIPN	.UPMP+.UPVRT	;VIRTUAL?
	SKIPE	.UPMP+.UPMEM	;OR NON-CONTIGUOUS
	SKIPA	T1,MINCOR	;YES
IFN FTPEEKSPY,<
	PJRST	CLRSPG##	;ZAP SPY PAGES
>
IFE FTPEEKSPY,<
	POPJ	P,		;RETURN
>
GET1PG::HRRZM	T1,.JDAT+SGACOR	;ONE PAGE
	CALLI	SGACOR,200011	;REDUCE LOW SEG IMAGE TO PAGE ZERO
	  JFCL			;CAN'T FAIL
	HRRZS	.JDAT+JOBPD1##	;CLEAR USER MODE SINCE CAN'T RETURN TO USER
IFN FTPEEKSPY,<
	PJRST	CLRSPG##	;ZAP SPY PAGES IF ANY
>
IFE FTPEEKSPY,<
	POPJ	P,		;AND RETURN
>
;SUBROUTINE TO CLEAR VARIOUS ITEMS WHEN THE CONTENTS OF A CORE
; IMAGE IS CHANGED OR RENAMED (SAVE)
CLRTAB:	MOVE	T1,[JACCT,,JS.XO!JS.XOR] ;CLEAR EXECUTE ONLY SO
	ANDCAM	T1,JBTSTS##(J)	; USER WILL NOT BE RESTRICTED
	MOVSI	T1,(UP.CXO)
	ANDCAM	T1,.USBTS	;CLEAR XO CORE IMAGE
	MOVSI	T1,(JB.LSY)	;NO LONGER A PROGRAM
	ANDCAM	T1,JBTLIM##(J)	; FROM SYS
	PUSHJ	P,FNDPDS##	;POINT TO PDB
	SETZM	.PDNAM##(W)	;ZERO NAME
	SETZM	.PDSTR##(W)	; AND STR
	SETZM	.PDDIR##(W)	; AND PPN
MINCOR:	POPJ	P,PAGSIZ##-1	;RETURN
	SUBTTL	SAVGET -- IO ROUTINES

;ROUTINE TO RELEASE DEVICE AND FIND TTY

SGREL::	SKIPN	F,USRJDA##	;HAS CHANNEL BEEN RELEASED ALREADY?
	JRST	SGREL2		;YES, FIND TTY AND WAIT FOR OUTPUT TO FINISH
	PUSH	P,S		;NO,
	MOVE	T1,DEVMOD(F)
	TLNE	T1,DVDSK	;DISK?
	CLOSE	0,CLSNMB	;YES, KEEP THE ACCESS TABLES
	TLNE	T1,DVMTA	;MAGTAPE?
	TLNN	F,INPB		;YES, WAS AN INPUT DONE?
	JRST	SGREL1		;NO
	SETZM	DEVBUF(F)	;INSURE NO PAGE FAULTS
	CLOSE	0,CLSOUT	;YES, CLOSE MTA INPUT
	STATO	0,IOTEND+IODEND	;AT END OF APTE?
	MTAPE	0,16		;NO SKIP TO EOF
SGREL1:	RELEASE	0,		;NO RELEASE DEVICE
	POP	P,S
SGREL2:	PUSHJ	P,TTYFNU##	;FIND TTY FOR CURRENT USER SET J TO CURRENT JOB
	PJRST	CLRASA		;CLEAR EXEC MODE UUO FLAG
;SUBROUTINE TO ADJUST LOW SEG CORE ACCORDING TO ARG
; ON GET OR PREVIOUS SAVE
;CALL:	PUSHJ P,LOWFIN
;	ALWAYS RETURN

LOWFIN:	HRRZ	T1,.JDAT+JOBCOR##	;CORE ARG FROM PREVIOUS SAVE(THIS MONITOR
				; ALWAYS STORES SOMETHING)
	SKIPN	T1		;IS THIS AN OLD FORMAT FILE WITH NO CORE ARG TO SAVE?
	MOVE	T1,.CPREL##	;YES, USE ASSIGNMENT MADE WHEN LOW FILE READ IN
	PUSHJ	P,CKSARG	;RETURN ONLY IF USER'S SUPPLIED ARG IS 0 OR NOT
				; SMALLER THAN SAVE CORE ARG, RETURN LARGER
	HRRZM	T1,.JDAT+SGACOR	;STORE CORE ARGUMENT
	PUSH	P,T1		;SAVE IN CASE OF AN ERROR
	MOVE	T1,.JDAT+SGANAM	;NAME OF PROGRAM
	TLNE	F,SYSDEV	;IS PROGRAM FROM SYS  ?
	PUSHJ	P,PRVPG		;YES, SHOULD IT BE NON-VIRTUAL?
	  TDZA	T1,T1		;NO
	MOVEI	T1,UPHNLY	;YES, LIGHT PHYSICAL-ONLY BIT
	CALLI	SGACOR,11(T1)	;TRY TO GET THE CORE (VIRTUAL OR PHYSICAL)
	  JRST NOROOM		;NOT AVAILABLE

	MOVE	T1,.CPREL##	;HIGHEST LOC ASSIGNED TO LOW SEG
	HRRM	T1,.JDAT+JOBCOR##	;SET INITIAL CORE ASSIGNMENT IN JOB DATA AREA FOR
				; USER TO USE TO RESET CORE TO INITIAL SETTING WHEN
				; PROGRAM IS RESTARTED
	JRST	TPOPJ##
;ROUTINE TO EXECUTE DUMP MODE COMMAND LIST SETUP IN SGALEN(R)
;AND CHECK FOR ERRORS. USED ONLY TO READ LOW FILE.
;CALL:	PUSHJ P,SGDO
;	INPUT 0,SGALEN OR OUTPUT 0,SGALEN
;	OK RETURN(NO ERRORS)
;SGDOA CALLED FROM SAVE, IT HAS ALREADY SET LH OF USRHCU=-2
;TO INDICATE CORE IS COMPRESSED


SGDO:	HRROS	USRHCU##	;SET LH OF USRCHU-1 AS A FLAG TO INDICATE SAVE GET
				; LOW FILE IO IN PROGRESS, SO MONITOR WILL
				; NOT STORE HIGH SEG PROTECTION IN JOBHRL WHICH
				; HAS IOWD FOR ZERO COMPRESSION
SGDOA:
IFN FTEXE,<
	SETZM	.JDAT+SGAEND
>
	XCT	@(P)		;EXECUTE INPUT OR OUTPUT UUO
	MOVE	J,.CPJOB##	;READ INTO PROTECTED PART OF JOB DATA AREA
	PUSHJ	P,EXPAND	;EXPAND CORE IMAGE
	  JRST	ADRERR##	;ADDRESS CHECK, PRINT MESSAGE AND STOP JOB
	MOVE	T1,.JDAT+JOBDDT##	;COPY DDT STARTING ADR
	MOVEM	T1,USRDDT##	;INTO MONITOR PROTECTED AREA(IN CASE THIS IS GET)
	SETZM	USRHCU##	;FLAG THAT SAVE-GET IO FINISHED AND CORE EXPANDED
	AOS	(P)		;SKIP OVER UUO IN CALLING SEQUENCE

;ROUTINE TO CHECK FOR IO ERRORS(CALLED FROM SEGCON)
;CALL:	MOVE F,DEVICE DATA BLOCK ADDRESS
;	PUSHJ P,SGIOCK
;	RETURN ONLY IF NO ERRORS


SGIOCK::MOVE	S,DEVIOS(F)	;IO STATUS WORD FOR THIS DEVICE
	TRNN	S,IOBKTL!IODTER!IODERR!IOIMPM	;ANY ERRORS ON SAVE-GET DEVICE?
	POPJ	P,		;NO, GIVE OK RETURN
IFN FTEXE,<
	MOVSI	T1,USRMOD	;USER-MODE BIT
	TDNN	T1,.JDAT+JOBPD1## ;FROM A UUO?
	 JRST	SGIO2		;NO, SKIP THIS
	POP	P,.UPMP+.UPTMC	;RESTORE VM LOCS
	POP	P,.UPMP+.UPTMI
>	;END OF IFN FTEXE
SGIO2:	MOVEI	T1,TRNERR	;YES, ERROR CODE IN CASE THIS IS RUN UUO
				; (TRANSMISSION ERROR)
	PUSHJ	P,SGRELE	;RELEASE DEVICE AND ERROR RETURN TO USER IF RUN UUO
				; OR FIND TTY AND PRINT ?CRLF
	JSP	T1,PHOLD##	;START TTY AND STOP JOB
	ASCIZ	/Transmission error/
	SUBTTL	SAVGET -- EXPAND COMPRESSED FILES

;ROUTINE TO EXPAND CORE AFTER A SAVE(LOW SEG ONLY)
;CALL:	MOVE F,DEVICE ADR.
;	MOVE R,JOBADR.
;	MOVE J,JOB NUMBER
;	PUSHJ P,EXPAND
;	ERROR RETURN, ADR. CHECK, OR NEED CORE BUT NOT CURRENT USER(COMMAND
;			DECODER EXPANDING AFTER USER HAS REDUCE CORE)
;	OK RETURN, CORE EXPANDED
;CALLED FROM SAVE AND COMMAND DECODER
;START,CSTART,DDT,REENTER,SAVE,SSAVE COMMANDS IF CORE STILL COMPRESSED

EXPAND:	HLRE	P3,.JDAT+SGALEN	;-LENGTH OF FILE
	MOVNS	P3		;+LENGTH OF FILE
	ADDI	P3,JOBSVM##	;ADD FIRST LOC-1 TO FORM HIGHEST LEGAL ADR.

	SKIPL	T1,.JDAT+JOBSV##	;IF FIRST LOC IS POSITIVE
	JRST	SGDO1		;OLD FORMAT, SO DONT EXPAND
	AOJE	T1,SGDO2	;DO NOT EXPAND IF NOT COMPRESSED
	PUSHJ	P,SAVE1##	;SAVE P1
	HRRZ	T1,.JDAT+JOBSV##	;LOOK AT 1ST WORD OF FILE
	CAILE	T1,JOBDDT##	;IS IT BELOW JOBJDA?
	JRST	EXPND1		;NO. NEW COMPRESSED FORMAT
	CAIE	T1,JOBSAV##	;IS JOBDDT THE DATA WORD?
	JRST	EXPND1		;NO. EXPAND
	SKIPN	.JDAT+JOBSV3##	;IS THE SAVE FILE FROM CONVERT?
				; CONVERT DOES NOT ZERO COMPESS
				; IT JUST WRITES ENTIRE FILE WITH 1 IOWD IN FRONT
	SOJA	P3,SGDO1	;YES, GO BLT DATA DOWN AS IF OLD DISK SAVE FILE
				; (NON-COMPRESSED)
	HRROI	T1,JOBSD1##	;YES. CHANGE TO IOWD 1,JOBSDD
	EXCH	T1,.JDAT+JOBSV##	;ZAP. THE IOWD IS FIXED
	HLRES	T1		;WORD COUNT OF IOWD
	AOJE	T1,EXPND1	;JUST 1 DATA WORD - THROUGH
	MOVSI	T1,1(T1)	;MAKE IOWD N-2,JOBSAV
	JUMPE	T1,EXPZ
	HRRI	T1,JOBSAV##	;SO NEXT DATA WDS WILL BE SKIPPED
	MOVEI	T2,.JDAT+JOBSV##
	MOVEM	T1,2(T2)	;STORE IN COMPRESSED DATA
	JRST	EXPND1
EXPZ:	MOVSI	T1,-2
	HLLM	T1,.JDAT+JOBSV##
;COME HERE TO DO THE ACTUAL EXPANSION OF A FILE
EXPND1:	MOVEI	T1,JOBSV##	;IT WAS READ INTO JOBSV
	EXCTUX	<MOVE T2,@T1>	;GET FIRST IOWD
EXPLP1:	HRRZ	P1,T2		;ADDRESS OF IOWD
	CAIGE	P1,JOBSD1##	;LEGAL?
	AOJA	P1,TOOLOW	;NO. DELETE DATA WHICH IS TOO LOW
	HLRE	P1,T2		;YES. GET WORDCOUNT
	MOVNS	P1		;+N
	HRLM	P1,T2		;CONVERT IOWD TO +N IN LH
	ADDI	T1,1(P1)	;ADDRESS OF NEXT IOWD
	CAMLE	T1,P3		;IN BOUNDS?
	JRST	GETERR		;NO. COMPLAIN
	ADDI	T2,(P1)		;YES. CHANGE RH OF IOWD
	EXCTUU	<EXCH T2,@T1>	;MAKE IT XWD +N,A+N-1 AFTER DATA BLOCK
	JUMPL	T2,EXPLP1	;CONTINUE IF NEXT THING IS AN IOWD
	HLRZ	P1,T2		;GET LH OF SUSPECTED STARTING
	CAIE	P1,(JRST)	;IS IT JRST?
	CAIN	P1,(HALT)	;OR HALT?
	SKIPA			;YES,
	JRST	EXPLP1		;NO, LOOP BACK AND ASSUME JUST
				; A COUNT OF GREATER THAN 128K
				; GET ADDRESS CHECK MESSAGE IF FILE
				; WAS NOT THAT BIG
	PUSH	P,T1		;SAVE DATA LOCATION
	EXCTUX	<HRRZ T1,@T1>	;TOP REAL LOCATION NEEDED

	TRO	T1,PG.BDY##	;MAKE IT NK-1
	HLRZ	T2,R		;PRESENT SIZ OF LOW SEG
	CAMG	T1,T2		;IS THERE ENOUGH?
	JRST	EXPCOR		;YES,
	CAME	J,.CPJOB##		;NO, IS TIS THE CURENT JOB?
	JRST	SGDOER		;NO, GIVE ERROR RETURN, MUST BE COMMAND DECODER
				; DOING EXPAND AFTER USER HAS REDUECED CORE
	PUSHJ	P,GETCOR	;YES. GET IT
EXPCOR:	POP	P,T2

	MOVEI	P1,@T2		;TOP  DATA LOC
	HRLI	P1,1(P1)	;SET TO ZERO TO TOP OF CORE
	HRRI	P1,2(P1)
	EXCTXU	<SETZM -1(P1)>	;ZERO FIRST LOC
	EXCTUU	<BLT P1,@T1>	;CLEAR CORE
	MOVEI	T4,JOBSV##	;SET UP END-OF-LOOP WORD
	HLL	T4,T2		;R IN LH(T4) IF KA10
	HRROI	T1,@T2		;FROM DATA POINTER
EXPLP2:	EXCTUX	<HRRZ	P1,(T1)>	;TO DATA POINTER
	MOVSS	R		;CHECK ADR OF, IOWD
	CAILE	P1,(R)		;IN BOUNDS?
	JRST	GETER0		;NO-ERROR
	MOVSS	R		;YES. OK
	CAIGE	P1,(T1)		;MAKE SURE WE DO NOT GO BACKWARDS
	JRST	GETERR		; CAN HAPPEN IF TOO MANY IOWDS W/O 0'S.
	EXCTUX	<HLRZ	P2,(T1)>	;WORD COUNT
	SUBI	T2,1(P2)	;POINT T2 TO PREVIOUS IOWD
	JUMPE	P2,EXPLP5	;FORGET IT IF ZERO WORD-COUNT
	EXCTXU	<SETZM (T1)>
	SOSA	T1		;POINT TO DATA
EXPLP3:	SOS	P1
	CAIGE	P1,JOBSDD##
	JRST	EXPLP5
	JRST	EXPLP6
EXPLP5:	SOSA	T1
EXPLP6:	EXCTUU	<POP T1,(P1)>	;MOVE A DATA WORD
	EXCTUU	<SETZM 1(T1)>	;ZERO WHERE IT CAME FROM
	SOJG	P2,EXPLP3	;LOOP IF MORE DATA
	CAMLE	T2,T4		;THROUGH?
	JRST	EXPLP2		;NO. DO NEXT BLOCK
	EXCH	P2,.JDAT+JOBSDD##	;YES. ZERO JOBSDD
	MOVEM	P2,.JDAT+JOBDDT##	;SET USER DDT STR ADR
	JRST	SGDO2		;AND SETUP USRDDT IN MONITOR PROTECTED
				; FROM THIS USER
;THIS ROUTINE WILL DELETE ALL DATA FROM A COMPRESSED FILE
;WHICH IS BELOW JOBSDD (PROBABLY WRITTEN BY TENDUMP)

TOOLOW:	EXCTUX	<HLRE P2,@T1>	;WORDCOUNT OF OFFENDING IOWD
	JUMPGE	P2,GETERR	;PROHIBIT AGAINST UNFORMATTED SAVE FILES
	SUB	P1,P2		;ADDRESS+N
	HLRZ	T2,R		;PROTECTION
	CAILE	P1,(T2)		;ADR TOO HIGH?
	JRST	GETERR		;YES, COMPLAIN
	CAIG	P1,JOBSDD##	;IS ANY DATA IN IT LEGAL?
	AOJA	T1,NXIOWD	;NO, TEST NEXT IOWD
	SUBI	P1,JOBSDD##	;YES, NUMBER OF WORDS TO KEEP
	MOVNS	P2		;TOTAL NUMBER OF WORDS
	SUBB	P2,P1		;NUMBER OF WORDS TO DROP
	HRLS	P2		;INTO BOTH HALVES
	EXCTUX	<ADD P2,@T1>	;NEW IOWD FOR ONLY GOOD DATA
	ADDI	T1,(P1)		;POINT T1 TO LAST BAD DATA LOC
	EXCTXU	<MOVEM P2,@T1>	;STORE UPDATED IOWD OVER IT
	JRST	IOWBLT		;GO BLT OVER BAD DATA
NXIOWD:	SUB	T1,P2		;POINT T1 TO NEXT IOWD
	CAMLE	T1,P3		;PROTECTION
	JRST	SGDOR2
	EXCTUX	<HRRZ P1,@T1>	;GET ADDRESS
	CAIGE	P1,JOBSD1##	;LEGAL?
	AOJA	P1,TOOLOW	;NO, AT LEAST PART OF THE DATA IS LOW
IOWBLT:	EXCTUX	<MOVSI T2,@T1>	;YES. KEEP THE ENTIRE IOWD DATA
	HRRI	T2,JOBSV##	;T2 IS A BLT POINTER
	SUBI	T1,JOBSV##	;RH OF T1 IS AMOUNT BEING DELETED
	SUBI	P3,(T1)		;P3 POINTS TO TOP OF DATA READ IN-(N)
	EXCTUU	<BLT T2,@P3>	;MOVE ONLY GOOD DATA DOWN
	JRST	EXPND1		;GO EXPAND THE GOOD DATA
SGDO1:	MOVEI	T1,JOBDDT##	;MOVE EVERYTHING DOWN )MUST BE NON-COMPRESSED DSK FILE
	HRLI	T1,JOBSVD##(T1)	;OR CONVERT SAVE FILE
	SKIPGE	.JDAT+JOBSV##	;IS THIS CONVERT FILE(FIRST WORD IS IOWD)?
	HRLI	T1,JOBSDP##(T1)	;YES, ALSO SKIP OVER IOWD
	SUBI	P3,JOBSVD##
	EXCTUU	<BLT T1,(P3)>
SGDO2:	AOSA	(P)		;SET FOR OK RETURN
SGDOER:	POP	P,T1
SGDOR2:	SETZM	USRHCU##	;CLEAR LH AND SET HIGHEST USER CHAN. IN
				; USE TO 0(WHERE IT SHOULD BE ANYWAY)
	POPJ	P,		;ERROR RETURN OR OK RETURN
;ROUTINE TO CHECK USER SUPPLIED CORE ARG AND CHECK TO SEE IF 0
;OR GREATER THAN OR EQUAL TO IOWD USED TO SAVE OR GET FILE
;CALL:	HLRE T2,-NO. OF WORDS IN FILE
;	PUSHJ P,CKIOWD
;	RETURN WITH LARGER OF 2 POSITIVE NOS. IN T1(1777 ORED IN)
;	DO NOT RETURN IF CORE ARG SUPLLIED BY USER IS TOO SMALL
;CALLED FROM SAVE AND GET


CKIOWD:	MOVEI	T1,JOBSVM##	;FIRST LOC-1 READ OR WRITTEN IN USER AREA
	HRRM	T1,.JDAT+SGALEN	;RESTORE RH TO JOBSAV AFTER LOOKUP
	SUB	T1,T2		;HIGHEST LOC=FIRST LOC-1+LENGTH OF FILE
				; FALL INTO CHSARG

;ROUTINE TO CHECK USER SUPPLIED CORE ARG AND CHECK IF 0
;OR GREATER THAN OR EQUAL TO CORE ARG FOR PREVIOUS SAVE
;CALL:	HRRZ T1,JOBCOR(R)	;WRITTEN WHEN FILE SAVED
;	PUSHJ P,CKSARG
;	RETURN WITH LARGER OF 2 IN AC T1, ONLY IF USER ARG NOT TOO SMALL
;CALLED ONLY FROM GET AFTER JOB DATA AREA LOADED FROM FILE(JOBCOR) OR HIGH SEG


CKSARG:	IORI	T1,PG.BDY##	;MAKE SURE 1K-1
	CAMLE	T1,.JDAT+SGANEW	;IS USER SUPPLIED ARG BIGGER?
	JRST	CKSAR1		;NO
	MOVE	T1,.JDAT+SGANEW	;YES, RETURN IT
	POPJ	P,
CKSAR1:	PUSH	P,T1		;IN CASE OF ERROR
	SKIPN	.JDAT+SGANEW	;DID USER SUPPLY ONE?
	PJRST	TPOPJ##		;NO, RETURN LARGER OF TWO

;ROUTINE TO PRINT #K OF CORE NEEDED
;CALL:	PUSH	P,HIGHEST REL. USER ADR.
;	JRST	NROOM
;	NEVER RETURN

NOROOM::MOVEI	T1,NECERR	;NOT ENOUGH CORE ERROR CODE
NROOM::	PUSHJ	P,SGRELE	;RELEASE DEVICE AND ERROR RETURN TO USER IF RUN UUO
				; OR FIND TTY AND PRINT ?CRLF
	PUSHJ	P,EXONLY	;SET JS.XO AS APPROPRIATE
	HRRZ	T1,(P)		;GET AMOUNT OF CORE REQUESTED
	LSH	T1,W2PLSH##	;CONVERT TO NO. OF 1K BLOCKS-1
	PUSHJ	P,DECP1##	;ADD 1 TO T1 AND PRINT DECIMAL
	PUSHJ	P,PRPORK	;PRINT "P" OR "K"
	JSP	T1,PHOLD##	;START TTY ADN STOP JOB
	ASCIZ	/ of core needed/
	SUBTTL	SAVGET -- SUBROUTINES


;ROUTINE TO ASSIGN CORE FOR LOW  AND HIGH SEG
;CALL:	MOVE R,LOW SEG RELOCATION
;	HRR T1,HIGHEST LOC DESIRED
;	PUSHJ P,GETCOR
;	RETURN ONLY IF ASSIGNED


GETCOR::
IFN FTEXE,<
	PUSHJ	P,SAVE1##	;SAVE P1 FOR EXE FILES
>
	HRRZM	T1,.JDAT+SGACOR	;SOTRE CORE ARG FOR CORE UUO IN USER AC
	PUSH	P,T1		;SAVE IN CASE OF ERROR
	MOVE	J,.CPJOB##
	MOVE	T4,T1
	SKIPN	T2,.UPMP+.UPREL
	HLRZ	T2,R
	IORI	T4,PG.BDY##
	SUB	T4,T2
	LSH	T4,W2PLSH##
	PUSHJ	P,GSIZT##
	  JRST	GETGET
	  SKIPA	T2,.UPMP+.UPBTS
	JRST	GETCR1
	TLNN	T2,(UP.GET)
	JRST	GETGET

GETCR1:	CALLI	SGACOR,200011	;DO PHYSICAL-ONLY CORE UUO
	  JRST	NOROOM		;NOT AVAILABLE, PRINT ERROR AND AMOUNT TRYING FOR
	JRST	TPOPJ##		;OK, REMOVE T1 FROM PD LIST AND RETURN
GETGET::MOVE	T4,T1
	MOVE	T1,.JDAT+SGANAM
	TLNE	F,SYSDEV
	PUSHJ	P,PRVPG
	  SKIPA	T1,JBTSTS##(J)
	JRST	GETCR1
	TLNE	T1,JACCT
	JRST	GETCR1
GETGTS::LSH	T4,W2PLSH##
	HLRZ	T2,.PDCVL##(W)	;CURRENT VIRTUAL LIMIT FOR JOB
	MOVSI	T3,(UP.GET)
	TDNN	T3,.UPMP+.UPBTS
	CAIL	T4,(T2)		;WANT MORE THAN THAT?
	JRST	NOROOM		;YES, ERROR
	IORM	T3,.UPMP+.UPBTS
	JSP	T1,MONSTR##	;RESET P TO AVOID PDL OVF SINCE STARTING ALL OVER
	PUSHJ	P,RMVPFH##	;DELETE DEFAULT PFH, IF THERE
	HRRZS	USRHCU##
	MOVEI	T1,JS.RUU
	ANDCAM	T1,JBTSTS##(J)
	MOVEI	T1,.UPMP+.UPUAC-1
	PUSH	T1,.JDAT+SGADEV	;NO, SAVE WHAT HE WANTS TO GET
	PUSH	T1,.JDAT+SGANAM
	PUSH	T1,.JDAT+SGAEXT
	HLRZ	T2,.JDAT+SGAEXT
	MOVE	T3,.JDAT+SGAHGH
	CAIN	T2,'LOW'
	HLLZM	T3,(T1)
	PUSH	T1,.JDAT+JOBUAL##+2 ;PPN
	SETZM	.JDAT+SGAPPN
	AOBJP	T1,.+1		;SKIP SIXBIT COMMAND OR UUO NAME
	PUSH	T1,.JDAT+SGANEW
	MOVE	T1,[PHONLY,,DR]
	MOVE	P1,T1
	MOVSI	T2,'SYS'
	SETZB	T3,T4
	DMOVEM	T1,.JDAT+SGAMOD
	DMOVEM	T3,.JDAT+SGAMOD+2
	MOVSI	T1,'GET'
	MOVEM	T1,.JDAT+SGANAM
	DMOVEM	T3,.JDAT+SGANAM+2
	MOVE	T1,['SHRHGH']
	MOVEM	T1,.JDAT+SGAHGH
	MOVE	T1,.UPMP+.UPUAC+4
	TRNN	T1,-1
	PUSHJ	P,GETMIN
	PUSHJ	P,CLRTAB
	HRRZS	.JDAT+JOBPD1##
	MOVE	T1,.JDAT+SGADEV
	PUSHJ	P,DEVSRG##
	  JRST	SGERRA
IFN FTEXE,<
	MOVSI	T1,GTHGH
>
	PUSHJ	P,GETSEG##
	  JRST	NOFILE
IFN FTEXE,<
	  JFCL
>
	PUSHJ	P,CLRASA
	MOVSI	T1,.UPMP+.UPUAC
	EXCTXU	<BLT T1,7>
	HRRZ	T2,.VJDT+.JBHSA##
	MOVE	T1,['GETSEG']
	CAMN	T1,.UPMP+.UPUAC+4
	JRST	STARTU
	HRLZ	T1,.VJDT+.JBHSA##
	PUSH	P,T1
	HLLZS	.JDAT+JOBSA##
	JRST	URUN3


SETASJ::PUSH	P,J		;SAVE J
	MOVE	J,.CPJOB##	;J=JOB NUMBER OF CURRENT JOB
	PUSHJ	P,SETASA	;MAKE AC REFERENCES BE TO THE SHADOW AREA
	JRST	JPOPJ##		;RESTORE J AND RETURN

SETASA::PUSHJ	P,SAVE1##	;SAVE P1
	MOVEI	P1,JS.ASA	;LITE THE BIT WHICH INDICATES REFERENCES TO
	IORM	P1,JBTSTS##(J)	; LOCATIONS 0-17 IN THE USER'S AREA ARE TO SHADOW ACS
	POPJ	P,		;RETURN

CLRASA::PUSHJ	P,SAVE1##	;SAVE P1
	MOVEI	P1,JS.ASA	;CLEAR THE BIT WHICH INDICATES REFERENCES TO
	ANDCAM	P1,JBTSTS##(J)	; USER LOCATIONS 0-17 ARE TO SHADOW ACS
	POPJ	P,		;AND RETURN
;ROUTINE TO PRINT NOT A SAVE FILE IF WRONG FORMAT FILE DETECTED


GETER0:	MOVSS	R		;"SAVE" FILE ISN'T RIGHT
GETERR::MOVEI	T1,NSFERR	;ERROR CODE IN CASE THIS IS RUN UUO(NOT SAVE FILE)
	PUSHJ	P,SGRELE	;RELEASE DEVICE AND ERROR RETURN TO USER IF RUN UUO
				; OR FIND TTY AND PRINT ?CRLF
	JSP	T1,PHOLD##	;START TTY AND STOP JOB
	ASCIZ	/Not a save file/

;ROUTINE TO PRINT FILE NOT FOUND OR NEEDS 2 RELOC REG


NOFILE::MOVEI	T1,FNFERR	;ERROR CODE IN CASE THIS IS RUN UUO(FILE NOT FOUND)
				; CHANGE ERROR CODE TO DISK ERROR CODE IF DEV IS DSK
	PUSHJ	P,SGRELL	;RETURN DISK LOOKUP OR ENTER ERROR CODE IF DSK
				; RELEASE DEVICE AND ERROR RETURN TO USER IF HE WANTED
				; OR FIND TTY AND PRINT ?CRLF
	HRRZ	T1,.JDAT+SGAEXT	;SEE WHICH ERROR
	JUMPN	T1,LOOKFL	;NOT NOT FOUND
	MOVE	T2,.JDAT+SGANAM	;PRINT FILE NAME
	PUSHJ	P,PRNAME##
	PUSHJ	P,PRPER		;PRINT PERIOD
	HLLZ	T2,.JDAT+SGAEXT	;PRINT EXTENSION
	PUSHJ	P,PRNAME##
	JSP	T1,PHOLD##	;START TTY AND STOP JOB
	ASCIZ	/ not found/

LOOKFL:	PJSP	T1,LKENFL	;LOOKUP ERROR - PRINT MESSAGE
	ASCIZ	/Lookup error /


LKENFL:	PUSHJ	P,CONMES	;ISSUE MESSAGE
	HRRZ	T1,.JDAT+SGAEXT	;GET ERROR
	SKIPE	T1		;SEE IF = 0
	PUSHJ	P,PRTDI8##	;NO - PRINT IN OCTAL
	PJRST	HOLD##		;STOP JOB
;ROUTINE TO RELEASE DEVICE ON AN ERROR AND CHECK TO SEE
;IF THIS IS A MONITOR COMMAND OR USER UUO
;IF USER UUO, GIVE ERROR RETURN TO USER UNLESS THERE IS A HALT
;IN LH OF EROR RETURN WORD, IN WHICH CASE FIND TTY, PRINT ?CRLF
;AND RETURN TO CALLER SO CAN ADD MORE INFO TO ERROR MESSAGE AND STOP JOB
;CALL:	MOVEI T1,ERROR CODE(DEFINED IN S.MAC)
;	PUSHJ P,SGRELE
;DO NOT RETURN TO CALLER IF USER WANTS ERROR RETURN ON RUN AND GETSEG UUOS


SGRELL:				;LOOKUP OR ENTER FAILURE
	MOVE	T2,DEVMOD(F)	;IS THIS DEVICE A DISK?
	TLNE	T2,DVDSK
	HRRZ	T1,.JDAT+SGAEXT	;YES, RETURN DISK SERVICE ERROR CODE

SGRELE::PUSH	P,T1		;SAVE T1
	MOVE	J,.CPJOB##	;GET JOB #
IFN FTEXE,<
	TLNN	P1,GTMRG!GTSAV	;DON'T RELEASE HI-SEG IF MERGING
>
	SKIPN	.JDAT+JOBPD1##	;SKIP IF SAVE IS IN PROGRESS
				; IF IT IS NOT WE WANT TO KILL ANY
				; HISEG WE MAY HAVE GOTTEN.  THIS
				; PREVENTS US FROM LEAVING AN EXECUTE
				; ONLY HISEG ADDRESSABLE WHEN A RUN UUO
				; FAILS.
IFE FTMP,<
	CAIA			;MERGING OR SAVING, KEEP HI-SEG
	PUSHJ	P,KILHSH##	;KILL THE HISEG IF NOT SAVE
>
IFN FTMP,<
	CAIA			;MERGING OR SAVING, KEEP HI-SEG
	PUSHJ	P,[PUSHJ P,GGVMM## ;MUST OWN THE MM RESOURCE
		   PJRST KILHSH##] ;REMOVE THE HI SEG
>
	MOVEI	T2,JS.RUU	;CLEAR RUN FLAG
	ANDCAM	T2,JBTSTS##(J)	;  SO FILSER STOPS ITS CHECKS
	GETPC	T2,.JDAT+JOBPD1## ;GET FIRST PC ON PD LIST
	TLNN	T2,USRMOD	;IS IT IN USER MODE(IE USER UUO)?
	JRST	SGRLE1		;NO, MUST BE MONITOR COMMAND OR CALLER OVERLAYED
				; RELEASE DEVICE, FIND TTY, AND RETURN TO CALLER
	HRR	M,T2		;ADDRESS OF RETURN AFTER RUN OR GETSEG UUO
	TRNN	M,777760	;FROM AC'S?
	JRST	SGRLE1		;YES - TYPE MESSAGE
	PUSHJ	P,GETWRD##	;GET ERROR RETURN WORD FROM RUN OR GETSEG UUO
	  MOVSI	T1,(HALT)
	LSH	T1,-^D23	;ISOLATE OP CODE
	CAIN	T1,<HALT>B58	;IS IT HALT?
	JRST	SGRLE1		;YES, RELEASE DEVICE,FIND TTY, AND RETURN TO CALLER
	SKIPE	USRJDA##	;DO NOT RELEASE CHANNEL 0 IF NOT INITED YET
				; UUO HANDLER DOES NOT ALLOW THIS FROM EXEC MODE
	RELEAS	0,		;RELEASE DEVICE(IF INITED)
	PUSHJ	P,CLRASA	;CLEAR EXEC MODE UUO FLAG
	HRR	M,.JDAT+JOBPD3##+IFN FTKLP,<1> ;NO, AC NUMBER OF RUN OR GETSEG UUO
	POP	P,T1		;RESTORE ERROR CODE
	PUSHJ	P,PUTWDU##	;STORE ERROR NUMBER IN USER AC
	JRST	ERRGOU##	;PUT RETURN ON END OF PDLIST
				; AND RETURN TO USER TO HANDLE ERROR

SGRLE1:	POP	P,T1		;REMOVE ERROR CODE FROM LIST
	MOVSI	T1,.JDAT	;SAVUAC WILL STORE OVER
	EXCTXU	<BLT T1,17>	; SHADOW ACS, SO SET USERS ACS
SGRLE2:	PUSHJ	P,SGREL		;RELEASE DEVICE AND FIND TTY
	PUSHJ	P,TTYFUW##	;MAKE SURE ATTACHED FOR ERROR MESSAGES
	PUSHJ	P,TSETBI##	;CLEAR TYPE AHEAD
	SETZM	JBTPRG##(J)	;CLEAR NAME SINCE LOST
PPQCRL::PJSP	T1,CONMES	;PRINT ? ON SAME LINE AS ERROR MSG,
				;FOR BATCH AND SCRIPT, RETURN TO CALLER
				; WHO WILL PRINT REST OF ERROR MESSAGE AND STOP JOB
	ASCIZ	/
?/
	$LIT
COMEND:	END			;END OF COMCON

