TITLE COMMON - MONITOR COMMON DATA AREA AND CONFIGURATION DEFINITION - V2000
SUBTTL PART 6 COMMON.MAC - T. HASTINGS/PH/TWE/DAL/EVS/JBS/EGF 25 JAN 84
	SEARCH	F,S

STUPID==-1
FTYORK==-1

	IFN FTNET,<
	SEARCH	NETPRM		;GET NETWORK PARAMETER FILE
	>
	HIORG==:MONORG
	$RELOC
	$ABS
;COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


; DATE		LOAD	EDIT #
; ----		----	------
;
;19-AUG-80	70112	1541
;9369-9358
;
;26-AUG-80	70113	1542
;9372
;
;02-SEP-80	70114	1543
;9380,9381
;09-SEP-80	70115	1544
;9388-9390-9393
;23-SEP-70	70116	1545
;30-SEP-80	70117	1546
;9418-9424
;07-OCT-80	70121	1547
;9429-
;14-OCT-80	70122	1550
;9440
;21-OCT-80	70123	1551
;28-OCT-80	70124	1552
;9447-
;04-NOV-80	70125	1553
;25-NOV-80	70126	1554
;02-DEC-80	70127	1555
;09-DEC-80	70130	1556
;9491-
;16-DEC-80	70131	1557
;23-DEC-80	70132	1560
;30-DEC-80	70133	1561
;9521
;13-JAN-81	70134	1562
;20-JAN-81	70135	1563
;27-JAN-81	70136	1564
;9545-
;03-FEB-81	70137	1565
;9566-
;10-FEB-81	70140	1566
;9567-9569
;17-FEB-81	70141	1567
;24-FEB-81	70142	1570
;9593
;03-MAR-81	70143	1571
;10-MAR-81	70144	1572
;17-MAR-81	70145	1573
;24-MAR-81	70146	1574
;31-MAR-81	70147	1575
;07-APR-81	70150	1576
;14-APR-81	70151	1577
;21-APR-81	70152	1600
;9692,9691
;28-ARP-81	70153	1601
;9701
;05-MAY-81	70154	1602
;9713,9714,9713
;12-MAY-81	70155	1603
;19-MAY-81	70156	1604
;26-MAY-81	70157	1605
;02-JUN-81	70160	1606
;09-JUN-81	70161	1607
;9755
;16-JUN-81	70162	1610
;9762
;23-JUN-81	70163	1611
;30-JUN-81	70164	1612
;9790
;07-JUL-81	70165	1613
;9803
;14-JUL-81	70166	1614
;21-JUL-81	70167	1615
;9834
;28-JUL-81	70170	1616
;04-AUG-81	70171	1617
;9848
;11-AUG-81	70172	1620
;18-AUG-81	70173	1621
;15-SEP-81	70174	1622
;22-SEP-81	70175	1623
;9893-9904-
;29-SEP-81	70176	1624
;9905
;06-OCT-81	70177	1625
;9919-9922-
;13-OCT-81	70111	1626
;20-OCT-81	70112	1627
;27-OCT-81	70113	1630
;02-NOV-81	70114	1631
;10-NOV-81	70115	1632
;17-NOV-81	70116	1633
;22-NOV-81	70117	1634
;9993
;01-DEC-81	70120	1635
;08-DEC-81	70121	1636
;15-DEC-81	70122	1637
;10009-10013
;22-DEC-81	70123	1640
;10019
;29-DEC-81	70124	1641
;10022,10024
;05-JAN-82	70125	1642
;12-JAN-82	70126	1643
;10033-10044
;19-JAN-82	70127	1644
;10050-10051-10052
;26-JAN-82	70130	1645
;10060-10062
;02-FEB-82	70131	1646
;10077
;9-FEB-82	70132	1647
;10098,10100
;16-FEB-82	70133	1650
;10102
;23-FEB-82	70134	1651
;10121
;02-MAR-82	70135	1652
;09-MAR-82	70136	1653
;10134-10141
;16-MAR-82	70137	1654
;10140,10145,10151,10156
;23-MAR-82	70140	1655
;30-MAR-82	70141	1656
;10176-10187
;06-APR-82	70142	1657
;10193
;13-APR-82	70143	1660
;10199-10207-10208-10210
;27-APR-82	70144	1661
;10213-10218-10231-10232
;4-MAY-82	70145	1662
;11-MAY-82	70146	1663
;10244
;18-MAY-82	70147	1664
;25-MAY-82	70150	1665
;10257-10258
;1-JUN-82	70151	1666
;10270-10266-10272
;8-JUN-82	70152	1667
;10275
;15-JUN-82	70153	1670
;22-JUN-82	70154	1671
;29-JUN-82	70155	1672
;6-JUL-82	70156	1673
;10304-
;13-JUL-82	70157	1674
;20-JUL-82	70160	1675
;27-JUL-82	70161	1676
;03-AUG-82	70162	1677
;10-AUG-82	70163	1700
;17-AUG-82	70164	1701
;24-AUG-82	70165	1702
;31-AUG-82	70166	1703
;10386-10393
;07-SEP-82	70167	1704
;14-SEP-82	70170	1705
;21-SEP-82	70171	1706
;28-SEP-82	70172	1707
;05-OCT-82	70173	1710
;10429-10442
;12-OCT-82	70174	1711
;19-OCT-82	70175	1712
;10453-10454
;26-0CT-82	70176	1713
;02-NOV-82	70177	1714
;10474
;09-NOV-82	70111	1715
;16-NOV-82	70112	1716
;10496
;23-NOV-82	70113	1717
;10507
;30-NOV-82	70114	1720
;07-DEC-82	70115	1721
;10522
;21-DEC-82	70116	1722
;04-JAN-83	70117	1723
;11-JAN-83	70120	1724
;10563
;18-JAN-83	70121	1725
;10573
;25-JAN-83	70122	1726
;10581-10589
;01-FEB-83	70123	1727
;08-FEB-83	70124	1730
;15-FEB-83	70125	1731
;01-MAR-83	70127	1733
;09-MAR-83	70130	1734
;10632
;22-MAR-83	70132	1735
;29-MAR-83	70135	1736
;10679
;5-APR-83	70134	1737
;10687
;12-APR-83	70135	1740
;17-MAY-83	70142	1745
;31-MAY-83	70143	1746
;7-jun-83	70144	1747
;10788
;14-JUN-83	70145	1750
;10794
;21-JUN-83	70146	1751
;10807-10811
;24-JUN-83	70147	1752
;28-JUNE-83	70150	1753
;10833
;12-JULY-83	70151	1754
;10836
;19-JUL-83	70152	1755
;10857
;26-JUL-83	70153	1756
;2-AUG-83	70154	1757
;9-AUG-83	70155	1760
;10897
;16-AUG-83	70156	1761
;10908-10909
;23-AUG-83	70157	1762
;10927
;30-AUG-83	70160	1763
;10935
;6-SEPT-83	70161	1764
;13-SEP-83	70162	1765
;10950
;27-SEP-83	70164	1766
;10970,10973
;4-OCT-83	70165	1767
;11-OCT-83	70166	1770
;11001,10993S
;18-OCT-83	70167	1771
;25-OCT-83	70170	1772
;11015-11018
;1-NOV-83	70171	1773
;13-DEC-83	70172	1774
;3-JAN-83	70173	1775
;17-JAN-84	70174	1776
;
XP VCOMMN,2000
				;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP



REPEAT 0, <
;THE COMMON SUBPROGRAM CONSISTS OF 6 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM
	1. F.MAC -- FEATURE TESTS (OUTPUT OF MONGEN).
	2. S.MAC - THE USUAL SYSTEM SYMBOL DEFINITIONS ASSEMBLED WITH
	EVERY	MONITOR SUBPROGRAM
	3. HDWCNF.MAC -- HARDWARE CONFIGURATION
	4. TTYCNF.MAC -- TERMINAL CONFIGURATION
	5. REMCNF.MAC -- REMOTE CONFIGURATION
	6. COMMON.MAC - THE REST OF THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL	CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS	AND MACROS DEFINED IN 2.

	THE	FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. MONITOR STARTUP LOCATIONS (400-407), HENCE LOAD THIS FIRST.
	B. JOB TABLES - LENGTH DEPENDENT ON MAXIMUM NUMBER OF JOBS ALLOWED
	C. ALL VARIABLE STORAGE NOT ASSOCIATED WITH A PARTICULAR DEVICE
	D. COMMON SUBROUTETURNS
	E. COMMON BYTE POINTERS
	F. TABLE OF SERVICE ROUTINE INTERRUPT LOCS TO BE LINKED BY ONCE ONLY CODE
	G. TABLE OF DEVICE DATA BLOCK ADDRESSES AND NUMBER TO BE USED BY ONCE TO
		LINK THEM TOGETHER AND GENERATE MULTIPLE COPIES.
	H. ASSIGNMENT OF PI CHANNELS
	I. PI CHANNEL SAVE AND RESTORE ROUTINES
	J. UUO TRAP LOCATIONS 40/41, 60/61
	K. APR INTERRUPT LOCATIONS CPU0,1, KA10/KI10
	L. SYSTEM CRASH STOP CONI'S.
	NOTE:  SEE COMDEV FOR DEVICE DEPENDENT CODE, DATA, AND SYMBOLS


LEVEL D DISK SERVICE PARAMETERS:

	ALL	SYMBOLS ANAS ONATIONS ARE IN A SEPARATE FILE CALLED
	COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIG (BUT NOT WITH FEATURS FILES).
	THE	SEPARATE FILE IS FOR TWO REASONS:	1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
	(THE DATA MUST BE IN THE COMMON MEMORY)
	2.  ELIMINATE THE NEED TO ASSEMBLE COMMOD IF NOT A DISK SYSTEM
	(COMMOD.MAC TAKES LOTS OF CORE FOR ITS COMPLICATED MACROS)


THE FOLLOWING EQUATES ARE GENERATED FOR REMOTE
COMMUNICATIONS PROGRAM SETUP:	LOCSTA	- THE STATION NUMBER OF THE (PDP10) CENTRAL SITE

		COMMUNICATIONS SOFTWARE
>
IFE FTNET,<IFN M.NET,<PRINTX ?ASSEMBLE SOURCES WITH FTNET=-1
			M.NET==0>>
IFN M.NET,<
	XP	LOCSTA,OURNNM	;DEFINE THE LOCAL NODE NUMBER
>;END OF IFN M.NET

IFE M.NET,<
IFNDEF LOCSTA,<	XP	LOCSTA,0>	;NO, NETWORK DEFINE LOCAL NODE=0
>;END OF IFN M.NET

IFN	M.TTY-53,<
	PRINTX	?Wrong version of MONGEN was used to
	PRINTX	? make TTYCNF.MAC go back and use version
	PRINTX	? 53 of MONGEN
	PASS2
	END
>
IFN FTEMRT,<IFE M.KL10,<PRINTX ? CPU MUST BE A KL10 TO SELECT EBOX/MBOX RUNTIME>>
SUBTTL CONVERT MONGEN SYMBOLS
REPEAT 0,<

;THIS SECTION CONVERTS NEW MONGEN SYMBOLS TO OLD MONGEN SYMBOLS
;SO THAT THE REST OF COMMON AND MONITOR CAN STILL USE THE OLD
;SYMBOLS.  THIS WAS DONE RATHER THAN CONVERTING ALL OF THE
;MONITOR TO NEW SYMBOLS FOR TWO REASONS:
; 1.  IT IS EASIER AND FASTER AND LESS LIKELY TO INTRODUCE BUGS, AND
; 2.  IT ALLOWS CUSTOMERS TO USE OLD MONGEN WITH A MINIMUM
;OF TROUBLE: ONLY A FEW EXTRA SYMBOLS MUST BE DEFINED.
;THE MONITOR WILL PROBABLY BE CONVERTED TO THE NEW MONGEN SYMBOLS
;AFTER THE 5.04 RELEASE.  THE ORDER HERE PARALLELS THE OLD
;MONGEN ORDER.

>

DEFINE TEMPM(TYPE),<
IRP TYPE,<
IFN M.'TYPE'10,<ZZ==ZZ+1>
>>
	ZZ==0
	TEMPM	<KI,KL,KS>
IFE ZZ,<
	PRINTX	?NONE OF M.KS10, M.KL10 OR M.KI10 IS SET NON-ZERO
	END
>
IFN ZZ-1,<
	PRINTX	?MORE THAN 1 CPU TYPE SELECTED
>

DEFINE	TEMPM(A,B),<
IFN M.'A'10,<IFE FT'A'10,<
	PRINTX	? A'10 SELECTED BUT FT'A'10 IS ZERO
>>
IFN M.'A'10,<
IRP B,<
IFN FT'B'10,<
	PRINTX	? A'10 SELECTED BUT FT'B'10 IS NOT ZERO
>>>
>
	TEMPM(KI,<KL,KS>)
	TEMPM(KL,<KI,KS>)
	TEMPM(KS,<KI,KL>)
XP SYS40N,0		;NEW MONGEN MAKES SWAPPING SYSTEMS ONLY
XP SYS50N,1
XP DSKN,1
XP LOGINN,1

XP APRSN,M.C0SN		;APR SERIAL NUMBER (REALLY PROCESSOR 0)
XP APR0SN,M.C0SN	;PROCESSOR 0 SERIAL NUMBER
XP APR1SN,M.C1SN	;PROCESSOR 1 SERIAL NUMBER
XP CP0KIN,M.KI10	;PROCESSOR 0 MAY BE A KI10
XP CP1KIN,M.KI10	;PROCESSOR 1 MAY BE A KI10
XP CP0KLN,M.KL10	;PROCESSOR 0 MAY BE A KL10
XP CP1KLN,M.KL10	;PROCESSOR 1 MAY BE A KL10
XP CP0KSN,M.KS10	;PROCESSOR 0 MAY BE A KS10
XP CPUN,M.CPU		;NUMBER OF PROCESSORS

XP LEVDN,1		;NEW MONGEN MAKES ONLY LEVEL D DISK SERVICE
XP LEVCN,0
XP CHNN,M.CHN		;NUMBER OF DATA CHANNELS FOR DISKS

XP RD10N,M.RC10
XP RH10NS,M.RH1S
XP RH10NP,M.RHP4
XP RP10N,M.RP10
XP RN10N,M.RP20		;RP20
XP RA10N,0		;NO MDF
XP RH11NP,M.R11D

	DEFINE	SYSDEV,<
	SIXBIT	/DSK/
>
XP JOBN,M.JOB+1


IFG	JOBN-^D512,<XP JOBN,^D512
		PRINTX %NUMBER OF JOBS REDUCED TO MAX=511>
XP COREN,M.CORE
XP PDP10N,M.KI10!M.KL10!M.KS10
XP KT10AN,MD.2RR
XP SEGN,MD.SEG
XP DDTN,MD.DDT

XP EDITN,0

XP PTRN,M.PTR
XP PTPN,M.PTP
XP PLTN,M.PLT
XP LPTN,M.LPT
IFNDEF M.DLP,<M.DLP==:0>
IFNDEF M.DCR,<M.DCR==:0>
XP DLPTN,M.DLP
XP DCDRN,M.DCR
XP MOVIEN,MD.MOV
XP CDRN,M.CDR
XP CR10N,MD.C10
XP CPFN,M.CDP
XP CDPN,M.CDP
XP VBCN,M.VBXC
IFN	FTXTC,<
XP XTCN,M.XTC
>
IFE	FTXTC,<
	IFN	M.XTC,<
PRINTX	?NO DA28 SUPPORT WITH FTXTC=0
PRINTX	?PROCEEDING ASSUMING NO DA28
XP M.XTC,0
XP M.XTL,0
>
XP XTCN,0
>
	IFE	M.XTC,<
XP M.XTL,0
XP XTTDSP,CPOPJ
XP XTKLDB,CPOPJ
XP XTUUO,CPOPJ
XP XTCTTY,CPOPJ2
XP XTCIOS,CPOPJ
XP XTCSEC,CPOPJ
>


IFE M.DAS78,<			;IF NO DAS78 SUPPORT
	CALL78==:CPOPJ		;CAL78. UUO IS A NOOP
	D78SEC==:CPOPJ		;NO ONCE-A-SECOND CODE
	D78MIN==:CPOPJ		;NO ONCE-A-MINUTE CODE
> ;END IFE M.DAS78
IFN M.DAS78,<			;IF DAS78 SUPPORT
	M.D78L==:M0D78L		;HACK FOR D78INT
	M78LM==:-M.D78L		;MINUS NUMBER OF LINES
> ;END IFN M.DAS78


XP DISN,M.DIS
XP PENN,M.DIS
XP T340N,M.340
XP TVP10N,M.VP10
XP T30N,0		;NO TYPE 30

ifn FtCImp,<		;[arpa]
xp m.IMP,IMPN		;[arpa] number of IMPs
>			;[arpa]
;DEFINE ALL DL10 SYMBOLS

	DLX.CK(1)		;MACRO DEFINED IN S.MAC

IFN FTDAS78!DLX.78,<
IFE FTDAS78,<
	PRINTX	?DEFINING A DAS78 REQUIRES FTDAS78 TO BE ON
PDP11N=PDP11N-DLX.78
DLX.78=0			;ACTUAL NUMBER
>
> ;END IFN FTDAS78!DLX.78

IFN FTDN60!DLX.60,<
IFE FTDN60,<
	PRINTX	?DEFINING A DN60 REQUIRES FTDN60 TO BE ON
PDP11N=PDP11N-DLX.60
DLX.60=0			;ACTUAL NUMBER
>
> ;END OF IFN FTDN60!DLX.60

IFN DLX.76,<EXTERN D76INT>
IFE PDP11N,<
	XP	D76MIN,CPOPJ
	XP	D76SIL,CPOPJ
>
IFE PDP11N!M.KL10!M.DN60!M.KDUP!M.DMRN,<
	XP	CALL11,CPOPJ
	XP	DLXSEC,CPOPJ
	XP	DLXWIN,0
> ; END IFE PDP11N!M.DN60!M.KDUP!M.DMRN
IFE DL10XI,<
 IFN PDP11N,<
	XP	DLXDWN,0	;;IF NO PDP-11S ON DL10'S
>>; END OF IFE DL10XI AND IFN PDP11N
DEFINE TDMAC(X),<
	XP	DT'X'N,M.DT'X
M.DTXN==M.DTXN+M.DT'X
>
ZZ=="A"
M.DTXN==0
REPEAT	M.TD10,<
	TDMAC(\"ZZ)
ZZ==ZZ+1
>
IFNDEF M.TM10,<XP M.TM10,0>
IFNDEF M.TC10,<XP M.TC10,0>
IFNDEF M.TX01,<XP M.TX01,0>
IFNDEF M.TM02,<XP M.TM02,0>
IFNDEF M.DX20,<XP M.DX20,0>
XP TAPN,M.TM10+M.TC10+M.TX01+M.TM02+M.DX20+M.TM78
IFNDEF MTCN,<MTCN==0>

IFG TAPN,<
DEFINE KONMAC <		;MACRO FOR LOOPING THROU TAPE CONTROLLERS
	..KON==0
	REPEAT	TAPN,<
	  TAPMAC(\..KON)
	  ..KON==..KON+1>
>

DEFINE TAPMAC (X) <
IFE FTAUTC,<
	IFE	M.MT'X'T,<TM10A==TM10A+1>	;COUNT TM10A CONTROLLERS
	IFE	<M.MT'X'T-K.TMB>,<TM10B==TM10B+1>	;COUNT TM10B CONTROLLERS
	IFE	<M.MT'X'T-K.TC1>,<TC10C==TC10C+1>
	IFE	<M.MT'X'T-K.TX1>,<DX10N==DX10N+1>	;COUNT OF DX10 CHLS
	IFE	<M.MT'X'T-K.TM2>,<TM02N==TM02N+1>
	IFE	<M.MT'X'T-K.DX2>,<DX20N==DX20N+1>
	XP	MT'X'N,M.MT'X	;# OF UNITS / CONTROLLER
>
IFN FTAUTC,<
TM02N==1
DX20N==1
>
>
TC10C==0
TM10A==0	;INIT VALUES
TM10B==0
DX10N==0
TM02N==0
DX20N==0

	KONMAC			;PERFORM GOOD STUFF

>	;;; END IFG TAPN

IFNDEF TM10A,<TM10A==0>
IFNDEF TM10B,<TM10B==0>
IFNDEF DX10N,<DX10N==0>
IFNDEF TC10C,<TC10C==0>
IFNDEF TM02N,<TM02N==0>
IFNDEF DX20N,<DX20N==0>
XP PTYN,M.PTY

XP SYSCN,M.SYSC
XP LOKN,M.LOK
XP CMNN,M.MGC
XP RTTRPN,M.RTD
XP HPQN,M.HPQ

IFNDEF M.TTDN,<M.TTDN==:0>
XP M.TLTL,M.TLTL+M.TTDN		;REDEFINE FOR RSX-20F LINES
XP M.TLTL,M.TLTL+M.XTL		;REDEFINE FOR XTC LINES
ifn FtCImp,<			;[arpa]
xp m.TLTL,m.TLTL+ITYN		;[arpa] IMP terminal lines are local
>				;[arpa]
XP TTD28N,M.XTL
IFN M.KS10,<
XP	KLILIN,M.TLTL+M.RMCR	;LINE NO. FOR KS10 KLINIK
XP	M.TLTL,M.TLTL+1		;ADD ONE FOR KLINIK LINE
>
XP TCONLN,M.TLTL+M.RMCR+M.CPU	;LINE NUMBER FOR CTY (NOT ON SCANNER)

XP CTYLIN,TCONLN

	DEFINE	OPRL(LINE),<
IFIDN <LINE> <CTY>,<SIXBIT /CTY/>
IFDIF <LINE> <CTY>,<
	SIXBIT	/TTY'LINE/
	IFG LINE-M.TLTL,<PRINTX %OPR LINE NOT DEFINED TO BE A LOCAL TTY>
>;END IFDIF <LINE><CTY>
>
SUBTTL DEFAULT SYMBOLS
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERSEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE HDWGEN.MAC FILE USING THE MONGEN PROGRAM....
;**********************************************************************
;ADD NEW SYMBOLS AT END SO EASY TO UPDATE MONGEN APPENDIX	      *
;SYMBOLS SHOULD APPEAR HERE IN COMMON (AND NOT IN COMDEV, OR COMMOD)  *
; UNLESS THEY REFER TO NON-DISK DEVICES OR DISKS RESPECTIVELY.        *
; IF A SYMBOL IS IN COMDEV OR COMMOD, IT SHOULD NOT APPEAR HERE.      *
;**********************************************************************
IFNDEF XPANDN,<XP XPANDN,0>	;FORCE NO EXPANSION OF MACROS
				; UNLESS XPANDN IS DEFINED NON-ZERO WITH MONGEN

IFNDEF APRSN, <XP APRSN,0>	;SERIAL NUMBER OF ARITHMETIC PROCESSOR

				;STANDARD MAG TAPE DENSITY
IFNDEF STDENS, <XP STDENS,5>	;STANDARD = 6250 BPI
				;STDENS,D
				;D=1 (200 BPI), OR D=2 (556 BPI), OR D=3 (800 BPI)

				;NUMBER OF CLOCK TICKS (JIFFIES) PER SECOND
IFNDEF JIFSEC, <XP JIFSEC,M.TPS> ;STANDARD == 60 JIFFIES PER SECOND

XP JIFSC2,JIFSEC/2		;NUMBER OF JIFFIES IN A HALF SECOND (FOR ROUNDING)
XP JIFMIN,JIFSEC*^D60		;NUMBER OF JIFFIES PER MINUTE
JIF2SC==^D2*JIFSEC
IFN FTKI10!FTKL10,<

QQTTY1==:M.TPS/^D7		;SEVENTH SECOND FOR TTIOWS & PQ1(NON-CALASS SCHED)
>
IFN FTKS10,<
QQTTY1==:M.TPS/5		;FIFTH SECOND ON KS10
>
QQRUN1==:QQTTY1

				;NUMBER OF TIMES TO TRY ON DECTAPE ERRORS
IFNDEF DTTRY, <XP DTTRY,4>	;STANDARD == 4 TRIES

				;NUMBER OF NANO-SECONDS PER MEMORY CYCLE
IFNDEF NSPMEM, <XP NSPMEM,^D1000>	;STANDARD == 1000 NANO-SECONDS PER MEMORY CYCLE

IFNDEF TTXTRA <TTXTRA==0>	;NUMBER OF EXTRA TTY DDBS FOR SLAVE LINES
				; AND THE LIKE
IFN FTMBTS,<
IFNDEF CPYNAM,<XP CPYNAM,SIXBIT/CRSCPY/> ;DEFAULT NAME OF PROGRAM TO RUN TO
>					; DO AUTO CRASH COPY
;FREE CORE ALLOCATION REQUIREMENTS FOR DECNET RANDOM SIZED POOL.

ND DCNSIZ,30000			;CAN BE REDEFINED AT MONGEN TIME
XP DCNSIZ,<^D144*<<DCNSIZ+^D143>/^D144>>
;FREE CORE ALLOCATION REQUIREMENTS FOR DISK
; DEVICE DATA BLOCKS AND ACCESS TABLE ENTRIES.

XP CORSIZ,4		;NO. OF WORDS IN MONITOR FREE CORE BLOCKS
IFN DSKN,<
IFNDEF MINCOR, <XP MINCOR,JOBN*^D150> ;ASSUME 3 DDBS PER JOB
IFL MINCOR-6*^D140,<
XP MINCOR,6*^D140>>		; BUT PUT FLOOR UNDER MINCOR IF JOBN .LT. 6
IFNDEF LOGSIZ, <XP LOGSIZ,^D34>	;STANDARD == 17K (CURRENT SIZE OF LOGIN CUSP)
				;MINIMUM AMOUNT OF VIRTUAL CORE WHICH CAN REMAIN AND
				; STILL LET THE SYSTEM PERMIT LOG-INS.  MUST BE
				; AT LEAST AS BIG AS LOGIN CUSP IN K.
XP BLKSPK,^D3			;# OF PLACES TO SHIFT LEFT TO CONVERT BLOCKS TO K
XP MBKSPK,-BLKSPK		;# OF PLACES TO SHIFT RIGHT TO CONVERT K TO BLOCKS
XP MAXLVL,5			;ABSOLUTE MAX LEVEL OF NESTED SFD'S

IFNDEF INDPPN,<XP INDPPN,0>	;NON-ZERO IF CUSTOMER WANTS PROGRAMMER NOS
				; IN PROJECT X TO BE INDEPENDENT OF THOSE IN PROJECT Y

IF1,<
IFNDEF SYSSEG,<XP SYSSEG,-1>	;MINUS ONE FOR FAST GETSEG FROM SYS
				; WITH SOMEWHAT DIFFERENT BEHAVIOR
				; WHEN SHR FILES ARE SUPERCEDED
IFDEF	SYSSEG,<IFN	<SYSSEG+1>,<XP SYSSEG,0>>
XP SYSSEG,SS.SYS&SYSSEG		;SYSSEG=:0 OR SS.SYS
>
IFN M.KL10!M.KS10,<
IFNDEF CTYDCR,<XP CTYDCR,0>	;DELAY FOR CR ON LA36 CTY DURING ONCE
IFNDEF CTYDLF,<XP CTYDLF,0>	;DELAY FOR LF ON LA36 CTY DURING ONCE
>

IFNDEF CTYDCR,<XP CTYDCR,^D18>	;DELAY FOR CR ON CTY DURING ONCE
IFNDEF CTYDLF,<XP CTYDLF,^D8>	;DELAY FOR LF ON CTY DURING ONCE
IFNDEF RLDTIM,<XP RLDTIM,^D112>  ;TIME TO AUTO-RELOAD
IFNDEF M.STOF,<XP M.STOF,0>	;FREQUENCY TO CALL START TERMINAL OUTPUT (SHOULD BE2**N-1)
IFNDEF	MINMAX,<XP MINMAX,^D1024*^D12> ;SMALLEST LEGAL CORMAX
;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA MONGEN.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.

;MOST OF THE SLAVE PROCESSOR CHANNELS ARE BUSIED OUT TO PREVENT CORE
;FROM BEING WASTED FOR CHANNEL SAVE ROUTINES

IFNDEF CPTOS,<XP CPTOS,0>	;CPTOS EQUAL TO ZERO MAKES CPU0 TRAP TO 40-61, CPU1 TO 140-161
				;CPTOS NON-ZERO MAKES CPU0 TRAP TO 140-161, CPU1 TO 40-61

IFNDEF SFC0,<XP	SFC0,^D20>	;CPU0 SCHEDULER FAIRNESS COUNT.  PICK A JOB OUT OF
				;PQ2 INSTEAD OF PQ1 IF 'SFC0' PICKS IN A ROW HAVE COME FROM PQ1 AND NULL JOB DID NOT RUN.

IFNDEF SFC1,<XP	SFC1,^D20>	;CPU1 SCHEDULER FAIRNESS COUNT
				;PICK THIS MANY JOBS TO RUN ON CPU0.  WHICH
				; CAME FROM CPU1 UUOS BEFORE PICKING OTHER JOBS

IFNDEF IFC0,<XP IFC0,^D5>	;SWAPPER FAIRNESS COUNT MAXIMUM


IFNDEF UFC0,<XP	UFC0,^D10>	;UUO FAIRNESS COUNTER MAXIMUM

IFNDEF UFC1,<XP	UFC1,^D10>	;UUO FAIRNESS COUNTER FOR SLAVE
				;PICK UFC1 JOBS TO RUN ON CPU1
				;WHICH CAME FROM CPU0 AND JUST FINISHED
				;A UUO
IFNDEF MEMITL,<XP MEMITL,^D4>	;NUMBER OF WAYS MEMORY CAN BE INTERLEAVED
IFNDEF	MLACTS,<XP MLACTS,^D39>  ;MAXIMUM LENGTH OF THE ACCOUNT STRING
				; IF NOT DEFINED, 39 CHARACTERS
IFNDEF SCHEDN,<SCHEDN==0>	;SCHEDULE VALUE
SCHEDN==SCHEDN&777777		;ONLY A RIGHT HALF NUMBER
IFNDEF	PAVJSP,<XP PAVJSP,^D20>	;PREDICTED AVERAGE JOB SIZE
IFG	MLACTS-^D39,<XP MLACTS,^D39>  ;MAXIMUM LENGTH IS 39 CHARACTERS
IFL	MLACTS,<XP MLACTS,0>
IFG	MLACTS,<XP ACTSTL, MLACTS/^D5+1> ;LENGTH OF ACCOUNT STRING IN WORDS
IFE	MLACTS,<XP ACTSTL,0>
XP MACTSL,-ACTSTL
XP MAXACS,^D8		;MAX LENGTH OF ACCOUNT STRING
IFNDEF M.CBAT,<XP M.CBAT,^D10>	;NO. OF BAD ADDRESSES IN PER CPU BAD
				; ADDRESS TABLE FOR MEMORY PARITY RECORDING
IFNDEF M.BMAX,<XP M.BMAX,^D13>	;MAX. NO. OF SIMULTANEOUS BATCH JOB STREAM'S
				; INITIATES LOC BATMAX, CHECKED BY BATCON
IFNDEF M.BMIN,<XP M.BMIN,0>	;MIN. NO. OF GUARRANTEED BATCH JOBS
IFNDEF M.EXE,<XP M.EXE,1>	;SYMBOL WHICH DETERMINES TYPE OF FILE
				; CREATED ON "SAVE".  IF OFF, NORMAL (SAV,HGH,
				; LOW,..), IF ON AN EXE FILE IS CREATED
IFNDEF M.JMAX,<XP M.JMAX,M.JOB-M.BMIN>	;MAX. NO. OF SIMULTANEOUS INTERACTIVE JOBS
IFNDEF M.WCH,<XP M.WCH,JW.WMT>	;WATCH BITS USED TO SET INITIAL
				; WATCHING. SINCE LOGIN SETS JBTWCH
				; THIS IS USEFUL ONLY FOR LINES WHICH
				; DON'T NEED LOGIN - INITIA.
				;200000 = TIME OF DAY STARTED TO WAIT
				;100000 = RUN TIME
				;40000 = WAIT TIME
				;20000 = BLOCKS READ
				;10000 = BLOCKS WRITTEN
				;4000 = VERSION NOS.
				;2000 = MTA STATISTICS
IFNDEF M.CMCT,<XP M.CMCT,^D32>	;NO. OF CALLS TO CHKTAL ROUTINE
				; BEFORE DOING 5 M.S. OF OVERHEAD
				; CHECKING CORE TABLES. I.E. ONLY
				; EVERY 32 TIME IS OVERHEAD PERFORMED
				;THIS REDUCES CPU TIME FOR
				; CORE, GETSEG, RUN UUOS
				; SYMBOL CANNOT EXCEED 262,000.
IFNDEF M.EBPS,<XP M.EBPS,^D12500000> ;DEFAULT # EBOX TICKS PER SECOND
					  ; (ACCT METER COUNTS AT 1/2 SYSTEM CLOCK RATE)
					  ; SYSTEM CLOCK RATE IS 25MHZ

IFNDEF M.MBPS,<XP M.MBPS,^D9750000> ;DEFAULT MBOX REFS/SECOND
				     ; THIS NUMBER WAS EXPERIMENTALLY
				     ; DETERMINED AT A CPU CLOCK RATE
				     ; OF 25MHZ SUCH THAT THE CPU TIME
				     ; OF A JRST . MATCHED ELAPSED TIME.
				     ; JRST . WAS ASSUMED TO BE A BEST CASE CONDITION.

				     ; THIS TERM MAKES EBOX/MBOX RUNTIME
				     ; PER REAL TIME UNIT DEPENDENT ON
				     ; CACHE HIT RATE, ALTHOUGH INSTRUCTIONS
				     ; PER E/MBOX RUNTIME UNIT SHOULD REMAIN CONSTANT.

IFNDEF M.EMRT,<XP M.EMRT,0>		;DEFAULT IS REGULAR RUNTIME
IFNDEF M.XPI,<XP M.XPI,0>		;AND INCLUDE PI TIME IN USER RUNTIME
IFNDEF M.ITA,<XP M.ITA,0>		;DEFAULT IS TO USE INTERVAL TIMER
IFE	LOKN,<XP EVBN,^D256-RHWEVM-PAGTBL-MEMTBL>	;NUMBER OF HALF WORDS IN THE EXEC MAP
IFN	LOKN,<IFNDEF EVBN,<XP EVBN,^D128>>	; AVAILABLE FOR MAPPING BUFFERS AND IOWDS
IFL EVBN-PAGTBL-MEMTBL,<XP EVBN,PAGTBL+MEMTBL>
IFL ^D256-EVBN-RHWEVM,<PRINTX<EVBN DEFINE TOO LARGE>
	XP	EVBN,^D256-RHWEVM
>
XP EVLN,^D256-RHWEVM-EVBN		;NUMBER OF HALF WORDS IN THE EXEC MAP AVAILABLE
				; FOR LOCKING IN EVM
IFNDEF M.XFFA,<XP M.XFFA,1>	;DO FILE ACCESS PROTACTION CHECKING ON [1,2] AND JACCT

IFN FTNSCHED,<
	ND	M.CLSN,^D16	;DEFAULT NUMBER OF CPU CLASSES FOR SCHEDULER
	ND	M.CLSS,1	;DEFAULT SCHEDULER IS CLASS SYSTEM SCHEDULER.
				; IF THIS MONGEN SYMBOL IS DEFINED
				; TO BE ZERO, THEN THE SCHEDULER WILL
				; RUN IN WMU MODE.

	ND	M.DCLS,0	;DEFAULT SCHEDULER CLASS FOR NEW JOBS.
				; CAN OBTAIN THIS FROM GETTAB OR SCHED UUO
IFG M.DCLS-M.CLSN,<PRINTX VALUE OF M.DCLS EXCEEDS M.CLSN.
			M.DCLS==M.CLSN-1>

>;END IFN FTNSCHED
IFE FTNSCHED,<
	ND	M.CLSN,1
	ND	M.CLSS,0
	ND	M.DCLS,0
	XP	SCHED.,CPOPJ	;NO SCHED. UUO
>;END IFE FTNSCHED

IFN FTKL10,<
IFNDEF TTDMOS,< XP TTDMOS,^D16>	;MAXIMUM OUTPUT STRING
				; DEFINES THE NUMBER OF CHARACTERS THAT CAN
				; BE SENT TO -20F IN A SINGLE BUFFER
>  ;END OF FTKL10

IFNDEF HIGHXC,<XP HIGHXC,^D80>	;HIGHEST EXTENDED CHANNEL
IFG HIGHXC-^D512,<PRINTX HIGHEST EXTENDED CHANNEL IS GREATER THAN 512
	PRINTX	REDUCING IT TO 512
	XP	HIGHXC,^D512>

IFNDEF MAXNBP,<XP MAXNBP,^D64>	;MAXIMUM NUMBER OF SNOOP UUO
				; BREAK POINTS ALLOWED
IFNDEF M.OMSM,<XP M.OMSM,^D60>	;NUMBER OF MINUTES BETWEEN CALLS
				; TO BIGBEN TO TYPEOUT MONITOR NAME,
				; UPTIME, AND DATE/TIME
				;SET TO <-1>_-1 TO NEVER PRINT
IFNDEF	M.DTLS,<XP M.DTLS,^D90>	;CPU TIME LIMIT (SECONDS) TO SET
				; ON A FORCED DETACH (.BYE) COMMAND
IFNDEF	LIM1MS,<XP LIM1MS,4>	;LIMIT OF STOPCD'S IN ANY 1 MINUTE PERIOD
IFNDEF	LIM8MS,<XP LIM8MS,7>	;LIMIT OF STOPCD'S IN ANY 8 MINUTE PERIOD
IFNDEF	LIM1HS,<XP LIM1HS,^D30>	;LIMIT OF STOPCD'S IN ANY 1 HOUR PERIOD
IFN M.EQDQ,<
IFNDEF	M.ENQD,<XP M.ENQD,EQDFEQ##>;DEFAULT ENQ QUOTA
IFNDEF	M.ENQM,<XP M.ENQM,EQMXAQ##>;MAXIMUM NUMBER OF ACTIVE QUEUES
> ;END IFN M.EQDQ
;THESE SYMBOLS DEFINE THE VALUES OF VERSION FROM MONGEN

AXXWHO==2
IFNDEF	A00CVN,<IFNDEF A00CLH,<AXXWHO=0>>
ND	A00CVN,0		;CUSTOMER VERSION NUMBER (36-BITS)
ND	A00MVN,702		;MAJOR VERSION OF MONITOR--UPDATED AT
				;  START OF DEVELOPMENT CYCLE (9-BITS)
ND	A00SVN,0		;SOUP NUMBER--UPDATED AT START
				;  OF EACH SOUP DEVELOPMENT CYCLE (6-BITS)
ND	A00MCO,^D11095		;HIGHEST MCO IN THIS LOAD (26-BITS)
ND	A00CLH,0		;CUSTOMER LH (%CNVER) (18-BITS)
ND	A00DLN,0		;DEC LOAD NUMBER (6-BITS)
				; SET TO ZERO FOR ANY RELEASE, ELSE
				; 1-7 IF SOUP, 10-77 IF DEVELOPMENT
ND	A00WHO,AXXWHO		;DEC LAST EDITED (3-BITS)

AXXVER==< BYTE (18) A00CLH (12) A00MVN-IFE A00SVN,<IFN A00DLN,<1>> (6) IFE A00SVN,<A00DLN>>

ND	A00VER,AXXVER		;DEFINES %CNVER

AXXDVN== BYTE (3) A00WHO (9) A00MVN (6) A00SVN (18) A00MCO

;DEFINE CNFDAE TO BE THE SIXBIT NAME OF THE MONITOR VERSION
;IN THE LEFT HALF, AND THE BINARY MONITOR VERISON IN THE RIGHT
;HALF. THE SYMBOL BECOMES THE VALUE OF THE %CNDAE GETTAB WHICH
;DAEMON (AND OTHER PROGRAMS) USES TO DETERMINE IF IT IS COMPATIBLE
;WITH THIS MONITOR. IF THE PROGRAM DECIDES IT ISN'T COMPATIBLE
;BY RANGE CHECKING THE RIGHT HALF, IT WILL USE THE LEFT HALF TO
;DETERMINE THE NAME OF THE PROGRAM TO RUN.
DEFINE ..CNFD(VERSION),<XWD SIXBIT \   VERSION\,VERSION>
CNFDAE==..CNFD(\A00MVN)


;DEFINE DEFAULT VALUE OF DEBUGF TO STOP ON STOPCD'S DURING FIELD-TEST,
; BUT NOT TO STOP IN RELEASED VERSIONS OF MONITOR.
IFNDEF DEFDEB,<DEFDEB==0+IFN A00DLN,<IFE M.MBTS,<320000000000>>>

; DEFINE DEFAULT CPU MASK FOR EDDT.  THIS MASK INDICATES WHICH CPUS
; MAY ENTER EDDT VIA THE UNSOLICITED BREAKPOINT FACILITY.
	ZZ==<1+<ZZZ==-1>>
	REPEAT CPUN,<ZZ==<ZZ!<DF.BP0_-<ZZZ==ZZZ+1>>>>
IFNDEF DEFBPT,<DEFBPT==ZZ>

IFNDEF BPTBIT,<XP BPTBIT,0>	;VALUE OF JS.BPT FOR NEW JOBS
;ADD NEW MONGEN SYMBOLS HERE (SEE ALSO COMDEV FOR MONGEN SYMBOLS)
SUBTTL COMPUTE SPECIAL SYMBOLS
;DEFINE PARAMETERS THAT SPECIFY SIZE OF CORTAB, NUMBER OF BITS PER
;ENTRY, AND BYTE POINTERS FOR CORE ALLOCATION ROUTINES


CTNBPE==1	;NUMBER OF BITS PER ENTRY IN CORTAB
		;MUST EVENLY DIVIDE 36 AND BE 1 OR A POWER OF TWO
CTNMCI==:1	;PUT THIS IN CORTAB TO INDICATE A BLOCK IN USE BY MONITOR
CTNXMI==:3	;PUT THIS IN CORTAB TO INDICATE A BLOCK OF NON-EXISTANT MEMORY


IFN FTLOCK,<IFN LOKN,<
CTNBPE==2	;NEED TWO BITS PER ENTRY TO MINIMIZE FRAGMENTATION IF LOCK UUO
CTNMCI==:2	;INDICATES CORE IN USE BY MONITOR,LOCKED JOB OR NON-EXISTANT
>
>
CTNBPW==:^D36/CTNBPE
		;NUMBER OF BYTES/WORD
CTNBPE==0	;0 BITS PER ENTRY IF KI10 (SINCE TABLE DOESN'T EXIST)
CTNBPW==:0

Z1==0
Z2==CTNBPE

;	XLIST
REPEAT Z2/2,<
Z2==Z2/2
IFN Z2,<Z1==Z1+1>
>
;	LIST

CTNBSA==:Z1	;THE LARGEST POWER OF TWO IN CTNBPE
;PERFORM TRANSLATION FROM HARDWARE TO SOFTWARE DESIGNATION
; FOR ALL DISK SYMBOLS

IFN DSKN,<
	FHDN==RD10N
	FSDN==RH10NS
	RPXN==RH10NP
	RNXN==RN10N
	DPCN==RP10N
	MDFN==RA10N
	RHXN==RH11NP
>
IFE DSKN, <
	FHDN==0
	FSDN==0
	RPXN==0
	RNXN==0
	DPCN==0
	MDFN==0
	RHXN==0
>

ALLKON==:FHDN+FSDN+RPXN+RNXN+DPCN+MDFN+TM10B+TC10C+TM02N  ;ALLKON = THE TOTAL # OF KONTROLLERS IN THE SYSTEM
				; IF YOU ADD ANOTHER KONTROLLER TYPE YOU MUST
				; INCLUDE THE # OF KONTROLLERS OF THAT TYPE HERE

;DEFINE THE PARAMETERS WHICH CONTROL THE TYPE OF SYSTEM

XP FTDISK,-DSKN			;10/40D OR 10/50S
XP FTSWAP,-SYS50N		;10/50S
XP FTLOGIN,-DSKN		;PUT FTLOGIN IN SO LOADER WILL COMPLAIN
				; IF DIFFERENT IN OTHER FILES

SEGN=JOBN+SEGN

IFN M.KL10,<
	;SYMBOLS SPECIAL TO KL10

XP EBCPT,10000		;KL10 EBOX CLOCK DOES THIS MANY COUNTS PER EBOX TICK
XP MBCPT,10000		; MBOX CLOCK DOES THIS MANY COUNTS PER MBOX TICK
>;END IFN M.KL10
SUBTTL ABSOLUTE LOCATIONS IN LOWER MEMORY

	CURJOB=:20		;LH=SLAVE CURRENT JOB NO.
				;RH=MASTER CURRENT JOB NO.
				;OPERATOR SETS SWITCHES TO FOLLOW ON MASTER
				;MASTER AND SLAVE REFERENCE THIS EACH CLOCK TICK.
	CLKDDT=:21		;JUMP TO EDDT IF DEBUG SET AND THIS NON-ZERO
	BOOTSA==:21		;PHYSICAL ADDRESS OF BOOTS DATA PAGE
	BOOTWD=:22		;CHANNEL ADR. PAIR FOR BOOTS (LEVEL D BOOTS STRAP)
	BOOTCL==22
	CRSDTM=:24		;CRASH DATE,,TIME(SECS)
	CRSWHY=:25		;CRASH CHECKSUM (24+25),,REASON(S..XXX)
	CPNDDT=:27		;SET NON-ZERO IF WE HIT A DDT BREAKPOINT.
				;CAUSES ALL OTHER CPU'S TO LOOP IN THE AC'S
				;UNTIL THIS WORD IS CLEARED AGAIN.
	CRSHWD=:30		;NORMALLY THIS WORD WILL BE 0.  IF IT IS ACCIDENTALLY
				; OR PURPOSEFULLY OVERWRITTEN THE MONITOR WILL
				; ATTEMPT TO SAVE THE AC'S AND THE STATE OF
				; ALL DEVICES, THEN HALT.   [A LA 407 RESTART]

	;WORDS 31-35 ARE SPECIAL LOCATIONS FOR THE KS10 SYSTEM
	;SEE S.MAC FOR DEFINITIONS

	CRSSTS=:36		;RH = CONTENTS OF THE STATES WORD AS
				; SET BY THE OPR. RESTORED UPON AUTO-RELOAD
				; AFTER A CRASH.
	SYSSNP=:37		;WHEN DEPOSITED NON-ZERO, PRINTS SNAP SHOT OF SYSTEM
				; ON LPT (SEE MOVIE SUBPROGRAM)
	FORTY=:40		;PLACE WHERE UUOS ARE STORED ON TRAP
	SIXTY=:60		;PLACE WHERE UNIMPLEMENTED INSTRUCTIONS ARE
				; STORED ON TRAP (PDP10 ONLY)
	ARSLOC=:70		;POWER FAIL RESTART LOCATION

IFN M.KS10!M.KL10,<
	KAFLOC=:71		;KEEP ALIVE FAILURE RESTART LOCATION
	WRSINS=:WRSINS		;WARM RESTART LOCATION
>
	LIGHTS=:77		;DUMP PERFORMANCE DATA HERE (METER UUO)
				; FOR SAMPLING WITH PROBES
;DATA STARTING AT 140:

IFN M.KL10!M.KS10,<
	LOC	41
	JSR	LUUOPC
	LOC	ARSLOC
	HALT	.
	LOC	KAFLOC
	HALT	.
IFN M.KL10,<
	LOC	WRSINS
	HALT	.
>
>

;SET JOBVER TO SYSTEM VERSION

	LOC	136
	A00CVN			;(136) CUSTOMER
	AXXDVN			;(137) DEC


	COMORG=140		;ORIGIN OF COMMON IS 140
	LOC	COMORG		;MAKE LISTING BE SAME AS LOADING SO IT WILL BE EASY
				; TO EXAMINE SYSTEM LOCATIONS WITH CONSOLE SWITCHES
				; WITHOUT NEEDING A STORAGE MAP

	SYSDSP=:400		;FIRST STARTING LOCATION OF MONITOR
;
;With all respect to DEC, but, this code occupies memory that
;we need, more than anything else... peter l|thberg 870128
;
;LOWER CORE FROM 140 UP THRU 410 (START LOCATIONS):
;ASCIZ /THIS SOFTWARE IS FURNISHED UNDER LICENSE AND MAY ONLY BE USED
;OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1984 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS./

SUBTTL	EXECUTIVE PROCESS TABLE(S)

	DEFINE	EPT(X,N,M,CPUN)<

.E'N'MP==:X
.E'N'OFS==:.E'N'MP-.EPMP
.E'N'2OF==:2*.E'N'OFS

	LOC	.E'N'MP+0	;WHERE EXEC PROCESS TABLE (FORMERLY
				; EXEC PAGE MAP PAGE) IS

IFN M.KL10,<
	BLOCK	40		;LOGOUT AREAS FOR RH20'S
>;END IFN M.KL10

	LOC	.E'N'MP+40
.E'N'IL::
IFE M.KL10,<
	BLOCK	1	;WHERE LOCAL UUO'S GO
>
IFN M.KL10,<
	IOP		;CAUSE AN IOP STOPCD IF A DEVICE INTERRUPTS TO 40
>
IFDIF <N><P>,<
	JSR	LUUOPC		;LUUO HANDLER
ZZ==10*CPUN
REPEAT 7,<
ZZ==ZZ+1
	INTINS	\ZZ		;NON-VECTORED INTERRUPT LOCATIONS
>
>;END IFDIF

IFN M.KL10,<
	LOC	.E'N'MP+60
;RH2ZRO::
	0			;LOCS USED BY RH20 FOR ZERO-FILL
	0
	0
	0
>;END IFN M.KL10

IFN M.KS10,<
	LOC	.E'N'MP+101
.E'N'VIT::			;POINTERS TO UBA INTERRUPT VECTOR TABLES
	VECTB1
	0
	VECTB3
	0
>;END IFN M.KS10

IFN M.KL10,<
	LOC	.E'N'MP+140	;START OF DTE0 HARDWARE LOCATIONS
DT'M'EBP::BLOCK	1		;TO 11 BYTE POINTER
DT'M'TBP::BLOCK	1		;TO 10 BYTE POINTER
DT'M'II::BLOCK	1		;DTE0 INTERRUPT INSTRUCTION
DT'M'UNS::BLOCK	1		;UNUSED LOCATION
DT'M'EPW::BLOCK	1		;EXAMINE PROTECTION WORD
DT'M'ERW::BLOCK	1		;EXAMINE RELOCATION WORD
DT'M'DPW::BLOCK	1		;DEPOSIT PROTECTION WORD
DT'M'DRW::BLOCK	1		;DEPOSIT RELOCATION WORD
>;END IFN M.KL10

	LOC	.E'N'MP+200
.E'N'PM::			;EXEC PAGE MAP FOR EXEC VIRTUAL ADDRESSES
				; 400000 AND UP

.EPRPM==:200
;GENERATE 1:1 MAP FOR UPPER EXEC 128K

	XLIST
	REPEAT	^D128,<0>	;ZEROS SO WILL IME IF USED BEFORE SET UP
	LIST

IFN M.KI10,<
	LOC	.E'N'MP+420	;PAGE FAIL TRAP
IFDIF <N><P>,<
	EXP	SEILM##		; ..
>
>;END IFN M.KI10

	LOC	.E'N'MP+421	;EXEC TRAPS

.E'N'AOV:	JFCL		;ARITHMETIC TRAP
IFDIF <N><P>,<
	EXP	SEPDLO##	;PUSH DOWN OVERFLOW TRAP
>
	LOC	.E'N'MP+423
	JSR	TRP3PC		;TRAP 3 TRAP
IFN M.KS10,<
.E'N'HSB:	BLOCK	^D18	;HALT STATUS BLOCK AREA
>
IFN M.KL10,<
.E'N'RH1:	BLOCK	4	;HALT STATUS AREA (OBSOLETE?)


	LOC	.E'N'MP+440	;DTE AREA

.E'N'STD:
IFDIF <N><P>,<
	JRST	DEBUG##	;DIAGNOSTIC START
>
	LOC	.E'N'MP+441
.E'N'DDT:	XCT	SYSDDT	;DDT START
.E'N'STL:	XCT	SYSCRH	;LOADER START ADDRESS (BOOTS)
.E'N'STM:	XCT	SYSDSP	;START MONITOR

DT'M'DBG::			;START OF DTE COMMUNICATIONS AREA
DT'M'FLG::	0
DT'M'CLK::	0
DT'M'CI::	0
DT'M'T11::	0
DT'M'F11::	0
DT'M'CMD::	0
DT'M'SEQ::	0
DT'M'OPR::	0
DT'M'CC::	0
DT'M'MTD::	0
DT'M'MTI::
DT'M'DND::	0		;END OF DTE DATA CLEARED AT SYSINI


	LOC	.E'N'MP+507
.E'N'R1E:	BLOCK	1	;LAST WORD OF FIRST HARDWARE RESERVED REGION
.E'N'HTB::BLOCK	1		;HIGH ORDER TIME BASE WORD
.E'N'LTB::BLOCK	1		;LOW ORDER TIME BASE WORD
.E'N'HPA::BLOCK	1		;HIGH ORDER PERFORMANCE COUNTER WORD
.E'N'LPA::BLOCK	1		;LOW ORDER PERFORMANCE COUNTER WORD
.E'N'TII::
IFE FTKLP,<
	JSR	TM'M'INT	;INTERVAL TIMER VECTOR INTERRUPT INSTRUCTION
>
IFN FTKLP,<
	XPCW	TM'M'INT
>
.E'N'RH2:			;START OF 2ND RESERVED FOR HARDWARE AREA

	LOC	.E'N'MP+577
.E'N'R2E:	BLOCK	1	;LAST LOC OF 2ND RESERVED FOR HARDWARE AREA
>;END IFN M.KL10

IFN M.KL10!M.KS10,<
	LOC	.E'N'MP+600
.E'N'LM::			;PAGE MAP FOR LOWER 112K OF EXEC SPACE

;GENERATE 1:1 MAP FOR LOWER EXEC 112K

	ZZ==0
IFE <M.CPU-1>,<
	ZZ=ZZ+PM.CSH
>
IFN M.KS10,<
	ZZ==0			;UNCACHE PAGE ZERO ON KS
>
IFN FTKLP,<
DEFINE	ONE41,<
	EXP	0
>
>
	ONE41
IFN M.KS10,<
	ZZ==ZZ+PM.CSH
>
	XLIST
	REPEAT	^D111,<ONE41>
	LIST
IFN FTKLP,<
	LOC	.E'N'MP+540
.E'N'STB::
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
	EXP	<PM.DCD>B2+PM.WRT+PM.CSH+.E'N'MAP/PAGSIZ
	BLOCK	^D30
>

IFN M.KL10,<
	LOC	.E'N'MP+760
.E'N'RCU:			;RESERVED FOR CHANNEL USE
>;END IFN M.KL10
	LOC	.E'N'MP+777
>;END IFN M.KL10!M.KS10

.E'N'MPE::			;LAST LOCATION IN EPT
.E'N'ND==.
E'N'MPA==<.E'N'MP/1000>
IFE FTKLP,<
.E'N'MAP==:.E'N'MP
>
IFN FTKLP,<
	LOC	.E'N'MP+1000
.E'N'MAP::
DEFINE ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+<IFE <M.CPU-1>,<PM.CSH>>+ZZ
	ZZ==ZZ+1
>
	ZZ==0
	XLIST
	REPEAT	^D224,<ONE41>
	LIST
DEFINE	ONE41,<
	EXP	<PM.ICD>B2+PM.WRT+PM.CSH+<ZZ+340>B17+0
	ZZ==ZZ+1
>
	ZZ==0
	XLIST
	REPEAT	^D32,<ONE41>
	LIST
	LOC	.E'N'MAP+777
>;END IFN FTKLP
>;END DEFINE EPT
DEFINE ONE41,<
	XWD	PM.ACC+PM.WRT+ZZ,PM.ACC+PM.WRT+ZZ+1
	ZZ==ZZ+2
>

DEFINE	INTINS(X)<
IFE FTKLP,<
	JSR	CH'X
>
IFN FTKLP,<
	XPCW	CH'X
>
IFE FTKL10,<
	JSR	PIERR##
>
IFN FTKL10,<
	IOP
>>

IFN FTKL10,<
XP TMEINT,TM0INT
>

;NOW GENERATE EPT'S

IFN M.KI10!M.KS10,<
	.EPMP==:0
>

IFN M.KL10,<
	.EPMP==:1000
>
IFN XPANDN,<LALL>

	EPT(.EPMP,P,E,0)	;GENERATE TRADITIONAL SYMBOLS

ZZ1==0
ZZ2==.EPMP
NLUPMP==:.EPMP

REPEAT M.CPU,<
	NLUPMP==:NLUPMP+1000
	IFN M.KS10,<NLUPMP==:NLUPMP+1000>	;RESERVE PAGE 1 FOR FE
	EPT(ZZ2,\ZZ1,\ZZ1,ZZ1)
	ZZ1==ZZ1+1
	ZZ2==ZZ2+1000
IFN FTKLP,<
	ZZ2==ZZ2+1000
	NLUPMP==:NLUPMP+1000
>
>

;REDEFINE ONE41 FOR GENERATION OF THE NULL JOB'S MAP

IFE FTKLP,<
DEFINE ONE41,<
	XWD	PM.ACC+PM.WRT+ZZ,PM.ACC+PM.WRT+ZZ+1
	ZZ==ZZ+2
>
>
IFN FTKLP,<
DEFINE ONE41,<
	EXP	<PM.DCD>B2+PM.WRT+ZZ
	ZZ==ZZ+1
>
>
SUBTTL	SOME DEFINITIONS FOR KI10'S
IFN M.KI10,<
	LOC	.EPMPE
;NULL JOB DUMP AC AREA:

DEFINE NULDAC(N)<
NU'N'DAC::BLOCK	20
	XP NU'N'DAT,NU'N'DAC-20
>
ZZ==0
REPEAT M.CPU,<
	NULDAC(\ZZ)
ZZ==ZZ+1
>


;LOWER CORE CHANNEL PAIRS FOR EACH CONTROLLER IN SYSTEM

IFN ./2*2-.,<0>			;MAKE SURE DF10 LOCATIONS START IN AN EVEN LOC.
				; IN LOW CORE (LESS 1000)
LOCOCW::
IFE FTAUTC,<
BLOCK	ALLKON*4		;CHANNEL ADR PAIRS FOR ALL CONTROLLERS IN SYSTEM.
				;ICWA+3:JSR XXX'VIN
>
IFN FTAUTC,<
	BLOCK	3*4*CPUN	;SINCE MAXIMUM OF 3 RH10S PER CPU
>
				; EVEN IF ON THE SAME DF10 CHANNEL.
LOCODW::
IFE FTAUTC,<
BLOCK	4*DX10N		;4 WORDS EACH DX10
>
IFN FTAUTC,<
	BLOCK	4*2*CPUN	;MAX OF 2 DXS PER CPU
>

ERPDLL==40
ERRPLL==:-ERPDLL+1
DEFINE PDLDEF(N)<
IFE N,<
ERRPDL::
>
ER'N'PDL::
	BLOCK	ERPDLL
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>
;FREE CORE FOR 4 WORD BLOCKS:

XP FREORG,<<.-1>/4*4+4>		;MAKE ORIGIN OF FREE LOW CORE AN EVEN MULTIPLE OF 4.
	LOC	FREORG

>;END M.KI10
SUBTTL INITIALIZATION DISPATCH TABLE, STARTING AT LOCATION 400
;ROUTINE "ONCE" IS ONCE ONLY CODE. IT CONVERTS THE DATE
;AND SETS UP I/O SERVICE CHAIN,


	LOC	SYSDSP		;ORIGIN START LOCATIONS TO 400

SYSDSP::

	JRST	SYSTRT		;(400) INITIALIZE SYSTEM VARIABLES IF CPU0
SYSDDT::IFG	DDTN, <		;IF EXEC DDT IS LOADED.....
	JRST	PATSYM##	;(401) PATCH SYMBOL TABLE POINTER, THEN ENTER EXEC DDT
>
IFE	DDTN, <
	JFCL
>
	HALT	.		;(402)
	HALT	.		;(403)
	JRST	STPALL		;(404) SET CRSHWD TO -1 AND DO A 406
				;  START TO STOP ALL OTHER CPU'S AND
				;  GET TO BOOTS.  MOSTLY FOR DEBUGGING.
	JRST	STPCPU		;(405) STARTING THE BOOT CPU AT 405 IS THE SAME
				;  AS A 407 START.  ON ALL OTHER CPUS, A 405
				;  START WILL CAUSE THE CPU TO SAVE THE
				;  MACHINE STATE AND JUMP INTO THE AC'S UNTIL
				;  MANUALLY RESTARTED THROUGH 400.
	JRST	STPLDB		;(406) SET SR.LBH IN .CPSBR AND DO A 407
				;  START TO FORCE BOOTS TO BE LOADED ON
				;  THIS CPU REGARDLESS OF WHO IS THE BOOT
				;  CPU NOW
SYSCRH:	JRST	SYSTOP		;(407) MONITOR CRASH AND RELOAD LOCATION

;START ABSOLUTE LOCATIONS HER TO BE PUBLISHED FOR USERS( UP TO 417)


ABSTAB::EXP	NUMTAB##	;(410) ABSOLUTE LOCATION OF GETAB TABLE TABLE.
				; USED TO BE LOC 151. NEEDED TO DO GETTAB UUO
				; SIMULATION ON A CRASHED MONITOR.
MBTCOM::EXP	0		;(411) ABSOLUTE LOCATION USED FOR MONBTS COMMUNICATION
UCDSIZ::EXP	0		;(412) XWD NUMBER PAGES,NUMBER BYTES IN THE DX20/RP20
				;      MICROCODE STORED IN MEMORY
UCDADR::EXP	0		;(413) PHYSICAL ADDRESS OF THE START OF THE DX20/RP20
				;      MICROCODE STORED IN MEMORY.  IF THIS WORD IS
				;      ZERO, THERE IS NO MICROCODE LOADED REGARDLESS
				;      OF THE VALUE OF UCDSIZ.
				;(417) CUSTOMER'S WORD
	LOC	420		;SKIP RESERVED SPACE
SUBTTL	(NULL JOB AND) USER PROCESS TABLE(S)
IFN M.KI10,<			;DEFINE KI10 USER PAGE MAP PAGE
	LOC	NLUPMP
NUPPPM==:NLUPMP+400
	LOC	NUPPPM
	ZZ==340
	XLIST
	REPEAT	^D16,<ONE41>
	LIST
NUPPMT==:NLUPMP+420

	LOC	NUPPMT
;USER TRAPS
	EXP	SEILM##		;PAGE FAULT TRAP
	JFCL	SAROVF##	;ARITHMETIC TRAP
	EXP	SEPDLO##	;PUSH DOWN LIST OVERFLOW TRAP
	JFCL			;TRAP 3 TRAP

EXP	0			;MUUO STORED HERE
EXP	0			;MUUO PC STORED HERE
EXP	0			;EXEC PAGE FAIL WORD
EXP	0			;USER PAGE FAIL WORD
EXP	IC.UOU+MUUO		;KERNAL NO TRAP MUUO NEW PC
EXP	IC.UOU+KTUUO		;KERNAL TRAP MUUO NEW PC
EXP	IC.UOU+SNTUUO		;SUPERVISOR NO TRAP MUUO NEW PC
EXP	IC.UOU+STUUO		;SUPERVISOR TRAP MUUO NEW PC
EXP	IC.UOU+MUUO		;CONCEALED NO TRAP MUUO NEW PC
EXP	IC.UOU+CTUUO		;CONCEALED TRAP MUUO NEW PC
EXP	IC.UOU+MUUO		;PUBLIC NO TRAP MUUO NEW PC
EXP	IC.UOU+PTUUO		;PUBLIC TRAP MUUO NEW PC
NUPMPL==:.-NLUPMP
NULASW==NLUPMP+1000
	LOC	NULASW
> ;END KI10 CASE
IFN M.KL10!M.KS10,<			;DEFINE KL10/KS10 USER PROCESS TABLE
	LOC	NLUPMP

IFE FTKLP,<
NUPPPM==:NLUPMP+400
	LOC	NUPPPM
	ZZ==340
	XLIST
	REPEAT	^D16,<ONE41>
	LIST
>
IFN FTKLP,<
NUPPPM==:NLUPMP+340
	LOC	NUPPPM
	ZZ==340
	XLIST
	REPEAT	^D32,<ONE41>
	LIST
>

NUPPMT==:NLUPMP+420

	LOC	NUPPMT
LIST
;USER TRAPS
	EXP	0		;PAGE FAIL WORD (USER OR EXEC)
	JFCL	SAROVF##	;ARITHMETIC TRAP
	EXP	SEPDLO##	;PUSH DOWN LIST OVERFLOW TRAP
	JFCL			;TRAP 3 TRAP

EXP	0			;MUUO STORED HERE
EXP	0			;MUUO PC STORED HERE
EXP	0			;PROCESS CONTEXT WORD
EXP	0			;UNUSED
EXP	IFE FTKLP,<IC.UOU>+MUUO		;KERNAL NO TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+KTUUO	;KERNAL TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+SNTUUO	;SUPERVISOR NO TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+STUUO	;SUPERVISOR TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+MUUO		;CONCEALED NO TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+CTUUO	;CONCEALED TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+MUUO		;PUBLIC NO TRAP MUUO NEW PC
EXP	IFE FTKLP,<IC.UOU>+PTUUO	;PUBLIC TRAP MUUO NEW PC
	LOC	NLUPMP+.LMPFW		;GET TO PAGE FAIL WORD

EXP	0				;PAGE FAIL WORD
EXP	0				;PAGE FAIL OLD PC
EXP	IFE FTKLP,<IC.UOU>+SEILM##	;PAGE FAIL NEW PC
EXP	SEILM##				;PAGE FAIL NEW PC
NUPMPL==:.-NLUPMP
;HARDWARE LOCATIONS
;504 - 507 EBOX/MBOX METERS
;510 - 577 RESERVED
IFN FTKLP,<
NULSTB==NLUPMP+540		;SECTION TABLE ORIGIN
	LOC	NULSTB
	EXP	<PM.DCD>B2+PM.PUB+PM.WRT+NLUPMP/PAGSIZ
	BLOCK	^D31		;RESERVE THE REST
>
NULASW==NLUPMP+1000		;FIRST LOC AVAIL TO SOFTWARE
LOC	NULASW
>;END OF IFN M.KL10!M.KS10
SUBTTL	EXECUTIVE UUO DISPATCHERS
$HIGH
KTUUO:
IFE FTKLP,<
	JRST	@.UPMP+.UPMUO	;DISPATCH TO KERNAL MODE TRAP HANDLER
>
IFN FTKLP,<
	JRST	@.USMUE		;E FIELD OF THE MUUO IS TRAP HANDLER ADDRESS
				; N.B., USRIOT ISN'T ON
>
SNTUUO:	HALT	.		;NOT IMPLEMENTED
STUUO:	HALT	.		;NOT IMPLEMENTED
CTUUO:PTUUO:
	EXECAC
IFE FTKLP,<
	SKIPL	T1,.UPMP+.UPMUO
>
IFN FTKLP,<
	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	JUMPL	T1,ILLTIN##
>
	CAILE	T1,UP.MLT
	JRST	ILLTIN##
	JRSTF	@UUTDSP(T1)
UUTDSP:	IC.UOU+SEILM##		;PAGE FAULT
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+SEPDLO##		;PUSH DOWN LIST OVERFLOW
	IC.UOU+ILLTIN##		;TRAP 3
	IC.UOU+SUILM##		;USER ENABLED PAGE FAULT
	IC.UOU+SAROVF##		;USER ENABLED ARITHMETIC OVERFLOW
	IC.UOU+SUPDLO##		;USER ENABLED PDL OVERFLOW
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+PSIAPR		;PSI ENABLED ARITHMETIC OVERFLOW
	$ABS
LUUOPC::0			;JSR HERE ON A LUUO IN EXEC MODE
	EXCH	T1,LUUOPC
	MOVEM	T1,.UPMP+.UPMUP
	JRST	UUOERR##
TRP3PC:	0			;JSR HERE ON A TRAP 3 IN EXEC MODE
	HALT	.
SUBTTL	SOME DEFINITIONS FOR KL10'S
IFN M.KL10,<
KLRELC==.
	LOC	420
	IFN	./2*2-.,<0>	;MAKE SURE THEY START ON EVEN LOCATION
LOCODW::BLOCK	4*DX10N		;4 WORDS EACH DX10
LOCODE==:.-1			;END OF THAT AREA
LOCOCW::BLOCK	ALLKON*4	;ICCW PAIRS
				;ICCW+3: JSR XXXVIN IF A TM02
	LOCOCE==:.-1

	XP	FREORG,<<.-1>/4*4+4>
	LOC	FREORG
	BLOCK	13*4
	XP	LEN1,<<.-FREORG+1>/4>




	LOC	KLRELC
>;END IFN M.KL10
SUBTTL	KS10 UBA INTERRUPT VECTOR TABLES

IFN M.KS10,<
;TABLES FOR DISPATCHING 11-STYLE VECTORED INTERRUPTS FROM THE
;KS10'S UNIBUS ADAPTORS. INITIALLY SET TO ZEROS.
;APPROPRIATE LOCATIONS WILL BE SET UP BY THE DEVICE SERVICE ROUTINES.

VECTB1::			;UBA 1 VECTOR TABLE
;REPEAT ^D128,<0>		;THIS IS WHAT'S ASSEMBLED
XLIST
REPEAT ^D128,<0>
LIST
VECTB3::			;UBA 3 VECTOR TABLE
XLIST
REPEAT ^D128,<0>
LIST
>;END IFN M.KS10
SUBTTL	VIRTUAL MEMORY DATA
.EPMPP==:.EPMP/PAGSIZ
MONORG==:MONORG
EVTABL==^D256/^D36+1
EVMPTR::XWD	-EVTABL,EVBTAB
PAGPTR::0
ALPHA==1			;FRACTIONAL PART OF TIME CONSTANT
EXPON==^D10			;NEGATIVE EXPONENT OF TIME CONSTANT
.GTVM::
SWPCNT::0			;(0)
SCNCNT::-1			;(1)
SPRCNT::0			;(2) COUNT OF SWAPS + PAGE OPERATIONS IN PROGRESS
				;  (SQREQ IS ONLY SWAPS)
SLECNT::0			;(3) TOTAL NUMBER OF SWPLST ENTRIES
VMTOTL::0			;(4) TOTAL AMOUNT OF VM CURRENTLY IN USE
VMCMAX::0			;(5) MAX ALLOWABLE VALUE OF VMTOTL
VMRMAX::1			;(6) OBSOLETE
VMCNST::ALPHA			;(7) CONSTANT USED TO COMPUTE SWAPPING RATE
VMQJOB::0			;(10) OBSOLETE
JBRMAX::RTUPS/^D10		;(11) OBSOLETE
LSFTIM::0			;(12) TIME OF LAST FAULT
SYSVCT::0			;(13) TOTAL NUMBER OF PAGE FAULTS (SYSTEM WIDE)
				;LH=NUMBER OF FAULTS WHEN PAGE NOT IN WS
				;RH=NUMBER WHEN PAGE IS IN WORKING SET, PM.ACC=0
	EXP	SWPLST		;(14) LCTN OF SWAP TABLE #1
	EXP	SW2LST		;(15) LCTN OF SWAP TABLE #2
	EXP	SW3LST		;(16) LCTN OF SWAP TABLE #3
VMCEXP::EXPON			;(17) TIME CONSTANT EXPONENT
VMCDIF::EXPON-ALPHA		;(20)
MAXINT::777777			;(21) MAX INTERVAL FOR FAULT-RATE CALCULATION (ABOUT 8 SEC. BETWEEN FAULTS)
IPCCNT::0			;(22) COUNT OF IPCF PAGES BEING SWAPPED OUT
	EXP	.UPJOB	 	;(23) OFFSET OF JOB NUMBER IN UPMP
	EXP	.UPREL		;(24) OFFSET OF END OF LOW SEG IN UPMP
	EXP	.UPLST		;(25) OFFSET OF POINTER TO SWAPABLE
	EXP	.UPMP		;(26) VIRTUAL ADDRESS OF PAGE MAP
	EXP	.UPLNM		;(27) OFFSET OF POINTER TO LOGICAL NAMES
SINCNT::0			;(30) NUMBER OF SWAP INPUT REQUESTS IN SWPLST
	EXP	.EAHUA		;(31) HIGHEST "UNMAPPED" EXEC ADDRESS
	EXP	.FPPP		;(32) START OF "PER PROCESS" ADDRESS SPACE
	EXP	.LPPP		;(33) END (+1) OF "PER PROCESS" ADDRESS SPACE
	EXP	.JDAT		;(34) "PER PROCESS" ADDRESS OF USER JOBDAT
	EXP	.UPFCC		;(35) OFFSET IN UPMP FOR TMPCOR POINTERS
	EXP	.UPCTA		;(36) OFFSET IN UPMP FOR EXTENDED CHANNEL TABLE POINTER
	EXP	USRJDA		;(37) OFFSET IN UPMP FOR USRJDA
GTVMXL==:<.-.GTVM-1>B26		;MAXIMUM ENTRY IN GETTAB


EVBMAX::EVBN
EVBTAB::BLOCK	EVTABL
NUPMPP==:NLUPMP/1000
NUPMPA==<NUPMPP>B17
EPMPA==<.EPMP/1000>
.UPMPE==.
SUBTTL	IOWD SPACE ALLOCATION

IFN M.KI10!M.KL10,<
LEN2==0
IFN M.KI10,<
LEN1==<FREORG!777-FREORG+1>/4
IFG CPUN-1,<
LEN2==<NLUPMP+1-<.E0ND+<1000*<CPUN-1>>>>/4
>
>;END IFN M.KI10
NPAGUC==^D512
IFL <2*M.NKC-^D512>,<NPAGUC==2*M.NKC>
IFNDEF XTR4WD,<IFE FTAUTC,<IFL <M.CHN-2>,<XTR4WD=0>>>
IFNDEF XTR4WD,<XTR4WD==<<NPAGUC+3>/4-<LEN1+LEN2>>>
LTINIT::
IFG LEN1,<
	XWD	LEN1,FREORG
>

IFN M.KI10,<
IFG LEN2,<
	XWD	LEN2,<<.E0ND+<1000*<CPUN-1>>+3>/4>*4
>
>;END IFN M.KI10

IFG XTR4WD,<
	XWD	XTR4WD,X4WORG
>
	0		;END OF LTINIT XWD'S

XP X4WORG,<<.-1>/4*4+4>
	LOC	X4WORG
IFG XTR4WD,<
	BLOCK	4*XTR4WD
>
IOWNUM==.-FREORG
NOIOWD::EXP	LEN1+LEN2+XTR4WD ;NUMBER OF FREE IOWD BLOCKS
>;END IFN M.KI10!M.KL10

XP CHKSHF,CPOPJ
XP UPMPSZ,1
XP BLTINS,0

XP UPMSZW,PAGSIZ*UPMPSZ
FLG256::0

	SUBTTL	COMMON MEMORY FOR KDP (KMC-11/COM-IOP/DUP-11) & DMR11

;NOTE: TO AVOID WASTING SPACE THE VALUE OF "XTR4WD" ON
;  THE LAST PAGE CAN BE ADJUSTED.

;NOTE: KDL PAGES ARE BOTH AS BUFFERS AND COMM REGIONS.  SINCE THEY
;  ARE MAPPED BY THE UBA, IT IS ASSUMED THAT THEY CAN BE TRASHED
;  BY AN ERRANT UNIBUS DEVICE.  FOR THIS REASON, THEY ARE NOT STATICALY
;  INITIALIZED.  INSTEAD, THERE IS CODE IN THE KDP UUO SERVICE
;  TO CLEAR OUT AND INITIALIZE A KDL PAGE.

IFNDEF M.KDUP,<M.KDUP==0>	;MAKE SURE M.KDUP IS DEFINED
IFNDEF M.DMRN,<M.DMRN==0>	;Do the same for DMRs
IFE M.KDUP+M.DMRN,<		;IF NO KMC/DUP-11S THEN
	KDLFST==:0		;  DEFINE THESE TWO SYMBOLS
	KDLLST==:0		;  TO KEEP SYSINI HAPPY
>
IFN M.KDUP+M.DMRN,<		;ONLY ALLOCATE PAGES IF WE HAVE KDP'S or DMRs
	BLOCK	<1000-<.&777>>	;GO TO A PAGE BOUNDARY
	KDLFST=:.		;DEFINE SYMBOL = TO FIRST LOC OF FIRST PAGE
	BLOCK	KDLLEN * M.KDUP	;ALLOCATE SPACE FOR THE I/O BUFFERS
	BLOCK	1000 * M.DMRN * DMRPPL	;Allocate space for DMR11 comm region
	KDLLST=:.-1		;REMEMBER LAST ADDRESS USED.
>				;END M.KDUP

	DEFINE KDLDEF(N,V),<	;;MACRO TO DEFINE KDL'N'PG SYMBOLS
	KDL'N'PG=:KDLFST+V
>

ZZ=0
Z=0

REPEAT M.KDUP,<
	KDLDEF(\Z,\ZZ)		;DEFINE THE NEXT SYMBOL
	Z=Z+1			;STEP THE KDL INDEX
	ZZ=ZZ+KDLLEN		;STEP THE PAGE ADDRESS
>;END REPEAT

;Do DMRs too
	DEFINE DMRDEF(N,V),<	;;MACRO TO DEFINE DMR'N'PG SYMBOLS
	DMR'N'PG=:KDLFST+V>

Z=0
REPEAT M.DMRN,<
	DMRDEF(\Z,\ZZ)
	Z=Z+1
	ZZ=ZZ+<DMRPPL*1K>
>;End REPEAT (Note the DMRs start after KDPs)
	SUBTTL	COMMON MEMORY FOR PDP10/PDP11

;NOTE: TO AVOID WASTING SPACE BEFORE THE FIRST DL10 WINDOW
;  THE VALUE OF "XTR4WD" ON THE LAST PAGE CAN BE ADJUSTED.

IFN	PDP11N,<
;;THIS MACRO BUILDS THE DL10 MAP FOR A GIVEN PORT.
DEFINE	BLDM76(CPU,PORT),<

;;COMPUTE THE SIZE OF THE MAP
	DEFINE	WORD(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	DATA(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	PNTR(A,B),<A==ZZ	;;DEFINE THE OFFSET
	XP	DLX'A,ZZ	;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+1>
	DEFINE	BLK(A,B),<
	XP DLX'A,ZZ			;DEFINE GLOBAL SYMBOL
	ZZ==ZZ+B>

;;SIZE OF TO -10 AND TO -11 QUEUES
	TTBS'PORT==:<<M.D7'PORT'N!7>+1>*2
	TEBS'PORT==:<<M.D7'PORT'N*2>!17>+21

;;EXPAND MAP76 TO SEE HOW BIG IT IS
	ZZ==0
	MAP76(CPU,PORT)
REPEAT ^D18,<ZZ==ZZ!<ZZ_<-1>>>

	ZZ==ZZ!<<DLX8K*777>!77>  ;MUST BE BIG ENOUGH
IFN M.DC75,<ZZ=ZZ!177>		;MIN OF 128 WORDS IF MAY BE DC75

	LOC	<<.-1>!ZZ>+1	;LOC TO BEGINNING OF WINDOW
	ZZ==ZZ_<-<6+<3*DLX8K>>>	;SIZE OF BLOCK
	M7'PORT'END==<<<<ZZ+1>_<DLX8K*3>>*^D64>+.-1>
IFN ZZ&777760 <PRINTX ?DL10 MAPPED AREA IS TOO LARGE.>
	XP	M7'PORT'BAM,ZZ	;DL10 WINDOW MASK
	ZZ=ZZ*4			;SHIFT TO PROPER PLACE
	ZZ=ZZ+<PORT&3>		;MASK OUT OVEERFLOW IN PORT

;;NOW LAY OUT THE MAP FOR REAL
DEFINE	WORD(SYM),<
M7'PORT''SYM::	0
>

DEFINE	DATA(SYM,THING),<
IF2,< IFNDEF THING,<EXTERNAL THING>>
M7'PORT''SYM::	THING
>

DEFINE PNTR(SYM,PLACE),<
IF2,< IFNDEF PLACE,<EXTERNAL PLACE>>
M7'PORT''SYM::	<61B5>+PLACE
>

DEFINE BLK(SYM,SIZE),<
M7'PORT''SYM::	BLOCK	SIZE
>

IFNDEF DLXFST,<DLXFST==:.>		;START OF DL10 UNCACHED SPACE

.DL'CPU'PORT'B::	;;FIRST ADDRESS IN COMMON MEMORY
	MAP76(CPU,PORT)
> ;END DEFINITION OF BLDM76
IFN	XPANDN,<LALL>			;EXPAND LISTING IF WANTED FROM MONGEN
	ZZD78L==0			;LINE NUMBER CONCATENATOR

;THIS MACRO USES THE "MAP78" MACRO TO ACTUALLY BUILD THE
;THE WINDOW.  IT CALLS "MAP78" TO FIRST CALCULATE THE WINDOW
;SIZE AND THEN IT CALLS "MAP78" AGAIN TO ACTUALLY BUILD THE
;THE DAS78 WINDOW.
;
DEFINE	BLD78	(CPU,PORT),<

IFN <M'CPU'PORT'D78>,<			;ONLY BUILD IF THERE IS LINES ON PORT

;THESE MACRO'S ARE USED FOR COMPUTING THE SIZE OF THE MAP
;
DEFINE	Q78BLK(A),<
	ZZD78A==ZZD78A+A>
;
DEFINE Q78WRD(A),<
	ZZD78A==ZZD78A+1>
;
DEFINE	Q78DAT(A,B),<
	ZZD78A==ZZD78A+1>
;
DEFINE	Q78SYM(A,B),<
	;A>
DEFINE	Q78INC(A,B),<
	;A==A+B>
;END OF MACRO'S THAT DETERMINE MAP SIZE

	ZZD78A==0			;START WITH 0

IFNDEF	M78FPO,<M78FPO==:PORT>		;FIRST PORT INUSE BY DAS78.
	M78HPO==:PORT			;FIGURE HIGHEST DAS78 PORT.

;CALL MAP78 TO CALCULATE WINDOW SIZE
;
	MAP78	(CPU,PORT)

	ZZD78A==<ZZD78A-1>		;ADJUST TO LAST USED LOCATION

REPEAT ^D18,<ZZD78A==ZZD78A!<ZZD78A_<-1>>>

	ZZD78A==<ZZD78A!<<M78M8K*777>!77>>	;MAKE BIGGER IF 8K DL10

IFN	<.&ZZD78A>,<
	LOC	<.!ZZD78A>+1
>;END IFN <.&ZZD78A>

	ZZD78A==<ZZD78A_<-<6+<3*M78M8K>>>>	;SIZE OF BLOCK
	M8'PORT'END==<<<<ZZD78A+1>_<M78M8K*3>>*^D64>+.-1>

IFN	<ZZD78A&777760>,<PRINTX ?DAS78 DL10 MAPPED AREA TOO LARGE.>
	M8'PORT'BAM==<ZZD78A*4>		;SHIFT TO CORRECT PLACE FOR BASE ADR MASK

DEFINE	Q78BLK(A),<
	BLOCK	A>

DEFINE	Q78WRD(A),<
	A::!Z>

DEFINE	Q78DAT(A,B),<
	A::!B>

DEFINE	Q78SYM(A,B),<
	A'B::>
DEFINE	Q78INC(A,B),<
	A==A+B>
;CALL MAP78 NOW TO ACTUALLY BUILD THE WINDOW
;
.DL'CPU'PORT'B::
	MAP78	(CPU,PORT)

	M78NUM==:<-<M78HPO-M78FPO+1>>	;MINUS NUMBER OF POSSIBLE PDP11'S


	LOC	<M8'PORT'END>+1

>;END OF IFN M'CPU'PORT'D78
>;END OF DEFINITION OF BLD78

; CALCULATE WINDOW SIZE AND BUILD THE PDP11 WINDOW
;
DEFINE	MAPIT	(CPX,P),<	;[JEQ] Sigh...
	IFN TP.DL'P,<
		IFE M'CPX''P'D78,<BLDM76(CPX,P)> ;[JEQ]
		IFN M'CPX''P'D78,<BLD78(CPX,P)>	;[JEQ]
	> ;;END IFN TP.DL'P
> ;END MAPIT

ZZZ=0			;FIRST PORT
	REPEAT	10,<
	IFLE	<ZZZ-3>,<
IFNDEF	DLX08K,<DLX08K==0	;;ASSUME JUMPERED FOR 1K MAXIMAL>
IFN	DLX08K,<DLX08K==1	;;FORCE TO 1 IF NOT ZERO>
DLX8K==DLX08K			;;USED BY BLDM76
M78M8K==DLX08K			;;USED BY BLD78
>
	IFG	<ZZZ-3>,<
IFNDEF	DLX18K,<DLX18K==0	;;ASSUME JUMPERED FOR 1K MAXIMAL>
IFN	DLX18K,<DLX18K==1	;;FORCE TO 1 IF NOT ZERO>
DLX8K==DLX18K			;;USED BY BLDM76
M78M8K==DLX18K			;;USED BY BLD78
>
	MAPIT(0,\ZZZ)		;GET THE RIGHT MAP OR NOTHING
ZZZ=ZZZ+1
>
SUBTTL	DL10 INTERRUPT HANDLING


;INTERRUPT ROUTINE FOR EACH DL10 BASED DAS78
DEFINE	EACH78(PORTN),<
IFN	M0'PORTN'D78,<

IFLE	PORTN-3,<DLBD78=60
	DLCD78=64>			;FIRST DL10
IFG	PORTN-3,<DLBD78=160
	DLCD78=164>			;SECOND DL10

	$ABS

D80'PORTN'KI:				;DL10 FORCES JSR HERE
IFE FTKLP,<EXP	0,<JRST D80'PORTN'IN>>
IFN FTKLP,<EXP	0,0,IC.UOU,<D80'PORTN'IN>>

	$HIGH

DEFINE	D8.CH(A,B),<IF2,<A'B>>
IFNDEF	DLXSCC,<DLXSCC:>
D80'PORTN'KA:
	CONSO	DLCD78,1B<32-<3*<PORTN&3>>> ;IS THIS PDP11 INTERRUPTING?
	JRST	DLX'PORTN'NX		;TRY THE NEXT ONE
	CONSO	DLCD78,1B31_<<PORTN&3>*3> ;PORT PORTN ENABLED?
	JRST	.-2			;NO, IGNORE.
	JRST	D80'PORTN'CM		;ENTER COMMON CODE

D80'PORTN'IN:
	CONO	DLCD78,1B19+1B<32-<3*<PORTN&3>>>+XXICHN	;TURN OFF INTERRUPT
IFE FTKLP,<
	EXCH	0,D80'PORTN'KI		;SAVE AC 0, GET INTERRUPT PC
	MOVEM	0,D8.CH(CH,\XXICHN)	;STORE SO WE CAN USE CHN SAVE ROUTINES
	MOVE	0,D80'PORTN'KI		;RESTORE AC 0
> ;END IFE FTKLP
IFN FTKLP,<
	DMOVEM	0,D8.CH(SVAC,\XXICHN)	;SAVE ACS 0 AND 1
	DMOVE	0,D80'PORTN'KI		;GET INPTERRUPT PC DOUBLE WORD
	DMOVEM	0,D8.CH(CH,\XXICHN)	;STORE SO WE CAN USE CHN SAVE ROUTINES
	DMOVE	0,D8.CH(SVAC,\XXICHN)	;RESTORE ACS 0 AND 1
> ;END IFN FTKLP

D80'PORTN'CM:
	CONO	DLCD78,1B19+1B<32-<3*<PORTN&3>>>+XXICHN	;TURN OFF INTERRUPT
	JSR	D8.CH(SAV,\XXICHN)	;SAVE THE ACS AND SET UP P
	SKIPE	J,M78BT+PORTN		;J TO POINT TO WINDOW FOR PORT PORTN
	  PUSHJ	P,D78KII##		;GO TO DAS78 INTERRUPT SERVICE ROUTINE
	POPJ	P,			;DISMISS INTERRUPT


;BASE TABLE FOR DAS78 DL10
;
M80'PORTN'BT:
	PHASE	0
M78CPE::!CONO	DLCD78,XXICHN+<1B31_<<PORTN&3>*3>>	;CLEAR PORT ENABLE FOR PORT PORTN
M78I10::!CONSO	DLCD78,1B32_<<PORTN&3>*3>		;SEE IF PDP11 PORTN SET 10 INT
M78I11::!CONO	DLCD78,1B19+1B20+XXICHN+<1B30_<<PORTN&3>*3>>	;SET PDP11 INTERRUPT ON PORTN
M78SWA::!CONO	DLBD78,M8'PORTN'KII!M8'PORTN'BAM!<PORTN&3>	;LOAD ADDRESS FOR PORT PORTN
M78ENP::!CONO	DLCD78,1B20+XXICHN+<1B31_<<PORTN&3>*3>>	;ENABLE PORT PORTN
M78CPI::!CONSO	DLCD78,7			;SEE IF PIA ASSIGNED
M78SPI::!CONO	DLCD78,XXICHN			;GIVE PI CHN ASSIGNMENT
M78PNO::!PORTN,,.DL0'PORTN'B			;;PORT##,,WINDOW
IFN M.PSI,<
M78PSI::!DATAO	DLCD78,[200001,,0]	;KA STYLE INTERRUPTS
>					; SO PSISER CAN FIND THE PC
IFE M.PSI,<
M78PSI::!JFCL
>
M78SER::!DATAO	DLBD78,[<PORTN&3>_^D<35-5>]  ;PUT PORT NUMBER IN THE "R" REGISTER
M78GWA::!CONI	DLBD78,T1	;GET BASE ADDRESS
	DEPHASE

DLX'PORTN'NX::
	$ABS

>;END IFN M0'PORTN'D78
>;END DEFINE EACH78

;INTERRUPT ROUTINE FOR EACH DL10 BASED ANF10 PDP11
DEFINE	EACH76(N)<
IFN TP.DL'N,<			;IF PORT DEFINED
IFE M0'N'D78,<			;AND NOT A DAS78
IFLE N-3,<DLX=DLC
	DLBX=DLB>		;FIRST DL10
IFG N-3,<DLX=DLC2
	DLBX=DLB2>		;SECOND DL10
	$ABS
D70'N'KI:Z			;DL10 FORCES JSR TO HERE
IFN FTKLP,<
	Z
	IC.UOU
	D70'N'IN
>
IFE FTKLP,<
	JRST	D70'N'IN	;DO INTERRUPT IN CACHED HIGH SEGMENT
>
	$HIGH
DEFINE	D7.CH(A,B),<IF2,<A'B>>
IFNDEF	DLXSCC,<DLXSCC==.>	;DEFINE START OF KA SYTLE DL10 CONSO CHAIN
D70'N'KA:CONSZ	DLX,1B32_<<N&3>*3> ;IS THIS -11 INTERRUPTING
	CONSO	DLX,1B31_<<N&3>*3> ;YES, PORT ENABLED ?
	JRST	DLX'N'NX	;NO, TRY THE NEXT -11
	JRST	D70'N'CM	;JOIN COMMON CODE WITH VECTORED STYLE
D70'N'IN:
IFE FTKLP,<
	EXCH	0,D70'N'KI	;SAVE 0, GET INTERRUPT PC
	MOVEM	0,D7.CH(CH,\SCNCHN) ;STORE SO CAN USE CHANNEL SAVE ROUTINES
	MOVE	0,D70'N'KI	;GET AC BACK
>
IFN FTKLP,<
	DMOVEM	0,D7.CH(SVAC,\SCNCHN)
	DMOVE	0,D70'N'KI
	DMOVEM	0,D7.CH(CH,\SCNCHN)
	DMOVE	0,D7.CH(SVAC,\SCNCHN)
>
D70'N'CM:CONO	DLX,1B19+<1B32_<<N&3>*3>>+SCNCHN ;TURN OFF INTERRUPT
	JSR	D7.CH(SAV,\SCNCHN) ;SAVE AC'S AND STUFF
	SKIPE	W,DLXBAT+N	;SET UP BASE ADDRESS
	XCT	DLXINI(W)	;TAKE ACTION FOR THIS INTERRUPT
	POPJ	P,		;DISMISS INTERRUPT

	IFE	TP.DL'N-TP.D76,<	;THIS IS A DC76 PORT
DC76'N'D::JRST	[PUSHJ P,SETJ'N	;SET UP J AS BASE ADDRESS
		 PJRST D76TYP##];CALL TYPEOUT ROUTINE
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76DSC##];MODEM CONTROL
	POPJ	P,		;NO PI CHANNEL TO CHECK ON
	POPJ	P,0		;NO INIT
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76CHP##];CHANGE HARDWARE PARAMETERS
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76LPC##];LINE PARAMETER CONTROL

	POPJ	P,		;SET ELEMENT. NO 2741
	POPJ	P,		;REMOTE STATION STUFF
	JRST	[PUSHJ P,SETJ'N
		 PJRST D76OFL##]

SETJ'N:	EXCH	J,(P)		;SAVE J
	MOVEM	J,1(P)		;SAVE RETURN ADDRESS
	MOVE	J,DLXBAT+N	;POINT TO BASE OF MAP
	MOVE	J,DLXWIN(J)	; ..
	PUSHJ	P,@1(P)		;DO FUNCTION
	  PJRST	IPOPJ		;RETURN
	PJRST	IPOPJ1		;ALLOW CPOPJ1
> ;END OF IFE TP.DL'N-TP.D76
DLX'N'NX:
> ;END IFE M0'N'D78
> ;IFN TP.DL'N
> ;END OF DEFINITION OF EACH76
> ;END IFN PDP11N
; PDP11 BASE TABLE OFFSETS
	  PHASE	0		;START BASE TABLE
DLXWIN::! BLOCK	1		;STANDARD XWD CPU#,DTE#
DLXNMT::! BLOCK	1		;FRONT END NAME
DLXSTA::! BLOCK	1		;DTE KNOW'S WHEN THE -10'S ALIVE
DLXINI::! BLOCK	1		;DO THIS ON INTERRUPT
DLXCAL::! BLOCK	1		;POINTER TO CAL11. UUO TABLE
DLXCEU::! BLOCK	1		;CAL11. USER'S JOB NUMBER
DLXPRG::! BLOCK	1		;DO THIS WHEN PDP11 GOES DOWN
DLXTYP::! BLOCK	1		;TYPE OF PDP11 (FOR CALL11)
DLXTIM::! BLOCK	1		;CONTAINS UPTIME OF TIMEOUT, OR 0
DLXPRE::! BLOCK	1		;
DLXCEV::! BLOCK	1		;CAL11. UUO ENTRY VECTOR
DLXFEK::! BLOCK	1		;ADDRESS OF ASSOCIATED FEK
DLXLEN::!			;LENGTH OF COMMON BASE TABLE AREA
	  DEPHASE

IFN FTKI10!FTKL10,<		;DL10 SPECIFIC BASE TABLE OFFSETS
	  PHASE	DLXLEN
DLXMSK::! BLOCK	1		;MASK OF FRONT END BITS
DLXKAX::! BLOCK	1		;INSTRUCTION FOR NON-KA10 STYLE INTERRUPTS
DLXSWA::! BLOCK	1		;WINDOW ADDRESS
DLXENB::! BLOCK	1		;INSTRUCTION TO ENABLE WINDOW AND INTERRUPTS
DLXCLR::! BLOCK	1		;INSTRUCTION TO CLEAR PORT ENABLE
DLXCNI::! BLOCK	1		;INSTRUCTION TO READ DL10 CONDITIONS
DLXI11::! BLOCK	1		;
DLXDBL::!			;LENGTH OF DL10 BASE TABLE
	  DEPHASE
> ;END IFN FTKI10!FTKL10

IFN FTKL10,<			;DTE SPECIFIC BASE TABLE OFFSETS
	  PHASE	DLXLEN
DLXEVM::! BLOCK	1		;REMEMBER NUMBER OF PAGES OF EVM AND THE EXEC
				; VIRTUAL ADDR FOR RETURNING EVM
DLXOCN::! BLOCK	1		;COUNT OF BYTES IN DIRECT OUT MSG
DLXODA::! BLOCK	2		;BYTES TO BE PUT IN THE DIRECT MSG
DLXICI::! BLOCK	1		;# BYTES EXPECTING IN THE INDIRECT INPUT MSG
DLXIBP::! BLOCK	1		;BYTE PTR TO USER BUFFER PASSED TO DTESER
DLXICN::! BLOCK	1		;COUNT OF BYTES RECEIVED IN INPUT DIRECT MSG
DLXIDA::! BLOCK	2		;BYTES FROM THE INPUT DIRECT MSG
DLXSBL::!			;DTE BASE TABLE LENGTH
	  DEPHASE
> ;END IFN FTKL10

IFN FTKS10,<			;KMC/DUP SPECIFIC BASE TABLE OFFSETS
				;D6RINT USES THE SAME OFFSETS...
	  PHASE	DLXLEN
DLXFLG::! BLOCK	1		;GENERAL PURPOSE FLAGS WORD (SEE D6KINT)
DLXICI::! BLOCK	1		;# BYTES EXPECTING IN THE INDIRECT INPUT MSG
DLXIBP::! BLOCK	1		;BYTE POINTER TO USER BUFFER PASSED TO KDPINT
DLXIMQ::! BLOCK	1		;INPUT MESSAGE QUEUE (0 OR 1 LONG)
DLXKBL::!			;KMC/DUP (AND DMR) BASE TABLE LENGTH
	  DEPHASE
> ;END IFN FTKS10
SUBTTL	BASE TABLE GENERATION -- DL10


DEFINE	BASE11	(CPX,N),<	;;CPX = CPU NUMBER, N = PORT NUMBER
IFN TP.DL'N,<			;;IF A PDP11
IFE M'CPX'N'D78,<		;; BUT NOT A DAS78
DL'CPX'N'BS:
	BLOCK	DLXDBL		;;RESERVE SPACE FOR ONE DL10 BASE TABLE

IFLE N-3,<			;;DL10 #0
	DLX=DLC			;;CONTROL REGISTER
	DLBX=DLB		;;BASE ADDRESS REGISTER
>
IFG N-3,<			;;DL10 #1
	DLX=DLC2		;;CONTROL REGISTER
	DLBX=DLB2		;;BASE ADDRESS REGISTER
>

;; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DL'CPX'N'BS+OFS
	DAT
>

;; DATA COMMON TO ALL DL10 BASE TABLES
X	DLXWIN,<.DL'CPX'N'B>	;;WINDOW ADDRESS
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXMSK,<777777700007!<70_<<N&3>*3>>>
				;;"AND" OUT OTHER PDP11 BITS
X	DLXKAX,<DATAO	DLX,[XWD 400001,0]>
				;;NON-KA10 STYLE INTERRUPTS
X	DLXSWA,<CONO	DLBX,.DL'CPX'N'B+<M7'N'BAM>_2+<N&3>>
				;;WINDOW ADDRESS
X	DLXENB,<CONO	DLX,1B19+1B20+<1B31_<<N&3>*3>>+SCNCHN>
				;;ENABLE WINDOW AND INTERRUPTS.
X	DLXCLR,<CONO	DLX,1B19+<70_<<N&3>*3>>+SCNCHN>
				;;CLEAR PORT ENABLE
X	DLXCNI,<CONI	DLX,T1>	;;READ DL10 CONDITIONS
X	DLXI11,<CONO	DLX,1B19+1B20+<1B30_<<N&3>*3>>+SCNCHN>
				;;INTERRUPT THE PDP11

IFN M'CPX'N'D85,<		;;ANF10 DC75/DN87 FRONT ENDS
X	DLXSTA,<SETOM DLXTA(P1)>;;MARK -10 AS BEING ALIVE
X	DLXTYP,.C1D75		;;TYPE OF PDP11
X	DLXPRE,<PUSHJ P,D85PRE##>;;
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<D8'N'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFN    M'CPX'N'D60,<		;;DN60 FRONT ENDS
X	DLXSTA,<SETOM DLXTA(P1)>;;MARK -10 AS BEING ALIVE
X	DLXTYP,.C1D60		;;TYPE OF PDP11
X	DLXPRE,<JFCL>		;;
X	DLXCEV,<JRST D60CEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<D8'N'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DL'CPX'N'BS+DLXDBL
> ;END IFE M'CPX'N'D78
> ;END IFN TP.DL'N
> ;END BASE11 MACRO
SUBTTL	BASE TABLE GENERATION -- DTE


DEFINE	BASDTE	(CPX,DTX),<
DS'CPX'DTX'BS:
	BLOCK	DLXSBL		;;RESERVE SPACE FOR ONE DTE BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DS'CPX'DTX'BS+OFS
	DAT
>

;; DATA COMMON TO ALL DTE BASE TABLES
X	DLXWIN,<XWD CPX,DTX>	;;CPU#,,DTE#
X	DLXSTA,<JFCL>		;;DTE KNOWS WHEN THE -10'S ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M'CPX'DTX'DTE-DT.RSX>,<	;;RSX20F FRONT ENDS
X	DLXNMT,<SIXBIT /RSX20F/>;;NAME
X	DLXTYP,.C1CFE		;;FRONT END TYPE
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M'CPX'DTX'DTE-DT.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D8S		;;FRONT END TYPE
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<S'CPX'DTX'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M'CPX'DTX'DTE-DT.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;FRONT END TYPE
X	DLXCEV,<JRST D6SCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,<S'CPX'DTX'FEK>	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M'CPX'DTX'DTE-DT.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1MCB		;;FRONT END TYPE
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DS'CPX'DTX'BS+DLXSBL
> ;END BASDTE MACRO
SUBTTL	BASE TABLE GENERATION -- KMC/DUP


DEFINE BASKDP	(KMX,KLX),<	;;KMX = KMC #, KLX = DUP # (KMX == 0)
DK'KMX'KLX'BS:
	BLOCK	DLXKBL		;;RESERVE SPACE FOR ONE KMC/DUP BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DK'KMX'KLX'BS+OFS
	DAT
>
;; DATA COMMON TO ALL KMC/DUP BASE TABLES
X	DLXWIN,<KDL'KLX'PG>	;;KDL BASE TABLE
X	DLXSTA,<JFCL>		;;KDP KNOWS WHEN THE -10 IS ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M.'KLX'KDP-KD.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,DK'KLX'FEK	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.USR>,<	;;USER FRONT ENDS
X	DLXNMT,<SIXBIT /USER/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'KLX'KDP-KD.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;TYPE
X	DLXCEV,<JRST D6KCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DK'KMX'KLX'BS+DLXKBL
> ;END BASKDP MACRO
SUBTTL	BASE TABLE GENERATION -- DMR


DEFINE BASDMR	(DRX),<	;;DRX = DMR #
DMR'DRX'BS:
	BLOCK	DLXKBL		;;RESERVE SPACE FOR ONE DMR BASE TABLE

; MACRO TO LOAD UP TABLE LOCATIONS
DEFINE	X	(OFS,DAT),<
	LOC	DMR'DRX'BS+OFS
	DAT
>
;; DATA COMMON TO ALL DMR BASE TABLES
X	DLXWIN,<DMR'DRX>	;;DMR BASE TABLE
X	DLXSTA,<JFCL>		;;DMR KNOWS WHEN THE -10 IS ALIVE
X	DLXINI,<JFCL>		;;DO THIS ON INTERRUPT
X	DLXPRG,<JFCL>		;;DO THIS WHEN THE -11 GOES DOWN
X	DLXPRE,<JFCL>		;;


IFE <M.'DRX'DMR-RD.ANF>,<	;;ANF10 FRONT ENDS
X	DLXNMT,<SIXBIT /ANF10/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,DR'DRX'FEK	;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.DNT>,<	;;DECNET FRONT ENDS
X	DLXNMT,<SIXBIT /DECNET/>;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.USR>,<	;;USER FRONT ENDS
X	DLXNMT,<SIXBIT /USER/>	;;NAME
X	DLXTYP,.C1D22		;;TYPE OF PDP11
X	DLXCEV,0		;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

IFE <M.'DRX'DMR-RD.IBM>,<	;;DN60 FRONT ENDS
X	DLXNMT,<SIXBIT /DN60/>	;;NAME
X	DLXTYP,.C1D60		;;TYPE
X	DLXCEV,<JRST D6RCEV##(P1)> ;;CAL11. UUO ENTRY VECTOR
X	DLXFEK,0		;;ADDRESS OF ASSOCIATED FEK
>

	LOC	DMR'DRX'BS+DLXKBL
> ;END BASDMR MACRO
IFN PDP11N,<	;IF DL10 BASED PDP11S

	$HIGH
IFN M.DAS78,<XXIINT:>		;DAS78 XXI INTERRUPTS HERE
DLXINT:	JRST	DLXSCC		;START OF KA STYLE INTERRUPT CHAIN
	JRST	.-1		;MAKE SYSINI HAPPY

IFN M.DAS78,<
DEFINE	B78BT	(CPU,PORT),<
	IFNDEF	M8'CPU'PORT'BT,<EXP	Z>
	IFDEF	M8'CPU'PORT'BT,<EXP	M8'CPU'PORT'BT>>
	$HIGH
M78BT::
ZZZ=0
	REPEAT	10,<
	B78BT	(0,\ZZZ)
	ZZZ=ZZZ+1>
>;END IFN M.DAS78
	$ABS


ZZZ==0				;GENEATE INTERRUPT ROUTINE FOR EACH
	REPEAT	10,<		; DL10 BASED DAS78
	EACH78	(\ZZZ)
	ZZZ==ZZZ+1
>
ZZZ=0				;GENERATE INTERRUPT ROUTINE FOR EACH
	REPEAT	10,<		; DL10 BASED ANF10 PDP11
	EACH76(\ZZZ)
	ZZZ==ZZZ+1
>
	$HIGH
	JRST	DLXINT+1	;CONSO CHAIN FALLS OUT HERE

	$ABS
;
; GENERATE THE BASE TABLES.  ONE FOR EACH DL10 PDP11 AND ONE
;  FOR EACH PDP11 ON A DTE20 (EXCEPT FOR THE CONSOLE AND
;  DN87S'S)

;FIRST THE DL-10 BASED FRONT ENDS

ZZZ==0				;START WITH #0
    REPEAT 8,<
	BASE11(0,\ZZZ)		;BUILD THE NEXT BASE TABLE
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DL-10 PORT
> ;END OF IFN PDP11N

;NOW THE DTE-20 BASED FRONT ENDS
IFN FTKL10,<
ZZ==0				;CPU #
    REPEAT M.CPU,<		;FOR ALL CPU'S
	ZZZ==0			;DTE NUMBER
	REPEAT 4,<		;FOR ALL DTE'S ON THIS CPU
	    BASDTE(\ZZ,\ZZZ)	;BUILD A BASE TABLE
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DTE
    ZZ==ZZ+1>			;STEP TO THE NEXT CPU
> ;END FTKL10
	$ABS

;BASE TABLES FOR KDP'S (IF USING IBM COMM)
IFN FTKS10,<
    ZZ==0			;START OUT ON LINE ZERO
    REPEAT M.KDUP,<		;FOR ALL LINES
	BASKDP(0,\ZZ)		;BUILD A BASE TABLE
	ZZ==ZZ+1>		; AND STEP TO THE NEXT
    ZZ==0			;START OUT ON LINE ZERO
    REPEAT M.DMRN,<		;FOR THE DMRS TOO
	BASDMR(\ZZ)		;BUILD A BASE TABLE
	ZZ=ZZ+1>		;AND STEP TO THE NEXT
> FTKS10
IFN PDP11N,<
	$HIGH

; BUILD THE BASE TABLES FOR ANF10 AND DAS78 FRONT ENDS

DEFINE	B78BAT	(CPU,PORT),<
IFE	TP.DL'PORT,<EXP	0>
IFN	TP.DL'PORT,<
	IFE	M'CPU'PORT'D78,<EXP	0>
	IFN	M'CPU'PORT'D78,<XWD	M8'PORT'DDB,.DL'CPU'PORT'B>
> ;;END IFN TP.DL'PORT
> ;END B78BAT

DEFINE	BLXBAT	(CPU,PORT),<
IFE	TP.DL'PORT,<EXP	0>
IFN	TP.DL'PORT,<
	IFE	M'CPU'PORT'D78,<EXP	DL'CPU'PORT'BS>
	IFN	M'CPU'PORT'D78,<EXP	0>
> ;;END IFN TP.DL'PORT
> ;END BLXBAT

DLXBAT::			;START OF THE ANF10 MAPPING TABLE
ZZZ==0				;PORT COUNTER
    REPEAT 8,<			;FOR ALL POSSIBLE PORTS
	BLXBAT	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT


IFN M.DAS78,<
M78BAT::			;START OF THE DAS78 MAPPING TABLE
ZZZ==0				;PORT COUNTER
	REPEAT 8,<		;FOR ALL POSSIBLE PORTS
	B78BAT	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT


	$ABS
; MACRO TO BUILD A TABLE CONTAINING DDB ADDRESSES FOR EACH DAS78
DEFINE	B78DDB	(CPU,PORT),<
IFDEF	M8'PORT'KII,<M8'PORT'DDB::BLOCK	M'CPU'PORT'D78>
> ;END B78DDB
M78DDB::
ZZZ==0
	REPEAT	8,<		;FOR ALL POSSIBLE PORTS
	B78DDB	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT

	$HIGH
; MACRO TO BUILD A TABLE WHICH CONTAINS THE LAST USED LOCATION IN
; THE DAS78 WINDOW FOR EACH PORT.
DEFINE	B78END	(CPU,PORT),<
	IFNDEF	M'CPU'PORT'END,<EXP	0>
	IFDEF	M'CPU'PORT'END,<EXP	M'CPU'PORT'END>
> ;END B78END

M78END::
ZZZ==0
	REPEAT	8,<
	B78END	(0,\ZZZ)
	ZZZ==ZZZ+1>

; MACRO TO BUILD A TABLE WHICH CONTAINS THE NUMBER OF LINES
; ON EACH DAS78
DEFINE	B78LIN	(CPU,PORT),<EXP	M'CPU'PORT'D78>

M78LIN::
ZZZ==0
	REPEAT	8,<		;FOR ALL POSSIBLE PORTS
	B78LIN	(0,\ZZZ)	;EXPAND THE MACRO
	ZZZ==ZZZ+1>		;AND STEP TO THE NEXT PORT

	$ABS
D78NAM::BLOCK	10		;TABLE OF NAMES FILLED IN BY THE PDP11
				; THROUGH A POINTER IN THE DAS78 WINDOW
> ;END IFN M.DAS78
> ;END OF IFN PDP11N

	$HIGH


;HELPER MACRO FOR SETTING UP THE DTE -- BASE TABLE CORRISPONDENCE MAP
DEFINE	BLXBAT	(CPX,DTX),<
	IFE	M'CPX'DTX'DTE,<EXP	0>
	IFN	M'CPX'DTX'DTE,<EXP	DS'CPX'DTX'BS>
>

DTEBAS::			;START OF THE DTE TO BASE TABLE MAPPING
IFN FTKL10,<
ZZ==0				;CPU COUNTER
    REPEAT M.CPU,<		;FOR ALL CPU'S
	ZZZ==0			;ZERO THE DTE COUNTER
	REPEAT 4,<		;FOR ALL DTE-20S
	    BLXBAT(\ZZ,\ZZZ)	;MAKE THE MAP ENTRY
	    ZZZ==ZZZ+1>		; STEP TO THE NEXT DTE
	ZZ==ZZ+1>		; STEP TO THE NEXT CPU
>


DEFINE BLXBAT(KMX,KLX),<EXP DK'KMX'KLX'BS>	;BASE TABLE ADDRESS

KDPBAS::			;START OF THE KDP BASE TABLES
IFN M.DN60&M.DN6K,<		;IF WE HAVE IBM
    ZZ==0			;START AT THE FIRST LINE
    REPEAT M.KDUP,<		;FOR ALL LINES
	BLXBAT(0,\ZZ)		;EXPAND A POINTER TO THEM
	ZZ==ZZ+1>		;STEP TO THE NEXT
>; END IFN M.DN60&M.DN6K

DEFINE BLXBAT(DRX),<EXP DMR'DRX'BS>	;BASE TABLE ADDRESS

DMRBAS::			;START OF THE DMR BASE TABLES
IFN M.DN60&M.DN6R,<		;IF WE HAVE IBM
    ZZ==0			;START AT THE FIRST LINE
    REPEAT M.DMR,<		;FOR ALL LINES
	BLXBAT(\ZZ)		;EXPAND A POINTER TO THEM
	ZZ==ZZ+1>		;STEP TO THE NEXT
>; END M.DN60&M.DN6R


	$ABS
IFNDEF DLXFST,<DLXFST==:.>		;START OF DL10 UNCACHED SPACE
DLXLST::	;END OF UN-CACHED AREA
IFN FTMP&M.KL10,<
OUCHTB::MONORG+0*PAGSIZ(T1)
	MONORG+1*PAGSIZ(T1)
	MONORG+2*PAGSIZ(T1)
	MONORG+3*PAGSIZ(T1)
>
SUBTTL	BACKGROUND PERFORMANCE ANALYSIS SELECTION TABLE

IFN	M.KL10&FTRSP,<

	$HIGH		;THE TABLE IS "PURE"

;BPATAB  --  TABLE OF BACKGROUND PERFORMANCE ANALYSIS CONDITIONS
;
;THIS TABLE CONTAINS THE ORDERED LIST OF "ASPECTS" OF THE SYSTEM
;TO WATCH VIA THE PERFORMANCE ANALYSIS METER OF THE KL-10 CPU.
;
;EACH ITEM IN THE BPATAB TABLE HAS A CORRESPONDING 4-WORD BLOCK IN
;THE CDB VARIABLES AREA (SUBTABLE .CPBPV). THE FIRST TWO WORDS ARE
;THE RDTIME TOTAL FOR WHICH THE CONDITION(S) WAS(WERE) WATCHED, AND
;THE SECOND TWO WORDS ARE THE PERFORMANCE METER COUNT FOR THE ENABLED
;CONDITION(S) - EITHER AN INTEGER COUNT IF IN EVENT MODE OR ELAPSED
;TIME IF IN DURATION MODE. THE ORDER OF THE TABLE IS IMPORTANT SINCE
;THE NUMBERS ARE GETTAB'ED OUT OF THE .CPBPV SUBTABLE.
;
;ALTHOUGH THIS TABLE REALLY BELONGS IN KLSER IT MUST APPEAR IN COMMON
;BEFORE THE CDB DEFINITIONS AS THE LENGTH OF THE TABLE IS NEEDED TO
;DEFINE THE CDB VARIABLES SUBTABLE.

BPATAB::PE.CP0!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 0
	PE.CP1!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 1
	PE.CP2!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 2
	PE.CP3!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 3
	PE.CP4!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 4
	PE.CP5!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 5
	PE.CP6!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 6
	PE.CP7!PE.UCI!PE.PRI!PE.CCI!PE.PPI!PE.PCI!PE.CLR	;CH 7
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP0!PE.PCI!PE.CLR	;PI 0
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP1!PE.PCI!PE.CLR	;PI 1
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP2!PE.PCI!PE.CLR	;PI 2
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP3!PE.PCI!PE.CLR	;PI 3
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP4!PE.PCI!PE.CLR	;PI 4
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP5!PE.PCI!PE.CLR	;PI 5
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP6!PE.PCI!PE.CLR	;PI 6
	PE.CPI!PE.UCI!PE.PRI!PE.CCI!PE.PP7!PE.PCI!PE.CLR	;PI 7

	BPATLN==:.-BPATAB

	$ABS		;BACK TO "IMPURE"
> ;END OF IFN M.KL10&FTRSP
SUBTTL CPU DATA BLOCK(S):

REPEAT 0,<

EACH CPU HAS ITS OWN DATA BLOCK, KNOWN AS A CDB.
THE REST OF THE MONITOR ONLY REFERENCES THE CDB FOR THE MASTER CPU.
IN THESE CASES IT WILL USUALLY USE THE OLD 6 CHAR NAME.
MANY LOCATION IN THE CDB PERTAIN ONLY TO THE MASTER CPU. HOWEVER,
FOR GENERALITY AND FUTURE EXPANSION TO A MASTER/MASTER SYSTEM, INSTEAD
OF MASTER/SLAVE, THEY ARE INCLUDED IN CDB(WITH OLD NAMES
AND NO P4).  A FEW LOCATIONS ARE REALLY SYSTEM PARAMETERS(EG CORTAL),
RATHER THAN CPU PARAMETERS.  HOWEVER, THEY WERE IN THE MIDDLE OF A
GETTAB(NSWTBL) AND SO COULD NOT BE SEPARATED OUT WITHOUT INVALIDATING
SOME PROGRAMS.

ALL .CP??? SYMBOLS ARE DEFINED RELATIVE TO THE (MAPPED) CDB,
.CN??? SYMBOLS ARE ABSOLUTE LOCATIONS.
NOTE THAT .CP??? SYMBOLS ARE (AS OF 701) NOT REFERENCED WITH
P4 AS AN INDEX REGISTER

ACTUALLY USED.  THIS MINIMIZES THE NO. OF SYMBOLS AND IS A USEFUL
DOCUMENTATION TOOL.  IN OTHER WORDS A LOCATION WILL ONLY HAVE AN OLD
SYMBOL, OR A NEW .CP??? SYMBOLS, OR .CP??? AND .C0??? AS NEEDED.
FOR DEBUGGING WITH DDT, THE ABSOLUTE SYMBOLS FOR CPU0 AND CPU1 ARE
ALWAYS GENERATED AT LEAST AS LOCAL SYMBOLS.
>

REPEAT 0,<

PRINCIPLE:	WHEN ADDING CONSTANTS OR VARIABLES TO COMMON,
GREAT CARE MUST BE EXERCISED IN DECIDING WHETHER TO PUT IT
IN THE CDB OR IN A SYSTEM DEPENDENT TABLE(.SYTBL).
IF THE CONTENTS COULD EVER BECOME CPU DEPENDENT IN THE FUTURE, BE
SURE TO PUT IT IN THE CDB INSTEAD OF .SYTBL.  IF A MISTAKE IS MADE,
THE LOCATION WILL HAVE TO APPEAR IN THE CDBS AS WELL AS
.SYTBL IN ORDER TO INSURE COMPATIBLITY.

;DEFINE CONSTANTS AREA IN CDB
;EACH 'C' MACRO GENERATES A CONSTANT FOR CPU0
;AND A CONSTANT FOR CPU1.
;THE CALL IF OF FORM:
;	C <XXX,CP0,CP1,CONST0,CONST1>
;WHERE:	XXX IS THREE LETTER SUFFICE FOR LOC.SYMBOL
;	CP0 IS EITHER NULL (IE ,,) OR "CPO"
;	CP1 IS EITHER NULL (IE ,,) OR "CP1"
;	CONST0 IS THE CONSTANT VALUE FOR CDB 0
;	CONST1 IS THE CONSTANT VALUE FOR CDB 1
>
;DEFINE C MACRO TO GENERATE CONSTANTS IN CPU DATA BLOCK
;ALWAYS DEFINE .C'N'XX SYMBOLS AS EITHER INTERN OR LOCAL,
;LOCAL IF USED ONLY FOR DEBUGGING WITH DDT.

	DEFINE C(NAM,N,YESNO,VALUE)<
IFDIF <YESNO><Y>,<.C'N'NAM:>
IFIDN <YESNO><Y>,<.C'N'NAM::>
.CP'NAM=:.-.C'N'CDB+.EPCDB
VALUE
>


;DEFINE V MACRO TO GENERATE VARIABLES FOR END OF CDB
;THESE VARIABLES ARE CLEARED AT SYSTEM STARTUP AND 403 RESTART

	DEFINE V(NAM,N,YESNO,TRAD,LENGTH)<
   IFNB <NAM>,<.CP'NAM=:.-.C'N'CDB+.EPCDB
   IFDIF <YESNO><Y>,<.C'N'NAM:>
   IFIDN <YESNO><Y>,<.C'N'NAM::>>
   IFNB <TRAD>,<IFNDEF TRAD,<TRAD::>>
   IFB <LENGTH>,<LOC .+1>
   IFNB <LENGTH>,<LOC .+LENGTH>
>

;DEFINE MACRO TO DETERMINE WHICH KIND OF CPU
	DEFINE KILS<
   IFN M.KI10,<KI>
   IFN M.KL10,<KL>
   IFN M.KS10,<KS>
>

;DEFINE XPC MACRO TO DEFINE A CONSTANT IFF THIS IS THE CPU0 CDB
	DEFINE XPC(A,B,N),<
   IFE N,<XP A,B>
>
;DEFINE ENTIRE CDB DATA AREA AS ONE MACRO (CDB) WHICH CALLS
;C MACRO FOR EACH CONSTANT AND V MACRO FOR EACH VARIABLE

;NOTE: ; MUST APPEAR IMMEDIATELY AFTER ) IN MACRO CALL, ELSE NO COMMENT.

DEFINE	CDB (N)	<

;CONSTANTS IN GETTAB UUO.(NOT CLEARED AT STARTUP OR 143 RESTART)

DEFINE NXTCPU(L)<
IFG <M.CPU-N-1>,<XWD .C'L'CDB,0>
IFE <M.CPU-N-1>,<0>>
C	(CDB,N,Y,<NXTCPU(\<N+1>)>);	;(0) LH=ADR OF NEXT CDB, RH=0
C	(ASN,N,Y,M.C'N'SN);		;(1) APR SERIAL NO.
C	(OK,N,Y,1);			;(2) THIS CPU RUNNING OK.
					;IF GREATER THAN 0, THIS CPU HAS STOPPED
					;RUNNING CORRECTLY.  CONTENTS ARE NO. OF
					;JIFFIES CPU HAS BEEN STOPPED.
C	(EPT,N,Y,.E'N'MP);		;(3)CONTAINS TRAP OFFSET
					; NEEDED FOR TWO CPUS INTERRUPT LOCATIONS
					; DEFAULT VALUES FOR .C0TOS==0,.C1TOS==100.
					; MONGEN ALLOWS CHANGE.

DEFINE CPUNAM<
SIXBIT	/CPU'N/>

C	(LOG,N,Y,<CPUNAM>);		;(4) LOGICAL CPU NAME (CPUN)
DEFINE KI<
	SIXBIT	/CPI'N/>
DEFINE KL<
	SIXBIT	/CPL'N/>
DEFINE KS<
	SIXBIT	/CPS'N/>
C	(PHY,N,Y,<KILS>);		;(5) PHYSICAL CPU NAME (CPXN)
IFN M.KI10,<CPTYP==CT.KI>
IFN M.KL10,<CPTYP==CT.KL>
IFN M.KS10,<CPTYP==CT.KS>
C	(TYP,N,Y,CPTYP);	;(6) TYPE OF PROCESSOR RH DEC, LH CUSTOMERS
.XX==<M.CBAT-1>B8+.CPBAT-.CPVBG	;DEFINE BITS 0-8 = MAX. REL. ENTRY
				; RH=REL ADR IN VAR CDB GETTAB
C	(MPT,N,,<.XX>)
				;(7) POINTER TO BAD ADR SUB-TABLE.
				; BITS 0-8 LENGTH OF SUB-TABLE
				; RH=REL. ADR. OF SUB-TABLE (IN CDB VARIABLE AREA)
				; (SEE .CPBAT)

C	(RTC,N,,C'N'RTC##);	;(10) REAL TIME CLOCK (DK10) DDB

C	(RTD,N,,C'N'RTD##);	;(11) DK10 DDB IF HI PREC TIME ACCT.
				;   0 IF LOW PREC. (APR CLOCK)

.XX==<.CPPRL-1>B8+.CPLPA-.CPVBG	;DEFINE BITS 0-8 = MAX. REL. ENTRY
				; RH = REL ADR IN VAR CDB GETTAB
C	(PAR,N,,<.XX>)
				;(12) REL PTR AND LENGTH TO PARITY
				; SUB-TABLE IN VARIABLE GETTAB. 0 IF FEATURE
				; NOT PRESENT

IFE FTRSP,<XP .CPAOR,.CPVBG>	;NO SUB-TABLE IF NO RESPONSE STUFF
IFE FTRSP,<XP .CPRSL,1>		;MAX IS 0
.XX==<.CPRSL-1>B8+.CPAOR-.CPVBG	;DEFINE BITS 0-8 = MAX REL. ENTRY,
				; RH = REL ADR IN VAR. CDB. GETTAB
C	(RSP,N,,<.XX>)
				;(13) REL PTR AND LENGTH TO RESPONSE
				; SUB-TABLE IN VARIABLE GETTAB.
				; 0 IF FEATURE NOT PRESENT
C	(DKX,N,,M.RT'N);	;(14) NUMBER OF DK10'S ON THIS CPU

IFN M.KL10,<.XX==M.EBPS>
IFN M.KI10!M.KS10,<.XX==0>

C	(EBS,N,,<.XX>);		;(15)EBOX TICKS PER SECOND

IFN M.KL10,<.XX==M.MBPS>
IFN M.KI10!M.KS10,<.XX==0>

C	(MBS,N,,<.XX>);		;(16)MBOX TICKS PER SECOND
.XX==<.CPNML-1>B8+.CPLNA-.CPVBG	;DEFINE BITS 0-8 LENGTH.
C	(NMT,N,,<.XX>);		;(17)POINTER TO NXM SUBTABLE
.XX==<.CPCSL-1>B8+.CPAPD-.CPVBG	;LENGTH OF CPU STATUS BLOCK
C	(CSB,N,,<.XX>);		;(20)POINTER TO CPU STATUS BLOCK
.XX==<.CPDVL-1>B8+.CPDVS-.CPVBG ;LENGTH OF DEVICE STATUS BLOCK
C	(DSB,N,,<.XX>);		;(21)POINTER TO DEVICE STATUS BLOCK
IFE M.KL10,<.XX==0>		;NO SUBTABLE IF NOT A KL
IFN M.KL10,<
.XX==<.CPSDL-1>B8+.CPSBD-.CPVBG ;LENGTH OF SBDIAG SUBTABLE
>
C	(SDP,N,,<.XX>);		;(22) POINTER TO SBDIAG SUBTABLE (KL ONLY)
IFE	M.KL10&FTRSP,<.XX==0>	;ONLY KL-10'S HAVE PERF METER
IFN	M.KL10&FTRSP,<
.XX==<BPATLN*4>B8+.CPBPV-.CPVBG>;SIZE FOR PERF BACKGROUND TABLE
C	(BPA,N,,<.XX>);		;(23) PERF ANAL NUMBERS SUBTABLE POINTER

;ADD CONSTANTS TO BE PUBLISHED ABOVE HERE:
;UNPUBLISHED CONSTANTS:

C	(MAP,N,Y,.E'N'MAP);		;ADDRESS OF THIS CPU'S EXEC MAP
IFN FTKL10&FTKLP,<
C	(SPT,N,Y,<EXP NLUPMP/PAGSIZ>);	;SPECIAL PAGES TABLE
C	(XPT,N,Y,0)			;TEMP STORAGE FOR ABOVE
>
ifn ftmp,<
c	(chx,n,y,<exp tkschx##_'n>)
>
C	(CPN,N,Y,<EXP N>);		;CPU NUMBER
DEFINE CPUDEF(M)<
	IFE N,<
		IFE M,<CAIA>
		IFN M,<CAI>>
	IFN N,<
		IFN M,<CAIA>
		IFE M,<CAI>>
	>
C	(SK0,N,Y,CPUDEF(0));		;GENERATE SKIP FOR "SKPCPU(0)"
C	(SK1,N,Y,CPUDEF(1));		;AND FOR "SKPCPU(1)" **MAINTAIN ORDER**
C	(OK1,N,Y,.C0OK);		;CONTAINS ADR OF OTHER CPU
					; OK WORD. SEE .CPOK ABOVE.
C	(SLF,N,Y,.C'N'CDB);		;POINTER TO START OF CDB

DEFINE SCNLOC<
IFE N,<SSCAN>
IFN N,<SSCAN1>>
C	(SCN,N,Y,<SCNLOC>);		;CONTAINS ADR OF SCHEDULER RUN QUEUE SCAN LIST
IFN FTNSCHED,<
DEFINE SCN<
IFE N,<SSSCAN>
IFN N,<SSSCN1>
>
C	(SST,N,Y,<SCN>);
>
DEFINE PDLDEF(LEN)<
IFE N,<XWD LEN,NULPDL>
IFN N,<XWD LEN,NU'N'PDL>>
C	(NPD,N,Y,<PDLDEF(MNULPD)>);	;CONTAINS NULL PDL PTR
DEFINE PDLDEF(LEN)<
IFE N,<XWD LEN,ERRPDL>
IFN N,<XWD LEN,ER'N'PDL>>
C	(EPD,N,,<PDLDEF(ERRPLL)>);	;CONTAINS ERR PDL PTR
					; ERROR IN NULL JOB
C	(NJD,N,Y,NU'N'DAT);		;CONTAINS ADR OF NULL JOB DATA AREA. OFFSET BY 20
					; USED TO SAVE ACS IN 20-37.
C	(STO,N,,SC'N'TIC##)		;SCANNER ONCE A TICK ROUTINE FOR THIS CPU
C	(ISR,N,,SC'N'SEC##)		;SCANNER ONCE A SECOND
IFN FTMP,<
C	(DLK,N,,-1)			;USED FOR CALLING DSKLOK WHEN ALREADY HAVE IT
C	(SCD,N,Y,-1)			;PER CPU SCHEDULER INTERLOCK FLAG
C	(RES,N,,<HALT AP'N'RES>)	;RESTORE AFTER POWER FAIL
C	(NBI,N,,0)			;NUMBER OF INTERLOCKS THAT WERE OWNED
					; BY THIS CPU AND BROKEN BY BRKLOK
IFG <CPUN-1>,<
C	(ABK,N,,AP'N'BCK)		;RETURN ADDRESS FOR CPNBPT
>
>
IFN FTKL10!FTKS10,<
C	(KAF,N,,AP'N'KAF)		;CPU DEPENDANT KEEP-ALIVE FAILURE
					;DISPATCH ADDRESS
>

;APR DEPENDENT CONSO AND CONO BITS

C	(NAP,N,Y,A'N'.NOT);		;CONTAINS ALL PIS IN PROGRESS EXCEPT APR PI
					; ON THIS CPU. (NOT APR PI)
C	(APP,N,,A'N'.APP);		;APR PI IN PROGRESS
A'N'.XXX==AP'N'CHN
IFN M.KI10,<A'N'.XXX==A'N'.XXX+AP'N'CHN_3>
C	(API,N,Y,<A'N'.XXX>);		;APR PI CHANNEL FOR THIS CPU
C	(ACO,N,,A'N'.ACO);		;APR PI CHANNEL ON
C	(CHL,N,,<EXP AP'N'CHL>);	;ADDRESS OF INTERRUPT PC FOR APR LEVEL
C	(CKL,N,Y,<EXP CK'N'CHL>);	;ADDRESS OF INTERRUPT PC FOR CLOCK LEVEL
IFN M.KI10,<
AN.XXX==IP.TTO+IP.PAR+IP.PWF+XP.CLK+IP.NXM
>
IFN M.KL10,<
AN.XXX==LP.PAR+LP.PWF+LP.SBE+LP.NXM+LP.IOF+LP.CDP+LP.ADP
>
IFN M.KS10,<
AN.XXX==SP.PWF+SP.ITI+SP.FEI
>
C	(CON,N,,AN.XXX);		;APR CONSO MASK

IFN M.KI10,<AN.XXX==IP.NXM+XP.CLK+IP.TTO+IP.PAR+IP.PWF+IP.IOF>
IFN M.KL10,<AN.XXX=LP.NXM+LP.SBE+LP.PAR+LP.PWF+LP.IOF+LP.CDP+LP.ADP+LP.CSD>
IFN M.KS10,<AN.XXX==SP.PWF+SP.ITI+SP.FEI>

C	(EEB,N,,AN.XXX);		;EXEC ENABLED BITS

IFN CP0KIN,<A0.XXX==IP.CTE+IP.CAE+IP.ECI+IP.CIO+ip.cnm>	;Tummen mitt	[JMR]
IFN CP1KIN,<A1.XXX==IP.CTE+IP.CAE+IP.ECI+IP.CIO+ip.cnm>	; i handen!	[JMR]
IFN CP0KLN,<A0.XXX==LP.CSF+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.SBE+LP.CDP+LP.ADP>
IFN CP1KLN,<A1.XXX==LP.CSF+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.SBE+LP.CDP+LP.ADP>
IFN CP0KSN,<A0.XXX==SP.CSF+SP.PWF+SP.HMP+SP.NXM>

C	(IEF,N,,A'N'.XXX);		;MASK TO CLEAR ALL APR ERROR BITS

DEFINE KI,<CONO APR,XP.CCF>
DEFINE KL,<SETZM .CPTIM>
DEFINE KS,<SETZM .CPTIM>

C	(CCF,N,,<KILS>);		;CLEAR CLOCK FLAG INSTRUCTION

DEFINE KI,<CONSO APR,XP.CLK>
DEFINE KL,<SKIPN .CPTIM>
DEFINE KS,<SKIPN .CPTIM>

C	(HCT,N,,<KILS>);		;HAS CLOCK TICKED? (SKIP IF YES)

DEFINE KI<EXP CPIMPI##>
DEFINE KL<EXP CPLMPI##>
DEFINE KS<EXP CPSMPI##>

C	(MPI,N,,<KILS>);	;LH=0, RH=ADDRESS OF CPUN
				; PARITY SWEEP LOOP INSTRUCTION WHICH PICKS
				; UP MEMORY. USED BY APR PI INTERRUPT TO
				; CHECK FOR EXPECTED BAD PARITY IN SWEEP

DEFINE KI<EXP CP.PXX+CP.PS'N'+CPIMPS##>
DEFINE KL<EXP CP.PXX+CP.PS'N'+CPLMPS##>
DEFINE KS<EXP CP.PXX+CP.PS'N'+CPSMPS##>

C	(MPS,N,,<KILS>);	;RH=ADR OF MEMORY PARITY/NXM SCAN ROUTINE
				;LH=BITS TO REQUEST SCAN BY THIS CPU
DEFINE KI<EXP IP.NXM>
DEFINE KL<EXP LP.CSF+LP.NXM>
DEFINE KS<EXP SP.CSF+SP.NXM>

C	(NXM,N,,<KILS>);		;MASK TO TEST/CLEAR APR NXM ERROR

DEFINE KI<EXP IP.PAR>
DEFINE KL<EXP LP.CSF!LP.PAR>
DEFINE KS<EXP SP.CSF!SP.HMP>

C	(MPE,N,,<KILS>);		;MASK TO TEST/CLEAR APR PARITY ERROR
	DEFINE	EVENTM(LIST),<
	NARGS==0
	IRP LIST,<NARGS==NARGS+1>
	IFG NARGS*M.CPU-^D36,<PRINTX ?DOORBELL BIT OVERFLOW>
	ZZ==0
	IRP LIST,<
	XX1==0
	XX2==ZZ
	XX3==0
	REPEAT M.CPU,<
		IFN <N-XX3>,<XX1==XX1!1B<XX2>>
		XX3==XX3+1
		XX2==XX2+NARGS>
.C'N''LIST'S:	EXP	XX1
.C'N''LIST'C:	EXP	1_<^D36-<<N+1>*NARGS>+<NARGS-ZZ>-1>
.CP'LIST'S==:.C0'LIST'S-.C0CDB+.EPCDB
.CP'LIST'C==:.C0'LIST'C-.C0CDB+.EPCDB
	ZZ==ZZ+1
	>
.C'N'DBM:	EXP	<<1_NARGS>-1>_<^D36-<<N+1>*NARGS>>
.CPDBM==:.C0DBM-.C0CDB+.EPCDB
>
	EVENTM (<SC,QP>)
INTERN .C0QPC

IFN M.KI10,<
DEFINE EPMDEF,<
IFE N,<PG.LEB+PG.EAT+EPMPA>
IFN N,<PG.LEB+PG.EAT+E'N'MPA>>
>
IFN M.KL10,<
DEFINE EPMDEF,<
IFE N,<LG.TEN+EPMPA+IFN FTKLP,<LG.KLP>>
IFN N,<LG.TEN+E'N'MPA+IFN FTKLP,<LG.KLP>>>
>
IFN M.KS10,<
DEFINE EPMDEF,<
IFE N,<SG.TEN+EPMPA>
IFN N,<SG.TEN+E'N'MPA>>
>
C	(EBR,N,Y,<EPMDEF>);	;EXEC BASE REGISTER ON THIS CPU
IFN M.KS10,<
C	(FEF,N,,0);		;FRONT END FLAG-SET NON-ZERO WHEN FE INTERRUPTS
>
C	(CTN,N,Y,CT'N'LIN);	;RH = CTY NUMBER FOR THIS CPU
				;LH = DLS LINE NUMBER ON DTE
IFN M.KL10,<
C	(DTN,N,Y,M'N'DTEN);	;NUMBER OF DTES ON THIS CPU
>;END IFN M.KL10
C	(CAC,N,Y,0);		;DEFINE CRASH AC'S IN CPU DATA BLOCK
.C'N'CA0=.C'N'CAC
BLOCK	17
C	(STT,N,Y,0)		;TEMP USED BY K?SER FOR TRAP PROCESSING
;THE FOLLOWING TWO ENTRIES (.CPST1 & .CPST2) MUST BE CONTIGUOUS
C	(ST1,N,Y,0)		;PLACE TO SAVE T1 ON PAGE TRAPS
C	(ST2,N,Y,0)		;PLACE TO SAVE T2 ON PAGE TRAPS
;THE FOLLOWING FOUR ENTRIES (.CPEJ1 TO .CPEJ4) MUST BE CONTIGUOUS
C	(EJ1,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
C	(EJ2,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
C	(EJ3,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
C	(EJ4,N,Y,0)		;TEMP USED BY K?SER FOR IME PROCESSING
IFN FTRTTRP,<
IF1,<
C	(RCT,N,Y,0)		;REAL TIME PI CHANNEL TABLE
BLOCK	5
C	(RDT,N,N,0)		;REAL TIME DISMISS TABLE
BLOCK	5
>
IF2,<
	ZZ==10*N+1

	DEFINE	BLDTB1(ZZ)
	<IFNDEF UNIQ'ZZ,<BLDTB2(ZZ)>
	IFDEF	UNIQ'ZZ,<IFE UNIQ'ZZ,<BLDTB2(ZZ)>
				IFN UNIQ'ZZ,<EXP 0>>>

	DEFINE	BLDTB2(ZZ)
	<IFN CUSD'ZZ,<EXP CH'ZZ>
	IFE	CUSD'ZZ,<XWD 400001,CH'ZZ>>

	DEFINE	BLDTB3(ZZ)
	<IFDEF CHND'ZZ,<XWD RTSV'ZZ,CHND'ZZ>
	IFNDEF	CHND'ZZ,<EXP 0>>

REPEAT 6,<
	BLDTB1(\ZZ)
	ZZ==ZZ+1>

	ZZ==10*N+1


REPEAT 6,<
	BLDTB3(\ZZ)
	ZZ==ZZ+1>
>>
C	(CPI,N,Y,0);		;PI STATUS
;**** KEEP THE FOLLOWING TWO LOCATIONS TOGETHER
C	(SVA,N,,0)		;JSR HERE TO SAVE ALL AC SETS
C	(SVB,N,,<JRST SVSETS>)	;WHERE TO GO TO DO THE WORK
;**** END OF KEEP TOGETHER
C	(TRP,N,Y,0);		;MUUO DURING CRASH
C	(RTS,N,,0)		;TEMP USED DURING RTTRP ERROR PROCESSING
C	(RTT,N,Y,0);		;RTTRP IN PROGRESS FLAG (DEFINED
				; HERE BECAUSE IT MUST BE 0 DURING ONCE-ONLY)
C	(TML,N,,0)		;VALUE OF "TIME" AT LAST CLOCK TIC
				; USED FOR TIMING FUNCTION, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
				; MUST BE DEFINED HERE SINCE INITIALIZED BY SYSINI
C	(OCB,N,,0)		;0 IF THIS CDB ISN'T OWNED BY ANY CPU
C	(AID,N,,0)		;-1 IF RESTART AS OPPOSED TO INITIAL STARTUP
C	(DWD,N,,-1)		;RECURSION INTERLOCK FOR DIE
IFE FTKS10,<
DEFINE SAVPIS(C,A,B)<
	IFN C,<	XWD SAV'C'A,SAV'C'B>
	IFE C,<XWD SAV'A,SAV'B>
>
IF1,<C	(SAV,N,,0)>
IF2,<
C	(SAV,N,,SAVPIS(N,\TAPCHN,\DSKCHN)) ;PI SAVE ROUTINES.
>
C	(ACD,N,,<-1>)	;AUTCON HAS RUN ON THIS CPU. ZEROED
IFN FTMP,<
DEFINE INTLTP(C,A)<
	IFN C,<EXP INTL'C'A>
	IFE C,<EXP INTL'A>
>
IF1,<C	(TIL,N,,0)>
IF2,<
C	(TIL,N,,INTLTP(N,\TAPCHN))
>
>
>
IFN FTAUTC,<
IFNDEF CP'N'NRP,<CP'N'NRP==7*N>	;RESERVE 7 CHANNELS PER CPU FOR RP04 CHANNELS
IFNDEF CP'N'NRN,<CP'N'NRN==7*N>	;RESERVE 7 CHANNELS PER CPU FOR RP20 CHANNELS
IFNDEF CP'N'NTP,<CP'N'NTP==7*N>	;RESERVE 7 CHANNELS PER CPU FOR TAPES
DEFINE NUM(C)<	BYTE (12)	CP'C'NRP,CP'C'NRN,CP'C'NTP>
C	(NUM,N,,NUM(N))		;STARTING RP, RN, MT LETTER (0=A, 1=B,...)
>	;END IFN FTAUTC
C	(CML,N,,0)		;LDB ADDRESS OF LINE ON WHICH COMMAND IS BEING
				; PROCESSED ON THIS CPU
DEFINE TAPCHL(C,A)<
	IFN C,<EXP CH'C'A>
	IFE C,<EXP CH'A>
>
IF1,<C	(TCH,N,,0)>
IF2,<
C	(TCH,N,,TAPCHL(N,\TAPCHN))	;CH'N USED FOR VECTORED TAPE INTERRUPTS
>
;CDB CONSTANTS FOR KL10 ERROR REPORTING/RECOVERY
IFN M.KL10,<
C	(SPR,N,,<CONO APR,LP.SSF+LP.PAR+AP'N'CHN>);
	;INSTRUCTION TO CAUSE PARITY ERROR INTERRUPT
C	(CPR,N,,<CONO APR,LP.CSF+LP.PAR+LP.SBE+AP'N'CHN>);
	;INSTRUCTION TO CLEAR PARITY ERROR FLAG(ALSO CLEARS SBUS ERROR-ON FOR SOME PARITY)
C	(SB0,N,,<100000,,0>)	;DO SBDIAG 0 HERE ON ERRORS
C	(S0A,N,,<0>)		;ANSWER RETURNED HERE
C	(SB1,N,,<100000,,1>)	;SBDIAG FN 1 DONE HERE
C	(S1A,N,,<0>)		;ANSWER RETURNED HERE


>;END IFN M.KL10


C	(TOA,N,,0)		;TYPE OUT ADDRESS FOR THIS CPU (OLD COMTOA)
C	(TIV,N,,0)		;ADDRESS OF VECTOR OF INPUT ROUTINES
IFN M.KL10,<
C	(NLD,N,,0)		;FLAG THAT SAYS WHETHER OR NOT TO DO AUTO
				;  RELOAD OF DX20'S.  0 TO ENABLE RELOADS,
				;  NON-ZERO TO DISABLE RELOADS
>
;EXEC DDT WORDS
C	(DDT,N,Y,<BPTNOP>)	;NOOP OR INSTRUCTION TO ENTER EDDT
				; THIS WORD MAY BE EXECUTED ANYTIME ANY
				; ROUTINE WANTS TO ENTER EDDT VIA THE
				; THE UNSOLICITED BREAKPOINT FACILITY.
				; SETUP BY CPUDDT.

;EXEC DATA VECTOR FOR EDDT SYMBOL TABLE HIDING

C	(EDV,N,Y,<XWD 'EDV',.EDLEN>);CODE,,LENGTH OF EXEC DATA VECTOR
C	(ED1,N,N,<0>)		;ADDRESS OF THE ADDRESS SWAPPING BLOCK
C	(ED2,N,N,<0>)		;RELOCATED CONTENTS OF .JBSYM
C	(ED3,N,N,<0>)		;RELOCATED CONTENTS OF .JBUSY
C	(ED4,N,N,<.CPHSF>)	;ADDRESS OF A WORD FOR DDT TO PLAY WITH
C	(ED5,N,N,<0>)		;CPU/PAGING/HARDWARE DATA
C	(ED6,N,N,<0>)		;PHYSICAL ADDRESS OF THE EPT
C	(ED7,N,N,<0>)		;PHYSICAL ADDRESS OF THE SPT
C	(ED0,N,N,<0>)		;PHYSICAL ADDRESS OF THE CST

C	(HSF,N,N,<0>)		;THE WORD ITSELF

C	(SYB,N,Y,<5>)		;LENGTH OF THE ADDRESS SWAPPING BLOCK
C	(SY1,N,N,<0>)		;NUMBER OF WORDS TO SWAP
IFN FTKLP,<
C	(SY2,N,N,<.E'N'MAP+<MONORG/1000>>) ;FIRST WORD TO SWAP
>
IFE FTKLP,<
C	(SY2,N,N,<.E'N'MP+<MONORG+1000>/2000>) ;FIRST WORD TO SWAP
>
C	(SY3,N,N,SYMBK1)	;PLACE WHERE NEW MAP MAY BE FOUND
C	(SY4,N,N,SYMBK2)	;PLACE TO SAVE OLD CONTENTS



CRSHAC==:.C0CAC
CRSHPI=.C0CPI
.CPCLN==.-.C0CDB		;LENGTH OF CONSTANTS AREA
XP .CPPCL,<<.C0CPN-.C0CDB>B26>	;PUBLISHED CPU DEPENDANT CONSTATNS LENGTH
				;SHIFTED LEFT 9 BITS FOR GETTAB TABLE
;VARIABLES AREA FOR CPU 0 CDB (ALSO DEFINED SYMBOLS FOR CPU 1)

;OLD NSWTBL GETTAB
;HAS SOME VARIABLES WHICH ARE SYSTEM RATHER THAN CPU DEPENDENT.
;HOWEVER FOR COMPATIBILITY, THEY ARE KEPT TOGETHER.
;.SYTBL HAS NEW SYSTEM VARIABLES DEFINED AFTER 5.03 RELEASE
IFE N,<
XP NSWTBL,.-10		;GETTAB TABLE NO 12. VARIABLES PERTAINING
			; TO SWAPPING AND NON-SWAPPING SYSTEMS.
			; FIRST 10 LOCATION NO LONGER USED.
			;THE NUMBERS IN () ARE FOR NEW CPU DEPENDENT
			; GETTAB TABLE .GTC0V.
>

LOC==.			;START LOC AT ABS. BEG OF VARIABLE AREA
			; LOC USED IN V MACRO AS A LOCATION COUNTER
V	(VBG,N,Y,,0) ;BEGINNING OF VARIABLE AREA FOR CPU 0

V	(,N,,CORMAX);	;(0)(REALLY SYSTEM VAR.) MAXIMUM CORE REQUEST+1 (IE LARGEST REL. ADR,+1)
			; CAN BE RESTRICTED TO LESS THAN ALL OF USER CORE
			; BY BUILD AND/OR ONCE
V	(,N,,CORLST);	;(1)(REALLY SYSTEM VAR.) 1 BIT BYTE POINTER TO LAST FREE
			; BLOCK POSSIBLE SET BY SYSINI ON 143 STARTUP
V	(,N,,CORTAL);	;(2)(REALLY SYSTEM VAR.) TOTAL NUMBER OF
			; FREE+DORMANT+IDLE CORE BLKS LEFT
V	(,N,,SHFWAT);	;(3)(REALLY SYSTEM VAR.) JOB NUMBER SHUFFLER
			 ;HAS TEMPORARILY STOPPED FOR ITS I/O DEVICES TO
			; BECOME INACTIVE BEFORE SHUFFLING
V	(,N,,HOLEF);	;(4)(REALLY SYSTEM VAR.) ABSOLUTE ADDRESS OF
			; LOWEST HOLE IN CORE, 0=NONE
V	(UPT,N,Y)	; ;(5) UPTIME FOR THIS CPU. NO OF CLOCK TICKS
			; SINCE SYSTEM LOADED OR RESTARTED AT 143
V	(,N,,SHFWRD);	;(6)(REALLY SYSTEM VAR.) TOTAL NUMBER OF WORDS
			; SHUFFLED BY SYSTEM
V	(,N,,STUSER);	;(7)(REALLY SYSTEM VAR.) JOB CURRENTLY USING THE
			; SYSTEM TAPE NEEDED SO CONTROL C WILL NOT TIE
			; UP SYSTEM TAPE
V	(,N,,HIGHJB);	;(10)(REALLY SYSTEM VAR.) HIGHEST JOB NUMBER
			; CURRENTLY ASSIGNED
V	(,N,,CLRWRD);	;(11)(REALLY SYSTEM VAR.) TOTAL NUMBER OF WORDS
			; CLEARED BY 'CLRCOR' RTN.
V	(LST,N,,LSTWRD);	;(12)LOST TIME ON THIS CPU.  TOTAL NUMBER OF
			; CLOCK TICKS WHEN NULL JOB RAN BUT OTHER JOBS
			; WANTED TO RUN AND COULD NOT DO SO BECAUSE: ---
			;  1. SWAPPED OUT OR ON WAY IN OR OUT
			;  2. MONITOR WAITING FOR I/O TO STOP SO IT
			;     CAN SHUFFLE OR SWAP
			;  3. JOB BEING SWAPPED OUT BECAUSE IT IS
			;     EXPANDING CORE
V	(,N,,MEMSIZ);	;(13)(REALLY SYSTEM VAR.) SIZE OF PHYSICAL MEMORY
			; IN WORDS (=FIRST NON EXIST WORD) SET BY SYSINI ON
			; 143 RESTARTS UNLESS SYMBOLS SAVED BY PATCHING
			; SYSLIM SMALLER.
V	(TPE,N);	;(14)TOTAL PARITY ERROR WORDS IN MEMORY DETECTED ON
			; DURING ALL CPU SWEEP WHILE PROCESSOR WAS IN EXEC OR USER MODE.  IF
			; SYSTEM HALTS,N, THIS LOC IS ALREADY UPDATED
V	(SPE,N);	;(15)TOTAL NON-REPRODUCING PARITY ERRORS IN MEMORY.
			; DETECTED ON THIS CPU.  IE ONES WHICH DID NOT
			; REOCCUR WHEN SAME CPU SWEPT THRU CORE.
			; CAN BE READ-PAUSE-WRITE WHICH REWRITES MEMORY
			; SO STILL A PARITY ERROR
			; OR CHANNEL DETECTED PARITY WHICH APR SWEEP DID
			; NOT FIND - SEE .CPPCS
V	(MPC,N,Y);	;(16)MEMORY PARITY CONTINUES FOR THIS CPU.
			; COUNT OF NUMBER OF TIMES OPERATOR PUSHED CONTINUE
			; AFTER SERIOUS MEMORY PARITY HALT
			; LH = -1 IF SERIOUS ERROR ON THIS BAD PARITY (MUST HALT)
			; LH CLEARED ON CONTINUE OR STARTUP.
V	(MPA,N,Y);	;(17)MEMORY PARITY ADDRESS FOR THIS CPU.
			; FIRST BAD PHYSICAL MEMORY ADDRESS FOUND WHEN
			; WHEN MONITOR SWEPT THRU CORE AFTER PROCESSOR
			; DETECTED FIRST BAD PARITY
V	(MPW,N,Y);	;(20)MEMORY PARITY WORD FOR THIS CPU.
			; CONTENTS OF FIRST BAD WORD FOUND BY MONITOR WHEN
			; MONITOR SWEPT THRU CORE AFTER FIRST PARITY
V	(MPP,N,Y);	;(21)MEMORY PARITY PC FOR THIS CPU.
			; PC OF LAST MEM PARITY (NOT COUNTING SWEEP THRU CORE)
V	(,N,,EPOCNT);	;(22)(REALLY SYSTEM VAR)
			; # OF PDL OVF'S AT UUO LEVEL IN EXEC MODE NOT
			; RECOVERED
V	(,N,,EPOREC);	;(23)(REALLY SYSTEM VAR) # OF PDL OVF'S AT
			; UUO LEVEL IN EXEC MODE RECOVERED
V	(,N,,MAXMAX);	;(24)(REALLY SYSTEM VAR) HIGHEST LEGAL VALUE OF CORMAX
V	(,N,,SYSKTM);	;(25)(REALLY SYSTEM VAR) COUNT-DOWN TIMER FOR SET
			; KSYS COMMAND
V	(,N,,CORMIN);	;(26)(REALLY SYSTEM VAR) LOWER BOUND ON CORMAX,
			; LOKCON WILL NEVER ALLOW CORMAX TO BECOME
			; SMALLER THAN THE CONTENTS OF THIS LOCATION
V	(ABC,N,Y);	;(27)ADDRESS BREAK COUNT ON THIS CPU.
V	(ABA,N,Y);	;(30)ADDRESS BREAK ADDRESS ON THIS CPU.
			; STORAGE FOR DATA SWITCHES ON ADDRESS BREAK
			; INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
			; TO USERS IN NON-SWAP AND SWAP SYSTEMS
V	(LJR,N);	;(31)LAST JOB RUN ON THIS CPU.  JOB IS COPIED
			; TO .CPLJR WHENEVER JOB IS CHANGED (INCLUDING TO
			; NULL JOB) - FTTRACK COND.
V	(ODA,N,,,3)	; OBSOLETE (MOVED TO RESPONSE SUBTABLE)
IFE N,<
XP NSWMXL,<<.-NSWTBL-1>B26>	;MAX. NSWTBL ENTRY SHIFTED LEFT 9 BITS.
>
			; NEW ENTRIES ARE ADDED BEYOND END OF NSWTBL END.
			; SO NSWTBL IS NO LONGER ACTIVE.  INSTEAD
			; CPU DEPENDENT GETTAB .GTC0V SHOULD BE USED.
V	(STS,N,Y);	;(35)STOP TIME SHARING ON THIS CPU.
			; CONTAINS JOB NO. WHICH DID TRPSET UUO.
V	(RUN,N,Y);	;(36)OPERATOR CONTROLLED SCHEDULING FOR THIS CPU
			; AS SET BY PRIVILEGED .STRUN
			; FUNCTION OF SETUUO.  (SEE OPSER :SET RUN COMMAND).
			; SIGN BIT=0 MEANS RUN JOBS ON THIS CPU.
			; SIGN BIT=1 MEANS DO NOT RUN JOBS ON THIS CPU.
			; EXCEPT UUOS ON MASTER.  REST OF BITS
			; RESERVED FOR FUTURE SCHEDULING PARAMETERS.
			; RESET TO 0 ON 143 RESTART
V	(NUL,N);	;(37) CONTAINS THE NULL TIME FOR THIS CPU
			;IN JIFFIES
V	(EDI,N);	;(40) NO. OF EXEC. DON'T CARE
			; INTERRUPTS. IE USER ENABLED APR
			; INTERRUPTS WHICH MONITORS CAUSES (AOV,N,FOV)
			; LH = EXEC PC SO WE CAN FIX
			; INEFFICIENT CODE
V	(JOB,N,Y);	;(41) CURRENT JOB ON THIS CPU. REFERENCED
			; AS BOTH .CPJOB AND JUST JOB THROUGHOUT MONITOR.
			;MAKE AVAILABLE FOR SNOOPY
V	(OHT,N);	;(42) CONTAINS THE OVERHEAD TIME
			; FOR THIS CPU IN JIFFIES.
			; INCLUDES CLOCK QUEUE PROCESSING,N, SHORT COMMAND PROCESSING,
			; SWAPPING & SCHEDULING DECISIONS, SOFTWARE CONTEXT SWITCHING
			; DOES NOT INCLUDE UUO EXECUTION
			; SINCE THAT IS NOT REALLY OVERHEAD

V	(EVM,N,Y);	;(43) THE MAXIMUM AMOUNT OF EXEC VIRTUAL
			; ADDRESS SPACE ALLOWED TO BE USED FOR
			; MAPPING USER SEGMENTS IN EXEC MODE
			; BY THE LOCK UUO.

V	(EVU,N,Y);	;(44) THE TOTAL AMOUNT OF EXEC VIRTUAL
			; ADDRESS SPACE CURRENTLY BEING USED
			; TO MAP USER SEGMENTS.
V	(LLC,N,Y);	;(45) LOCK LOOP COUNT. NO. OF TIMES
			; THIS CPU HAS LOOPED
			; WAITING FOR OTHER CPU
V	(TUC,N,Y);	;(46) TOTAL NO. OF UUOS FROM
			; EXEC AND USER MODE ON THIS CPU
			; SINCE SYSTEM WAS STARTED.
			; INCLUDES TRAPS TO 60 EXCEPT UJEN.
			; (DO NOT COUNT TRAPS ON CPU1 ON CPU0 ALSO)
V	(TJC,N);	;(47) TOTAL JOB CONTEXT-SWITCHES
			; COUNT FOR THIS CPU INCLUDING
			; NULLJOB SINCE SYSTEM WAS
			; STARTED. COUNT ONE EACH TIME
			; NEW JOB IS DIFFERENT FROM OLD ONE
V	(TNE,N);	;(50) TOTAL NXM'S THIS CPU
V	(SNE,N);	;(51) TOTAL NON-REPRODUCIBLE NXM'S THIS CPU
V	(NJA,N);	;(52) TOTAL JOBS CRASHED THIS NXM
V	(MNA,N,Y);	;(53) FIRST ADDRESS FOUND WITH NXM
V	(EBJ,N,Y);	;(54)EBOX TICKS/JIFFY (ONCE COMPUTED)
V	(MBJ,N,Y);	;(55)MBOX TICK/JIFFY
V	(PBA,N,Y);	;(56)PHYSICAL ADDR WITH BAD PARITY ON LAST AR/ARX
			;  PARITY TRAP
V	(TBD,N,Y);	;(57)CONTENTS OF BAD WORD ON LAST AR/ARX
			;  PARITY TRAP
V	(TGD,N,Y);	;(60)GOOD CONTENTS OF WORD AFTER WE RECOVERED
			; AR/ARX PARITY TRAP
V	(NPT,N,Y);	;(61)TOTAL NUMBER OF AR/ARX PARITY TRAPS
V	(AER,N,Y);	;(62)RESULTS OF RDERA ON PARITY/NXM INTERRUPT
V	(PEF,N,Y);	;(63)RESULTS OF CONI APR, ON PARITY/NXM INTERRUPT
V	(PSB,N,Y,,4);	;(64-67)OBSOLETE
V	(PPC,N,Y);	;(70)PC ON LAST AR/ARX PARITY TRAP
V	(PFW,N,Y);	;(71)PAGE FAIL WORD ON LAST AR/ARX PARITY TRAP
V	(HPT,N);	;(72)NUMBER OF HARD AR/ARX PARITY TRAPS
V	(SAR,N);	;(73)NUMBER OF SOFT AR/ARX TRAPS
V	(PTP,N);	;(74)NUMBER OF PAGE TABLE PARITY TRAPS
V	(CSN,N,Y);	;(75)NUMBER OF CACHE SWEEPS STARTED (CACHE SWEEP SERIAL NUMBER)
V	(CLN,N);	;(76)NUMBER OF TIMES SCHEDULER SKIPPED OVER A JOB BECAUSE CACHE
			; SWEEP HAD TO BE DONE FIRST
V	(CLT,N);	;(77)AMOUNT OF TIME IN JIFFIES THAT CPU RAN NULL JOB BECAUSE OF STATE OF CACHE
V	(CSD,N);	;(100)CACHE - SWAPPER DELAY COUNT-INCREMENT ON 1088
			; SYSTEMS IF SWAPPER HAS TO WAIT FOR ANOTHER CPU
			; TO SWEEP ITS CACHE BEFORE IT CAN START I/O
V	(CRN,N);	;(101)CACHE SWEEP REQUEST SWEEP COUNT (SIC)
			; COMMANDING THIS VALUE TO .CPCSD+.CPCLN (NUMBER
			; OF SWEEP REQUESTS MADE) WILL INDICATE TO WHAT EXTENT
			; THE REQUEST SCHEME IS A BOTTLENECK

V	(CEC,N,Y);	;(102)COUNT OF NON-RECOVERABLE AR/ARX
			; PARITY ERRORS WHICH INVOLVED CACHE.  AFTER 3
			; SUCH FAILURES CACHE IS TURNED OFF IN TRAP
			; ROUTINE WITH APPROPRIATE MESSAGE TO OPERATOR.
V	(PTR,N,Y);	;(103)RETRY WORD FOR AR/ARX PARITY TRAP
			; ROUTINE.  INCLUDES STATUS FLAGS IN LH AND
			; RETRY COUNT IN RH.
V	(TSD,N,Y);	;(104)AR/ARX TRAP ROUTINE HAS ALREADY
			; SAVED APR.ERA.SB DIAGS ETC FOR ERROR REPORTING.
			; WON'T BE DONE AGAIN AT APR INTERRUPT
V	(REP,N,Y);	;(105)USED BY PARITY/NXM RECOVERY ROUTINES
			; TO DETERMINE WHICH TYPE ERRORS SHOULD BE LISTED.
V	(NDB,N)		;(106)NUMBER OF TIMES THIS CPU'S DOORBELL WAS RUNG
V	(SBR,N)		;(107) CPU/DEVICE STATUS BLOCKS READ ON THIS CPU
			;LH=UNUSED
			;RH=BITS TELLING WHICH STATUS BLOCKS HAVE BEEN
			;READ ON THIS CPU.  SEE DEFINITIONS FOR SR.XXX IN S.
V	(BPF,N,Y);	;(110) BACKGROUND PERFORMANCE ANALYSIS FLAG
			;.LT. 0 IF METER ENABLED (SINCE COUNTED UP AT
			; CLOCK LEVEL INDEPENDENTLY ON EACH CPU PROGRAMS
			; SHOULD CHECK FOR .LE. 0)
V	(FBI,N)		;(111) FILE BLOCKS INPUT (READ)
V	(FBO,N)		;(112) FILE BLOCKS OUTPUT (WRITTEN)
V	(SBI,N,Y)	;(113) SWAPPING BLOCKS INPUT (READ)
V	(SBO,N,Y)	;(114) SWAPPING BLOCKS OUTPUT (WRITTEN)
V	(SNC,N)		;(115) NUMBER OF CPU STOPCDS
V	(SND,N)		;(116) NUMBER OF DEBUG STOPCDS
V	(SNJ,N)		;(117) NUMBER OF JOB STOPCDS
V	(SJN,N)		;(120) JOB NUMBER OF LAST STOPCD
V	(SNM,N)		;(121) LH=NAME OF LAST STOPCD
			;      RH=PC+1 OF LAST STOPCD
V	(SPN,N)		;(122) PROGRAM RUNNING AT LAST STOPCD
V	(SPP,N)		;(123) PPN RUNNING AT LAST STOPCD
V	(STN,N)		;(124) TTY NAME AT LAST STOPCD
V	(SUP,N)		;(125) USER PC AT TIME OF LAST STOPCD
V	(SUU,N)		;(126) UUO AT TIME OF LAST STOPCD
V	(EJN,N)		;(127) JOB NUMBER AT LAST PARITY/NXM ERROR
V	(EPN,N)		;(130) PROGRAM NAME AT LAST PARITY/NXM ERROR
V	(PPI,N)		;(131) RESULTS OF CONI PI, ON PARITY/NXM INTERRUPT
V	(TPI,N)		;(132) RESULTS OF CONI PI, ON PARITY/NXM TRAP
			; IF SWEEP IS AT APR LEVEL, CH7 LEVEL ALWAYS
			; REPORTED NXM ERROR REGARDLESS OF WHY THE SWEEP WAS DONE.
V	(RSI,N)		;(133) NUMBER OF TIMES SCHEDULER INTERLOCK WAS
			; REQUESTED WHEN NOT OWNED.
V	(TFI,N)		;(134)NO OF TAPE FRAMES READ ON THIS CPU
V	(TFO,N)		;(135)NO OF TAPE FRAMES WRITTEN ON THIS CPU

;**********************************************************************
;PUT NEW PUBLISHED VARIABLES ABOVE HERE
;**********************************************************************
;PUT NEW PUBLISHED SUB-TABLES BELOW HERE (SO LAST BUT STILL
;**********************************************************************
; INSIDE LEGAL RANGE OF VARIABLE GETTAB FOR THIS CDB
;**********************************************************************

;MORE RESPONSE DATA IN 4 WORD BLOCKS: SUM, NO. OF RESPONSES, SUM OF SQUARES
;THIS IS A CDB SUB-TABLE. IT IS CONDITIONALLY ASSEMBLED.
;USER PROGRAMS CAN ACCESS AFTER GETTING REL. POSITION FROM .CPRSP IN
; CPU CONSTANTS TABLE
IFN FTRSP,<			;RESPONSE FEATURE?
;INDICIES INTO 3 WORD BLOCKS:
XP RSPAXR,0			;ACCUMULATE SUM OF RESPONSE
XP RSPNXR,1			;NO. OF RESPONSES
XP RSPHXR,2			;SUM OF SQUARES OF RESPONSE(HIGH ORDER HALF)
XP RSPLXR,3			;SUM OF SQUARES OF RESPONSE(LOW ORDER HALF)
V	(AOR,N,Y)		;(R0) ACCUMULATED TTY OUTPUT UUO RESPONSE.
				; TOTAL NO. OF JIFFIES USERS HAVE SPENT WAITING
				; FOR THEIR JOBS TO DO A TTY OUTPUT UUO
				; AFTER TYPING INPUT (COMMAND OR USER TTY)
				; SEE JBTRSP, RSPTOR - CPU0 ONLY
V	(NOR,N);		;(R1) NO. OF TTY OUTPUT UUO RESPONSES
V	(HOR,N);		;(R2) SUM OF SQUARES OF TTY OUTPUT UUO RESPONSES
				; HIGH ORDER WORD
V	(LOR,N);		;(R3) SUM OF SQUARES OF TTY OUTPUT UUO RESPONSES
				; LOW ORDER WORD
V	(AIR,N,Y);		;(R4) ACCUMMULATED TTY INPUT UUO RESPONSES.
				; TOTAL NO. OF JIFFIES USERS SPENT WAITING
				; FOR THEIR JOBS TO DO A TTY INPUT UUO
				; AFTER TYPING INPUT (COMMAND OR USER TTY)
				; SEE JBTRSP, RSPTIR - CPU0 ONLY
V	(NIR,N);		;(R5) NO. OF TTY INPUT UUO RESPONSES
V	(HIR,N);		;(R6) SUM OF SQUARES OF TTY INPUT UUO RSPS
				; HIGH ORDER WORD
V	(LIR,N);		;(R7) SUM OF SQUARES OF TTY INPUT UUO RSPS
				; LOW ORDER WORD
V	(ARR,N);		;(R10) ACCUMMULATED CPU QUANTUM REQUE RESPONSES
				; TOTAL NO. OF JIFFIES USERS SPENT WAITING
				; FOR THEIR JOBS TO EXCEED CPU QUANTUM
				; AFTER TYPING INPUT (COMMAND OR USER TTY)
				; SEE JBTRSP,N, RSPREC - EITHER CPU
V	(NRR,N);		;(R11) NO. OF CPU QUANTUM REQUEUE RESPONSES
V	(HRR,N);		;(R12) SUM OF SQUARES OF CPU QUANT. REQUEUE RSPS
				; HIGH ORDER WORD
V	(LRR,N);		;(R13) SUM OF SQUARES OF CPU QUANT. REQUEUE RSPS
				; LOW ORDER WORD
V	(AXR,N);		;(R14) ACCUMMULATED RESPONSE TERMINATED BY
				; FIRST OF ABOVE 3 EVENTS (TTY OUTPUT
				; UUO,N, TTY INPUT UUO, OR CPU QUANTUM REQUE)
				; SEE JBTRSP, RSPREC
V	(NXR,N);		;(R15) NO. OF SUCH RESPONSES
V	(HXR,N);		;(R16) SUM OF SQUARES OF ANY OF ABOVE
				; HIGH ORDER WORD
V	(LXR,N);		;(R17) SUM OF SQUARES OF ANY OF ABOVE
				; LOW ORDER WORD
V	(ACR,N);		;(R20) ACCUMMULATED CPU RESPONSE
				; ON THIS CPU.  TOTAL # OF JIFFIES
				; USERS HAVE SPENT WAITING FOR THIS CPU
V	(NCR,N);		;(R21) NUMBER OF CPU RESPONSES ON THIS CPU.
V	(SCR,N);		;(R22) HIGH ORDER WORD OF SQUARE OF
				; CPU RESPONSES
V	(SCL,N);		;(R23) LOW ORDER WORD
V	(FADL,N)		;(R24) NUMBER OF FADL'S SIMULATED
V	(FSBL,N)		;(R25) NUMBER OF FSBL'S SIMULATED
V	(FMPL,N)		;(R26) NUMBER OF FMPL'S SIMULATED
V	(FDVL,N)		;(R27) NUMBER OF FDVL'S SIMULATED
V	(UFA,N)			;(R30) NUMBER OF UFA'S SIMULATED
V	(DFN,N)			;(R31) NUMBER OF DFN'S SIMULATED
V	(NRI,N)			;(R32)NUMBER OF CHARS (EXCLUDING MIC)RECEIVED
V	(NXI,N)			;(R33)NUMBER OF CHARS(INCLUDING FILL)XMITTED
V	(NEI,N)			;(R34)NUMBER OF CHARS ECHOED
XPC	.CPRSL,<.-.C0AOR>,N	;SUB-TABLE LENGTH
>				;END FTRSP

;THIS IS A CDB SUB-TABLE.
;USER PROG CAN BE ACCESS AFTER GETTING REL. POSITION FROM .CPPAR
; IN CPU CONSTANTS TABLE.

;MORE MEMORY PARITY ANALYSIS LOCATIONS
V	(LPA,N);		;(R0) LAST (HIGHEST) BAD MEM PARITY ADDRESS ON LAST
				; SWEEP OF MEMORY. USED TO TELL OPERATOR RANGE OF BAD
V	(MPR,N);		;(R1) REL. ADR (NOT VIRTUAL) IN HIGH OR LOW SEG OF
				; LAST MEM PAR ERROR
V	(PTS,N);		;(R2) NO. OF PARITY ERROR THIS (LAST) SWEEP OF CORE
				; SET TO 0 AT BEG OF SWEEP
V	(PSC,N);		;(R3) NO. OF PARITY SWEEPS BY MONITOR
				; (CP.TPE HAS TOTAL NO. OF BAD WORDS ON ALL SWEEPS)
V	(UEP,N);		;(R4) NO. OF USER ENABLED PARITY ERRORS
V	(PAA,N);		;(R5) AND OF BAD ADDRESSES THIS (LAST) MEM PAR SWEEP
V	(PAC,N);		;(R6) AND OF BAD CONTENTS THIS (LAST) MEM PAR SWEEP
V	(POA,N);		;(R7) OR OF BAD ADDRESSES THIS (LAST) MEM PAR SWEEP
V	(POC,N);		;(R10) OR OF BAD CONTENTS THIS (LAST) MEM PAR SWEEP
V	(PCS,N);		;(R11) NO. OF SPURIOUS PARITY ERRORS (APR SWEEP
				; FOUND NO BAD PARITY BUT CHANNEL HAD REQUESTED
				; SWEEP RATHER THAN PROCESSOR. THIS INDICATES A
				; CHANNEL MEMORY PORT PROBLEM
	XPC	.CPPRL,<.-.C0LPA>,N	;SUB-TABLE LENGTH

;THIS IS A CDB SUB-TABLE.
;USER PROG CAN ACCESS AFTER GETTING REL. POSITION FROM .CPPAR
; IN CPU CONSTANTS TABLE.

V	(BAT,N,,,M.CBAT)	;;(R0) TABLE OF BAD ADDRESSES ON LAST
				; MEMORY PARITY SWEEP. NOT
				; CLEARED, SO NUMBER OF VALID ENTRIES
				; KEPT IN .CPPTS (# PARITIES THIS SWEEP)
;MEMORY NXM SUBTABLE, POINTED
; TO BY .CPNMT
V	(LNA,N);		;(R0) LAST NXM ADDRESS
V	(MNR,N);		;(R1) LAST NXM RELATIVE ADDRESS
V	(NTS,N);		;(R2) NUMBER OF NXM'S FOUND THIS SWEEP
V	(NSC,N);		;(R3) NUMBER OF NXM SWEEPS DONE
V	(UEN,N);		;(R4) NUMBER OF USER ENABLED NXM'S
V	(NAA,N);		;(R5) LOGICAL AND OF BAD ADDRESSES
V	(NOA,N);		;(R6) INCLOSIVE OR OF BAD ADDRESSES
V	(NCS,N);		;(R7) NUMBER OF SPURIOUS CHANNEL NXM'S
XPC	.CPNML,<.-.C0LNA>,N		;NXM SUBTABLE LENGTH
;CPU STATUS BLOCK ENTRY GENERATED ON VARIOUS ERRORS

;THIS IS A CDB SUBTABLE
V	(APD,N,,VERSTS);	;(R0) APRID
V	(ACN,N,,APRSTS);	;(R1) CONI APR,
V	(PIC,N,,PISTS);		;(R2) CONI PI,
IFN M.KI10,<
V	(PGD,N,,EUBSTS);	;(R3) DATAI PAG,
>
IFN M.KL10!M.KS10,<
V	(PGD,N,,UPTSTS);	;(R3) DATAI PAG,
>
IFN M.KI10,<
V	(PGC,N,,PAGSTS);	;(R4) CONI PAG,
>
IFN M.KL10!M.KS10,<
V	(PGC,N,,EPTSTS);	;(R4) CONI PAG,
>
V	(UP0,N,,,4);		;(R5-R10) UPT LOCS 424-427
IFN M.KL10!M.KS10,<
V	(ERA,N,,ERASTS)		;(R11) RDERA
V	(RHC,N,,,8);		;(R12-R21) CONI RH20, FOR ALL RH20'S
V	(DTC,N,,,4);		;(R22-R25) CONI DTEN,
V	(EP0,N,,,40);		;(R26-R65) EPT LOCATIONS 0-37
V	(EP1,N,,,40);		;(R66-R125) EPT LOCATIONS 140-177
V	(UP1,N,,,4);		;(R126-R131) UPT LOCS 500-503
V	(6,N,,,5);		;(R132-R136) AC BLOCK 6 REGS 0-3 AND 12
V	(7,N,,,3);		;(R137-R141) AC BLOCK 7 REGS 0 THROUGH 2
>
IFN M.KL10,<
;IN ADDITION TO BEING A PART OF THE CPU STATUS BLOCK SUBTABLE, THE
;SBDIAG BLOCK IS A CDB SUBTABLE IN ITS OWN RIGHT.  POINTER IS .CPSDP.
V	(SBD,N,,,50)		;(R142-R211) SBDIAG DATA
	XPC	.CPSDL,<.-.C0SBD>,N ;SBDIAG SUBTABLE LENGTH
>;END IFN M.KL10
	XPC	.CPCSL,<.-.C0APD>,N ;SUB-TABLE LENGTH
;DEVICE STATUS BLOCK ENTRY FOR DEVICES ON THIS CPU.
; THIS IS A CDB SUBTABLE.  THE ORDER OF THESE ENTRIES MUST
; EXACTLY MATCH THE ORDER OF THE INSTRUCTIONS IN DVSCST
; THAT FILL THE ENTRIES.

V	(DVS,N,,,0)
IFN M.KI10!M.KL10,<
IFN M.KL10,<
V	(TMR,N,Y)
V	(MTR,N,Y)
>; END IFN M.KL10
V	(TTY,N,Y)
V	(PRA,N,Y)
V	(PPA,N,Y)
V	(DLS,N,Y)
V	(DAC,N,Y)
V	(DAS,N,Y)
V	(CRA,N,Y)
V	(LPT,N,Y)
V	(PLA,N,Y)
V	(TMS,N,Y)
V	(TMC,N,Y)
V	(DX1,N,Y)
IFN M.KI10,<
V	(CCI,N,Y)
>; END IFN M.KI10
V	(DSK,N,Y)
V	(FH2,N,Y)
V	(FSD,N,Y)
V	(FS2,N,Y)
V	(FS3,N,Y)
V	(DPC,N,Y)
V	(DP2,N,Y)
V	(DP3,N,Y)
V	(DP4,N,Y)
V	(2DS,N,Y)
V	(2DC,N,Y)
V	(DLC,N,Y)
V	(DLB,N,Y)
V	(DC2,N,Y)
V	(DB2,N,Y)
V	(CDP,N,Y)
V	(CRB,N,Y)
V	(LPB,N,Y)
V	(LPC,N,Y)
V	(PLB,N,Y)
IFN M.KI10,<
V	(DST,N,Y)
>; END IFN M.KI10
IFN M.KL10,<
V	(DAK,N,Y)
>
V	(DDK,N,Y)
V	(DH2,N,Y)
V	(DFS,N,Y)
V	(DS2,N,Y)
V	(DS3,N,Y)
V	(DDP,N,Y)
V	(DD2,N,Y)
V	(DD3,N,Y)
V	(DD4,N,Y)
V	(DDC,N,Y)
V	(DDB,N,Y)
V	(D2C,N,Y)
V	(D2B,N,Y)
IFN M.KL10,<
V	(IVI,N,Y,,20)
>;END IFN M.KL10
>;END IFN M.KI10!M.KL10
IFN M.KS10,<
V	(TMR,N,Y)
V(TMB,N,Y,,2)
V	(UB1,N,Y)
V	(UB3,N,Y)
V	(RH1,N,Y,,2)
V	(RH3,N,Y,,2)
V	(LPT,N,Y,,2)
V	(CDR,N,Y)
>

LENSTS==:<.-APRSTS-1>B26
	XPC	.CPDVL,<.-.C0DVS>,N ;SUB-TABLE LENGTH

IFN	M.KL10&FTRSP,<
V	(BPV,N,Y,,<<BPATLN*4>>);KL10 BACKGROUND PERFORMANCE NUMBERS
			; EACH ENTRY IS 4 WORDS LONG
			;  0'1 := RDTIME TOTAL ELAPSED TIME
			;  2'3 := TOTAL PERF METER COUNT
> ;END IFN M.KL10&FTRSP


;***********************************************************************
;INSERT NEW SUB TABLES JUST ABOVE HERE - SO AT END OF VARIABLE TABLE
;INSERT NEW VARIABLES A FEW PAGES BACK - SO NEXT TO OTHER VARIABLES
;***********************************************************************
IFE N,<
XP .CPPVL,<<.-.C0VBG>B26>	;PUBLISHED CPU DEPENDANT VARIABLE LENGTH
				;SHIFTED LEFT 9 BITS FOR GETTAB TABLE ENTRIES
>
;UNPUBLISHED CPU DEPENDENT VARIABLES:
;PROTECTED JOB INFORMATION.  COPIED FROM JOB DATA AREA INTO MONITOR
; EACH TIME A JOB RUNS.
V	(ADR,N,Y,JOBADR);	;XWD PROTECTION, RELOCATION FOR CURRENT
			; JOB SAME AS JBTADR(JOB) AND AC R
V	(REL,N,Y);		;LH==0, RH CONTAINS CONTENTS OF PROTECTION REGISTER
			; LOW ORDER BITS==1777,IE THIS IS HIGHEST REL.
			; LOC IN CURRENT USER AREA (USED FOR ADDRESS
			; CHECKING)
V	(PC,N,Y,,<1+IFN FTKLP,<1>>);;JOB PC WHEN SCHEDULER IS CALLED
XP USRPRT,JOBPRO
XP USRPR1,,USRPRT+1
XP USRHCU,USRPRT
XP USRPC,USRHCU+1
XP USRDDT,USRPC+1+IFN FTKLP,<1>	;THIS DEPENDS ON JOBDDT-JOBPC=1
XP USRJDA,USRDDT+1
XP USRLO,USRJDA		;FIRST LOC CLEARED BY SETUSR ROUTINE
			; ON A CALL RESET. - ALSO CLEARS USRHCU
XP USRLO1,USRLO+1	;FIRST LOC+1
XP USRHI,USRJDA+17	;LAST LOC CLEARED BY SETUSR ROUTINE
V	(XTM,N);		;TIME OF LAST SWITCH FROM MONITOR CYCLE TO USER JOB
			; OR VICE VERSA IN (SECONDS*RTCSEC)
V	(LS2,N);		;ADDITIONAL LOST TIME,N, IN JIFFIES*RTCSEC, BEYOND LAST JIFFY
V	(NL2,N);		;ADDITIONAL NULL TIME,N, IN JIFFIES*RTCSEC, BEYOND LAST JIFFY
V	(OH2,N);		;ADDITIONAL OVERHEAD TIME,N, IN JIFFIES*RTCSEC,
			; BEYOND LAST JIFFY--SEE OHT ABOVE (53)
V	(TNT,N)		;TIME INTERVAL IN TICS SINCE LAST AT CLOCK LEVEL
V	(HTM,N)		;HUNG DEVICE TIME CHECK FOR HUNG IO
V	(SEC,N)		;NUMBER OF SECONDS LEFT BEFORE DOING
			; ONCE-A-MINUTE CODE ON THIS CPU. SEE CPUMIN
			; IN CLOCK1
IFN FTRTTRP,<
V	(RCU,N,N,,6)	;COUNT OF REAL TIME CONSO'S ON SKIP CHAIN
V	(RIT,N,Y,,6)	;REAL TIME INITIALIZATION TABLE
V	(DMI,N)		;REAL TIME DISMISS INSTRUCTION FOR CURRENT INTERRUPT
>
;SCHEDULER FLAGS:
V	(CKF,N,Y,CLKFLG);;NON-ZERO WHEN CLK INTERRUPT (PI7) REQUESTED
			; FOR ANY REASON ON THIS CPU.  THIS LOCATION
			; TAKES THE PLACE OF A HARDWARE INTERRUPT
			; FLAG ON PDP-6 AND KA10S.
V	(TMF,N,Y,TIMEF);;NON-ZERO WHEN APR CLOCK TICKED ON THIS CPU.
			; SET SO CLK INTERRUPT ROUTINES WILL KNOW
			; ANOTHER JIFFY HAS PASTED.  SET BY APRINT,
			; TESTED AND CLEARED BY CLKINT MODULE.
V	(SCF,N,Y);	;NON-ZERO AS A FLAG TO CLK ROUTINE TO FORCE
			; RESCHEDULING, ON THIS CPU, EVEN THOUGH
			; ITS CURRENT JOB IS IN EXEC MODE.  CAN HAPPEN
			; ON MONITOR DETECTED ERRORS.

V	(CHT,N);	;CLOCK HAS TICKED, START QUEUED I/O.

V	(RTF,N,N,SCDRTF); ;NON-ZERO ON REAL TIME RESCHEDULE REQUIRED
			; REALLY A SYSTEM VARIABLE
V	(ISF,N,Y)	;NON-ZERO IF IN THE SCHEDULAR
			; WHEN IN COMCON CONTAINS THE STACK POINTER
			; JUST BEFORE COMMAND DISPATCH

V	(SUD,N);	;SCAN USED FOR THIS SCHEDULING SCAN
IFN FTHPQ!FTNSCHED,<
V	(HQU,N,Y)	;NON-ZERO IF CURRENT JOB ON THIS CPU DID A HPQ UUO
			; TO FORCE RESCHEDULING TO THE NEW HPQ
>
V	(PLT,N);	;POTENTIALLY LOST (WASTED) CLOCK TICK ON
			; THIS CPU IF NON-ZERO.
			;NON-ZERO WHEN SCHEDULER SEES THAT THERE ARE
			; JOBS WHICH ARE POTENTIALLY RUNABLE ON THIS CPU
			; BUT HAS TO RUN NULL JOB.
			;0 WHEN IT FINDS A REAL JOB TO RUN OR
			; NULL JOB IS ONLY JOB WHICH WANTS TO RUN ON THIS CPU.
			; .CPLST INCREMENTED EVERY JIFFY IF THIS FLAG
			; IS NON-ZERO AND PREVIOUS JOB WAS NULL JOB.
;v	(chx,n)		;tkschx shifted for this cpu, pl}thberg
IFN FTKL10,<
IFN FTMP,<
V	(CLF,N);	;POTENTIAL CACHE LOST TIME FLAG (SEE .CPCLN)
V	(CL2,N);	;LOW ORDER CACHE LOST TIME IN RTUPS UNITS
V	(SDA,N);	;NUMBER OF TIMES CACHE WAS SWEPT BECAUSE OF
			; CORE DEALLOCATION
>; IFN FTMP
V	(CSR,N,Y);	;CACHE SWEEP REQUEST FLAG FOR THISCPU
			; IF IT IS .GE. CURRENT SWEEP SERIAL NUMBER FOR
			; THIS CPU,N, MUST SWEEP AT CH7 LEVEL FOR ANOTHER CPU
>;END IFN FTKL10&FTMP
V	(AEF,N,Y);	;APR ERROR FLAG ON THIS CPU.  CONTAINS APR
			; CONI IF NULL JOB WAS CURRENT JOB ON THIS
			; CPU WHEN APR ERROR OCCURRED SO COULD NOT
			; STORE IN JOB DATA AREA.
			; LEFT HALF USED FOR MEMORY PARITY CONTROL
			; TO REQUEST PARITY SWEEPS AND PRINTING. SEE .CPMPS FOR
			; BIT DEFINITIONS.
V	(SAC,N);	;SAVED COPY OF .CPAEF
V	(APC,N,Y,,2);	;APR ERROR PC ON THIS CPU WHEN ERROR WHILE
			; NULL JOB WAS CURRENT JOB ON THIS CPU.
V	(MDP,N,Y,,2);	;MEMORY PARITY ERROR DOUBLE WORD PC
V	(PPD,N,Y,,2);	;AR/ARX TRAP DOUBLE WORD PC
V	(NJE,N,Y);	;ERROR IN NULL JOB HAS OCCURRED IF NON-ZERO
V	(SFC,N);	;SCHEDULER FAIRNESS COUNT. COUNT OF THE NUMBER
			;OF SCANS OF THE PRIMARY SCAN TABLE WITHOUT GETTING
			;TO THE LOWER QUEUES IN THE TABLE.  IF THE COUNT
			;EXCEEDS THE MAXIMUM,N, THE SCAN USES THE SECONDARY TABLE

V	(SQF,N);	;NON-ZERO IF CURRENT JOB WAS TAKEN FROM SUBQUEUES
V	(APR,N,Y)	;CONI APR INTO THIS LOCATION TO READ
			; THE STATE OF MI PROG DIS SWITCH

IFN FTKL10,<
V	(IPI,N,Y);	;INTERVAL TIMER PI ASSIGNMENT ON KL10
>
IFN FTKL10&FTMP&FTDOTD,<
V	(PIY,N);	;SAVE PI STATE FOR BYTPIN (RMWDPB)
>

;PROCESSOR DEPENDENT VARIABLES FOR APR INTERRUPTS

V	(CN1,N,Y);	;CONTAINS CONSO MASK FOR APR INTERRUPTS,
			; THE USER WANTS TO HANDLE HIMSELF.  MOVE TO
			; PDB IN FUTURE.
V	(DTO,N,Y);	;LAST DATAO OUT TO SET HARDWARE RELOCATION
			; AND PROTECTION FOR THIS CPU.
V	(SP,N,Y,,<1+IFN FTKLP,<1>>);	;PLACE TO SAVE P ON APR INTERRUPT FOR THIS CPU.
V	(S17,N,Y,,<1+IFN FTKLP,<1>>);	;PLACE TO SAVE AC 17 ON CLK INTERRUPT

;MEMORY PARITY ANALYSIS VARIABLES
V	(A00,N,,,17);		;FIRST WORD TO STORE AC0 ON
				; PAR SWEEP ON APR PI (USUALLY NOT
				; DONE EXCEPT FOR SERIOUS ERROR)
V	(A17,N);		;LAST WORD TO STORE AC17 ON
				; PAR SWEEP AT APR PI.
V	(LPP,N);		;LAST MEM PARITY PC - USED TO DETECT
				; PI DISMISS LOOPS. CLEARED AT END
				; OF PI 7 SWEEP OF MEMORY
V	(LSB,N,Y);		;LAST SEG (HI OR LOW) WHICH IS (WAS) BLTED
				; USED TO DETECT BAD PARITY DURING BLT
V	(LCI,N);		;TIME OF LAST PAR/NXM INTERRUPT CAUSED
				; BY A CHANNEL REFERENCE
V	(PIP,N);		;POINTER TO  REAL INTERRUPT PC
V	(PSP,N,Y);		;PARITY/NXM SWEEP IN PROGRESS ON THIS CPU
V	(CHE,N);		;CHANNEL ERROR REPORTING IN PROGRESS ON THIS CPU
V	(TCX,N);		;RESULTS OF DATAI PAG, ON ERROR TRAP

IFN M.KI10,<
V	(CA1,N,,,20)		;AC BLOCK 1 SAVED HERE ON A CRASH
>;END IFN M.KI10
IFN M.KL10,<
V	(TCT,N,Y);		;TRIAD COUNTER FOR 60HZ LEAP JIFFIES
V	(PJB,N,Y);		;# OF JOB WHO OWNS PERFORMANCE METER
				; 0 IF FREE
V	(MJB,N,Y);		;MEASURED JOB (JOB ENABLE OF PERF. UUO)
				; -2 = NULL JOB, 0 = DON'T CARE
V	(MJ1,N,Y);		;JOB ENABLE CONDITION SET ONLY WHEN
				; METER IS RUNNING. (SEE KLSER)
V	(PMR,N,Y);		;NONZERO MEANS PERFORMANCE METER IS
				; RUNNING.
V	(PAE,N,Y);		;USED TO STORE PERFORMANCE ANALYSIS
				; ENABLES
V	(PRQ,N,Y);		;SEMAPHORE USED IN TESTING AND GIVING
				; METER AWAY
V	(APS,N,Y);		;NON ZERO MEANS ACCT + PERF METERS SHOULD BE KEPT IN SYNC
V	(MM0,N);		;"VIRTUAL PERF METER'S" HIGH ORDER MEM REF COUNT
V	(MM1,N);		;LOW ORDER
V	(BPC,N,Y);		;BACKGROUND PERF ANAL SAMPLE INTERVAL (TICKS)
V	(BPI,N,Y);		;B.P.A. SAVED PACTAB INDEX
V	(BPT,N,Y,,2);		;B.P.A. SAVED RDTIME AT START OF CURRENT SAMPLE
V	(TIM,N,Y);		;CLOCK INTERRUPT FLAG FOR KL10S
V	(ETM,N);		;SOSN DONE ON THIS LOCATION EVERY MINUTE TO
				; MAKE SURE CHUNKS DON'T STAY ALLOCATED FOREVER
				; IN THE CASE THAT DAEMON IS SICK, WRONG VERSION, ETC.
V	(EAD,N);		;LH=ADDRESS OF LAST KL ERROR CHUNK
				;RH=ADDRESS OF FIRST CHUNK
V	(KPB,N,N,,<<KPSLEN+3>/4>); ;KLINIK PARAMETER BUFFER
V	(20F,N);		;LH = FLAGS ABOUT RSX-20F FRONT END
				;RH = COUNT OF CHARACTERS CURRENTLY BEING OUTPUT
V	(20S,N,,,2)		;SPACE FOR INCOMING LINE SPEEDS
V	(20B,N,,,<<TTDMOS+3>/4>);;BUFFER FOR 16BIT DATA TO 20F
;LOCATIONS USED BY CPU HARDWARE ERROR RECOVERY
V	(PTH,N,Y);		;AR/ARX TRAP HAPPENED DURING PARITY SWEEP
V	(STE,N,Y);		;ERA CONTENTS ON SWEEP TRAP
V	(PTF,N,Y);		;COUNT OF PAGE TABLE PARITY TRAPS BETWEEN CLOCK
				;  TICKS--USED TO CRASH SYSTEM IF TO HIGH
				;  REINITIALIZED EVERY JIFFY
V	(CA1,N,,,20);		;POWER FAIL AC BLOCK SAVE AREA
				; ALSO AC BLOCK 1 ON A CRASH
V	(CA2,N,,,20);		;AC BLOCK 2
V	(CA3,N,,,20);		;AC BLOCK 3
V	(CA4,N,,,20);		;AC BLOCK 4
>;END IFN M.KL10
IFN M.KS10,<
V	(TCT,N,Y);		;TRIAD COUNTER FOR 60HZ LEAP JIFFIES
V	(TIM,N,Y);		;CLOCK INTERRUPT FLAG FOR KS10S
V	(PTH,N,Y);		;HARD PARITY TRAP HAPPENED DURING PARITY SWEEP
V	(PTF,N,Y);		;COUNT OF PAGE TABLE PARITY TRAPS BETWEEN CLOCK
				;  TICKS--USED TO CRASH SYSTEM IF TO HIGH
				;  REINITIALIZED EVERY JIFFY
V	(LMC,N);		;LEAP MILLISECOND COUNTER FOR 4.1 MHZ CLOCK RATE
V	(CA1,N,,,20);		;POWER FAIL AC BLOCK SAVE AREA
				; ALSO AC BLOCK 1 ON A CRASH
V	(CA2,N,,,20);		;AC BLOCK 2
V	(CA3,N,,,20);		;AC BLOCK 3
V	(CA4,N,,,20);		;AC BLOCK 4
>;END IFN M.KS10
V	(CTQ,N);		;SCNSER OUTPUT QUEUE HEADER FOR CTY ON THIS CPU
				;FOR KL10, IS HEADER FOR ALL RSX-20F LINES
IFN FTMP,<
V	(QUE,N)		;QUEUE FOR IO REGS ON OTHER CPUS
			; EMPTIED INTO CPUDSQ ONCE A TICK
V	(SWP,N,Y)	;NON-0 IF SWAP REQUEST FOR OTHER CPU
V	(QND,N)		;END OF QUEUE ABOVE
V	(SWD,N)		;FLAG FOR FILIO CACHE SWEEPS
V	(DRQ,N)		;DISKS ON CPU NEED RECUING
V	(TAP,N)		;0 IF NO TAPE IO WAITING FOR SWEEP
			;-1 IF TAPE IO WAITING, NEEDS SWEEP
			;0,,-1 IF TAPE WAITING, DSKTIC DID SWEEP
;V	(CHX,N)		;TKSCHX SHIFTED FOR THIS CPU, this might be bug!! pl}t
IFN FTKL10,<
V	(PIB,N);	;SAVE PI STATE FOR NBFOFF
>
V	(PIS,N);	;SAVE PI STATE FOR SYSPIN
V	(DPI,N);	;SAVE PI STATE FOR DEVPIN
V	(BTI,N);	;SAVE PI STATE FOR BTSOFF
>
V	(IUT,N);	;UPTIME A SECOND AGO
IFN FTNET,<
V	(NTF,N,Y);	;DEFINE THE ONE SOFTWARE INTERRUPT FLAG
>			; ON EACH CPU FOR NETSER TO USE
IFN FTEQDQ,<
QDBLEN==:23		;LENGTH OF QUESER DATABASE
V	(QTS,N,,,QDBLEN) ;QUESER VARIABLES
>
V	(CPG,N)		;RESULT OF DATAI PAG, DONE BY SVSETS WITH BITS
			;SET SO THAT DATAO WILL RESTORE CURRENT AC SET
V	(ACA,N)		;ADDRESS OF 20 WORD BLOCK IN WHICH SVSETS SAVED
			;THE CURRENT AC SET
IFN FTKLP,<
V	(SPC,N,,,2)	;STOPCD PC STORED HERE TO RETURN TO THE PROPER SECTION
>
IFN FTPATT,<
V	(PAT,N,,,10)	;PATCH SPACE
>
;END OF VARIABLES FOR CDBS.  ADD MORE HERE
>;END OF CDB MACRO

IFN XPANDN,<LALL>
ZZZ==0
REPEAT M.CPU,<
	LOC	<.+777>&777000
	CDB(\ZZZ)
IFE ZZZ,<
.CPLEN==.-.C0CDB		;LENGTH OF CDB FOR CPU 0
IFN <<.CPLEN+777>/1000>-<RHWEVM-^D2>,<PRINTX ?RHWEVM DOES NOT MATCH CDB SIZE>
>
ZZZ==ZZZ+1
>
.CPSOF==:^D36-^L<<.CPLEN+777>&777000>-1 ;INVALID IF CPU DATA BLOCK
				; IS MORE THAN TWO PAGES LONG
.CPVLN==.-.C0VBG		;LENGTH OF VARIABLE AREA
.C0EVA==:.C0CDB+.CPLEN		;END OF CPU 0 VARIABLE AREA

	$LIT			;ANY LITERALS IN CDB CAN GET CACHED IN HIGH SEG
	$ABS			;BACK TO ABS CODE
SYSBEG::			;START OF THE ONCE ONLY
				;OVERLAY CODE. IT OVERLAYS
				;VARIABLES AND CLOBBERS THE REAL
				;ONCE ONLY. IT IS IN TURN
				;ZEROED AFTER SYSINI IS MOVED

;NOW GENERATE REFERENCES FOR GETTAB TABLES 55 THRU 70
;WILL GENERATE A ZERO WORD FOR INDIRECT REFERENCES TO NON EXISTANT CDB'S
DEFINE CPUGTB(A,B)<
IFG <CPUN-A>,<XP ITMC'B'C,.CPPCL
	XP	ITMC'B'V,.CPPVL>
IFLE <CPUN-A>,<XP ITMC'B'C,0	;MAKE LENGTH 0 SO ERROR RETURN
	XP	ITMC'B'V,0	;MAKE LENGTH 0 SO ERROR RETURN
	.C'B'CDB::		;DEFINE ADR TO BE A WORD CONTAINING 0.
	.C'B'VBG::
>>
ZZ==0
REPEAT 6,<
	CPUGTB(ZZ,\ZZ)
ZZ==ZZ+1
>
IFLE <CPUN-5>,<EXP 0>		;GETTABS FOR NON-EXISTANT CDB'S GET THEIR DATA HERE
IFN FTNSCHED,<
;TABLES INDEXED BY CLASS NUMBER

CLSSTS::BLOCK	M.CLSN		;BITS IN LH, QUOTA (NUMBER FROM 0 TO 100) IN RH

CLSQTA::BLOCK	M.CLSN		;COMPUTED QUOTA IN JIFFIES, FIGURED OUT
				;FROM CLSSTS, RECOMPUTED AT THE
				;BEGINNING OF EVERY SCHEDULING INTERVAL.
				;DECREMENTED WHENEVER A CLASS USES A JIFFY
				;OF RUNTIME.


CLSRTM::BLOCK	M.CLSN		;RUNTIME FOR CLASSES SINCE ANY CHANGE IN CLSSTS
				;MINUS ANY TIME LEFT OVER AFTER ALL QUOTAS
				;WERE SATISFIED WITHIN AN INTERVAL

CLSMXL==:<M.CLSN-1>B26		;MAXIMUM LENGTH OF PER CLASS TABLES FOR GETTAB
>;END IFN FTNSCHED
SUBTTL MONITOR TABLES WITH ONE ENTRY PER JOB

	JOBMAX==:JOBN-1		;MAXIMUM LEGAL JOB NUMBER
	JOBMXL==:<JOBMAX>B26	;HIGHEST JOB NUMBERSHIFTED LEFT 9 (FOR GETTAB UUO)
	MJOBN==:-JOBN		;NEGATIVE NUMBERS OF JOBS (COUNTING NULL JOB)
	JBTMAX==:JOBN+SEGN-1	;HIGHEST INDEX IN JBT TABLES
	MJBTMX==:-JBTMAX		;MINUS JBTMAX FOR AOBJN POINTER
	JBTMXL==:<JBTMAX>B26	;HIGHEST JBT ENTRY SHIFTED LEFT 9 (FOR GETTAB UUO)
JBTSTS::BLOCK	JOBN+SEGN	;JOB AND HIGH SEG STATUS WORD
				;THIS IS DOCEMENTED AS GETTAB TABLE NUMBER 0
				;LH==STATUS BITS (SEE S.MAC FOR DESCRIPTION)
				;BITS 18-23=EXTENDED JOB STATUS BITS
	JBSSPR==^D9			;SIZE OF ACCES PRIV FOR HIGH SEG
	JBNSPR==^D17			;BYTE PTR. POS.
				;RH=IN CORE COUNT FOR HIGH SEGS

JBTST2::BLOCK	JOBN		;SECOND WORD OF JOB STATUS. USED BY SCHEDULER
				;  AND EVENT WAIT INFO

IFN M.KL10*<CPUN-1>,<;IF KL10 SYSTEM WITH MORE THAN ONE CPU
JBTST3::BLOCK	JOBN		;18-35 = CPU DATA BLOCK ADDR OF LAST
				; CPU JOB RAN ON.  CLEARED WHEN
				; JOB GIVES UP ALL PHYSICAL CORE, OR
				; DOES RUN, GET, ETC.

JBTCSN::BLOCK	JOBN		;36 BIT SWEEP SERIAL NUMBER, TAKEN FROM
				; CPU WHOSE CDB ADDRESS IS IN JBTST3
>;END IFN M.KL10*<CPUN-1>

IFN FTNSCHED,<
JBTSCD::BLOCK	JOBN		;SCHEDULER WORD CONTAINING EACH JOB'S
				;CLASS AND TYPE.
>;END IFN FTNSCHED

JBTSPS::IFG	<CPUN-1>,<	;MULTI-PROCESSING SYSTEM?
	BLOCK	JOBN		;SECOND PROCESSOR STATUS BITS BOTH HALVES (PREFIX=.SP)
				;RH=GETTAB BITS FOR 6 CPU'S.
				;LH=UNPUBLISHED BITS
				;SEE S.MAC FOR DEFINITIONS.
	XP	ITMSPS,JOBMXL	;LH SYMBOL FOR GETTAB UUO
>
	IFLE	<CPUN-1>,<	;SINGLE-PROCESSOR SYSTEM?
	0			;DUMMY ENTRY
	XP	ITMSPS,0	;DON'T ALLOW ANY REFERENCE IF NOT 2 CPU SYSTEM
>

JBTADR::BLOCK	JOBN+SEGN	;JOB AND HIGH SEG CORE ASSIGNMENT
				; LH==PROTECTION (LENGTH-1)
				; RH==RELOCATION (ABSOLUTE LOCATION IN CORE)
				; DURING BLT OF LOW OR HIGH SEG, THIS WORD
				; CONTAINS THE SOURCE RELOCATION
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 1
	JBTAD1==:JBTADR+1	;ADDRESS OF JOB 1 (USED BY SYSMAK)
	JBTDAT==:JBTADR		;RH==ADDRESS OF JOB DATA AREA
				;SAME AS JBTADR (R==R)

JBTSWI::
JBTSGN::IFG	SEGN, <
	BLOCK	JOBN+SEGN	;RH=SEGMENT NUMBER OF HIGH SEGMENT THIS JOB
				; IS USING IN CORE OR ON DISK
				; 0 MEANS JOB DOES NOT HAVE HIGH SEG
				;LH=USER DEPENDENT HIGH SEG STATUS BITS (SEE S.MAC)
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 14
				;INDEXED BY HIGH SEGMENT NUMBER THE TABLE (JBTSWI)
				; CONTAINS THE LOW SEGMENT NUMBER OF THE SEGMENT
				; WHICH THIS HIGH SEGMENT IS BEING SWAPPED IN FOR
>
	IFE	SEGN, <
	0			;SINGLE-ENTRY NULL JBTSGN TABLE....
	XP	ITMSGN,JOBMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTSGN IS
				; UNDEFINED, I.E., MAKE INDEXING BY J BE 0, BUT
				; ALLOW REFERENCES UP TO JOBMXL.
>


	IFG	DSKN, <		;DISK SYSTEM ?
JBTPPN::			;HIGH SEGMENT DIRECTORY NAME IF , 0 IF DTA,MTA
JBTPPN::BLOCK	JOBN+SEGN	;XWD PROJECT NUMBER, PROGRAMMER NUMBER
				;THIS IS DOCUMENTED AT GETTAB TABLE NUMBER 2
>
ifn stupid,<
JBTLPN::BLOCK	JOBN		;[JE] Logged-in PPN, for mailers & such.
>

	IFG	SEGN, <		;REENTRANT MONITOR CAPABILITY?
JBTDEV==:.-JOBN		;JUST HIGH HALF (NO ENTRIES FOR LOW SEGS)
	BLOCK	SEGN		;HIGH SEGMENT PHYSICAL DEVICE NAME
			; OR FILE STRUCTURE NUMBER(DSKA,DSKB,DTAN,MTAN)
>
IFE	SEGN,<
JBTDEV==:JBTSGN-JOBN		;USE THE DUMMY ENTRY IN JBTSGN
	XP	ITMDEV,JBTMXL	;LH SYMBOL FOR GETTAB UUO SO THAT JBTDEV IS
				;UNDEFINED, IE. MAKE INDEXING BYITEM BE 0
>
JBTVRT::BLOCK	JOBN		;PER-JOB PAGING RATES
SWPLST::BLOCK	JOBN+SEGN
SW2LST::BLOCK	JOBN+SEGN	;PARALLEL SWPLST TABLE FOR USE BY FILSER
SW3LST::BLOCK	JOBN+SEGN	;PARALLEL SWPLST TABLE FOR ADDITIONAL INFO
				; LH=C(SWPOUT) FOR SCHED1, RH=JOB NUMBER

	IFG	SYS50N, <	;SWAPPING SYSTEM ?
JBTSWP::BLOCK	JOBN+SEGN	; DISK ADDRESS WHILE SWAPPED OUT
				;BIT 0=1 IF SEGMENT IS FRAGMENTED
				;BITS 1-17 DISK ADDRESS IF NOT FRAGMENTED
				;FOR LEVEL D,
				;  BITS 3-5=INDEX OF UNIT IN SWPTAB (JBYSUN)
				;  BITS 6-17=1ST LOGICAL K ON UNIT (JBYLKN)
				;  BITS 1-17 CORE ADR OF FRAGMENT TABLE IF FRAGMENTED
				; BITS19-26:==OUTCORE IMAGE SIZE
				; BITS28-35:==INCORE IMAGE SIZE
				; FOR HIGH SEG, LH ALWAYS DISK ADDRESS
JBTCHK::BLOCK	JOBN+SEGN	;CHECK SUM FOR SWAPPED OUT JOB DATA AREA OR
				; SAME AREA FOR HIGH SEG

>
JBTNAM::			;NAME OF HIGH SEGMENT (FILE IT WAS INITIALIZED FROM)
JBTPRG::BLOCK	JOBN+SEGN	;NAME OF FILE USED IN LAST R,RUN,GET, ETC
				; USED BY SYSTAT PROGRAM, AND AS DEFAULT FOR
				;  THESE COMMANDS

IFN	FTWATCH,<		;WATCH SYSTEM RESPONSE DATA
JBTWCH::BLOCK	JOBN		;BITS 1-5 = ENABLE BITS - SEE S.MAC
				;BITS 13-35 = TIME OF DAY IN JIFFIES USER
				;STARTED TO WAIT FOR RESPONSE FROM SYSTEM
				;REST UNUSED
>
IFN	FTRSP,<		;USER TTY INPUT RESPONSE TIMES
JBTRSP::BLOCK	JOBN		;UP TIME AT WHICH USER BEGAN TO WAIT
			; FOR SYSTEM RESPONSE.
			; SET WHEN USER JOB COMES OUT OF TTY INPUT WAIT
			; OR TYPES A COMMAND WHICH RUNS A JOB.
			;HIGH ORDER BITS SET TO 0 WHEN USER STARTS TO WAIT
			; SET TO ONE AS EACH OF SEVERAL TYPES OF RESPONSE
			; TERMINATION CONDITIONS OCCUR.
			; SEE S.MAC FOR BITS OF FORM JR.R??
			; SEE CPU DATA BLOCK (ACR, ADR, AIR, ARR, AXR)
			; FOR DESCRIPTION OF TYPES OF RESPONSES GATHERED
JBTRQT::BLOCK	JOBN	;'RUN QUEUE TIME' ACCUM. TIME (JIFFIES) THAT JOB
			; HAS SPENT IN ONE OF THE RUN QUEUES (INCLUDING SWAPPED)
>
IFNDEF	FTSPL,<FTSPL==:-DSKN>	;BY DEFAULT, COMES WITH DISKS

IFN FTSPL!FTDPRI,<
JBTSPL::BLOCK	JOBN		;LH=INPUT FILE NAME COUNTER
				;BITS 27-35 - WHAT DEVICES BEING SPOOLED
				; (SEE S.MAC FOR DEF'NS)
				;BITS 24-26 = DSK PRIORITY FOR JOB
				; (SEE JBXPRI IN COMMOD)
>
JBTLIM::BLOCK	JOBN		;TIME LIMIT, ETC. FOR JOB
				; (SEE S.MAC FOR LAYOUT)


JBTPDB::BLOCK	JOBN		;ADDRESS OF PDB

JBTHSA::
JBTUPM::BLOCK	JOBN+SEGN	;ADDRESS OF THE UPMP
IFN FTWATCH,<
;PC TABLE
JBTPC::BLOCK JOBN		;RH - USER MODE PC
				;LH - RESERVED FOR BITS TO IMPROVE ^C RESPONSE
				;     IN 6.02
>;END FTWATCH
JBTDAU::BLOCK	JOBN		;LH=UDB FOR WHICH JOB OWNS DA
				;RH=PPB FOR WHICH JOB OWNS AU

IFN FTNET,<
JBTLOC::BLOCK	JOBN		;JOB LOCATION TABLE
				;JBTLOC+0 IS CENTRAL SITE STATION NUMBER
>	;IFN FTNET

IFN M.PSI,<
JBTPIA::BLOCK	JOBN		;LH HOLDS FLAGS (BITS 13-17 =0)
				;RH IS POINTER TO PROGRAM INTERRUPT
				;   TABLE.
>
IFE M.PSI,<
XP JBTPIA,777000		;CAUSE NXM IF REFERENCED
>
JBTJLT::BLOCK	JOBN		;JOB "LOGIN" TIME IN INTERNAL FORMAT

IFN FTIPCF,<
JBTPID::BLOCK	JOBN		;PID JOB IS DOING A IPCFR. FOR
>
JBTAD2::BLOCK	JOBN		;LH UNUSED
				;RH (BITS 18-22) UNUSED
				;BITS 23-35 PHYSICAL PAGE ZERO OF JOBS LOW SEG
JBTJRQ::BLOCK	JOBN		;LINKED LIST OF JOBS WAITING FOR REQUEUE
JBTPRV::BLOCK	JOBN		;PRIVILEGE BITS FOR JOB SET BY LOGIN

ifn FtCImp,<			;[arpa]
JBTLcl::block	JobN		;[arpa]
>				;[arpa]

	IFG	SYS50N, <
;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE, USED BY SWAPPING SCHEDULER (SCHED)
	FTDISK=:-DSKN		;DEFINE FEATURE SWITCH FTDISK, SINCE IT APPEARS
				; IN THE QUEUES MACRO (WHICH IS DEFINED IN S.MAC)
	XP	MXQUE,0

	DEFINE	X	<MXQUE==MXQUE+1;>
	QUEUES
	RWAITS
DEFINE	X	(A)

		<A'Z==MXQUE
		MXQUE==MXQUE+1;>
	CODES
		MXQUE==MXQUE+3	;LEAVE SPACE FOR PQ1,PQ2, AND CMMQ


	IFG	HPQN,<MXQUE=MXQUE+HPQN>
			;LEAVE SPACE FOR HIGH PRIORITY QUEUES

XP MXQUE2,<2*MXQUE>
	BLOCK	MXQUE2		;NUMBER OF QUEUES FOR SWAPPING SCHEDULER
QQQMXL==:<MXQUE-1>B26		;NUMBER QUEUES FOR GETTAB
JBTCQ::	BLOCK	JOBN		;ONE ENTRY PER JOB,
				; LH=PREVIOUS JOB, RH=NEXT JOB IN QUEUE
				; NEGATIVE MEANS THIS IS FIRST (LH) OR LAST (RH)
				; JOB IN QUEUE
JBCQM1==:JBTCQ-1		;
JBCQP1==:JBTCQ+1
NCNULQ==:NULZ+MXQUE		;NUMBER OF NULQ IN NO-CORE HEADER
JBCQMN==:JBTCQ-NCNULQ		;NUL QUEUE HEADER
JBCQOH==:JBTCQ-MXQUE		;WHAT TO INDEX TO GET SWAPPED OUT QUEUE HEADER
IFN FTNSCHED,<
	BLOCK	2*M.CLSN	;HEADER FOR PQ2 SUBQUEUES
JBTCSQ::BLOCK	JOBN		;SAME AS JBTCQ FOR SUBQUEUES
	JBCSOH==:JBTCSQ-M.CLSN	;SWAPPED OUT SUB-QUE HEADER
>;END OF IFN FTNSCHED
JBTBBQ::BLOCK	1		;HEADER FOR BB JUST INPUT QUEUE
JBTJIQ::BLOCK	1		;HEADER FOR PQ2 JUST INPUT QUEUE
JBTJIL::BLOCK	JOBN		;LIST OF PQ2 JOBS JUST INPUT
	BBQ==:JBTJIL-JBTBBQ	;OFFSET FOR JBTBBQ
	MBBQ==:-BBQ		;NEGATIVE OFFSET
	JIQ==:JBTJIL-JBTJIQ	;OFFSET FOR JBTJIQ
JBTOBQ::BLOCK	1		;HEADER FOR BB OUTPUT SCAN LIST
JBTOLQ::BLOCK	1		;HEADER FOR PQ2 OUTPUT SCAN LIST
JBTOLS::BLOCK	JOBN		;LIST OF PQ2 IN ORDER TO BE SCANNED FOR OUTPUT
	OBQ==:JBTOLS-JBTOBQ	;OFFSET FOR JBTOBQ
	MOBQ==:-OBQ
	OLQ==:JBTOLS-JBTOLQ	;OFFSET FOR JBTOLQ
>;END OF IFG SYS50N
;DATA STRUCTURE CLEARED ON SYSTEM STARTUP AND ON 143 RESTART


;TTYTAB IS A TABLE OF CONTROLLING (ATTACHED) TTY'S FOR EACH JOB,
;INDEXED BY JOB NUMBER. IF C(TTYTAB)=0 THEN THERE IS NO SUCH JOB.
;OTHERWISE, RH(TTYTAB(N)) IS CONTROLLING DDB FOR JOB N.

;THERE IS ALWAYS A TTY DDB FOR EVERY JOB, EVEN THOUGH NO TTY
; NEED BE ATTACHED.  THUS UUOS LOOK THROUGH TTYTAB(N) FOR A DDB,
; SINCE UUO'S COME FROM JOBS.  COMMANDS LOOK THROUGH LINTAB(LINENUMBER)
; TO THE LDB, SINCE COMMANDS COME FROM TTY'S (LINES).
; IF THE JOB IS DETACHED, THE LINKS FROM LDB TO DDB AND VICE VERSA
; ARE ZEROED (RH OF DDBLDB AND LDBDDB).
TTYTAB::BLOCK	JOBN

IFN FTCIMP,<			;[arpa]
ITYTAB::IFG IMPN,<IFE ITYN,<0>> ;[arpa] DUMMY IF NO ITY'S
	BLOCK	ITYN		;[arpa] SEMI-PSUEDO ITY DEVICE IS NOTHING MORE THAN
				;[arpa] AN ENTRY IN THIS TABLE. THE IMP DDB CONTAINS
				;[arpa] A LINE NUMBER WHICH IS OFFSET BY ITYFST
				;[arpa] FROM THE INDEX INTO ITYTAB.
XP	ITYTBN,.-1		;[arpa]
> ;END IFN FTCIMP		;[arpa]

PTYTAB::BLOCK	PTYN		;ADDRESSES OF THE DDBS OF
				;DEVICES PTYN (NOT TTYN LINKED BY PTY)

IFN FTDIAL,<
TTYDDL::BLOCK	1		;DIALLER INTERLOCK
TTYDDA::BLOCK	1		;TTY DIALLER DATA ADDRESS, 4 WORD BLOCK
DSDUNI::BLOCK	1		;TTY NUMBER USING DIALLER CODE
>

XPNMSZ==<JOBN/^D32>+1		;SIZE OF BIT MAP
XPNMAP::BLOCK	XPNMSZ		;BIT MAP OF EXPANDING JOBS
XP XPNMPT,-XPNMSZ		;FOR MAKING AOBJN POINTER
SUBTTL	SYSTEM WIDE VARIABLES

;SYSTEM WIDE VARIABLES:
; CLEARED AT SYSTEM STARTUP

;GETTAB FOR SYSTEM WIDE VARIABLES (AS OPPOSED TO PER CPU DATA)
; GETTAB TABLE NO(RH) IS .GTSYS=51


SYSTBL::		;GETTAB TABLE NO. 51.  ( .GTSYS = 51
SYSERR::0		;(0) TOTAL NUMBER OF HARDWARE AND SOFTWARE ERRORS
			; DETECTED BY THE MONITOR AND ENTERED IN DAEMON
			; ERROR LOG FILE INCLUDING DAEMON ERRORS.
			; INCLUDES HARD AND SOFT ERRORS
			; HARD ERROR WITH 80 RETRIES ONLY COUNTS AS 1 ERROR IN SYSERR.
CMNOTF::0		;(1) NUMBER OF TIMES SCNSER WAS CALLED TO
			; FIND A COMMAND BECAUSE COMCNT WAS
			; NON-ZERO AND NO COMMAND WAS FOUND
DELCNT::0		; (2) DISABLED ERROR LOGGING COUNT
			; INCREMENT INSTEAD OF SYSERR IF USER HAS DISABLED
			; ERROR LOGGING IN OPEN UUO
%SYSPC::0		;(3) LH = THREE LETTER SIXBIT CODE OF LAST STOPCD
			;    RH = ADDRESS + 1 OF LAST STOPCD
%SYNDS::0		;(4) NUMBER OF DEBUG STOPCD'S.
%SYNJS::0		;(5) NUMBER OF STOPCD'S WHICH CAUSED A JOB TO BE
			;    STOPED.
COMTOT::0		;(6) NUMBER OF COMMANDS PROCESSED
			; (DELAYED COMMANDS ARE COUNTED ONCE WHEN PROCESSED)

%SYSJN::0		;(7)JOB# OF JOB ON LAST STOPCD
%SYSTN::0		;(10)TTY NAME FOR LAST STOPCD
%SYSPN::0		;(11)PROGRAM NAME FOR LAST STOPCD
%SYSUU::0		;(12)UUO ON LAST STOPCD
%SYSUP::0		;(13)USER'S PC ON LAST STOPCD
%SYSPP::0		;(14)USER'S PPN ON LAST STOPCD
XP SYSMXL,<<.-SYSTBL-1>B26>	;MAX. ENTRY
;UNPUBLISHED SYSTEM VARIABLES:

;OTHER SYSTEM DATA STORAGE


COMCNT::0			;NUMBER OF COMMANDS TYPED-IN BUT NOT DECODED
				;SET BY SCNSER, DECREMENTED BY COMCON
IFN FTMP,<
COMJOB::0			;JOB NUMBER OF JOB CURRENTLY EXECUTING
				; A COMMAND USED TO AVOID JOBSTS UUO RACE
>
NFCNT::	0			;COUNT OF TIMES COMCNT NON-ZERO,
				;BUT NO WAITING COMMANDS
HNGMIN::0			;DO ONCE PER MINUTE FUNCTIONS WHEN THIS
				;FLAG COUNTS NEGATIVE
				; SCHEDULER SCANS ALL JOBS EVERY
				; MINUTE TO SEE IF QJOB HAS BEEN COUNTED
				; DOWN TOO FAR.  MORE LIKELY IN DUAL CPU SYS.

CHKCNT::0			;NO. OF CALLS TO CHKTAL TO CHECK CORE
				; BEFORE ACTUALLY DOING THE OVERHEAD.
				; RESET TO M.CMCT WHEN COUNTS TO 0.


DATREM::0			;LAST REMAINDER IN UPDATING "DATE" (SMITHSONIAN DATE)

SCDTIM::0			;DECREMENTED EVERY JIFFY, END OF MEDIUM
				;TERM SCHED INTERVAL WHEN THIS REACHES ZERO.
	subttl	Linking data

IFN FTLINK,<		;[link]

	EXTERN	LNKSER	;[link]	get support code

IFNDEF LKTSIZ,<		;[link]	any size set yet?
	LKTSIZ==:^D50	;[link] no.  use default MAXIMUM NUMBER OF LINKS
>			;[link]
LNKTBL::BLOCK	LKTSIZ	;[link] TERMINAL LINK LINKED-LIST TABLE
LKBSIZ==:LKTSIZ*4	;[link]
LNKBUF::BLOCK	LKBSIZ	;[link]	HOLDING BUFFERS FOR THE CHARACTES TO ECHO
LNKBND==:.-1		;[link]

> ;[link] END IFN FTLINK
;STORAGE FOR VARIOUS CORE ALLOCATION FUNCTIONS AND OTHER NON-SWAPPING DATA


	XP	PAGSIZ,1000

	XP	PG.BDY,PAGSIZ-1	;MASK TO MAKE CORE REQUEST AN EVEN MULTIPLE
				;OF THE BASIC UNIT MINUS ONE
	XP	MPGSIZ,-PAGSIZ
	XP	P2WLSH,11
	XP	W2PLSH,-P2WLSH	;SHIFT AMOUNT TO CONVERT # OF WORDS TO #
				;PAGES
	XP	K2WLSH,12	;SHIFT AMOUNT TO CONVERT # OF K TO # OF WORDS
	XP	W2KLSH,-12	;SHIFT AMOUNT TO CONVERT # OF WORDS TO # OF K
	XP	CRPOS,7		;POSITION OF BYTE
	XP	CRSIZ,9
	XP	CRPOS,8
	XP	P2KLSH,-1
	XP	K2PLSH,1
XP BLKSPP,BLKSPK-K2PLSH		;SHIFT AMOUNT TO CALCULATE # OF BLOCKS/PAGE
XP PP256K,^D512/<<PAGSIZ>_-^D9>



;CORE ALLOCATION DATA NOT AVAILABLE VIA GETTAB
			; BEFORE HALT.  USED TO DETECT SWEEP THRU CORE
;CALCULATE MOD(CORBLK,CTNBPW)

	XP	CORBLK,<^D256*^D1024>/PAGSIZ	;NUMBER OF BYTES IN CORTAB
	XP	COR256,CORBLK	;NUMBER OF PAGES (K) IN 256K

IFN M.KI10!M.KL10,<
	XP CORBLK,<^D16*CORBLK>
>
IFN M.KS10,<
	XP CORBLK,<4*CORBLK>
>

CORTAB::BLOCK	0
CTBMXL==:<.-CORTAB-1>B26		;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9

HOLES::	0			;SIZE OF THE LOWEST HOLE IN MEMORY

IFN FTLOCK,<
LOCK::	0			;JOB#,,HIGH SEGMENT# OR
				;0,,JOB# IF NO HIGH SEGMENT
				;OF JOB CURRENTLY BEING LOCKED IN CORE

LOKREL::0			;DESIRED PROTECTION,,RELOCATION
				;FOR JOB CURRENTLY BEING LOCKED
LASLOK::0			;JOB # OF LAST JOB LOCKED

IFN SYS50N,<
HOLEF1::0			;ADDRESS OF THE BOTTOM OF THE LARGEST CONTIGIOUS HOLE
				;THAT CAN BE MADE IN CORE IF EVERYTHING
				;SWAPPABLE IS SWAPPED
				;(INITIALIZED TO SYSSIZ ON 143 RESTART)

IFN LOKN,<
HOLTOP::0			;ADDRESS+1 OF THE TOP OF THE ABOVE HOLE
				;(INITIALIZED TO MEMSIZ ON 143 RESTART)
>
IFE LOKN,<HOLTOP==:MAXMAX>
>
>

IFN FTMONL!FTMOFFL,<
MOFLPG::0			;FLAG FOR SETTING MEMORY ON OR OFF LINE
>
DOORBL::0			;SYSTEM DOORBELL
IFN FTKL10&FTMP,<
SAVCTL::0			;VALUE OF CORTAL WHEN MM RESOURCE WAS OBTAINED
>
ONCHDR::0			;HEAD OF ONCE-ONLY LIST
IFN FTKLP,<
NZSFCU::0			;HEAD OF NON-ZERO SECTION FREE CORE LIST
NZSFC2::0			;HEAD OF SECTION-2 FREE CORE LIST
>
	$HIGH
NZSFCH::
	400000,,ONCHDR		;SECTION ZERO IS ONCE-ONLY CORE
IFN FTKLP,<
	Z			;NO SECTION-1
	400000,,NZSFC2		;POINTER TO SECTION 2 (SWAP SAT) LIST
	400000,,NZSFCU		;POINTER TO UNCACHED (SECTION 3) LIST
>
	NZSFCL==:.-NZSFCH
	$ABS
NZSFCE::			;TAIL POINTERS FOR NZS FREE CORE
	BLOCK	NZSFCL		;ACTUALLY FILLED IN BY SYSINI
;DATA LOCATIONS PRESENT ONLY IN SWAPPING SYSTEMS

	IFG	SYS50N, <	;SWAPPING SYSTEM ?

SWPTBL::!			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BY GETTAB UUO (THESE LOCATIONS
				; PRESENT ONLY IN SWAP SYSTEMS)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB ARG
				;THIS IS DOCUMENTED AS GETTAB TABLE NUMBER 13
BIGHOL::0			;(0) CURRENT BIGGEST HOLE IN CORE (1K BLOCKS)
FINISH::0			;(1) IF +, THEN JOB NUMBER OF JOB BEING SWAPPED IN,
				;IF -, THEN JOB NUMBER OF JOB BEING SWAPPED OUT
FORCE::	0			;(2) JOB NUMBER BEING FORCED TO SWAP OUT
FIT::	0			;(3) JOB NUMBER WAITING TO BE FITTED INTO CORE
VIRTAL::0			;(4) NUMBER OF FREE 1K BLOCKS OF SWAPPING SPACE LEFT
				; (COUNTING DORMANT SEGMENTS AS IF FREE).
				; PRINTED WITH CORE COMMAND (NO ARG) OR ERROR
				; USUALLY THE SAME AS THE AMOUNT OF VIRTUAL CORE
				; LEFT IN SYSTEM, EXCEPT WHILE R,RUN,KJOB,GET
				; COMMAND ARE WAITING TO BE SWAPPED IN, BECAUSE
				; THE OLD DISK SPACE HAS NOT BEEN RETURNED YET,
				; BUT VIRTUAL CORE IS ONLY 140 WORDS FOR SWAPIN
SWPERC::0			;(5) LH= NUMBER OF SWAPPER READ OR WRITE FAILURES
				; RH= ERROR BITS (BITS 18-23) + NUMBER OF K OF
				; IOCHNX=IO CHANNEL SWAP NON-EX MEM - BIT 23
				; IOCHMP=IO CHANNEL SWAP OUT MEMORY PARITY - BIT 22
				; BITS 18-22 = IOIMPM (SOFTWARE CHECKSUM),
				; IODERR, IODTER, IOBKTL
				; DISCARDED SWAPPING SPACE
SWAPIN::0			;(6) IF THE SYSTEM HAS FTPDBS TURNED ON,
				;     THIS WORD IS -1 WHEN A SWAPIN IS
				;     IN PROGRESS AND ZERO WHEN A SWAP OUT
				;     IS IN PROGRESS. IF FINISH IS ZERO
				;     THEN NO SWAP IS IN PROGRESS. IF FTPDBS
				;     IS OFF THIS WORD IS ALWAYS ZERO.



				;INSERT NEW LOCATIONS HERE WHICH ARE OF INTEREST
				; TO USER PROGS IN SWAPPING SYSTEMS
SWPEUJ::0			;(7)LH=J FOR JOB OR SEGMENT WHICH GOT A SWAP
				; READ/WRITE ERROR, RH=UNIT THAT THE
				; SWAPPING I/O WHICH RESULTED IN THE ERROR
				; WAS DONE TO
SWPMXL==:<.-SWPTBL-1>B26	;MAXIMUM ENTRY FOR GETTAB SHIFTED LEFT 9
;MORE SWAPPING SYSTEM LOCATIONS (NOT RETURNED BY GETTAB)

MAXJBN::0			;NUMBER OF JOB TO SWAP OUT
SUMCOR::0			;TEMPORARY STORAGE CELL USED BY SWAPPER FOR SUM OF
				; CORE NEEDED FOR SWAP IN
FITLOW::0			;NUMBER OF JOB BEING FIT (NEVER HI-SEG)
SWPIN::	0			;JOB NUMBER BEING SWAPPED IN IF IT HAS A HIGH SEG
SWPOUT::0			;JOB NUMBER BEING SWAPPED OUT IF IT HAS A HIGH SEG
				; (USED TO REMEMBER THE JOB NUMBER DURING HIGH SEG SWAP)



IFN FTRSP,<
SWPNU2::0			;JIFFY REMAINDER FOR SWAP NULL TIME
SWPLS2::0			;JIFFY REMAINDER FOR SWAP LOST TIME
SWPPLT::0			;POTENTIAL LOST TIME FLAG FOR SWAPPER
				;TO TELL CLOCK1 TO COUNT SOME LOST TIME
				;(HAVE JOB TO SWAP IN BUT SWAPPER IDLE)
SWPNUF::0			;NULL CYCLE FOR SWAPPER (AGAIN, SO CLOCK1
				;CAN COUNT NULL TIME FOR SWAPPER)
>;END IFN FTRSP

IFN FTNSCHED,<
SCDSTS::0			;TIME OF LAST SETTING OF PRIMARY PERCENTAGES
CNTSTS::0			;COUNT OF CPU CLASSES WITH NON-ZERO QUOTA
TOTSTS::0			;TOTAL OF ALL SUBCLASS PERCENTAGES
				; (MUST BE 100 OR ZERO)
MAXQTA::0			;NUMBER OF HIGHEST CLASS WITH SECONDARY QUOTA
CNTQTA::0			;COUNT OF CLASSES WITH NON-ZERO SECONDARY QUOTA
TOTQTA::0			;TOTAL OF ALL SECONDARY SUBCLASS PERCENTAGES
				; NORMALLY 100%, BUT CAN BE ANY NON-NEGATIVE

>;END OF IFN FTNSCHED
>;END OF IFN SYS50N
IFN FTNSCHED,<
;DESIRED CHANNEL UTILIZATION FRACTION TABLE
;VALUES EXPRESSED AS DECIMAL NUMBERS BETWEEN ZERO AND 100,
;INTERPRETED AS PERCENTAGES. SET BY SCHED. UUO, READ BY
;SCHED. UUO AND GETTAB

.GTDCF::BLOCK	M.CHN		;DCUF - TABLE #116

DCFMXL==:<.-.GTDCF-1>B26	;MAX LENGTH FOR GETTAB
>;END IFN FTNSCHED

	SYSEND==:.-1		;END OF CLEARED STORAGE ON RESTART
SUBTTL ONCE ONLY CODE TO CREATE DEVICE DATA BLOCKS

	LOC	SYSBEG		;PUT IN SYSTEM DATA AREA SO NOT TO TAKE
				; VALUABLE SPACE.  THIS AREA IS CLEARED
				; BY SYSINI AFTER IT HAS BEEN EXECUTED
IFN FTAUTC,<
	EXTERN	AUTCON
>

;CNTDB- ROUTINE TO INCREASE SIZE OF MONITOR FOR MULTIPLE DEVICE DATA BLOCKS
; BOTH DISK AND OTHER DEVICES (DTA,MTA,SCN,PTY)
; CALL:  JSP T1,CNTDB  (FROM LONG ONCE DIALOG)
;
;LINKDB- ROUTINE TO CREATE MULTIPLE DEVICE DATA BLOCKS (EXCEPT DISK)
; AND LINK THEM. THESE ARE STORED ON TOP OF ONCE ONLY CODE
;CALL:  JRST LINKDB (FROM LINKSR)
;BOTH ROUTINES UPDATE  SYSSIZ AS MORE DDB SPACE IS CONSUMED


LINKDB::!SETOM	DESONC		;PERMIT DESTRUCTION OF ONCE ONLY CODE
	SKIPA	T1,LINKSR##	;GET JSR PC OF CALLER OF LINKSR IN ONCE
CNTDB::!SETZM DESONC		;PREVENT DESTRUCTION OF ONCE ONLY CODE
				;SO THAT E.G. SAT TABLES MAY BE SCANNED
	HRRM	T1, LINKED	;STORE EXIT FROM THIS ROUTINE (ONCE ONLY CODE WILL
				; BE OVERLAYED BY MULTIPLE DEVICE DATA
				; BLOCK GENERATION)

IFN LEVDN,<;THIS CODE COMPUTES WHERE THE STR DATA BLOCKS ETC. MUST GO & HOW MUCH CORE THEY TAKE UP

	MOVEI	T1,SYSINI##	;BEGINNING OF SYSINI
	SKIPE	DESONC		;SKIP IF NOT DESTROYING ONCE
	CAMG	T1,SYSSIZ	;SKIP IF SYSINI WILL BE CLOBBERED
	JRST	NOMOVE		;NO, SYSINI IS SAFE, NO NEED TO MOVE IT
	HRRZ	T2,INIFRE	;DESTINATION=FIRST FREE LOCATION ABOVE MONITOR
	CAMGE	T2,HICORE##	;SKIP IF END OF MONITOR PAST DISK STUFF
	MOVE	T2,HICORE##	;NO, USE THAT INSTEAD
	MOVE	T1,T2
	HRLI	T1,SYSINI##	;SOURCE=BEGINNING OF SYSINI
	BLT	T1,ENDSYL##(T2)	;MOVE SYSINI TO SAFE PLACE
	SUBI	T2,SYSINI##	;T2=NEW SYSINI - OLD=CHANGE
	MOVEI	T3,SYSKON##-KONNXT## ;OFFSET FOR FIRST KDB IN SYSTEM
NXKUPA:!HLRZ	T3,KONNXT##(T3)	;STEP TO NEXT KDB IN SYSTEM
	JUMPE	T3,EFUPA	;GO IF AT END OF CHAIN
	ADDM	T2,KONUPA##(T3)	;PATCH LOCATION OF UPA ROUTINE (IN SYSINI)
	JRST	NXKUPA		;LOOP FOR NEXT KDB
EFUPA:!	HRRZ	T1,LINKED	;EXIT FROM RUN SUBROUTINE
	CAIL	T1,SYSINI##	;SKIP IF NOT TO SYSINI
	CAILE	T1,ENDSYS##
	JRST	NOMOVE
	ADDM	T2,LINKED	;NEW RETURN IN SYSINI

NOMOVE:!
	MOVE	T1,SYSSIZ	;SIZE OF MONITOR SO FAR (SYSMAK, EXEC DDT OR NOT)
	MOVE	T2,T1		;GET A COPY OF SYSSIZ FOR MAKING THE BLT PTR.
	HRL	T2,DDSTAR	;SETUP THE SOURCE ADR.
	ADD	T1,HICORE##	;NOW COMPUTE THE FINAL DESTINATION ADR. +1
	SUB	T1,DDSTAR
	MOVEM	T1,SYSSIZ
	SKIPE	DESONC		;DON'T BLT HIGH CORE STUFF IF NOT OK TO DESTROY ONCE
	BLT	T2,-1(T1)	;OVERLAY ONCE STUFF WITH STR DATA BLOCKS ETC.
	SKIPN	T1,QUESTR##	;GET PRESET STR NAME
	JRST	NOQSTR		;NONE SELECTED
	MOVE	T2,STRAOB##	;SEE IF IT EXISTS
	CAME	T1,@TABSTR##(T2)	;STRNAM IS FIRST WORD
	AOBJN	T2,.-1		;LOOK AT ALL STRS
	JUMPL	T2,QSTROK	;JUMP IF MATCH
NOQSTR:!MOVE	T1,TABST0##	;ADR. OF FASTEST FILE STRUCTURE
	MOVE	T1,STRNAM##(T1)	;FILE STRUCTURE NAME
	MOVEM	T1,QUESTR##	;STORE FOR QUEUEING CUSPS GETTAB UUO
>


QSTROK:!MOVSI	T1,INTNUM	;NEG NUMBER OF ENTRIES IN TABLE
	MOVEI	F,DEVLST-DEVSER	;MAKE DEVLST LOOK LIKE DEVSER IN A DDB
	SETZB	U,S		;START WITH NO PROTOTYPE DDB
				;S FOR FLAGS
LOOP:!	LDB	T2,PINTDB	;GET DDB ENTRY
	JUMPE	T2,NEXT		;0 MEANS NO DOB FOR DEVICE
	HLRZ	M,DEVNAM(T2)	;GET NEW GENERIC
	HLRZ	J,DEVNAM(U)	;GET PREVIOUS GENERIC
	CAME	T2,U		;IS NEW DDB BEING USED
	TRO	S,1		;YES - SET NO-COPY FLAG SO THAT
				;THIS DDB WILL BE USED ONCE
	CAME	M,J		;SAME DDB AS LAST ENTRY
	MOVEI	P3,0		;NO- RESET DEVICE NUMBER
IFN FTMP,<
	LDB	P2,PINTCH	;GET CHAN NUMBER
	EXCH	T2,F
	LDB	U,DEYCPF	;GET (1ST) CPU NUMBER
	CAIN	U,7		;TTY (NET) QUEUED PROTOCOL
	TDZA	U,U		;YES, USE "CPU0" INTERLOCKS
	LSH	U,3
	ADDI	U,INTL0(P2)	;CPU *10+CHAN IS INTERLOCK OFFSET
	SKIPE	DESONC
	HRRM	U,DEVCPU(F)	;SAVE LOC OF INTERLOCK IN DDB
	EXCH	F,T2
>
	HRRZ	U,T2		;UPDATE PROTO PTR
	PUSHJ	P,DDBLNK	;GO LINK DDB'S,ETC. FOR ONE INTTAB ENTRY


NEXT:!	AOBJN	T1,.+1		;MOVE BY TWOS
	AOBJN	T1,LOOP		;ANY MORE DEVICES
	MOVEI	T1,0		;NO, FLAG END OF DEVICE DATA BLOCK CHAIN WITH 0 LINK
	SKIPE	DESONC		;OK TO DESTROY ONCE ?
	HRLM	T1,DEVSER(F)	;YES, STORE 0 IN CASE LAST DDB IS MULTIPLE
IFG	XTCN,<
	MOVEI	F,XKB0##	;GET LOC OF FIRST KDB
XKBLP:	MOVEI	T1,1B33		;WANT TO READ
	XCT	XTCCNO##(F)	;  DA28 FEATURE REG
	XCT	XTSDTI##(F)	;READ FEATURES
	JUMPE	T1,XKBNUL	;NOT THERE
	ANDI	T1,17		;WANT ONLY NUMBER OF UNITS
	MOVEI	T2,XKBUDB##(F)	;GET ADDRESS OF UDB TABLE
	MOVE	T3,SYSSIZ	;GET CURRENT CORE ALLOCATION
XUBLP:	SKIPN	DESONC		;WRITING OVER ONCE?
	JRST	XUBALC		;NO, ONLY ALLOCATE
	MOVEM	T3,0(T2)	;SAVE UDB ADDRESS
	HRL	T4,T3		;BUILD BLT WORD
	HRRI	T4,1(T3)	;  TO ZERO UDB
	SETZM	0(T3)
	BLT	T4,XUBSIZ##-1(T3)	;ZERO IT
	MOVEM	F,XUBKDB##(T3)	;LINK UDB TO KDB
	MOVE	T4,T2
	SUBI	T4,XKBUDB##(F)	;CALCULATE UNIT NUMBER
	MOVEM	T4,XUBUNO##(T3)	;STORE IN XUB
	ADDI	T4,2120		;CONVERT TO SIXBIT
	TRZN	T4,10
	LSH	T4,6
	LSH	T4,6		;POSITION IN WORD
	MOVEM	T4,XUBNAM##(T3)	;MOVE INTO UNIT NAME
	MOVE	T4,XKBNAM##(F)	;PICK UP KNOTROLLER NAME
	HLLM	T4,XUBNAM##(T3)	;FILL IN REST OF UNIT NAME
XUBALC:	ADDI	T3,XUBSIZ##	;BUMP ALLOCATION
	MOVEM	T3,SYSSIZ	;AND SAVE IT
	AOS	T2		;BUMP UDB TABLE POINTER
	SOJGE	T1,XUBLP	;LOOP IF MORE UNITS
XKBNUL:	HRRZ	F,XKBKDB##(F)	;NO, GET ADDR OF NEXT KDB
	JUMPN	F,XKBLP		;LOOP IF IT IS THERE
	MOVEI	T1,1000		;SPACE FOR DDB'S
	ADDB	T1,SYSSIZ	; ..
>
;FOLLOWING CODE ALLOCATES SPACE FOR THE LINE DATA BLOCKS AND FOR CHARACTER LISTS

	MOVE	T1,SYSSIZ	;GET CURRENT SIZE
	TRZ	T1,TTCHKS-2	;NEAREST EVEN CHUNK BOUNDRY +1
	TRO	T1,1
	CAMGE	T1,SYSSIZ	;SMALLER THAN SYSSIZ?
	ADDI	T1,TTCHKS	;YES, THEN MUST USE NEXT ONE
	MOVEM	T1,SYSSIZ	;& REMEMBER
	HRRM	T1,TTCLST	;SAVE AS FIRST CHARACTER CHUNK ADDR
	HLRZ	T1,TTCLST	;COMPUTE SPACE NEEDED
	IMULI	T1,TTCHKS	;FOR CHARACTER LIST
	ADDM	T1,SYSSIZ	;AND UPDATE SYSTEM SIZE
	SKIPE	DESONC		;FIRST TIME?
	JRST	LNKTTA		;NO, GO BUILD THE LDBS
	SKIPE	LDBVRG		;ALREADY HAVE STARTING ADDRESS
	JRST	LNKTT3		;YES, MUST BE RESTART AT ONCE
	MOVE	T1,MONVFF	;FIRST FREE MONITOR VIRTUAL ADDRESS
	MOVEM	T1,LDBVRG	;SAVE AS THE ORIGIN OF THE LDB SPACE
	MOVEI	T1,TTPLEN##*LDBLEN## ;NUMBER OF WORDS REQUIRED BY LDBS
IFE FTKLP,<
	MOVEI	T2,PM.ACC+PM.WRT+PM.SWB+IFE M.KI10,<IFE M.CPU-1,<PM.CSH>>
>
IFN FTKLP,<
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.SWB)
>
	PUSHJ	P,ONCMAP##	;SETUP THE MAP SO THAT LDB SPACE IS ADDRESSABLE
	JRST	LNKTT3		;SKIP ON
LNKTTA:!MOVEI	J,0		;MAKE THE LDB'S
	SKIPA	U,LDBVRG	;WHERE TO ORGIN THE LDBS
LNKTTL:!ADDI	U,LDBLEN##	;LENGTH OF AN LDB
	MOVEI	T1,LDBLEN##(U)	;WHERE TO BLT TO
	HRLI	U,SCNLDB##	;GET THE ADR OF THE PROTO LDB
	PUSH	P,U
	BLT	U,-1(T1)	;COPY THE LDB
	POP	P,U
	HRRM	U,LINTAB##(J)	;AND SAVE ITS ADDRESS
	DPB	J,LDPLNO##	;STORE PHYSICAL LINE NUMBER IN LDB
DEFINE	CXDEF(SYM)<
IRP SYM,<
IFNDEF M0'SYM,<M0'SYM==M.'SYM>
IFNDEF M1'SYM,<M1'SYM==0>
IFNDEF M2'SYM,<M2'SYM==0>
IFNDEF M3'SYM,<M3'SYM==0>
IFNDEF M4'SYM,<M4'SYM==0>
IFNDEF M5'SYM,<M5'SYM==0>
>>
CXDEF(<TTG0,TTG1,68L0,68L1,D70N,D71N>)
CXDEF(<D72N,D73N,D74N,D75N,D76N,D77N>)
IFNDEF TTCHKS,<TTCHKS==4>
XP TTCHKS,TTCHKS
XP CK.BDY,TTCHKS-1
XP CK.BTH,-CK.BDY
DEFINE	TTDSPX(DSP,ADDON,CLEVER,STA,QUEUE,CPU,ACTY,X),<
	LINENO==LINENO+ADDON
IFN	ADDON,<
IF2,< IFNDEF QUEUE,<EXTERN QUEUE>>
	MOVSI	T4,QUEUE
	HRRI	T4,CPU
IF2,< IFNDEF DSP,<EXTERN DSP>>
	MOVEI	T1,DSP	;ASSUME THIS FRONT END
IFIDN <CLEVER>,<Y>,<
	TLO	T1,LILCFE##	;SET THE BIT FOR DC76
>
IFN M.NET,<
IFE STA-LOCSTA,<
	MOVEI	T2,0		;NOT A REMOTE STATION TTY
>
IFN STA-LOCSTA,<
	SETO	T2,		;SET A FLAG FOR REMOTE LDB
>>
	CAIG	J,LINENO-1	;IS IT THIS LINE?
	JRST	LNKTT2		;YES--SET LDBISR AND LDBREM
>>
	LINENO==0
DEFINE	TTSPCP(CPU),<
	DC10N0==10*M'CPU'TTG0
	DC10N1==10*M'CPU'TTG1
	TTDSPX(DL0DSP,DC10N0,N,\LOCSTA,DL0TQ'CPU,CPU,)
	TTDSPX(DL1DSP,DC10N1,N,\LOCSTA,DL1TQ'CPU,CPU,)
	TTDSPX(CC0DSP,M'CPU'68L0,N,\LOCSTA,CC0TQ'CPU,CPU,)
	TTDSPX(CC1DSP,M'CPU'68L1,N,\LOCSTA,CC1TQ'CPU,CPU,)
	TTDSPX(DC760D,M'CPU'D70N,Y,\LOCSTA,D70TQ'CPU,CPU,)
	TTDSPX(DC761D,M'CPU'D71N,Y,\LOCSTA,D71TQ'CPU,CPU,)
	TTDSPX(DC762D,M'CPU'D72N,Y,\LOCSTA,D72TQ'CPU,CPU,)
	TTDSPX(DC763D,M'CPU'D73N,Y,\LOCSTA,D73TQ'CPU,CPU,)
	TTDSPX(DC764D,M'CPU'D74N,Y,\LOCSTA,D74TQ'CPU,CPU,)
	TTDSPX(DC765D,M'CPU'D75N,Y,\LOCSTA,D75TQ'CPU,CPU,)
	TTDSPX(DC766D,M'CPU'D76N,Y,\LOCSTA,D76TQ'CPU,CPU,)
	TTDSPX(DC767D,M'CPU'D77N,Y,\LOCSTA,D77TQ'CPU,CPU,)
IFN FTKS10,<
	TTDSPX(DZDSP,M'CPU'DZNL,Y,\LOCSTA,DZTQ'CPU,CPU,)
>
IFN FTKL10,<
	TTDSPX(TTDDSP,M'CPU'TTDN,N,\LOCSTA,.C'CPU'CTQ,CPU,)
>; END IFN FTKL10
IFN	FTXTC,<
	IFN	M.XTL,<
	TTDSPX(XTTDSP,M.XTL,N,\LOCSTA,XTTQUE,)
>>		;END OF FTXTC & M.XTL
ifn FtCImp,<	;[arpa] generate LDBs for arpanet terminals
	TTDSPX(IMPISR,M'CPU'ITY,N,\LOCSTA,ITYQ'CPU,CPU,)	;[arpa]
> ;[arpa]
>
;GENERATE LDB'S FOR LOCAL LINES
ZZ==0
REPEAT	CPUN,<
	TTSPCP(\ZZ)
ZZ==ZZ+1
>
;NOW GENERATE A POOL OF LDB'S FOR NETWORK TTYS
;ASSUME ALL ARE ON CPU0 SINCE NETWORK LDB'S ARE DYNAMICALLY ALLOCATED
; FROM THE POOL AND THE CORRECT OUTPUT QUEUE AND CPU NUMBER ARE FILLED
; IN BY NETSER WHEN THE LDB IS USED

	TTDSPX(REMDSP,M.RMCR,N,37777,NETRTQ,)

;KS10 KLINIK LINE
IFN M.KS10,<
DEFINE TTSPCP(CPU),<
	TTDSPX(CTYDSP,1,N,\LOCSTA,.C'CPU'CTQ,CPU,)
>
ZZ==CPUN-1
REPEAT CPUN,<
	TTSPCP(\ZZ)
ZZ==ZZ-1
>
>;END IFN M.KS10

;NOW GENERATE AN LSB FOR INTERNAL FORCED COMMANDS

FRCLIN==:LINENO
	TTDSPX(ERRDSP,1,N,\LOCSTA,FRCQUE,7,)

;NOW GENERATE LDB'S FOR THE CTYS

DEFINE	TTSPCP(CPU),<
CT'CPU'LIN==:LINENO
	TTDSPX(CTYDSP,1,N,\LOCSTA,.C'CPU'CTQ,CPU,)
>
ZZ==CPUN-1
REPEAT	CPUN,<
	TTSPCP(\ZZ)
ZZ==ZZ-1
>
IFN TCONLN-CT0LIN,<PRINTX ?TTDSPX IS IN ERROR>

	MOVEI	T1,ERRDSP##	;PTY LINE
IFN M.NET,<
	MOVEI	T2,0		;NOT ON REMOTE STATION
>
	MOVEI	T4,7		;FAKE CPU NUMBER
	HRLI	T4,FRCQUE##	;AND FAKE QUEUE HEADER
LNKTT2:!TLO	T1,T1		;SET UP INDEX FOR @LDBISR(U)
	MOVEM	T1,LDBISR##(U)	;STORE AWAY
	HLLZM	T4,LDBQUE##(U)
	DPB	T4,LDPCPU##
IFN M.NET,<
	MOVEI	T3,LDRREM##	;REMOTE STATION BIT
	SKIPE	T2		;AT A REMOTE STATION?
	IORM	T3,LDBDCH##(U)	;YES, SET BIT.
>
LNKTT1:!CAIGE	J,TTPLEN##-1	;MADE ENOUGH LDB'S?
	AOJA	J,LNKTTL	;NO. MAKE ANOTHER ONE
LNKTT3:!
IFN M.DECN,<
	MOVE	T1,SYSSIZ	;GET NEXT FREE PLACE.
	HRRM	T1,DCNPTR##	;SAVE AS POINTER TO BIT MAP FOR DECNET FREE CORE
	ADDI	T1,DCNSIZ/^D144	;RESERVE ENOUGH WORDS FOR OUR BIT MAP
IFE FTKLP,<
	MOVEM	T1,DCNLOC##	;SAVE POINTER TO POOL
	ADDI	T1,DCNSIZ	;POINT POOL PAST THIS.
>;END IFE FTKLP (IFN FTKLP IS GENERATED AT D36MEM)
	MOVEM	T1,SYSSIZ	;NEW POINTER IS PAST THE DECNET FREECORE.
>;END IFN M.DECN

	MOVE	T1,SYSSIZ	;GET SYSTEM SIZE INTO T1
IFN FTCIMP,<			;[arpa] while we have the end in T1,
    IFG IMPN,<			;[arpa] take a free ride with it if ARPA.
	HRRZM	T1,IMPBUF##	;[arpa] STORE ADDR OF FIRST IMP BUFFER (SYSSIZ)
	ADDI	T1,IMPTBS##	;[arpa] RESERVE BUFFER SPACE
	HRRZM	T1,IMPBFE##	;[arpa] POINTER FOR END CHECKING
    >				;[arpa]
>				;[arpa]
IFN LEVDN,<
	ADDI	T1,CRWDM1##	;MAKE SURE 4 WORD BLOCKS HAVE BOTTOM 2 BITS = 0
	TRZ	T1,CRWDM1##
	HRLZM	T1,SYSCOR##	;SAVE ADR. OF 1ST. PERMANENT 4 WORD BLOCK IN SYSCOR
	MOVE	T2,CORNUM##	;GET # OF BLOCKS TO BE GENERATED
	ADDI	T1,CORWDS##	;COMPUTE ADR. OF NEXT BLOCK
	SKIPE	DESONC		;OK TO DESTROY ONCE ONLY CODE?
	HRLZM	T1,DIFLNK##(T1)	;YES - SAVE ADR. OF NEXT BLOCK IN THIS BLOCK
	SOJG	T2,.-3		;FINISHED YET?
	SKIPE	DESONC		;OK TO DESTROY ONCE ONLY CODE?
	SETZM	DIFLNK##(T1)	;YES - ZERO LINK IN LAST BLOCK TO SIGNAL END OF LIST
>	;END OF DSKN CONDITIONAL
	HRRM	T1,FREPTR	;SAVE ADR. OF BIT TABLE OF ALLOCATABLE 4 WORD BLOCKS
	MOVEM	T1,LOCORE	;SAVE POINTER TO 1ST. 4 WORD BLOCK
	MOVEI	T2,<<3*JOBN+3>/4>*4	;3/4 TIMES NUMBER OF JOB
	IMULI	T2,PDB4WD	;TIMES CORE FOR A PDB
	ADDI	T2,CSHMEM##	;PLUS CORE FOR DISK CACHE DIRECTORY
IFE FTKLP,<ADDI T2,CBHSHS##*200>;PLUS CORE FOR DISK CACHE DATA
ifn fthistory,<
	move	t3,histsz##	;Get size of a command history save block.
	imuli	t3,jobn		;Give one to each job.
	add	t2,t3		;Add it in.
>;ifn fthistory
	ADDI	T1,MINCOR(T2)	;MIN REQUIRED FOR DISK DDBS OR 10/40 EXTENDED PD LIST
	IORI	T1,PG.BDY	;FORCE PAGE BOUNDARY
	ADDI	T1,1
	MOVEM	T1,SYSSIZ	;STORE SIZE OF MONITOR (FIRST FREE LOC)
	SKIPE	INIFRE		;FIRST TIME THROUGH
	JRST	LNKTT6		;NO, PAGTAB AND MEMTAB ARE ALREADY SET UP
IFN FTMONL,<
	MOVE	T1,NWCORE
	CAMG	T1,FLG256
	MOVE	T1,FLG256
	MOVEM	T1,NWCORE
	MOVSS	T1
>
IFE FTMONL,<
	MOVS	T1,FLG256	;GET HIGHEST EXISTING ADDRESS +1
>
	SKIPE	T1		;IF ZERO, MACHINE HAS .LE. 256K OF CORE
	TLZE	T1,-1		;CHECK IF EXACTLY A MULTIPLE OF 256K
	ADDI	T1,1		;NO, 1 MORE PAGE REQUIRED FOR PAGTAB
	LSH	T1,P2WLSH	;NUMBER OF WORDS FOR EACH OF PAGTAB AND MEMTAB

IFE FTKLP,<
	PUSH	P,MONVFF	;SAVE HIGHEST VIRTUAL ADDRESS USED
	PUSH	P,T1		;AND NUMBER OF WORDS REQUIRED
	MOVEI	T2,PAGTAB
	MOVEM	T2,MONVFF	;MAP PAGES TO PAGTAB
	MOVEI	T2,PM.ACC+PM.WRT+PM.SWB+IFE M.KI10,<IFE M.CPU-1,<PM.CSH>>
	PUSHJ	P,ONCMAP##	;ALLOCATE AND MAP IN PAGTAB
	MOVEI	T2,MEMTAB	;NOW DO IT FOR MEMTAB
	MOVEM	T2,MONVFF
	POP	P,T1		;RESTORE NUMBER OF WORDS
	MOVEI	T2,PM.ACC+PM.WRT+PM.SWB+IFE M.KI10,<IFE M.CPU-1,<PM.CSH>>
	PUSHJ	P,ONCMAP##	;ALLOCATE AND MAP IN MEMTAB
	POP	P,MONVFF	;PUT THINGS BACK
>
IFN FTKLP,<
	PUSH	P,T1		;SAVE NUMBER OF WORDS
	MOVE	T1,[EXP MDSEC2+PAGTAB]
	MOVE	T2,T1
	ADD	T2,(P)
	PUSHJ	P,NZSCGT##
	MOVE	T1,[EXP MDSEC2+MEMTAB]
	POP	P,T2
	ADD	T2,T1
	PUSHJ	P,NZSCGT##
>
IFN M.DECN,<
;FOLLOWING CODE ALLOCATES SPACE FOR DECnet BUFFERS
D36MEM:!
IFE FTKLP,<
	PUSH	P,MONVFF	;START OF CORE WE ARE GOING TO ALLOCATE
	POP	P,DCNCOR##	;PUT IT WHERE D36INI CAN FIND IT.
	PUSHJ 	P,DNGTCR##	;GET TOTAL DECnet WORDS REQ'D IN T1
	MOVEI	T2,PM.ACC+PM.WRT+PM.SWB+IFE M.KI10,<IFE M.CPU-1,<PM.CSH>>
	PUSHJ	P,ONCMAP##	;GO CREATE THE CORE
> ;END IFE FTKLP
IFN FTKLP,<
	PUSHJ 	P,DNGTCR##	;GET TOTAL DECnet WORDS REQ'D IN T1
	PUSH	P,T1		;SAVE AMOUNT OF CORE WHICH IS FOR MESSAGES.
;RANDOM SIZED FREE POOL SIZE (SEE LNKTT3 FOR KI-PAGING CODE EQUIVALENT)
	ADDI	T1,DCNSIZ
	MOVEI	T2,777(T1)	;****TEMP**** ROUND UP TO NEXT PAGE
	MOVE	T1,[MDSEC2+MONORG] ;WHERE TO ALLOCATE THE CORE
	ADD	T2,T1		;END OF WHERE TO ALLOCATE THE CORE
	PUSHJ	P,NZSCGT##	;ASK ONCMOD FOR THE CORE
	MOVEM	T1,DCNCOR##	;SAVE AS STARTING ADDRESS OF MESSAGE CORE
	ADD	T1,(P)		;POINT TO END OF MESSAGE CORE
	MOVEM	T1,DCNLOC##	;SAVE AS POINTER TO START OF DECNET FREE CORE
	ADJSP	P,-1		;(DROP AMOUNT WE DON'T CARE ABOUT ANY MORE)
> ;END IFN FTKLP

> ;END IFN M.DECN
LNKTT6:!MOVE	T3,SYSSIZ
	MOVEM	T3,INIFRE	;STORE THAT AS WHERE TO MOVE SYSINI
	SUBI	T3,340000-ENDSYL## ;BELOW 112K + ROOM FOR SYSINI?
	JUMPLE	T3,LNKTT4	;JUMP IF SO
	IORI	T3,PG.BDY	;ROUND UP
	MOVNI	T1,1(T3)	;AMOUNT TO REDUCE THINGS BY
	ADDM	T1,INIFRE	;WHERE TO PUT SYSINI
	ADDM	T1,SYSSIZ
LNKTT4:!MOVE	T1,SYSSIZ	;FIND HOW MUCH IS LEFT OVER AT THE END OF THE PAGE
	SUB	T1,LOCORE	;FORM LENGTH OF EXCESS CORE
	IDIVI	T1,^D144	;MUST BE MULTIPLE OF 144. WORDS (LEVEL C:SEE DDBTAB)
				;SIZE OF BIT TABLE IS NOW IN T1
LNKTT5:!MOVE	T2,T1		;COPY NUMBER OF WORDS FOR BIT MAP
	IMULI	T2,^D145	;NUMBER OF WORDS DESCRIBED
				;  INCLUDING THE BIT MAP
	ADD	T2,LOCORE	;SEE WHERE IT TAKES US
	CAMLE	T2,SYSSIZ	;HOPEFULLY, NOT OFF THE END
	SOJA	T1,LNKTT5	;IT DOES, TRY A SMALLER NUMBER
	ADDM	T1,LOCORE	;MAKE LOCORE POINT TO 1ST. 4 WORD BLOCK
	MOVN	T1,T1		; -N
	HRLM	T1,FREPTR	;STORE USEABLE LENGTH OF DDBTAB
IFN M.DECN,<
	MOVNI	T1,DCNSIZ/^D144 ;NUMBER OF WORDS IN BIT MAP
	HRLM	T1,DCNPTR##	;MAKE THIS POINTER AN AOBJN POINTER
>

LINKED:!JRST .			;RETURN TO SYSINI
INIFRE:!EXP	0		;CONTAINS ADDR OF FREE SPACE FOR SYSINI
;DDB LINK AND CREATION SUBROUTINES

DDBLNK:!CAIN	M,(SIXBIT/DSK/)	;IS THIS A DSK DDB?
	JRST	DDBLDS		;YES - DO EXTRA SPECIAL STUFF
IFN FTAUTC,<
	CAIE	M,(SIXBIT /MTA/) ;MAGTAPE?
	JRST	DDBLN1		;NO
	HLRZ	T3,DEVSER(T2)	;YES. GET LINK (SET UP BY AUTCON)
	JUMPE	T3,CPOPJ	;NOTHING WE CAN DO IF NO MAGTAPES FOUND YET
	MOVE	T2,T3		;PATCH MT0DDB OUT OF CHAIN
DDBLN1:>
	LDB	P2,PINTNO	;NUMBER OF DDB'S TO CREATE
	TRZN	S,1		;SKIP COPY IF NO-COPY FLAG SET ON CALL
MULDDB:!PUSHJ	P,DDBCOP	;GO COPY A DDB
MULDD1:!SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	HRLM	T2,DEVSER(F)	;CHAIN TO PREVIOUS DDB
	HRRZ	F,T2		;UPDATE DDB PTR

	SKIPN	P3		;IF THIS IS DEV 0
	LDB	P1,PUNIT	;RESET UNIT NUMBER FROM DDB
				;(PTY'S, FOR EXAMPLE, START AT #1)
	SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	SKIPN	DEVNAM(F)	;DO NOT MAKE FUNNY NAMES
	SKIPA			;CON NOT WRITE OR NULL NAME
	PUSHJ	P,DDBFIX	;MAKE DDB UNIQUE
	AOS	P3		;INCREMENT # OF DEVNAM
	AOS	P1		;INCREMENT UNIT #
	SOJG	P2,MULDDB	;DO NEXT DDB TILL DONE
IFN FTAUTC,<
	CAIE	M,(SIXBIT /MTA/) ;IS THIS THE MAGTAPE DDB?
	POPJ	P,		;NO, WE'RE DONE
	HLRZ	T2,DEVSER(F)	;YES, PICK UP ITS LINK (SET BY AUTCON)
	JUMPE	T2,CPOPJ	;GO IF IT IS THE END
	EXCH	T2,F
	LDB	P1,PUNIT	;GET THE UNIT NAME
	EXCH	T2,F
	MOVE	P3,P1
	JRST	MULDD1		;GO FIX UP THIS NAME
>
IFE FTAUTC,<
	POPJ	P,0		;THEN RETURN
>

DDBLDS:!TRNE S,2		;HAVE WE BEEN HERE BEFORE
	POPJ	P,0		;YES - RETURN WITHOUT DOING ANYTHING
	TRO	S,2		;SET TRAP FOR ONCE ONLY
IFN SYS50N,<
	MOVEI	T3,SWPDDB##	;ADR. OF SWAPPING DDB
	SKIPE	DESONC		;SKIP IF NOT ABLE TO DESTROY ONCE ONLY
	HRLM	T3,DEVSER(F)	;LINK PREVIOUS DDB TO SWPDDB
	MOVEI	F,SWPDDB##	;UPDATE DDB PTR TO SWPDDB
				; THUS SWPDDB COMES BEFORE DSKDDB
				; IN DEVICE CHAIN.  NEED IN CHAIN FOR
				; HUNG TIMEOUT.
>
	SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	HRLM	T2,DEVSER(F)	;LINK DDB TO LAST
	HRRZ	F,T2		;UPDATE DDB PTR
	POPJ	P,0		;AND RETURN

;SUBROUTINE TO COPY DDB PROTOTYPE AND UPDATE SYSSIZ

DDBCOP:!HRRZ	T2,SYSSIZ	;IS PTR TO NEW DDB
	HRL	T2,U		;SOURCE OF COPY IS PROTOTYPE
	LDB	M,PINTSZ	;GET SIZE OF DDB
	ADDB	M,SYSSIZ	;UPDATE SYSSIZ AND GET END OF DDB+1
	PUSH	P,T2		;SAVE BLT AC
	SKIPE	DESONC		;SKIP IF UNABLE TO WRITE
	BLT	T2,-1(M)	;COPY DDB
	JRST	T2POPJ		;RESTORE T2 AND RETURN

;SUBROUTINE TO FIX UP EACH DDB TO BE UNIQUE
;THIS ROUTINE (1) UPDATES PUNIT
;		(2) UPDATES THE DEVNAM FIELD TO BE UNIQUE
;		(3) PUTS IN THE CORRECT STATION NUMBER
;		(4) DOES ODDS AND ENDS ON A DEVICE DEPENDANT BASIS
;			SUCH AS:
;				FOR DTA - PUTS IN DIR PTR

DDBFIX:!DPB	P1,PUNIT	;PUT IN UNIT NUMBER
IFE FTGSRC!FTNET,<
	LDB	W,PINTNO	;NUMBER OF DDB'S BEING CREATED
	SOJLE	W,DDBFI1	;JUMP IF ONLY 1, DON'T CHANGE ITS NAME
>
	MOVE	W,PHYNAM	;BYTE POINTER TO NEWLY CREATED
				; DDB PHYSICAL NAME
	LDB	T2,PDVTYP	;GET THE DEVICE TYPE
IFN FTCIMP,<			;[arpa]
	CAIN	T2,.TYIMP/.TYEST;[arpa] IMP?
	  JRST	DDBFI0		;[arpa] YES, RETAIN OLD-STYLE NAME
>				;[arpa]
	CAIE	T2,.TYTTY/.TYEST	;IS IT A TTY
	CAIN	T2,.TYPTY/.TYEST	; OR PTY
	JRST	DDBFI0		;YES, IGNORE STATION NUMBER IN DEV NAME
IFN FTAUTC,<
	CAIE	T2,.TYMTA/.TYEST ;MAGTAPE?
	JRST	DDBFI5		;NO
	MOVE	T2,(F)		;YES, GET ITS NAME
	TLNN	T2,40		;3RD CHARACTER ALPHABETIC?
	JRST	DDBFI1		;NO (EG MT110). DON'T CHANGE ITS NAME
DDBFI5:>
	LDB	J,PINTST	;GET THE STATION NUMBER
	LSH	J,3		;SHIFT FOR THE UNIT
	IORM	P1,J		;INSERT THE STATION NUMBER
	JRST	DDBFI4		;CONVERT THE NAME
DDBFI0:!MOVE	J,P3		;MAKE COPY OF UNIT NUMBER
	TRNN	J,700		;UNIT NUMBER 100 OR MORE?
	JRST	DDBFI2		;NO
DDBFI4:!LDB	T2,[POINT 3,J,29]
	ADDI	T2,20
	IDPB	T2,W		;PUY IN 00B NAM
	TRZ	J,700		;CLEAR HIGH ORDER
	JRST	DDBFI3		;AND PROCEED
DDBFI2:!TRNN	J,70		;IS IT 10 OR MORE ?
	JRST	SMALL		;NO
DDBFI3:!ROT	J,-3		;YES, CONVERT HIGH ORDER OCTAL DIGIT TO
	ADDI	J,20		;SIXBIT
	IDPB	J,W		;AND STORE
	TRZ	J,-1		;CLEAR OUT HIGH ORDER DIGIT
	ROT	J,3		;MOVE LOW ORDER DIGIT BACK
SMALL:!	ADDI	J,20		;CONVERT LOW ORDER DIGIT IN SIXBIT
	IDPB	J,W		;AND STORE IN PHYSICAL NAME
DDBFI1:!LDB	T2,PINTST	;GET STATION NUMBER
	DPB	T2,PDVSTA	;AND PUT IN DDB
IFN M.DTXN,<
	CAIE	T2,LOCSTA	;IS THIS FOR LOCAL STATION
>
	POPJ	P,0		;AND RETURN

IFN M.DTXN,<
FIXLOC:!MOVE	T2,DEVMOD(F)	;GET DEV CHR
	MOVEI	J,DTADIR##(F)	;ADDRESS OF DIR BLOCK ID DTA
	TLNE	T2,DVDTA	;IS IT A DTA
	MOVEM	J,DLOC##(F)	;YES -  PUT IN PTR TO DIR
	POPJ	P,0		;AND RETURN
>

;XCT'D FROM ONCE TO SEE IF ALL CPUS HAVE DK10S
;	XCT	CKDK10##
;	---			;HERE IF NO
;	---			;HERE IF YES

CKDK==SKIPA			;ASSUME YES
IFE M.RT0,<CKDK==JFCL>		;NO IF NONE ON CPU0
IFG CPUN-1,<IFE M.RT1,<CKDK==JFCL>>	;NO IF NONE ON CPU1
CKDK10::CKDK

DESONC:!0			;FLAG =0 IF CALLED BY JSP T1,CNTDB
				; (DO NOT DESTROY ONCE)
				; FLAG NON-ZERO IF CALLED BY JRST LINKDB
				; (OK TO DESTROY ONCE CODE)
DDBNUM::!POINT 11,INTTAB(T1),11	;POINTER TO DDB NUMBER
PHYNAM:!POINT 6,DEVNAM(F),17	;BYTE POINTER TO DB PHYSICAL NAME
PINTNO=DDBNUM
PINTIN:!POINT 18,INTTAB(T1),35	;PTR TO INTERUPT FIELD
PINTCP::!POINT 3,INTTAB(T1),CPUPOS	;POINTER TO CPU NUMBER
CPUPOS==^D14	;PLACE IN INTTAB WHERE CPU NUMBER IS STORED
PINTCH::!POINT 3,INTTAB(T1),PIAPOS	;PTR TO CHANNEL FIELD
PIAPOS==^D17	;PLACE IN INTTAB ENTRY WHERE PIA IS HELD
PINTDB:!POINT 18,INTTAB+1(T1),35	;PTR TO DDB ADDR FIELD
PINTST:!POINT 6,INTTAB+1(T1),8	;PTR TO STATION NUMBER FIELD -- SEE ALSO SYCHK: %IDB2
PINTSZ:!POINT 9,INTTAB+1(T1),17	;PTR TO DDB SIZE FIELD


IFN LEVDN,<DDSTAR::!Z		;STARTING ADDR OF STR DATA BLOCKS ETC. IN HIGH CORE
			;(USED BY ONCMOD AND REFSTR)
>
SYSCKI::
IFE SYSCN,<JFCL>		;"XCT"ED BY SYSINI
IFN SYSCN,<	JSR	SYSCHK## ;"XCT"ED BY SYSINI
>

IFN M.KL10!M.KS10,<
IFN M.FPS,<
	EXTERN	KASER		;CAUSE KA10 FP SIMULATION MODULE TO BE LOADED
>
IFE M.FPS,<
XP KALFPS,CPOPJ
XP SETFPS,CPOPJ
XP SETFPC,COMERA##
>
>
SUBTTL MACROS TO DEFINE PI CHANNELS
;;MACROS TO DEFINE PI CHANNEL NUMBER AND GENERATE INTERRUPT CHAINING
;; INFORMATION FOR ONCE SO IT CAN LINK THE DEVICE INTERRUPT SERVICE
;; ROUTINES AND THE DEVICE DATA BLOCKS


;;TABLE INTTAB IS GENERATED WITH PAIRS OF ENTRIES FOR EACH DEVICE
;;FIRST WORD: BIT 0==1 IF DECTAPE, BITS 1-11==NUMBER OF DDBS
;;	RH IS ADDRESS OF CONSO FOR SKIP CHAIN
;;SECOND WORD: BIT 0, FLAG SAYING DEVICE IS ON CPU1, BITS 1-3 PIA,
;;	BITS 4-8 STATION #,9-17 DDB SIZE AND RH IS DDB ADDRESS
;;
;;MACRO FOR DEVICES WHICH ARE ALWAYS PRESENT (AND WHICH DO NOT USE A
;; CHANNEL SAVE ROUTINE AND HAVE NO DDB)  EXAMPLES ARE APR, CTY, PEN, CLK...

DEFINE SPAXGINT (DEV,PI) <
	DEV'N==1
	ASGINT	DEV,PI
>


DEFINE ASGIN1 (DEV,PI) <
		DEV'CHL==:CH'PI
>

DEFINE SPASGINT (DEV,PI) <
	DEV'N==1
	ASGINT	DEV,PI
>

DEFINE ASGINT (DEV,PI) <
	IFG	DEV'N, <IFG PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		IF2,<IFNDEF DEV'INT,<EXTERN DEV'INT>>
		DEV'CHN==:PI&7
		DEV'CH1==PI		;DEFINE THIS FOR USE AFTER CHAN DEFINITIONS
		XWD PI,DEV'INT		;;GENERATE INTERRUPT ENTRY POINT FOR ONCE
		XWD 0,0
	ASGIN1	DEV,\PI
>>
>


;;MACRO FOR OPTIONAL DEVICES WHICH ALWAYS USE A CHANNEL SAVE ROUTINE
;; (EXAMPLES: CDR, DSK, PTR, ETC.  ALSO PTY WITH 0 PI)

DEFINE SPASGDDB (DEV,PI,NUM) <
	DEV'N==NUM
	NOSAV==1
	ASGSAV	DEV,PI
>
;MACRO TO GENERATE INTTAB ENTRY FOR SAVE ROUTINE BUT NO DDB
;  ASGSVE & ASGSVI
DEFINE ASGSVE (DEV,PI) <

	.CHAS==1
	DEV'CHN==:PI&7
	DEV'CH1==PI
	DEV'HAC==:13

	ASGSV2	DEV,\PI;
IFDIF	<DEV><SCN><
IF2 < IFNDEF DEV'INT,<EXTERNAL DEV'INT>> ;DEFINE AS EXTERN IF NOT IN COMMON
		XWD PI,DEV'INT
		XWD 0,0

>>
DEFINE ASGSAV (DEV,PI) <
	IFG	DEV'N, <
	ASGSV1	DEV,\PI
	>>

;;MACRO FOR:	1. COMPLETION OF THE DEFINITION REQUIRED FOR THOSE
;;		   DEVICES INVOKING THE ASGSAV MACRO
;;		2. DEFINE SYMBOLS FOR DISK (DEV'N=0)

DEFINE ASGSV1 (DEV,PI) <
IF2, < IFNDEF DEV'DDB, <EXTERNAL DEV'DDB>>	;;DEVICE DATA BLOCK ADDRESS
	IFG	PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		DEV'CHN==:PI&7		;;DEFINE DEVICE CHANNEL NUMBER
		DEV'CH1==PI		;;USED AFTER CH'PI DEFINITIONS
IFE NOSAV,<
	ASGSV2	DEV,PI
>
>

IFIDN <DEV><SCN><	SCNN*100,,0
	LOCSTA*1000+SCNDDS##,,SCNDDB##>
IFDIF <DEV><SCN><
IFG PI, <
IF2, < IFNDEF DEV'INT, <EXTERNAL DEV'INT>>	;;INTERRUPT SERVICE CONSO INSTRUCTION
>

	IFE	PI, <
		XWD DEV'N*100+0,0	;;NO PI CHANNEL FOR THIS DEVICE
	>
	IFG	PI, <
		XWD DEV'N*100+PI,DEV'INT	;;FIRST WORD OF INTTAB ENTRY
		IFE DEV'N,<IFNDEF FTCMBTH,<EXTERNAL DEV'INT>> ;;LEVEL D DISK IN COMMOD
	>

	IFG	DEV'N-1,<
		XWD <LOCSTA*1000>+DEV'DDS##,DEV'DDB	;;MULTIPLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
	IFE	DEV'N-1, <
		XWD <LOCSTA*1000>,DEV'DDB		;;SINGLE DEVICE SECOND WORD OF INTTAB ENTRY
	>
> ;;END IFDIF ABOVE
>		;;END ASGSV1 DEFINITION

DEFINE ASGSVN (DEV,X,PI) <
	IFG	PI, <
	IFE	<PI-.CH>, <.CHAS==1	;;CHANNEL PI IN USE.
>
		DEV'X'CHN==:PI&7	;;DEFINE DEVICE CHANNEL NUMBER
		DEV'X'CH1==PI		;;USED AFTER CH'PI DEFINITIONS
	ASGSV2	DEV'X,\PI
>

IFG PI, <
IF2, < IFNDEF DEV'X'INT, <EXTERNAL DEV'X'INT>> ;;INTERRUPT SERVICE CONSO INSTRUCTION
>

	IFG	PI, <
	IFE ISDSK,<
	IFNDEF DEV'X'N,<DEV'X'N==1>
		EXP <DEV'X'N>B11!<PI>B17!DEV'X'INT
	IF2,<IFNDEF DEV'X'DDB,<EXTERN DEV'X'DDB>>
	IFE DEV'X'N-1,<
		EXP <LOCSTA>B8!DEV'X'DDB
	>
	IFN DEV'X'N-1,<
	IF2,<IFNDEF DEV'X'DDS,<EXTERN DEV'X'DDS>>
		EXP <LOCSTA>B8!<DEV'X'DDS>B17!DEV'X'DDB
	>
	>
	IFN ISDSK,<
		EXP <PI>B17!DEV'X'INT##
		EXP <LOCSTA>B8!DSKDDB## ;;SECOND WORD
		IF1,<IFNDEF DSKCHN,<DSKCHN==:DEV'X'CHN>>
		DEFBIT DEV'X
		DSKPIF==:DSKPIF!DEV'X'BIT ;;KEEP LOG. OR OF PI OFF BIT FOR DSK CONTROLLERS
		DSKPIN==:DSKPIN!DEV'X'BIT ;;AND FOR PI ON
	>
	>
>		;;END ASGSVN DEFINITION

DEFINE MLUASG (DEV,DE,PI,X)<
	PI1==PI
	ZZ==0
	CPN==0
	ISDSK==0
	IFNB <X>,<ISDSK==1>
	REPEAT	M.CPU,<
	DVNASG	\CPN,DEV,DE,PI1
	CPN==CPN+1
	PI1=PI1+10
	>
>

DEFINE DVNASG (CPU,DEV,DE,PI)<
	REPEAT	M'CPU'DEV,<
	ASGSVN	DE,\ZZ,PI
	ZZ==ZZ+1
	>
>

;;MACRO'S TO ALLOW GENERATION OF MULTIPLE INTTAB ENTRIES FOR MULTIPLE
;; DEVICES SUCH AS LINE-PRINTERS

DEFINE MULASG (DEV,DE,PI,DSKFL) <
	IFG	DEV'N, <
		ZZ==0
		REPEAT DEV'N, <
			DEVASG DE,\ZZ,PI,DSKFL
			ZZ==ZZ+1
		>
	>
>

DEFINE DEVASG (DE,X,PI,DSKFL) <
	IFE	DSKFL,<DE'X'N==1>	;;DSKFL=1 IF NOT LEVEL D DISK
	IFN	DSKFL,<DE'X'N==0>	;;DSKFL=ZERO IF LEVEL D DISK
	ASGSV1	DE'X,\PI
>


;;MACROS TO CONTROL ASSIGNMENT OF PI CHANNELS TO DEVICES

DEFINE NEXTCH <	.CH==.CH+1	;;START ASSIGNING TO NEXT LOWER CHANNEL
.CHAS==0
NEXTCU \.CH
>
DEFINE NEXTCQ <	IFN .CHAS, <NEXTCH>>	;;START ASSIGNING TO NEXT LOWER CHANNEL IF
					;; CURRENT CHANNEL HAS BEEN USED.
DEFINE NEXTCU (N) < IFDEF UNIQ'N, < IFN UNIQ'N, <NEXTCH>>	;;TO SKIP OVER ANY
					;; SPECIALLY SPECIFIED CHANNELS (RECURSIVELY!)
		IFDEF RTCH'N,<IFN RTCH'N,<NEXTCH>>>	;IF RTCH'N IS DEFINED
					;DURING MONGEN, THAT CHANNEL WILL BE FREE FOR RT DEVICES

DEFINE DEFBIT (DEV) <
	DEV'BIT==1
	REPEAT	7-DEV'CHN, <DEV'BIT==DEV'BIT*2>
>

DEFINE UNIQDEF(N)
<	UNIQ'N==1
IFDEF	RTCH'N,<IFN RTCH'N,<
	PRINTX	?PI CHAN N CAN NOT BE RESERVED FOR REAL-TIME
	PRINTX	?IT IS NEEDED FOR BLKI/BLKO
>>>

DEFINE	MULINT,	(DEV,DE,PI) <
	ZZ==0
	PI1==PI
	CPN==0
	REPEAT M.CPU,<
		MULIN1 \CPN,DEV,DE,\PI1
	CPN==CPN+1
	PI1==PI1+10
	>
>

DEFINE	MULIN1(CPU,DEV,DE,PI)<
	REPEAT	M'CPU'DEV,<
	MULFLG	DE,\ZZ,\PI
	ZZ==ZZ+1
	>
>

DEFINE	MULFLG,	(DE,X,PI) <
	ASGSVE	DE'X,\PI
>

;;INITIALLY ASSUME NO PI CHANNEL SAVE ROUTINES NEEDED

DEFINE	USED(PI),<
	USED'PI==0
>
ZZ==0
REPEAT	M.CPU,<
ZZ==ZZ+1
REPEAT	7,<
	USED	\ZZ
ZZ==ZZ+1
>>
;MACRO TO ALLOW GENERATION OF CHANNEL SAVE ROUTINES ONLY

DEFINE SPASGSAV (DEV,PI,%ACNUM) <
	HIAC'PI==:%ACNUM
	DEV'HAC==:%ACNUM

	ASGSV2	DEV,PI
>

DEFINE ASGSV2 (DEV,PI) <
		USED'PI==:1		;SET FLAG SO THAT A CHANNEL SAVE
					; ROUTINE WILL BE GENERATED FOR
					; THIS PI CHANNEL

	IFDEF	SAV'PI, <		;WAIT TILL CHANNEL SAVE ROUTINES
					; ARE DEFINED BELOW (IN PASS 2)

		DEV'SAV==:SAV'PI	;CHANNEL AC SAVE ROUTINE LOCATION
		DEV'SV==:SAV'PI		;USED BY DISKS
		DEV'RET==:RET'PI	;CHANNEL AC RESTORE ROUTINE LOCATION
					; (USUALLY POPJ USED)
		DEV'CHL==:CH'PI		;LOCATION WHERE INTERRUPT PC IS STORED
		DEV'SAC==:SVAC'PI	;STARTING CHANNEL SAVE LOCATION FOR AC'S
		DEV'PDP==:C'PI'PDP	;LOCATION WHERE P STORED
		DEV'PD1==:C'PI'PD1	;PUSHDOWN LIST
		DEV'JEN==:C'PI'JEN	;LOCATION WHERE INT. IS DISMISSED
>>

;NOW GENERATE THE TABLE FOR ONCE AND DEFINE PI CHANNEL ASSIGNMENTS


		CTYN==:1		;ALWAYS ONE CTY
IFN M.NET,<
		NETN==1		;ONLY ONE DDB
>
		SCNN==:JOBN+TTXTRA	;NUMBER OF SCN DDB
				; ONE FOR EACH JOB + NULL JOB (EXTRA ONE)
		AP0N==1		;ALWAYS AN APR
		CK0N==1		;ALWAYS LOWEST PRIORITY CLOCK

IFG <CPUN-1>,<	AP1N==1		;SLAVE PROCESSOR EXISTS
		CK1N==1	;SO DOES ITS CLOCK OR SCHEDULER CHANNEL
>
IFE <CPUN-1>,<	AP1N==0	;SLAVE DOES NOT EXIST
		CK1N==0	;NOR DOES ITS CLOCK LEVEL
>

	DSKPIN==:2000	;SET PI ON BIT - WILL ALSO HAVE PI ON FOR DISK CONTOLLERS
	DSKPIF==:1000	;AND FOR PI OFF


INTTAB::!		;TABLE OF DATA FOR DEFINING PI CHAN AND NUMBER OF DOB
	NOSAV==0	;DO NOT SUPPRESS GENERATION OF SAVE ROUTINES
	INTTB1==:INTTAB+1
;PTY AND SCN MUST BE THE FIRST TWO ENTRIES IN INTTAB
	ASGSAV	PTY,0		;NO PI CHANNEL FOR PTY
	ASGSAV	SCN,0
IFN M.MSG,<			;IF WE WANT MSGSER
IFE FTMSGSER,<
PRINTX	?PLEASE ASSEMBLE WITH FTMSGSER =-1
>
	EXTERN	MSGSER
	XWD	0,0		;NO DDB ON NO PI CHANNELS
	XWD	0,MPXDDB##	;BUT WE WOULD LIKE TO BE PUT ON THE CHAIN
>
IFN M.KDUP,<
	XWD	0,0		;IF A KS, LINK IN THE PROTOTYPE KDP DDB
	XWD	0,KDPDDB##	; NO PI CHANNELS
>

IFN M.DMRN,<
	XWD	0,0		;IF A KS, LINK IN THE PROTOTYPE DMR DDB
	XWD	0,DMRDDB##	; NO PI CHANNELS
>

IFN	FTKL10,<
	XWD	0,0		;IF A KL, LINK IN THE PROTOTYPE DTE DDB
	XWD	0,DTEDDB##	;NO PI CHANNELS
>
.CHAS==0
.CH==0
NEXTCH		;BEGIN AT CHANNEL 1

;THE FOLLOWING DEVICES MUST HAVE A UNIQUE, HIGH PRIORITY
; CHANNEL FOR BLOCK I/O TRANSFERS.

;PDP10 MAGTAPE BLKI/BLKO PI CHANNEL:

IFNDEF MTDCHN,< IFG TM10A,<
	XP	MTDCHN,.CH
	UNIQDEF(\.CH)
	NEXTCH>>

IFNDEF BLKMXC, <BLKMXC==.CH>	;REMEMBER THIS CHANNEL ON PASS 1
.CH==BLKMXC			;ON PASS 2, SKIP OVER BLKI CHANNELS
;THE FOLLOWING ARE GROUPED ON A HIGH PRIORITY CHANNEL, BUT DO NOT
; WRITE INTO THE INTERRUPT LOCATIONS

IFE M.KS10,<
	MLUASG	CDR,CR,.CH
>
	MULASG	DCDR,FC,0	;TAKE CARE RSX-20F CARD READERS
DEFINE DTADF1(X),<
ASGSVE	D'X'D,PI1
>

DEFINE DTADEF(CPU),<
REPEAT M'CPU'TD10,<
	DTADF1(\"ZZZ)
	ZZZ==ZZZ+1
>
>

DEFINE GENDTA,<
ZZ==0
ZZZ=="A"
PI1==.CH
ISDSK==0
REPEAT M.CPU,<
	DTADEF(\ZZ)
ZZ==ZZ+1
PI1==PI1+10
>
>
	GENDTA
;Try to have all this (pi software and DTAs on the same chanel)Platberg 870426
;NEXTCQ

;THE FOLLOWING ARE GROUPED ON A CHANNEL FOR HIGH-PRIORITY DEVICES
DEFINE RTCDEF(X)<
IFG M.RT'X,<
	ASGSVE	RT'X,PI1
>>

ZZ==0
PI1==.CH
REPEAT M.CPU,<
	RTCDEF	\ZZ
ZZ==ZZ+1
PI1==PI1+10
>
	MLUASG	CDP,CP,.CH

ZZ==0
PI1==.CH
REPEAT M.CPU,<
	MULFLG	AP,\ZZ,\PI1
ZZ==ZZ+1
PI1==PI1+10
>
NEXTCQ
IFN FTCIMP,<			;[arpa]

;[arpa] THE IMP FRONT END GETS A LOW-PRIORITY CHANNEL (NEED NOT BE UNIQUE)

IFE FTDDP,<			;DDP, no 1822.				[JMR]
	ASGSVE	MPI,.CH		;[arpa] PI CHANNEL FOR INPUT
	ASGSVE	MPE,.CH		;[arpa] PI CHANNEL FOR END-OF-INPUT
	ASGSVE	MPP,.CH		;[arpa] PI CHANNEL FOR OUTPUT
>;IFE FTDDP			;DDP, no 1822.				[JMR]
    ifg IMPN,<	;[arpa] only if there are some DDBs to define
	SPASGDDB IMP,0,IMPN	;[arpa] define DDBs, too.
    >				;[arpa]
>				;[arpa]

;THE FOLLOWING ARE MEDIUM-PRIORITY DEVICES, AS A GROUP
	ASGSVE	SCN,.CH

	XP	SCNBIT,1_<7-SCNCHN>

IFN	M.TTG0,<
	ASGSVE	DL0,.CH
>
IFN	M.TTG1,<
	ASGSVE	DL1,.CH
>
IFN	M.68L0,<
	ASGSVE	CC0,.CH
>
IFN	M.68L1,<
	ASGSVE	CC1,.CH
>


	MLUASG	PTR,PR,.CH
IFE M.KS10,<
	MULINT	CDR,CF,.CH
>
IFN M.KS10,<
	MLUASG	CDR,CR,.CH
>
	MLUASG	LPT,LP,.CH
	MULASG	DLPT,FL,0	;TAKE CARE OF RSX-20F LINEPRINTER
DEFINE DTADF1(X),<
ASGSVN	DT,X,PI1
>
	GENDTA
	MLUASG	TAPN,MT,.CH

	ASGSAV	MTC,.CH
IFN M.KI10!M.KS10,<
DEFINE	CTYDEF(X),<
	SPAXGINT CT'X,PI1
>
	PI1==.CH
	ZZ==0
	REPEAT M.CPU,<
		CTYDEF	\ZZ
	ZZ==ZZ+1
	PI1==PI1+10
	>
>;END IFN M.KI10!M.KS10

IFN M.KL10,<
	XP	SPCPI,.CH	;SECONDARY PROTOCOL PI ASSIGNMENT
	XP	PPCPI,.CH	;PRIMARY PROTOCOL PI ASSIGNMENT
DEFINE	DTEDEF(X,Y,PI)<
	ASGSV2	D'X'Y,PI
>
	ZZ==0
PI1==.CH
REPEAT	M.CPU,<
ZZZ==1
REPEAT	4,<
	DTEDEF(\ZZ,\ZZZ,\PI1)
ZZZ==ZZZ+1
>
PI1==PI1+10
ZZ==ZZ+1
>
>;END IFN M.KL10

IFN DL10XI,<
;ADD THE DL10 AT THE END OF THE SCANNER CHANNEL.  NOW YOU WOULD THINK THAT
;	SINCE THE DL10 IS RUN IN VECTORED INTERRUPT MODE, YOU WOULDN'T NEED
;	TO LOOK AT THE DL10 AT 40+2*N CONSO TIME BUT IT TURNS OUT THAT YOU
;	DO.  IT SEEMS THAT SOME (BUT NOT ALL) DL10'S LIKE TO IGNORE THE VECTOR
;	ADDRESS AND CAUSE OLD STYLE INTERRUPTS AND EVEN THEN, NOT ALL THE TIME.
;	THE DL10 ON OUR DEVELOPMENT SYSTEM ACTS LIKE THIS MOST OF THE TIME.
;	IF YOUR DL10 ALWAYS (OR ALMOST ALWAYS) TAKES THE VECTORED INTERRUPT
;	THIS CODE IS IN THE RIGHT PLACE (WILL HARDLY EVER GET THIS FAR ON THE
;	CONSO SKIP CHAIN).  IF IT LIKES TO ACT LIKE A KA-10 DEVICE, MOVE THIS
;	UP (BEFORE "PTR" ASSIGNMENTS) TO SERVICE THEM A LITTLE FASTER.

	ASGSVE	DLX,.CH

IFN M.DAS78,<			;IF WE HAVE DAS78 SUPPORT
	XXIN==	M.D78L		;NUMBER OF LINES
	ASGSAV	XXI,.CH

	XXON==	M.D78L		;NUMBER OF LINES
	ASGSAV	XXO,0		;JUST GENERATE DDB'S
> ;END IFN M.DAS78
> ;END IFN DL10XI

IFN M.NET,<
;DEFINE THE SYMBOLS FOR THE "NETWORK FRONT END" CHANNEL
;  NOTE THAT BOTH THE DTE-20 AND THE DL-10 MUST BE ON THE
;  SAME CHANNEL

	XP	NTFCHN,.CH	;THE NETWORK FRONT END CHANNEL
	XP	NTFBIT,1_<7-NTFCHN>
	XP	NTFIIP,1_<7-NTFCHN+^D8> ;INTERRUPT IN PROGRESS
>

NEXTCQ

;THE FOLLOWING ARE LOWER-PRIORITY DEVICES, AS A GROUP
;FIRST ARE THE VARIOUS TYPES OF DISK CONTROLLERS....

IFN LEVDN,<
	MLUASG	FHD,FH,.CH,1
	MLUASG	FSD,FS,.CH,1
	MLUASG	RPX,RP,.CH,1
	MLUASG	RNX,RN,.CH,1
	MLUASG	DPC,DP,.CH,1
	MLUASG	MDF,MD,.CH,1
IFN M.KS10,<
	MLUASG	RHX,RH,.CH,1
>
>	;END CONDITIONAL ON LEVDN

IFN	FTXTC,<
	IFN	M.XTC,<
	MULASG	XTC,XT,.CH,0
	XP	XTCBIT,1_<7-XT0CHN>
>>
	ASGSAV	PEN,.CH
	MLUASG	PTP,PP,.CH
IFN CDPN,<
	MULINT	CDP,CG,.CH
>;END IFN CDPN

	MLUASG	PLT,PL,.CH



	ASGSAV	VBC,.CH

NEXTCQ

;THE DISPLAY GETS ITS OWN LOW-PRIORITY CHANNEL
	ASGSAV	DIS,.CH

NEXTCQ
;THE NETWORK WANT'S TO RUN ON ANY CHANNEL BETWEEN CLOCK(7) AND DISK
IFN M.NET,<

;DEFINE THE NETWORK SOFTWARE INTERRUPTS.  LINK CHAIN ON ALL CPU'S
DEFINE	NETDEF(CPU),<
	ASGSVE	NT'CPU,\<.CH+<CPU_3>>
>

ZZ==0
REPEAT	CPUN,<
	NETDEF	\ZZ
	ZZ==ZZ+1
>
	XP	NETCHN,NT0CHN
	XP	NETBIT,1_<7-NT0CHN>
	XP	NETIIP,1_<7-NT0CHN+^D8>	;INTERRUPT IN PROCESS
	XP	REQNET,PI.IIO+NETBIT	;CONO PI,REQDXX REQUEST INTERRUPT
	XP	CLRNET,II.CPP+NETBIT	;CONO PI,CLRDXX CLEAR INTERRUPT

	ASGSAV	NET,0		;TO GENERATE A DDB AT THE END OF THE LIST
				;NOTE!! THIS MUST BE THE LAST DDB.
>

NEXTCQ

;LAST IS THE SCHEDULER, ON CHANNEL 7 BY ITSELF

IFG <.CH-7>, <	PRINTX ?NOT ENOUGH PI'S TO SERVICE THIS CONFIGURATION.
		PRINTX ?SUGGEST EDITING COMMON TO PUT MORE DEVICES ON
		PRINTX ? A SINGLE CHANNEL
>

.CH==7

DEFINE CLKDEF(X)<
	CK'X'N==1
	ASGINT	CK'X,\PI1
>
ZZ==0
PI1==.CH
REPEAT M.CPU,<
	CLKDEF(\ZZ)
ZZ==ZZ+1
PI1==PI1+10
>


;NOW FOR SOME PI SYSTEM MASKS FOR DISK, SCANNER, AND NETWORK INTERLOCKS

IFE M.NET,<			;IF NO NETWORKS
	NTFBIT==0		; DON'T FOOL WITH ANY
	NETBIT==0		; PI CHANNELS
	NTFCHN==0		; ..
	NETCHN==0		; ..
>

IFG CPUN-1,<			;FOR MULTI-PROCESSORS

IFN FTCIMP&^-FTDDP,<				;[arpa]			[JMR]
	XP	DSKPIN,DSKPIN!NTFBIT!NETBIT!SCNBIT!ImpBts	;[arpa]
	XP	DSKPIF,DSKPIF!NTFBIT!NETBIT!SCNBIT!ImpBts	;[arpa]
> ;[arpa] end of IFN FtCImp						[JMR]
IFE FTCIMP&^-FTDDP,<				;[arpa]			[JMR]
	XP	DSKPIN,DSKPIN!NTFBIT!NETBIT!SCNBIT	;INCLUDE SCANNER AND NETWORKS
	XP	DSKPIF,DSKPIF!NTFBIT!NETBIT!SCNBIT
> ;[arpa] end of IFE FtCImp						[JMR]
	XP	SCNPIN,DSKPIN!1			;INCLUDE DISKS, NETWORKS, CH7
	XP	SCNPIF,DSKPIF!1
	XP	NETPIN,DSKPIN!1			;INCLUDE DISKS, SCANNER, CH7
	XP	NETPIF,DSKPIF!1
>
IFE CPUN-1,<			;FOR SINGLE PROCESSORS

ifn FtCImp&^-FTDDP,<	;[arpa] there is arpanet support		[JMR]
	XP	SCNPIN,2000!SCNBIT!NTFBIT!NETBIT!ImpBts!1	;[arpa]
	XP	SCNPIF,1000!SCNBIT!NTFBIT!NETBIT!ImpBts!1	;[arpa]
> ;[arpa] end of ifn FtCImp						[JMR]
ife FtCImp&^-FTDDP,<	;[arpa] no arpanet support			[JMR]
	XP	SCNPIN,2000!SCNBIT!NTFBIT!NETBIT!1 ;ONLY SCANNER, NETWORKS, CH7
	XP	SCNPIF,1000!SCNBIT!NTFBIT!NETBIT!1
> ;[arpa] end of ife FtCImp						[JMR]

IFN M.NET,<
	XP	NETPIN,2000!SCNBIT!NTFBIT!NETBIT!1 ;ONLY NETWORKS, SCANNER, CH7
	XP	NETPIF,1000!SCNBIT!NTFBIT!NETBIT!1
>
IFE M.NET,<
	XP	NETPIN,2000!SCNBIT!1			;INCLIDE SCANNER
	XP	NETPIF,1000!SCNBIT!1			;AND CH7
>>
IFG TAPN,<
;IF THE PROCESSOR DOES A TAPOFF AT UUO LEVEL,
;THE TAPE CH IS TURNED OFF, BUT AN INTERRUPT
;ON THE DSK CH MIGHT STILL BE POSSIBLE (AND OTHERS).
;IF THE INTERRUPT DOES A DSKOFF/DSKON, THE
;TAPE CH MAY BE TURNED BACK ON.
;CURE:  MAKE TAPOFF DISABLE DISK INTERRUPTS ETC.

DEFINE XX(AA,BB),<
IFN  BB&TAPBIT,<XP AA,AA!BB>>
	XP	TPION,PI.TNP!TAPBIT
	XX	TPION,DSKPIN
	XX	TPION,SCNPIN
	XP	TPIOFF,PI.TFP!TAPBIT
	XX	TPIOFF,DSKPIF
	XX	TPIOFF,SCNPIF
IFN M.NET,<
	XX	TPION,NETPIN
	XX	TPIOFF,NETPIF
>
> ;END IFG TAPN
	SPCINT
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NOT USE A CHANNEL SAVE ROUTINE AND HAVE
				; NO DEVICE DATA BLOCK
	SPCDDB
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				;WHICH HAVE MULTIPLE DEVICE DATA BLOCKS (0 MEANS NONE)
	SPCSAV
				;GENERATE ANY SPECIAL DEVICES CUSTOMER IS SUPPLYING
				; WHICH DO NEED A CHANNEL SAVE ROUTINE

;END OF THE ASSIGNMENT TABLE

	INTNUM==:INTTAB-.	;-LENGTH OF INTERRUPT CHANNEL ASSIGNMENT TABLE
SUBTTL NON-ZEROED DATA BASE
	IFLE	.-SYSEND, <LOC SYSEND+1>
				; SET LOC UP TO SYSEND+1, UNLESS ONCE ONLY CODE
				; IS BIGGER

; THE FOLLOWING DATA MUST NOT RESIDE WITHIN THE RANGE SYSBEG-SYSEND.
; IT CAN'T BE ZEROED WHEN SYSGED-SYSEND IS ZEROED BECAUSE A STOPCODE
; MIGHT HAVE OCCURED EARLY ON IN THE SYSTEM STARTUP CODE, AND THESE
; BLOCKS MAY HAVE BEEN WRITTEN INTO.  THERE'S REALLY NO REASON TO
; ZERO THIS STUFF ANYWAY, SYSTEM RESTARTS (OF THE 143 TYPE) DON'T WORK.

CLKNEW::0			;FLAG TO FORCE RECOMP OF CLKMIN
CLKMIN::BLOCK	M.CPU		;MIN TIME TO EXPIRE FOR THIS CPU
	SLJOBN=JOBN		;1 REQUEST PER JOB
CIPWT::	BLOCK	2*<SLJOBN+11>	;CLOCK REQUEST QUEUE
				;WORD 0 - RH=COUNT DOWN JIFFY TIMER
				;	- LH=ROUTINE TO CALL
				;
				;WORD 1 - RH=DATA MEM RETURNED
				;	- BIT 0=REQUEST IS CPU SPECIFIC
				;	- BITS 1-3=CPU#
				;	- BIT 4=SCANNED BY CLOCK1
CIPWTE::!			;FIRST WORD AFTER CIPWT. USED TO CHECK OVERFLOW
	CIPWTM==:CIPWT-1	;FIRST LOC-1 OF CLOCK QUEUE


DIECDB::0			;POINTER (IN PHYSICAL MEMORY) TO CDB IN USE AT
				;STOPCODE TIME. USED TO FACILITATE LOOKING AT
				;DUMPS.
;SPECIAL DEVICE SYMBOLS WHICH INVOLVE PI ASSIGNMENTS
; GOAL: MINIMIZE NO. OF SYMBOLS DEFINED HERE:
;
;    MAGTAPE PI SYMBOLS
IFG TAPN,<		;ANY MAGTAPES?

IFG TM10A+TM10B,<
	IFNDEF	MTDCHN,<XP MTDCHN,0>
	XP	MTAFLG,MT0CHN*10
	XP	MTBOTH,MTAFLG
IFG TM10A,<
	XP	MTBOTH,MTBOTH+MTDCHN
	XP	MTALOC,.EPMP+2*MTDCHN+40
>>

	XP	TAPCHN,MT0CHN
	XP	TAPBIT,<1_<7-MT0CHN>>
> ;END IFG TAPN

;    DECTAPE PI SYMBOLS

IFN M.DTXN,<
	XP	DTBOTH,DADCHN*10+DTACHN	;2ND DECTAPE PI
	XP	DTTURN,300200+DTBOTH
>

;	CDR PI ASSIGNMENTS
IFG M.CDR,<
IFE M.KS10,<
	XP	CRFCHN,CF0CHN
>
	XP	CDRCHN,CR0CHN
>
;    LINE PRINTER PI SYMBOLS
DEFINE	FLAGS(N)<
	XP	LP'N'BTH,LP'N'CHN*11
>
ZZ==0

REPEAT M.LPT,<
	FLAGS	\ZZ
ZZ==ZZ+1
>


;    DISPLAY PI SYMBOLS
IFG M.DIS,<			;DISPLAY
	XP	DISBLK,.EPMP+40+2*DISCHN	;BLKI/BLKO LOCATION
	XP	PENPIA,PENCHN*10	;PEN PI ASSIGNMENT FOR CONO
	XP	DISBTH,DISCHN+PENPIA	;BOTH DIS AND PEN PIS FOR CONO
XP DISBIT,1
REPEAT	7-DISCHN,<XP DISBIT,DISBIT*2>
>
IFN M.KS10,<
;UBA PI SYMBOLS
	XP UBA1PI,DSKCHN*10		;DISK PI
	XP UBA3PI,TAPCHN*10+SCNCHN	;TAPE, COMM & UNIT RCD PI'S
>

IFN FTCIMP,<			;[arpa]
   IFG IMPN,<			;[arpa] IMP PI SYMBOLS
IFE FTDDP,<			;DDP, no 1822.				[JMR]
	XP MPIPI,MPICHN_0	;[arpa] INPUT CHANNEL
	XP MPEPI,MPECHN_^D8	;[arpa] END-OF-INPUT CHANNEL
	XP MPPPI,MPPCHN_^D4	;[arpa] OUTPUT CHANNEL

;[arpa] BITS IN CONI/CONO
	MPIBIT==1_<7-MPICHN>	;[arpa] input bit
	MPEBIT==1_<7-MPECHN>	;[arpa] end-of-message bit
	MPPBIT==1_<7-MPPCHN>	;[arpa] output bit

;[arpa] BITS FOR PI CONTROL
	XP MPION,<PI.TNP!MPIBIT!MPEBIT>	;[arpa] allow input PI interrupts
	XP MPIOFF,<PI.TFP!MPIBIT!MPEBIT>;[arpa] don't allow input interrupts
	XP MPPON,<PI.TNP!MPPBIT>	;[arpa] allow output PI interrupts
	XP MPPOFF,<PI.TFP!MPPBIT>	;[arpa] don't allow output interrupts

;[arpa] all IMP PI channels set.
	XP IMPBTS,<MPIBIT!MPEBIT!MPPBIT>	;[arpa] all PI bits
>;IFE FTDDP			;DDP, no 1822.				[JMR]
    > ;[arpa] end of IFG IMPN
> ;[arpa] end of IFN FtCImp
;BLOCKS FOR SAVE/RESTORE OF MAPPING FOR EDDT

SYMBK1:: BLOCK	200		;FILLED IN BY ONCE WITH NEW MAPPING INFO
SYMBK2:: BLOCK	200		;WHERE DDT SAVES OLD CONTENTS OF MAP


;SYSTEM CONSTANTS AND PARAMETERS



CNFTBL::			;FIRST LOCATION OF MONITOR DATA STORAGE
				; RETURNED BE GETTAB UUO (THESE LOCATIONS
				; NOT CLEARED BY SYSINI)
				; CNFTBL IS GETTAB TABLE 11 (RH OF AC)
				; OCTAL NUMBERS IN () CORRESPOND TO GETTAB UUO AC'S LH
CONFIG::SYSNAM
				;(0-4) NAME OF SYSTEM, IN ASCII
	LOC	CONFIG+5	;ALWAYS LEAVE 5 WORDS (24 CHARS)
				; SO GETTAB UUO WILL BE CONSTANT
SYSDAT::SYSDAT
				;(5,6) GENERATE SYSTEM DATE
	LOC	SYSDAT+2	;ALWAYS LEAVE 2 WORDS SO GETTAB CONSTANT
SYSTAP::SYSDEV
				;(7) NAME OF SYSTEM DEVICE, IN SIXBIT

;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE AND NEVER RESET ON RESTARTS


TIME::	0			;(10) TIME OF DAY IN JIFFIES (60TH OR 50THS OF A SEC)
THSDAT::0			;(11) TODAY'S DATE ((Y-1964)*12+(M-1))*31+(D-1)
SYSSIZ::EXP	PAT##		;(12) SIZE OF MONITOR (FIRST LOC NOT USED)
DEVOPR::			;(13) SIXBIT PHYSICAL NAME OF OPERATORS CONSOLE
IFNDEF OPRLIN,<SIXBIT /CTY/>	;AT THE CENTRAL (PDP10) SITE
IFDEF OPRLIN,<OPRLIN;>;		; (IF THIS LOCATION CONTAINS 0, NONE HAS
				;  BEEN DESIGNATED)
				;PUBLIC LOGICAL NAME "OPR" WILL BE THIS DEVICE.
				; ALSO UNEXPLAINED MONITOR ERROR MESSAGES
				; WILL BE TYPED ON TTY OPR
DEVLST::XWD	0,0		;(14) LH CONTAINS ADDRESS OF FIRST DEVICE DATA BLOCK
				; ONCE ONLY CODE LINKS DEVICE DATA BLOCKS
SEGPTR::XWD	-SEGN,JOBN	;(15) AOBJN POINTER TO 1ST HIGH SEG IN JBTXXX TABLES
				; LH= - NUMBER OF HIGH SEGS,  RH= 1ST HIGH SEG NUMBER
	EXP	-1		;(16) FLAG TO INDICATE WHETHER BOTH HARDWARE AND
				; SOFTWARE HAVE 2 RELOC REG CAPACITY
				; NON-ZERO IF BOTH DO, 0 IF EITHER OR BOTH DO NOT
				; SET BY ONCE ONLY CODE

;STATES WORD LH BITS:
	ZZ==0
	IFG	DSKN, <ZZ==ZZ!ST.DSK>	;1 IF DISK SYSTEM (ANALOGOUS TO FTDISK)
	IFG	SYS50N, <ZZ==ZZ!ST.SWP>	;1 IF SWAPPING SYSTEM (ANALOGOUS TO FTSWAP)
	IFG	LOGINN, <ZZ==ZZ!ST.LOG>	;1 IF LOGIN (ANALOGOUS TO FTLOGIN)
	ZZ==ZZ!ST.FTT			;1 FOR TTCALL, FULL DUPLEX
	ZZ==ZZ!ST.PRV			;1 FOR PRIVILEGE CHECKING
	ZZ==ZZ!ST.TWR			;1 IF REENTRANT SOFTWARE
	IFN	LEVDN,<ZZ==ZZ!2B9>	;1 IF LEVEL D DISK SOFTWARE (ST.TDS)
	IFN	INDPPN,<ZZ==ZZ!ST.IND>	;1 IF INDEPENDENT PROJ-PROG NUMBERS
	ZZ==ZZ!ST.IMG			;1 FOR IMAGE, 8-BIT SCNSER
	IFG	CPUN-1,<ZZ==ZZ!ST.DUL>	;1 IF DUAL CPU SYSTEM
IFN FTDMRB,<ZZ==ZZ!ST.MRB>		;1 IF MULTIPLE RIBS

IFG	M.RTCA,<ZZ==ZZ!ST.HPT>		;1 IF HIGH PREC.TIME ACCT.
IFG	M.RTCO,<ZZ==ZZ!ST.EMO>		;1 IF EXCLUDE MON.OVERHED FROM USER RUN
IFG	M.RTX,<ZZ==ZZ!ST.RTC>		;1 IF MONITOR HAS REAL TIME CLOCK
	ZZ==ZZ!ST.MBF			;1 IF MONITOR BUILT TO HANDLE FOROTS

;STATES WORD RH BITS(INDICATE OPERATIONAL STATE OF SYSTEM):
;PATCHED BY SCHED COMMAND

		;1B35(ST.NLG) = NO LOGIN(EXCEPT FROM OPR)
		;1B34(ST.NRL) = NO LOGINS FROM REMOTE TTYS. DONT
		; ANSWER RINGING DATA SETS. "REMOTE" BIT IN
		; LINTAB IS SET BY MONGEN
		;1B33(ST.BON) = NO LOGINS EXCEPT BATCH JOBS EXCEPT FROM OPR
		;1B29(ST.ASS)=1 NO ASSIGN/INIT DEVICES
		;1B28(ST.NSP)=1 IF ANY JOB CAN UNSPOOL DEVICES
		;1B27(ST.NOP)=1 NO OPERATOR
		;1B26(ST.DDL)=1 NO DOWN LINE LOAD OF REMOTE DC71,DC72,DAS80'S

STATES::EXP	ZZ!SCHEDN	;(17) BITS WHICH DEFINE TYPE OF SYSTEM IN LH
				; RH PATCHED BY MONITOR COMMAND TO
				; INDICATE OPERATIONAL STATE OF SYSTEM
SERIAL::EXP	APRSN		;(20) SERIAL NUMBER OF CENTRAL PROCESSOR (APR)
MEMNSP::EXP	NSPMEM		;(21) NANO-SEC PER MEMORY CYCLE
PTYCNF:	XWD	PTYOFS##,PTYN	;(22) PTY PARAMETERS FOR BATCH
FREPTR::0			;(23) AOBJN WORD POINTING TO USE BIT MAP OF
				; MONITOR 4-WORD CORE BLOCKS. SET BY ONCE ONLY CODE
				; NEVER CHANGED WHILE MONITOR RUNS.
LOCORE::0			;(24) LH=0, RH=ABS. ADR. IN MONITOR OF FIRST WORD OF
				; MONITOR TO BE ALLOCATED IN 4-WORD CHUNKS.
				; SET BY ONCE ONLY CODE AND NEVER CHANGED WHILE
				; MONITOR RUNS.
STBPTR::EXP	0		;(25) POINTER NOT USED WITH NETWORKS

OPRLDB::0			;(26) LDB OF OPR TELETYPE
TTFREE::0			;(27) FILLED IN AT ONCE TIME BY FREE LIST ADR
IFNDEF TTCHKN,<EXTERNAL TTCHKN>
TTCLST::XWD	TTCHKN,0	;(30) NUMBER OF TTY CHUNKS, ADDRESS OF FIRST ONE
TTFREN::0			;(31) NUMBER OF FREE TTY CHUNKS AT THE MOMENT
LINSAV::0			;(32) POINTER TO CURRENT TTY SEEN BY COMMAND DECODER
LINPTR::XWD MTTYLN##,LINTAB##	;(33) POINTER TO EXAMINE TTY LINE TABLE,
				; INCLUDING REMOTES
MONVER:	EXP	A00VER		;(34) VERSION OF MONITOR (LH FOR CUSTOMER)
IFN FTMODM,<
DSCPTR::XWD MDSLN##,DSCTAB##	;(35) POINTER TO DATASET CONTROL TABLE
>
IFE FTMODM,<0>
DLSRWD::0			;(36) LAST RECEIVE INTERRUPT FROM DC10
CCIRWD::0			;(37) LAST RECEIVE INTERRUPT FROM 680
SEGPT1::EXP	JOBN		;(40) LAST DORMANT SEG NUMBER THROWN AWAY
				; TO FREE UP A SEG NUMBER.
LASPOK::0			;(41) CONTAINS ADR. OF LAST LOCATION CHANGED
				; IN MONITOR BY A SUCCESSFUL POKE UUO.  (NOT CLEARED
				; ON 403 RESTART SINCE CHANGE IS STILL VALID
LASPUC::0			;(42) RH=COUNT OF NUMBER OF SUCCESSFUL POKE UUOS
				; SINCE SYSTEM WAS LOADED.
				; LH=JOB NO. OF LAST JOB WHICH
				; SUCCEEDED IN CHANGING MONITOR VIA POKE
				; THE TWO ABOVE LOCATIONS ARE USEFUL
				; IN CRASH ANALYSIS AND FOR DAEMON LOGGING
WHYCOD::0			;(43) CONTAINS SIXBIT UNABBREVIATED OPERATOR ANSWER
				; FOR WHY RELOAD ONCE ONLY QUESTION.  SEE ONCE (WHYTAB)
				; FOR A LIST OF POSSIBLE CODES.  0 MEANS FTWHY=0 SO NO
				; QUESTION
TICSEC::JIFSEC			;(44) CONTAINS NUMBER OF TICKS PER SECOND
				; SET AT ONCE ONLY TIME BY MEASURING LINE
				; FREQUENCY (50 OR 60 HERTZ)
PDBPTR:	XWD	0,JBTPDB	;(45) RH=POINTER TO TABLE OF PDB'S FOR JOBS
				; LH=0 FOR FUTURE EXPANSION

RTCUPS::0			;(46) RESOLUTION (UNITS/SEC.) OF CLOCK
				; USED FOR RUN TIME ACCT.
				; SET & CHANGED BY SETIME
SYSCHN::
IFE FTAUTC,<
	XWD	CHN0CB##,0	;(47) LH=ADR OF FIRST CHANNEL (DF10) DATA BLOCK, RH=UNUSED
>
IFN FTAUTC,<0>			;AUTCON WILL FILL THIS IN
			;LOGMAX...BATMIN CHANGED WITH SETUUO
			;  ENFORCED BY LOGIN (MONITOR ONLY STORES THESE
			;  NUMBERS FOR LOGIN)
LOGMAX::M.JMAX			;(50) MAX.# JOBS ALLOWED TO BE LOGGED IN
BATMAX::M.BMAX			;(51) MAX.# BATCH JOBS ALLOWED
BATMIN::M.BMIN			;(52) MIN.# BATCH JOBS GARENTEED (RESERVED)
IFN FTMDA,<
UDATEX::
> ;END IFN FTMDA
DATE::	0			;(53) DATE TIME IN NEW FORMAT
				; LH = DAYS SINCE NOV. 17, 1858,
				; RH = FRACTION OF A DAY (GMT)
LOGNUM::0			;(54) NUMBER JOBS CURRENTLY LOGGED IN
BATNUM::0			;(55) NUMBER BATCH JOBS CURRENTLY LOGGED IN.
LOCYER::0		;(56) LOCAL YEAR
LOCMON::0		;(57) LOCAL MONTH (1,2,...,12)
LOCDAY::0		;(60) LOCAL DAY OF MONTH (1,2,3,...)
LOCHOR::0		;(61) LOCAL HOUR (MIDNIGHT=0)
LOCMIN::0		;(62) LOCAL MINUTE (0,1,...,59)
LOCSEC::0		;(63) LOCAL SECOND (0,1,...,59)

GMTDIF::0		;(64) DIFFERENCE BETWEEN LOCAL AND GMT TIME.
			; IN SAME UNITS AS DATE --
			; E.G. DATE + GMTDIF = LOCAL DATE-TIME
			; (LH = DAY, RH = FRACT. OF DAY)
DEBUGF::DEFDEB!DEFBPT	;(65) DEBUGGING STATES WORD - SIGN BIT=1 IF SYSTEM PROG IS
			; DEBUGGING MONITOR (SPEED UP ONCE ONLY)
			; BIT1=1 TO RELOAD ON DEBUG STOPCD'S
			; BIT2=1 TO RELOAD ON STOPCD'S WHICH ONLY
			; AFFECT 1 JOB
			; BIT3=1 TO DISABLE AUTO-RELOADS
			; BIT4=1 TO STOP SYSTEM IF ANY CPU GETS A CPU STOPCD
FRUSED::0		;(66) AMOUNT OF FREE CORE IN USE
			; (FTRSP CONDITIONAL)
RCCMAX::0		;(67) NUMBER OF BYTES IN TTY CHUNKS
CNFCVN:	A00CVN		;(70) CUSTOMER VERSION (=C(136))
CNFDVN:	AXXDVN		;(71) DEC VERSION (=C(137))
CNFCHN::IFE FTAUTC,<EXP M.CHN>	;(72) NUMBER OF DATA CHANGES
	IFN FTAUTC,<EXP 0>	;(72) AUTCON WILL COMPUTE IT
CNFRTD::EXP	M.RTD	;(73) NUMBER OF REAL TIME DEVICES
CNFHPQ::EXP	M.HPQ	;(74) NUMBER OF HPQ'S
CNFLDB::EXP	DDBLDB##  ;(75) WORD IN TTY DDB WHICH POINTS TO LDB
CNFMVO::EXP	PSIMVO	  ;(76)MAX. VECTOR OFFSET FOR PISYS. UUO
CNFMIP::EXP	PSIMPI	;(77)MAX. PRIORITY FOR PSISER
IFG TAPN,<
CNFMTA::XWD	TUBRID##,MT0DDB##  ;(100) POINTER TO FIRST MTA DDB AND INDEX
				   ; OF START OF DAEMON INFORMATION
>
IFE TAPN,<
CNFMTA::0
>

CNFET1:	EXP	JOBDAC##+T1	;(101) EXEC AC1 IN USER'S ADDRESS SPACE
CNFLSD:	EXP	DEVLSD		;(102) LENGTH OF SHORT DDB
CNFLLD:	EXP	DEVLLD		;(103) LENGTH OF LONG DDB
CNFLDD:	EXP	DDBLEN##	;(104) LENGTH OF DISK DDB
CNFEXM:	EXP	JOBEXM##	;(105) WORD IN JOBDAT WHICH HOLDS ADDRESS OF
				;      LAST EXAMINE OR DEPOSIT.

	ZZ==0
	ZZ==ZZ!1B35		;BIT 35=1 IF SWAP SPACE ALLOCATED IN PAGES
IFN M.TM10,<ZZ==ZZ!1B34>	;BIT 34=1 IF MTA ERROR REPORTING
	ZZ==ZZ!1B33		;BIT 33=1 IF VM MONITOR
IFN M.IPCF,<ZZ==ZZ!1B32>	;BIT 32=1 IF IPCSER IS LOADED
IFN M.PSI,<ZZ==ZZ!1B31>		;BIT 31=1 IF PSISER IS LOADED
IFN M.MSG,<ZZ==ZZ!1B30>		;BIT 30=1 IF MSGSER IS LOADED
ZZ==ZZ!1B29			;BIT 29=1 IF NON-SUPER ENTER
				; IS SUPPORTED
IFN FTNSCHED,<ZZ==ZZ!1B28>	;BIT 28=1 IF NEW SCHEDULER IS PRESENT
IFN M.EQDQ,<ZZ==ZZ!1B27>	;BIT 27 IF ENQ/DEQ IS LOADED
IF2, <ZZ==ZZ!<<ZGAL>B26>>	;BIT 26=1 IF MONITOR CONTAINS GALAXY-10 FEATURES
ZZ==ZZ!1B25			;BIT 25=1 MONITOR SUPPORTS MASSBUS ERROR REPORTING
ZZ==ZZ!1B24			;BIT 24=1 IF NEW TAPSER
ZZ==ZZ!1B23			;BIT 23=1 IF NEW ERROR REPORTING
ZZ==ZZ!1B22			;BIT 22=1 IF MONITOR SUPPORT MORE THAN 127 JOBS.
IFN  M.EXE,<ZZ==ZZ!1B21>	;BIT 21=1 IF "SAVE" COMMAND PRODUCES EXE FILE
IFN M.EMRT,<ZZ==ZZ!ST%EMR>	;BIT 20=1 IF EBOX/MBOX RUNTIME IS IN EFFECT (KL ONLY)
IFN M.XPI,<ZZ==ZZ!ST%XPI>	;BIT 19=1 IF PI TIME IS EXCLUDED FROM USER
				; RUNTIME (KL ONLY)
ZZ==ZZ!1B18			;BIT 18=1 IF FULL 6CHAR DEVICE NAMES
IFN M.ITA,<ZZ==ZZ!ST%ITA>	;BIT 17=1 IF INTERVAL TIMER ON KL10 IS AVAILABLE
IFE M.CLSS,<ZZ==ZZ!ST%NCS>	;BIT 16=1 IF NOT CLASS SYSTEM SCHED.
ZZ==ZZ!ST%NER			;BIT 15=1 MONITOR SUPPORTS 6.03 ERROR REPORTING
IFN M.ACV,<ZZ==ZZ!ST%ACV>	;BIT 14=1 IF ACCOUNT VERIFICATION SHOULD BE DONE
IFN FTKL10!FTKS10,<ZZ==ZZ!ST%LSC> ;BIT 13=1 IF LOW SEGMENT OF MONITOR IS CACHED

IFN FTMDA,<ZZ==ZZ!ST%MDA>	;BIT 12=1 IF ALLOCATOR WILL RUN
IFN FTKLP,<ZZ==ZZ!1B11>		;BIT 11=1 IF KL RATHER THAN KI PAGING
IFN M.DECN,<ZZ==ZZ!1B10>	;BIT 10=1 IF PHASE 3 DECNET LOADED
CNFST2::EXP	ZZ		;(106) FLAG BITS DEFINED ABOVE
PISYMN:EXP	M.PSI*C$MIN	;(107) MINIMUM CONDITION FOR PISYS.UUO
PITLEN:EXP	PITSIZ		;(110)LENGTH OF PI TABLE
CNFPIA::EXP	JBTPIA		;(111)ADDRESS OF JBTPIA
%CNMNT:	BYTE	(1)0(17)0(6)1(6)0(6)0	;(112) TYPE OF MONITOR
					;    (1)=STRANGE
					;    (17)=RESERVED TO DEC
					;    (6)=TYPE:	1=TOPS-10
					;		2=I.T.S.
					;		3=TENEX
					;		REST RESERVED TO DEC
					;    (6)=SUBTYPE (RESERVED TO DEC)
					;    (6)=RESERVED TO CUSTOMERS

IFN M.CDR,<
CR0DDB,,CDRCNT##		;(113)OFFSET TO CARD COUNT FOR CDR
>
IFE M.CDR,<
	EXP	0
>
IFN M.CDP,<
CP0DDB##,,CDPCTO##		;(114)OFFSET TO CARD COUNT FOR CDP
>
IFE M.CDP,<
	EXP	0
>
EXP	PAGSIZ			;(115)BASIC UNIT OF CORE ALLOCATION
EXP	MINMAX			;(116)MIN VALUE FOR CORMAX
EXP	M.CLSN			;(117)NUMBER OF SCHEDULER CLASSES
EXP	0			;(120)EXPONENTIAL FACTOR USED IN COMPUTING USER TIME
SYSORG::	0		;(121)
SYSLEN::	0		;(122)
NWCORE::2000*M.NKC		;(123)NUMBER OF WORDS OF CORE
NXMPTR::0			;(124)AOBJN POINTER TO NXMTAB USED TO SCAN FOR ZEROES
IFN M.NET,<
	EXP	NETNDB##	;(125)POINTER TO THE FIRST NODE BLOCK
>
IFE M.NET,<
	EXP	0		;(125)NO POINTER IF NO NETWORKS
>
IFG TAPN,<
CNFTKB:	EXP	TKBCDB##	;(126)POINTER FROM KDB TO CDB FOR MAGTAPES
>
IFLE TAPN,<
CNFTKB:	EXP	0		;(126)IF NO MAGTAPES
>
	EXP	0		;(127) OBSOLETE
HNGLST::XWD	0,0		;(130)LH IS ADDRESS OF FIRST DEVICE WHICH SHOULD BE
				; CHECKED TO SEE IF IT IS HUNG
EXP	BOOTXT			;(131) ADDRESS OF RELOAD CCL TEXT
IFG TAPN,<
EXP	TUBDDB##		;(132) OFFSET OF DDB PTR'S IN TUB
CNFMTK::
IFN FTAUTC,<	0>		;AUTCON WILL FILL IT IN
IFE FTAUTC,<
	EXP	MT0KDB##	;(133) 1ST MTA KDB IN SYS
>
>
IFE TAPN,<
	Z
CNFMTK::EXP	0
>
NOCPUS::EXP	M.CPU		;(134) NO OF CPUS MONITOR WAS BUILT FOR
CNFDJB:	XWD	PJBNLH,DEVJOB	;(135) GETTABLE PJOBN (SANS INDEX FIELD)
UPTIME::
SYSUPT::EXP	0		;(136) SYSTEM UPTIME
BOOTCP::EXP	-1		;(137) BOOT CPU NUMBER
BOOTCT::EXP	CT0LIN		;(140) BOOT CPU CTY LINE NUMBER
NCPRUN::EXP	M.CPU		;(141) NUMBER OF CPUS ALLOWED TO RUN
STRMON::SIXBIT	/SYS/		;(142) FILE STRUCTURE MONITOR WAS BOOTED FROM
FILMON::SIXBIT	/SYSTEM/	;(143) FILE NAME
EXTMON::SIXBIT	/EXE/		;(144) EXTENSION
PPNMON::XWD	1,4		;(145) PPN
SYSNBP::EXP	MAXNBP		;(146) MAXIMUM NUMBER OF BREAK POINTS
				; SETTABLE BY THE SNOOP. UUO
MONVFF::EXP	MONORG		;(147) FIRST FREE VIRTUAL ADDRESS ABOVE MONITOR
LDBVRG::EXP	0		;(150) VIRTUAL ADDRESS OF THE ORGIN OF LDBS
FOPHXC::EXP	HIGHXC-20	;(151) NUMBER OF EXTENDED CHANNELS AVAILABLE VIA FILOP.
MONHSO:	EXP	MONORG		;(152) VIRTUAL ADDRESS OF START OF MONITOR HIGHSEG
RSDTTM::EXP	0		;(153) UNIVERSAL DATE/TIME OF LAST ROLE
				;      SWITCH ON MULTIPLE CPU SYSTEMS

CNFDCH:	EXP	LDBDCH##	;(154) OFFSET OF LDBDCH IN LDB'S
SFDMON::EXP	0		;(155) 1ST SFD MONITOR WAS BOOTED FROM
	EXP	0		;(156) 2ND SFD MONITOR WAS BOOTED FROM
	EXP	0		;(157) 3RD SFD MONITOR WAS BOOTED FROM
	EXP	0		;(160) 4TH SFD MONITOR WAS BOOTED FROM
	EXP	0		;(161) 5TH SFD MONITOR WAS BOOTED FROM
	EXP	FRCLIN		;(162) TTY LINE NUMBER OF FRCLIN
PTYPTR:	XWD	-PTYN,PTYTAB	;(163) POINTER TO PTY TABLE
IFN M.NET<
	XWD	-LATLEN##,NETLAT## ;(164)-LENGTH,,LOCATION LINK ADDRESS TABLE
>
IFE M.NET<
	EXP	0
>
CNFLPD:	EXP	.PDLEN		;(165) LENGTH OF A PDB
	XWD	0,PAGSIZ	;(166) XWD FLAG, SIZE OF LARGEST JOBPEK TRANSFER
				; WHERE FLAG=0 IF SWAP SPACE JOBPEK'S MAY NOT
				; CROSS A PAGE BOUNDARY, FLAG=1 IF THEY MAY
	EXP	CNFDAE		;(167) XWD OLD DAEMON NAME,CURRENT MONITOR
				; VERSION. OLD DAEMON NAME IS THE SIXBIT NAME
				; OF THE PREVIOUS MONITOR, E.G. 701.
CNFHSH::XWD	-HSHLEN,HSHTAB	;(170) AOBJN POINTER TO HSHTAB
	EXP	<.PDACS-.PDBEG>	;(171) OFFSET IN PDB FOR ACCOUNT STRING
	XWD	TOPLN1##,TOPTB1## ;(172) POINTER TO TOPTB1, TRMOP DISPATCH
	EXP	JBTSFD##	;(173) POINTER TO JBTSFD
	EXP	CIPWT		;(174) POINTER TO CLOCK QUEUE
CNFMXL==:<.-CNFTBL-1>B26	;MAXIMUM ENTRY IN CNFTBL FOR GETTAB UUO

IFN STUPID,<
TMZWRD::			;Time zone word.
IFNDEF M.TMZ,<XWD 0,^D3600>	;Default is Sweden.
IFDEF M.TMZ,<XWD 0,M.TMZ>	;Make it redefineable.
>;IFN STUPID

;----------------------------------
;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY ONCE ONLY CODE.
; OR ARE CONSTANTS WHICH ARE NOT CLEARED AT STARTUP
;-------------------------------------

IFE M.NET,<IFN FTNET+FTCMSR,<
	.NTMXL==:0		;THIS LETS UUOCON'S GETTABS
NETGTT::0			; LOAD WITHOUT UNDEFINED GLOBALS
>>

TICMIN::JIFMIN			;NUMBER OF TICKS PER MINUTE (CALCULATED BY ONCE)
TIMLST::0			;VALUE OF "TIME" LAST TIME AT CLOCK LEVEL
				; USED FOR ALL TIMING FUNCTIONS, E.G.,
				; MAINTAINING CLOCK QUEUE AND SMITHSONIAN DATE
IFN M.KI10,<
NULJPC::EXP	XC.USR+IC.LIP+1	;PC FOR THE NULL JOB (NULL JOB RUN IN
				; PUBLIC USER MODE)
NULDOP::EXP	PG.LUB+<(NUPMPP)>
>
IFN M.KL10,<
NULJPC::EXP	XC.USR+IC.LIP+1	;PC FOR THE NULL JOB
NULDOP::EXP	LG.LUB+LG.IAM+NLUPMP/PAGSIZ
>
IFN M.KS10,<
NULJPC::EXP	XC.USR+IC.LIP+1
NULDOP::EXP	SG.LUB+NLUPMP/PAGSIZ
>
SYSBPJ::0			;SNOOP.ING JOB
SYSBPP::0			;ADDRESS OF BREAK POINT TABLE,, NUMBER OF BREAK POINTS
MSTCKS::0			;MONITOR SYMBOL TABLE CHECKSUM
LOWLOC::0
ONCCOM::0
MONPFF::0			;TO KEEP TRACK OF ALLOCATED PHYSICAL PAGES
				; (NOT IN ANY MAP)
IFN M.KI10!M.KL10,<
LOWLEN==<IOWNUM+^D143>/^D144
LOWPTR::XWD	-LOWLEN,LOWTAB
LOWTAB:	BLOCK	LOWLEN
>
NXMTBL==:<CORBLK+^D35>/^D36
NXMTAB::BLOCK	NXMTBL		;TABLE USED TO RECORD WHICH PAGES OF MEMORY EXIST
CORLIM::EXP	USRLIM
SYSINA::EXP	SYSINI##		;LOCATION AT WHICH SYSINI WAS LOADED
OMSMIN::EXP	M.OMSM		;# MINUTES REMAINING BEFORE NEXT CALL
				; TO BIGBEN
OMSINI::EXP	M.OMSM		;TIME BETWEEN CALLS
SEGPT2::EXP	JOBN		;ROUND ROBIN OVER IN-CORE DORMANT SEGMENTS
IFNDEF		MFRHPQ,<MFRHPQ==2>;DEFAULT IS 2
FRSHPQ::EXP	MFRHPQ		;MINIMUM HPQ FORCING SCHED
IFNDEF		STHLOG,<STHLOG==0>
STHFLG::EXP	STHLOG		;IF NON-ZERO,NRT CAN RUN W/O LOGIN
;INTERLOCK WORDS AND OWNER WORDS MUST BE IN THE SAME ORDER
; "INTRLK" MUST BE FIRST

IFN FTMP,<
	INTERN	INTL0,INTO0
INTRLK::-1			;CPU PI SYSTEM INTERLOCK
SCDLOK::-1			;SCHEDULER INTERLOCK
SCNLOK::-1			;SCNSER INTERLOCK
INTRDD::-1			;DDB-SCAN INTERLOCK
INTRST:	-1			;CPU START-UP INTERLOCK
INTRUU::-1			;GENERAL UUO-LEVEL LOCK
INTRDS::-1			;DSKOFF INTERLOCK
NETLOK::-1			;USED IN NETOFF,NETOM MACROS
NTLOCK::-1			;THE NETSER INTERLOCK
INTLBT::-1			;BIT DIDDLER INTERLOCK (SETOS,CLRBTS)
IFN FTKL10,<
INTLNB::-1			;BUFFER (CACHE) MANAGEMENT INTERLOCK
IFN FTDOTD,<
INTLBY::-1			;BYTE DIDDLER INTERLOCK (RMWDPB)
>>
IFN FTDECNET,<
SCTLOK::-1			;DECNET'S SESSION CONTROL INTERLOCK
NSPLOK::-1			;DECNET'S NSP INTERLOCK
>
IFN FTPATT,<			;FOR PATCHING
INTRP1::-1
INTRP2::-1
>
INTRCL::-1			;CLOCK QUEUE PROCESSING
DEFINE	INTLK(A,B)<
IFE A,<INTL'B: -1>		;PI LEVEL B ON CPU A PI INTERLOCK
IFN A,<INTL'A'B: -1>>

ZZ==0
REPEAT M.CPU,<
ZZZ==0
REPEAT 10,<
INTLK(\ZZ,\ZZZ)
ZZZ==ZZZ+1>
ZZ==ZZ+1>
;OWNING CPU OF INTERLOCKS (CONI PAG OR APRID)
INTOLK::-1			;CPU PI-SYSTEM
INOSCD::-1			;SCHEDULER
INOSCN::-1			;SCNSER
INTODD::-1			;DDB-SCAN
INTOST::-1			;CPU START-UP
INTOUU::-1			;GENERAL  UUO-LEVEL
INTODS::-1			;DSKOFF
INONET::-1			;NETOFF
INONT::	-1			;NETSER
INTOBT::-1			;BIT DIDDLERS
IFN FTKL10,<
INTONB::-1			;BUFFER (CACHE) MANAGEMENT
IFN FTDOTD,<
INTOBY::-1			;BYTE DIDDLER (RMWDPB)
>>
IFN FTDECNET,<
SCTLKO::-1			;DECNET'S SESSION CONTROL
NSPLKO::-1			;DECNET'S NSP INTERLOCK
>
IFN FTPATT,<			;FOR PATCHING
INTOP1::-1
INTOP2::-1
>
INTOCL::-1			;CLOCK QUEUE PROCESSING
DEFINE INTLKO(A,B)<
IFE A,<INTO'B:-1>
IFN A,<INTO'A'B:-1>>
ZZ==0
REPEAT M.CPU,<
ZZZ==0
REPEAT 10,<
INTLKO(\ZZ,\ZZZ)
ZZZ==ZZZ+1>
ZZ==ZZ+1>
;NOT CORRESPONDING TO ABOVE INTERLOCKS
SCNOWN::-1			;OWNER OF SCNCNT (.CPCPU)
INTLMO::-1			;OWNER OF THE MEMORY MANAGEMENT RESOURCE (APRID)
>;END FTMP
IFE FTMP,<
NTLOCK::-1			;NTLOCK EXISTS ON SINGLE CPU'S TOO
SCTLOK::-1			;DECNET INTERLOCKS EXIST ON SINGLE CPU's TOO
NSPLOK::-1
RTRLOK::-1
SCTLKO::-1
NSPLKO::-1
RTRLKO::-1
>
INTDIE::-1			;DIE INTERLOCK
INODIE::-1			;DIE
;GETTAB TABLE OF QUEUE CODES FOR JOBS - TABLE(RH)=25
;MUST BE A SEPARATE TABLE SINCE THE NUMBER OF ENTRIES VARIES ACCORDING
;TO THE CONFIGURATION

;ENTRIES ARE 2 SIXBIT CHARACTERS, THREE PER WORD
;STATE CODE 0 IS LEFT THIRD, 1 IS MIDDLE THIRD, 2 IS RIGHT THIRD OF FIRST WORD
;STATE CODE 3 IS LEFT THIRD OF SECOND WORD, ETC.


STSTBL::

DEFINE X(A,B,C)
<	IFE ZZ-ZZ/3*3-0,
	<	  XX==   <SIXBIT /A/&7777B11>B35>
	IFE	ZZ-ZZ/3*3-1,
	<	  XX==XX!<SIXBIT /A/&7777B11>B47>
	IFE	ZZ-ZZ/3*3-2,
	<	  XX==XX!<SIXBIT /A/&7777B11>B59
	  EXP XX>
ZZ==ZZ+1
>

ZZ==0
	QUEUES
	RWAITS
	CODES
	IFN	ZZ-ZZ/3*3-0,<
	  EXP XX>

STSMXL==:<.-STSTBL-1>B26		;MAX ENTRY IN STSTBL FOR GETTAB UUO
IFG DSKN, <


ODPTBL::!			;FIRST LOCATION IN MONITOR DATA AREA FOR DISK-
				; RELATED LOCATIONS WHICH ARE NOT SET TO 0 WHEN
				; THE SYSTEM IS STARTED UP.
				; ODPTBL IS GETTAB UUO TABLE NUMBER 15.

SWPHGH::0			;(0) HIGHEST LOGICAL BLOCK # ASSIGNED FOR SWAPPING.
				; SPACE IS ASSIGNED FROM HIGHEST BLOCK # DOWNWARDS.
K4SWAP::0			;(1) # OF K OF DISK WORDS SET ASIDE FOR SWAPPING.
				; ASSIGNED AT ONCE ONLY REFRESH TIME.

IFE SYS50N, <KXFTIM==0
SEEKTM==0			;DEFAULT VALUES FOR 10/40 DISK SYSTEM.>
IFN LEVDN,<KXFTIM==0		;SET PROTECT TIMES TO 0
SEEKTM==0			;ONCE ONLY CODE MUST SET PROT,PROT0
				;DEPENDING ON FASTEST UNIT USED FOR SWAPPING
>
PROT::	EXP	0		;(2) IN-CORE PROTECT TIME PARAMETER TO BE
				; MULTIPLIED BY <K-1> OF CORE IN JOB.
PROT0::	EXP	0		;(3) IN-CORE PROTECT TIME PARAMETER TO
				; BE ADDED TO ABOVE RESULT.
PROT1::	EXP	0		;(4) SWAPPABLE CYCLING TIME
PROTM::	EXP	0		;(5) MAXIMUM IN-CORE PROTECT TIME

	;INSERT HERE ANY NEW LOCATIONS OF INTEREST WHICH ARE SET UP BY
	; ONCE ONLY CODE AND WHICH PERTAIN ONLY TO DISK SYSTEMS.

ODPMXL==:<.-ODPTBL-1>B26		;MAXIMUM ENTRY IN ODPTBL FOR GETTAB UUO

;DISK LOCATIONS NOT IN GETTAB


REFLAG::Z			;FLAG LOCATION TO INDICATE WHETHER ANY REFRESHING
				; OCCURRED AND TO CONTAIN THE [PROJ,PROG]
				; NUMBERS FOR AUTOMATIC LOG-IN FOLLOWING REFRESH.

>	;END IFG DISKN CONDITIONAL
;MORE DATA LOCATIONS SETUP AT ASSEMBLY TIME OR ONCE ONLY TIME
; BUT NOT OF INTEREST TO USER PROGRAMS



	$HIGH
XJBPFI::XWD	JOBPFI##,0	; JOBPFI==HIGHEST LOC, IN USER JOB DATA AREA
				; PROTECTED FROM I/O
;MONTH TABLE FOR DAYTIME COMMAND PRINTING

PMONTB::POINT	6,MONTAB(T1),5	;POINTER TO NUMBER OF DAYS IN MONTH
MONTAB::EXP	^D30B5+"Jan"
	EXP	^D27B5+"Feb"
	EXP	^D30B5+"Mar"
	EXP	^D29B5+"Apr"
	EXP	^D30B5+"May"
	EXP	^D29B5+"Jun"
	EXP	^D30B5+"Jul"
	EXP	^D30B5+"Aug"
	EXP	^D29B5+"Sep"
	EXP	^D30B5+"Oct"
	EXP	^D29B5+"Nov"
	EXP	^D30B5+"Dec"
MIDNIT::EXP	0		;NO OF JIFFIES TILL MIDNIGHT (CALCULATED BY ONCE)
IFN FTMP,<
COKTAB:: -JIFSEC		;TABLE TO SET THE POLICY CPU'S OK WORD TO
	ZZ==1			;(INDEXED BY THE NUMBER OF RUNNING CPUS-1)
	REPEAT	M.CPU-1,<
	-ZZ*JIFSEC
	ZZ==ZZ+1
	>
>
	$ABS
;TABLE OF SCHEDULER STATISTICS (CAN BE USED TO HELP TUNE SYSTEM)

.GTSST::!			;SCHEDULER STATISTICS TABLE - #115


FORCFC::0			;(0)COUNT OF TIMES SCHEDULER RAN A JOB
				;OUT OF ORDER SO THAT IT WOULD RELEASE
				;A SHARABLE RESOURCE IN ORDER THAT IT
				;COULD BE SWAPPED OUT.

UNWNDC::0			;(1)COUNT OF TIMES SCHEDULER RAN A JOB
				;OUT OF ORDER BECAUSE ANOTHER JOB HAS BEEN
				;SELECTED THAT NEEDS A SHARABLE DISK
				;RESOURCE THE FIRST JOB OWNED

SWPNUL::0			;(2)SWAPPER NULL TIME (TIME WHEN SWAPPING
				;LOGIC COULD NOT FIND ANYTHING TO DO.)

SWPLOS::0			;(3)SWAPPER LOST TIME (TIME THAT SWAPPER
				;WANTED TO SWAP A JOB IN BUT COULDN'T

RQCNT::0			;(4)NUMBER OF PHYSICAL REQUEUES SINCE
				;SYSTEM STARTUP

MCUINT::0			;(5)INTERVAL AT WHICH MINIMUM CORE
				;USAGE FUNCTION IS CALCULATED.
				;ZERO MEANS DO NOT CALCULATE

SCDINT::0			;(6)MICRO SCHEDULING INTERVAL. ZERO
				;MEANS RUN ROUND ROBIN IGNORING CLASSES.

AVJSIZ::0			;(7)AVERAGE JOB SIZE COMPUTED ONCE A MINUTE

TOTRTC::0			;(10)TOTAL RUNTIME GIVEN TO ALL SUBCLASSES
				;DOES NOT INCLUDE ANY PQ1 OR HPQ TIME

SCDEXF::0			;(11)EXPONENTIAL FACTOR USED FOR COMPUTING
				;EXPONENTIALLY AVERAGED RUNTIME FOR
				;CPU CLASSES

UTMEAR::0			;(12)EXPONENTIALLY AVERAGED USER TIME USED
				;FOR THE ENFORCEMENT OF QUOTAS

RTCTOT::0			;(13)TOTAL USER RUNTIME SINCE LAST
				;SCHED UUO SET CLASS PARAMETERS

DEFCLS::M.DCLS			;(14)DEFAULT CLASS FOR NEW JOBS

SCDJIL::0			;(15)PERCENT OF TIME SCHEDULER SCANS
				;JUST SWAPPED IN QUEUE BEFORE SUBQUEUES

SCDSWP::0			;(16)MINIMUM NUMBER OF TICKS
				;SWAPPER SCANS THE SAME PRIMARY SUBQUEUE

BBSUBQ::0			;(17)BACKGROUND BATCH SUBQUEUE

SCDBBS::0			;(20)NUMBER OF TICKS BETWEEN
				;BACKGROUND BATCH SWAPS

SCDIOF::0			;(21)PERCENT OF TIME THAT SWAPPER SCANS PQ2
				;INCORE CHAIN BEFORE OUTCORE CHAIN
SCDSET::0			;(22)FLAG = 0 IF RUNNING ROUND ROBIN
				;= DATE/TIME WHEN CLASS RUNTIME TABLE
				;INITIALIZED IF RUNNING IN CLASS MODE
RRFLAG::0			;(23)FLAG = 0 IF RUNNING ROUND ROBIN SCHEDULER
				;= CNTSTS IF CLASS SCHEDULING
SCDCOR::0			;(24) TIME TO WAIT AFTER SWAPPING OUT
				;A RUNNABLE JOB BEFORE SETTING CORSCD
				;FLAG
SSDMXL==:<.-.GTSST-1>B26	;MAXIMUM LENGTH OF TABLE FOR GETTABS
;IPCF COMMON DATA

IFN FTIPCF,<
IFN M.IPCF,<

IFNDEF M.PIDN,<XP M.PIDN,JOBN*2>
XP MIDMXL,<<M.PIDN>B26>		;FOR GETTAB

IFNDEF	M.PKTL,<M.PKTL==12>
PIDMSK==JOBN
IFG <M.PIDN-JOBN>,<PIDMSK==M.PIDN>  ;MAX (JOBN,M.PIDN)
PIDMSK==<1B<^L<PIDMSK>-1>>-1	;MAKE INTO MASK
%IPCLS==:^D36-^L<PIDMSK>	;DEFINE NUMBER OF BITS IN MASK
%IPMPL==:M.PKTL			;MAXIMUM PACKET LENGTH
PIDTAB::XWD	IPCPID,0	;INITIALLY IPCPID IN TABLE
	XWD	SYSPID,0
	XP	%IPCNS,2	;NO. OF SYSTEM PROCESSES
	XLIST
	REPEAT	<M.PIDN-1>,<Z>	;REMAINDER OF TABLE ZERO
	LIST

IPCPID:	Z			;.EPIPC
	Z			;.EPIPA
	XWD	200000,-1	;.EPIPQ
	EXP	IPCFPR##	;.EPADR
	Z			;.EPIPN
SYSPID:	Z
	Z
	XWD	200000,-1
	EXP	IPCSPR##
	Z

	EXTERN	IPCSER


IPCTAB::			;MISCELLANEOUS IPCF DATA
%CNIPL::EXP	%IPMPL		;(0) MAX PACKET LENGTH
%CNIPI::Z			;(1) MID OF SYS:INFO (0=NONE)
%CNIPQ::XWD 200000,002005	;(2) DEFAULT QUOTA
%CNIPS::Z			;(3) TOTAL PACKETS SENT
%CNIIP::Z			;(4) NUMBER OF PACKETS OUTSTANDING
%IPCFP::XWD	IPCPID,0	;(5) PID OF [SYSTEM] IPCC
%IPCPM::	PIDMSK		;(6) MASK FOR PID
%IPCMP::	M.PIDN		;(7) LENGTH OF PID TABLE
%IPCNP::	2		;(10) CURRENT NUMBER OF PID'S
%IPCTP::	2		;(11) TOTAL PID'S SINCE RELOAD
%CNPIC::Z			;(12) NUMBER OF IPCF PAGES CURRENTLY IN CORE
%IPCSP::XWD	SYSPID,1	;(13) PID OF [SYSTEM]GOPHER
%IPTWT::Z			;(14) TOTAL WORDS PASSED (NON-PAGE MODE)
%IPTPT::Z			;(15) TOTAL PAGES PASSED
%IPOPP::.IPCFD##		;(16) OVERHEAD PER PACKED
IPCMXL==:<.-IPCTAB-1>B26	;FOR GETTAB

	$HIGH
.GTQFC::			;CUSTOMER SPECIAL QUEUE. FUNCTIONS GO HERE
IFN FTYORK,<
%QFTP::	%SIQSR			;(-1) Transfer a file.
>;End FTYORK
.GTQFT::0			;QUEUE. UUO FUNCTION TABLE (ZERO IS ILLEGAL)
%QPRNT::%SIQSR			;(1) PRINT A FILE
%QPCRD::%SIQSR			;(2) PUNCH A FILE ON CARDS
%QPTAP::%SIQSR			;(3) PUNCH A FILE ON PAPER TAPE
%QPLOT::%SIQSR			;(4) PLOT A FILE
%QSUBM::%SIQSR			;(5) SUBMIT A FILE
%QALLC::%SIQSR			;(6) ALLOCATE A VOLUME SET
%QDEAL::%SIQSR			;(7) DEALLOCATE A VOLUME SET
%QMOUN::%SIQSR			;(10) MOUNT A VOLUME
%QDMNT::%SIQSR			;(11) DISMOUNT A VOLUME
%QWTO::	%SIOPR			;(12) WRITE TO OPERATOR
%QWTOR::%SIOPR			;(13) WRITE TO OPERATOR WITH RESPONSE
%QVALA::%SIACT			;(14) VALIDATE AN ACCOUNT
%QMAUE::%SIACT			;(15) MAKE A USAGE ENTRY
QUTBLN==:.-.GTQFT-1
	$ABS

.GTCSD::			;CUSTOMER SPECIAL PID'S GO HERE
ifn stupid,<
%SISND::Z			;(-1) [SYSTEM]SENDER
>;stupid
.GTSID::			;SPECIAL PID TABLE
%SIIPC::XWD	IPCPID,0	;(0) IPCC
%SIINF::Z			;(1) [SYSTEM] INFO
%SIQSR::Z			;(2) [SYSTEM] QUASAR
%SIMDA::Z			;(3) MOUNT DEV ALLOCOTOR
%SITLP::Z			;(4) MAGTAPE LABELING PROCESS
%SIFDA::Z			;(5) FILE DAEMON
%SITOL::Z			;(6) TAPE AVR PROCESS
%SIACT::Z			;(7) [SYSTEM] ACCOUNTING
%SIOPR::Z			;(10) OPERATOR INTERFACE PROCESS
%SISEL::Z			;(11) SYSTEM ERROR LOGGER
%SIDOL::Z			;(12) DISK AVR PROCESS
%SITGH::Z			;(13) [SYSTEM] TGHA
%SINML::Z			;(14) DECNET NETWORK MANAGEMENT LAYER
%SIGFR::XWD	SYSPID,1	;(IS) PID OF [SYSTEM]GOPHER
%SICAT::Z			;(16) PID FOR [SYSTEM]CATALOG
%SIMAI::Z			;(17) PID FOR [SYSTEM]MAILER
SDTBLN==:.-.GTSID-1
SIDJOB==:.+<.GTSID-.GTCSD>	;ZERO 'TH SYSTEM JOB #
	BLOCK	<.-.GTCSD>	;SPACE FOR PARALLEL JOB
MDAJOB=:SIDJOB+<%SIMDA-.GTSID>
FDAJOB=:SIDJOB+<%SIFDA-.GTSID>
TLPJOB=:SIDJOB+<%SITLP-.GTSID>
ACTJOB=:SIDJOB+<%SIACT-.GTSID>
NMLJOB=:SIDJOB+<%SINML-.GTSID>
>>

IFE FTIPCF,<
IFN M.IPCF,<

PRINTX ? PLEASE ASSEMBLE SOURCES WITH FTIPCF=-1
>>

IFE M.IPCF,<

XP UIPCFR,CPOPJ			;MAKE IPCF UUOS LOOK UNIMPLEMENTED
XP UIPCFS,CPOPJ
XP UIPCFQ,CPOPJ
XP IPCFRC,CPOPJ			;DO NOTHING ON RESET UUO
XP LOKIPC,CPOPJ
XP FNDIPC,CPOPJ
XP GLXINF,CPOPJ			;NO QUEUE. UUO
XP IPMCHK,CPOPJ			;NO IPCF QUEUE TO INTERLOCK
XP IPCULK,CPOPJ			;NO IPCF QUEUE TO UNLOCK
XP SNDFFC,CPOPJ			;SEND MESSAGE TO SPECIAL PID


XP IPCLGO,CPOPJ			;DO NOTHING ON LOGOUT UUO
XP SNDMDR,CPOPJ			;LOCKED STRUCTURE MESSAGE TO MDA
XP SNDMDN,CPOPJ			;SEARCH LIST CHANGE MESSAGE TO MDA
XP SNDFIN,CPOPJ			;DEVICE DEASSIGN MESSAGE TO MDA
XP SNDMDX,CPOPJ			;SEND MESSAGE TO SPECIAL SYSTEM PID
XP ATTMPA,CPOPJ			;DISK UNIT ATTACH MESSAGE TO MDA
XP DETMPA,CPOPJ			;DISK UNIT DETACH MESSAGE TO MDA
XP XCHMPA,CPOPJ			;DISK UNIT EXCHANGE MESSAGE TO MDA
XP REMMPA,CPOPJ			;STRUCTURE REMOVAL MESSAGE TO MDA
XP MTAMPA,CPOPJ			;MAGTAPE ACCESSIBLE MESSAGE TO MDA

XP MIDMXL,0			;MAKE GETTABS FAIL
XP IPCMXL,0
XP PIDTAB,0
XP IPCTAB,0
XP .GTCSD,0			;NO CUSTOMER PID TABLE
XP .GTSID,0			;NO SPECIAL PID TABLE
XP .GTQFT,0			;NO QUEUE. TABLE
XP %QWTO,0			;NO QUEUE. TABLE OFFSET FOR WTO

XP SDTBLN,0
XP .IPCTL,0			;NO MESSAGE CODE FOR TAPE LABELING
XP .IPCSC,0			;NO CSHIFT MESSAGE TO ACCOUNTING DAEMON
XP .IPCGM,0			;NO QUEUE. UUO MESSAGE TO GALAXY COMPONENTS
XP .IPCME,0			;NO MOS MEMORY ERROR MESSAGE TO TGHA
XP FILMSG,0
XP .IPCFP,0
XP .IPCFD,0
XP SPBMAX,0
XP SPBCOR,0

%CNIPS::			;NUMBER OF PACKETS SENT
%CNPIC::			;NUMBER OF PIDS IN CORE

MDAJOB::			;MDA
FDAJOB::			;FILE DAEMON
TLPJOB::			;TAPE LABELER
ACTJOB::			;ACCCOUNTING DAEMON
NMLJOB::			;DECNET NETWORK MANAGEMENT LAYER

%SIIPC::			;(0) IPCC
%SIINF::			;(1) [SYSTEM] INFO
%SIQSR::			;(2) [SYSTEM] QUASAR
%SIMDA::			;(3) MOUNT DEV ALLOCOTOR
%SITLP::			;(4) MAGTAPE LABELING PROCESS
%SIFDA::			;(5) FILE DAEMON
%SITOL::			;(6) TAPE AVR PROCESS
%SIACT::			;(7) [SYSTEM] ACCOUNTING
%SIOPR::			;(10) OPERATOR INTERFACE PROCESS
%SISEL::			;(11) SYSTEM ERROR LOGGER
%SIDOL::			;(12) DISK AVR PROCESS
%SITGH::			;(13) [SYSTEM] TGHA
%SINML::			;(14) DECNET NETWORK MANAGEMENT LAYER
%SIGFR::			;(15) PID OF [SYSTEM]GOPHER
%SICAT::			;(16) PID FOR [SYSTEM]CATALOG
%SIMAI::			;(17) PID FOR [SYSTEM]MAILER
	EXP	0		;ALL THOSE WHO DO SKIPE %SIXXX

XP STRSIG,CPOPJ			;MAKE IPCF CALL FOR PSISER
XP SENDSN,CPOPJ			;MAKE IPCF CALL FOR TAPUUO
XP QSRSPL,CPOPJ			;MAKE IPCF CALL FOR FILUUO
XP SENDSP,CPOPJ
XP SNDMDC,CPOPJ
XP QSRLGI,CPOPJ
>
;36 BITS 1 PER WORD
	$HIGH
BITTBL::
SALL
	ZZ==1B0
REPEAT ^D36,<
	EXP	ZZ
	ZZ==ZZ_<-1>
>
XALL
	$ABS

;ENQUEUE/DEQUEUE COMMON DATA


IFE FTEQDQ,<
HSHTAB==:0			;DEFINE FOR SYSINI
HSHLEN==:0
>
IFN FTEQDQ,<
IFN M.EQDQ,<
HSHLEN==:2*JOBMAX		;SIZE OF HASH TABLE
HSHTAB::	BLOCK HSHLEN

	ENQBIT==JOBMAX/^D36+1	;NUMBER OF WORDS IN ENQ JOB BIT MAP
ENQZER::			;START OF ENQ AREA TO BE ZEROED
ENQTBC:: BLOCK	ENQBIT		;ENQ JOBS TO BE CHECKED BIT MAP
ENQHBC:: BLOCK	ENQBIT		;ENQ JOBS HAVE BEEN CHECKED BIT MAP
ENQEZR=:.-1			;LAST WORD OF ENQ AREA TO BE ZEROED
ENQBLT:: XWD ENQZER,ENQZER+1	;BLT POINTER TO ZERO BIT TABLES
ENQPTR:: XWD	-ENQBIT,0	;ENQ AOBJN POINTER TO ENQTBC BIT MAP

	EXTERN	QUESER



.EQTAB::
%ENQML:: EXP EQMXCH##		;MAXIMUM WORD SIZE OF STRING
%ENQNQ:: Z			;NUMBER OF ACTIVE QUEUES
%ENQTE:: Z			;TOTAL NUMBER OF ENQ'S SINCE RELOAD
%ENQTD:: Z			;TOTAL NUMBER OF DEQ'S SINCE RELOAD
%ENQNP:: Z			;NUMBER OF ACTIVE POOLED RESOURCES
%ENQDF:: EXP M.ENQD		;DEFAULT ENQ QUOTA
%ENQMM:: EXP EQMXMW##		;PIE-SLICE-LOCK MAX BLOCK SIZE
%ENQMT:: EXP EQMXTB##		;LOCK-ASSOCIATED TABLE MAX SIZE
%ENQLT:: EXP EQMLTL##		;MINUTES LONG TERM LOCKS STAY AROUND
%ENQDD:: Z			;NUMBER OF DEADLOCKS DETECTED
%ENQTO:: Z			;NUMBER OF TIMEOUTS
%ENQMQ:: EXP M.ENQM		;MAXIMUM NUMBER OF ACTIVE QUEUES


ENQMXL==:<.-.EQTAB-1>B26	;FOR GETTAB

>>;END OF IFN FTEQDQ CONDITIONAL


IFE M.EQDQ,<
XP	ENQ,CPOPJ
XP	DEQ,CPOPJ
XP	ENQC,CPOPJ		;MAKE ALL OF THESE GIVE ERROR RETURNS
XP	ENQRST,CPOPJ		;RESET
XP	ENQCLS,CPOPJ1		;CLOSE
XP	ENQMIN,CPOPJ		;ENQ/DEQ ONCE A MINUTE
XP	ENQMXL,0
XP	ENQTAB,0
XP	.EQTAB,0
XP	HSHTAB,0
XP	HSHLEN,0
XP	ENQSDT,CPOPJ		;ENQ/DEQ SET DAYTIME FIX UP
XP	ENQNDR,CPOPJ1		;ENQ/DEQ NO DELETE ON RESET CHECK
XP	ENQINI,CPOPJ		;ENQ/DEQ INITIALIZATION
>;END OF IFE M.EQDQ CONDITIONAL


IFE FTEQDQ,<
IFN M.EQDQ,<

PRINTX	?PLEASE ASSEMBLE SOURCES WITH FTEQDQ=-1

>>
;PSISER SYMBOLS

	$HIGH

IFN M.PSI,<
IFE FTPI,<PRINTX ?ASSEMBLE WITH FTPI==-1>
IFN FTPI,<EXTERN PSIAPR,PSISER,PSIMVO,PSIMPI,PITSIZ>
NOPISK::SKIPE	JBTPIA(J)	;SKIP IF USER IS NOT ENABLED FOR TRAPS
OKSGNL::SKIPN	JBTPIA(J)	;SKIP IF USER IS ENABLED FOR TRAPS
PINOJN::SKIPGE	JBTPIA(J)	;SKIP IF CANNOT GRANT AN INTERRUPT
> ;END M.PSI
IFE M.PSI,<
	XP	PSIMVO,0
	XP	PSIMPI,0
	XP	PITSIZ,0	;DUMMY CODE
PSIIVR::
PSIIVA::SETZ	T1,		;NOTHING TO TELL PFH
	POPJ	P,
PINOJN::			;CAN NEVER GRANT AN INTERRUPT
NOPISK::CAIA			;NOBODY EVER ENABLED
OKSGNL::CAI			;...
PSITST==:CPOPJ			;...
PSIERR==:CPOPJ2			;ALWAYS STOP THE JOB
USREIJ==:CPOPJ1			;...
PSIJBI==:CPOPJ1			;...
PSIIOD==:CPOPJ			;NO DEVICE INTERRUPTS
PSIIDN==:CPOPJ			;...
PSIONL==:CPOPJ			;...
PSIODN==:CPOPJ			;...
PSIDWN==:CPOPJ			;...
PSIEDN==:CPOPJ			;...
PSIDVB==:CPOPJ			;...
PISYS==:CPOPJ			;UUOS FAIL
PIINI==:CPOPJ			;...
PIRST==:CPOPJ			;...
PISAVE==:CPOPJ			;...
DEBRK==:CPOPJ			;...
PIJOB==:CPOPJ			;...
PITMR==:CPOPJ			;...
PIBLK==:CPOPJ			;...
PSINTC==:CPOPJ			;NO NETWORK INTERRUPTS
PSIDVT==:CPOPJ			;NO DECNET EVENTS
APPSI==:CPOPJ			;NO APR TRAPS
PSIAPR==:ILLTIN##		;...
ANYUUO==:CPOPJ			;NO UUO TRAPS
CLRPSI==:CPOPJ			;NOTHING TO CLEAR
PSIRMV==:CPOPJ			;NOTHING TO REMOVE
PSIGEN==:CPOPJ			;NOTHING TO GRANT
PSICND==:CPOPJ			;NOTHING TO SIGNAL
PSIKSY==:CPOPJ			;NO KSYS INTERRUPTS
PSISDT==:CPOPJ			;NO DATE/TIME INTERRUPTS
> ;END M.PSI

	$ABS

;TABLE OF MAPPINGS FROM 2-CHARACTER DEVICE NAMES
; TO 3-CHARACTER NAMES. EACH 2-CHAR NAME IS IN
; RIGHT OF WORD AND 3-CHAR EQUIVALENT IS
; IN LEFT HALF.
;

	$HIGH
SPCTAB::XWD	'LPT','LP '	;LINE PRINTER
	XWD	'CDP','CP '	;CARD PUNCH
	XWD	'CDR','CR '	;CARD READER
	XWD	'PTP','PP '	;PAPER-TAPE PUNCH
	XWD	'PTR','PR '	;PAPER-TAPE READER
	XWD	'SYS','SY '	;SYSTEM DEVICE
	XWD	'TTY','TT '	;TELETYPE

STEND==:.
STLEN==:STEND-SPCTAB

;TABLE OF GENERIC DEVICE NAMES USED TO SPEED UP
; GENERIC DEVICE SEARCH
;
;THE LEFT HALF OF EACH WORD IS THE SIXBIT GENERIC DEVICE NAME.
;THE RIGHT HALF IS A PTR TO THE 1ST DDB OF THAT TYPE OF DEVICE.
;SINCE THE DDB'S ARE SORTED BY SYSINI, THIS REDUCES THE AMOUNT
; OF TIME NEEDED TO SEARCH FOR A PARTICULAR DEVICE NAME.

DEFINE GNRIC(DEV,SYM),<
	IFNDEF	M.R'DEV,<M.R'DEV==0>	;DEFINE REMOTE DEVICES
	IFN	M.'DEV+M.R'DEV+SYM,<
;	XLIST
	SIXBIT	/DEV/
;	LIST
	>>

DEFINE TGNRIC (X),<<SIXBIT /MTA/>+X_^D18>

DEFINE	DGNRIC(X),<
	GNRIC	DT'X
>
TAPCNT==TAPN

	$ABS
GENTAB::
IFN TAPN,<
	..KON==0
	REPEAT	TAPCNT,<TGNRIC (\..KON)
		     ..KON==..KON+1>
	>
ZZ=="A"
REPEAT M.TD10,<
	DGNRIC(\"ZZ)
ZZ==ZZ+1
>
	GNRIC(LPT,M.DLP) ;LINE PRINTER
	GNRIC(PTP)	;PAPER-TAPE PUNCH
	GNRIC(PTR)	;  "     "  READER
	GNRIC(PLT)	;PLOTTER
	GNRIC(PTY)	;PSEUDO-TTY
	GNRIC(CDP)	;CARD PUNCH
	GNRIC(CDR,M.DCR) ;CARD READER
IFN M.DAS78,<		;IF DAS78 SUPPORT
	GNRIC(XXI)	;XXI DEVICE
	GNRIC(XXO)	;XXO DEVICE
> ;END IFN M.DAS78

IFN FTCIMP,<		;[arpa]
	GNRIC(IMP)	;[arpa] IMP - ARPA DEVICES
>			;[arpa]

GTLEN==:GTEND-GENTAB
GTEND::
;DATA BASE TO LIMIT THE NUMBER OF STOPCD'S PER UNIT TIME SO THAT
;WE DON'T KEEP GETTING "CONTINUABLE" STOPCD'S THAT REALLY AREN'T.
;THE DATA BASE CONSISTS OF TWO TABLES, SCCTAB AND SCLTAB.  SCCTAB
;IS THE COUNT OF THE NUMBER OF STOPCD'S PROCESSED DURING THE PERIOD
;INDICATED BY THE OFFSET IT THE TABLE.  SCLTAB CONTAINS, IN THE
;LEFT HALF, THE PERIOD FOR THIS ENTRY AND, IN THE RIGHT HALF, THE
;LIMIT FOR THE NUMBER OF STOPCD'S DURING THE PERIOD.  BOTH TABLES
;MUST BE ORDERED SUCH THAT THE PERIOD OF EACH ENTRY IS MONOTONICALLY
;INCREASING.  THE LIMITS FOR EACH PERIOD ARE CHANGABLE VIA THE MONGEN
;DIALOG AND MAY BE CHANGED BY THE CUSTOMER.  WHEN A STOPCD IS PROCESSED
;BY DIE, STCLIM INCREMENTS THE COUNTS OF STOPCD'S FOR EACH ENTRY
;AND COMPARES EACH WITH THE LIMIT FOR THE ENTRY.  IF A LIMIT HAS BEEN
;EXCEEDED, DIE TURNS THE CONTINUABLE STOPCD INTO A STOP STOPCD.  IF
;NO LIMIT HAS BEEN EXCEEDED, STCLIM PUTS IN A CLOCK REQUEST TO CALL
;DECSCC AFTER THE PERIOD OF THE LOWEST ENTRY IN THE TABLE.  DECSCC
;DECREMENTS THE COUNT OF STOPCDS FOR THIS ENTRY AND PUTS IN A CLOCK
;REQUEST TO DECREMENT THE NEXT HIGHER COUNT.  THIS CONTINUES UNTIL ALL
;HAVE BEEN DECREMENTED. NOTE, THAT SINCE THE CLOCK QUEUE IS USED TO
;DECREMENT THE STOPCD COUNTS, THE PERIOD OF THE LARGEST ENTRY CANNOT
;BE LARGER THAN 2**18-1 TICKS.


SCCTAB::EXP	0		;1 MINUTE COUNT OF STOPCD'S
	EXP	0		;8 MINUTE COUNT OF STOPCD'S
	EXP	0		;1 HOUR COUNT OF STOPCD'S
SCCTBL==:.-SCCTAB		;LENGTH OF TABLE


SCLTAB::XWD	^D60,  LIM1MS	;PERIOD:=1 MINUTE, LIMIT:=LIM1MS
	XWD	^D480, LIM8MS	;PERIOD:=8 MINUTES, LIMIT:=LIM8MS
	XWD	^D3600,LIM1HS	;PERIOD:=1 HOUR, LIMIT:=LIM1HS

;GALAXY-10 PARAMETERS

DEFINE GPARM(Z1),<
IFE Z1,<
ZGAL==0
>>

ZGAL==1
GPARM(M.IPCF)
GPARM(M.PSI)
GPARM(M.PTY)
GPARM(FTSPL)
IFN	FTIPCF,<
	IFN	M.IPCF,<
IFG ^D10-%IPMPL,<ZGAL==0>
>>

;DEFINE IPCF SYMBOLS IF NOT AROUND
IFE FTIPCF,<
	XP	QSRSPL,CPOPJ
>

	$HIGH
IFN FTSPL,<
;TABLE FOR SPOOLING DEVICES
SPLNAM==:0			;NAME OF SPOOLING DEVICE
SPLBIT==:2			;SPOOLING BIT
SPLLEN==:DEVMOD+1		;LENGTH OF EACH ENTRY
;NOTE THAT WORD 1 (DEVCHR) MUST BE 0
SPLTAB::SIXBIT	.LPT.
	0
	XWD	.TYLPT/.TYEST,.SPLPT
	0			;NO REAL DEVSER
LPTMOD==1_A+1_AL+1_I
	XWD	DVOUT+DVLPT,ASSCON!ASSPRG!LPTMOD
	SIXBIT	.PLT.
	0
	XWD	.TYPLT/.TYEST,.SPPLT
	0
	XWD	DVOUT,ASSCON!ASSPRG!14403
	SIXBIT	.CDP.
	0
	XWD	.TYCDP/.TYEST,.SPCDP
	0
	XWD	DVOUT+DVCDR,ASSCON!ASSPRG!14403
	SIXBIT	.PTP.
	0
	XWD	.TYPTP/.TYEST,.SPPTP
	0
	XWD	DVOUT+DVPTP,ASSCON!ASSPRG!14403
	SIXBIT	.CDR.
	0
	XWD	.TYCDR/.TYEST,.SPCDR
	0
SPLTOP::XWD	DVIN+DVCDR,ASSCON!ASSPRG!14403
>
	$ABS
SUBTTL	CPU START-UP CODE

SYSTRT::EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JRST	SYSINI##	;BOOT CPU
IFG <CPUN-1>,<
	JRST	SPRINI		;NON-BOOT CPU
>
IFLE <CPUN-1>,<
	HALT	.		;ATTEMPT TO START NON-BOOT CPU WITH A SINGLE CPU MONITOR
>
;SUBROUTINE TO SEE WHICH CPU THIS IS (CALLED ON SYSTEM
; STARTUP AND POWER FAIL AUTO-RESTART)
;CALLING SEQUENCE:
;	JSP	T4,SYSTR0
;	RETURN HERE IF BOOT CPU
;	RETURN HERE IF NON-BOOT CPU
SYSTR0::TLO	T4,(IC.UOU)	;TURN ON USRIOT FOR RETURN
IFN M.KL10,<
	CONO	APR,LP.CSF!LP.CSD
	DATAI	CCA,		;INVALIDATE CACHE, NOT VALIDATING CORE
	CONSO	APR,LP.CSD
	JRST	.-1
	CONO	APR,LP.CSF!LP.CSD
>
IFN M.KS10,<
	RDUBR	T2		;INVALIDATE CACHE
	WRUBR	T2
>
SYSTR1::
IFN FTKI10,<
	CONI	PAG,T1		;READ THIS CPU'S SERIAL NUMBER
	LSH	T1,-^D26	;RIGHT ADJUST IT
>
IFN FTKL10,<
	APRID	T1		;READ APR SERIAL #
	ANDI	T1,7777		;JUST SERIAL # BITS
>
IFN FTKS10,<
	APRID	T1		;READ APR SERIAL #
	ANDI	T1,77777	;JUST SERIAL BITS
>
IFN FTMP,<
	AOSE	INTRST
	LSTALL
>
	MOVEI	T2,.C0CDB
SYSTR3:	CAME	T1,.CPASN-.CPCDB(T2)
	JRST	SYSTR5
SYSTR4:	MOVE	T1,T2
	LSH	T1,W2PLSH
	MOVE	T3,.CPMAP-.CPCDB(T2)
	SETOM	.CPOCB-.CPCDB(T2)

;MAP THE FIRST (AND POSSIBLY ONLY) PAGE OF THE CDB AT .ESKPC

IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT(T1)
IFE <CPUN-1>,<
IFN M.KL10!M.KS10,<
	TRO	T1,PM.CSH
>>
	HRLM	T1,.MSKPC(T3)
>
IFN FTKLP,<
	HRLI	T1,(<PM.DCD>B2+PM.WRT)
	MOVEM	T1,.ESKPC/PAGSIZ(T3)
>

IFN <RHWEVM-^D3>,<IFN <RHWEVM-^D4>,<PRINTX ?RHWEVM IS SET TO AN UNKNOWN VALUE>>
;CODE BELOW IS TO MAP SECOND PAGE OF CDB IN THE .CP AREA
;RHWEVM IS CURRENTLY ONLY 3 OR 4, MEANING 1 OR 2 PAGE CDB. WHENEVER
;A CBD GOES OVER 2 PAGES, MORE CODE WILL HAVE TO BE ADDED HERE.

IFG <RHWEVM-^D3>,<
	AOS	T1
IFE FTKLP,<
	HRRM	T1,.MSKPC(T3)
> ;END IFE FTKLP
IFN FTKLP,<
	MOVEM	T1,.ESKPC/PAGSIZ+1(T3)
> ;END IFN FTKLP
> ;END IFG RHWEVM-^D3
IFN FTKLP,<
	XJRSTF	[EXP XC.UOU,.+1]	;SET PRVIOUS CONTEXT USER, PCS =0
	DATAO	PAG,[1B0+0B8+6B11]	;SET AC SET TO 0, PREVIOUS CONTEXT AC 6
	MOVSI	0,[EXP 0,-1,0]		;NO CST UPDATE
	EXCTXU	<BLT 0,2>		;SET LOCATIONS IN AC SET 6, FOR CSTS
	MOVEI	0,.CPSPT-.CPCDB(T2)	;MAKE A POINTER TO THE SPT FOR THIS CPU
	EXCTXU	<MOVEM 0,3>		;SET IT UP IN AC SET 6 LOCATION 3
	EXECAC				;FINISH UP.
	MOVE	0,.CPSPT-.CPCDB(T2)	;GET VALUE OF .CPSPT
	MOVEM	0,.CPXPT-.CPCDB(T2)	;SAVE WHERE REBOOT CAN FIND IT LATER
	MOVEI	0,NLUPMP/PAGSIZ		;ESTABLISH AN SPT
	MOVEM	0,.CPSPT-.CPCDB(T2)
> ;END IFN FTKLP

IFN M.KI10,<
	DATAO	PAG,.CPEBR-.CPCDB(T2)
	DATAO	PAG,NULDOP
>
IFN M.KL10,<
	CONO	PAG,@.CPEBR-.CPCDB(T2)
	DATAO	PAG,NULDOP	;SETUP UBR TO
				; NULL JOB'S UPT SO THAT MUUO'S, ACCOUNTING
				; METERS, EXEC PAGE FAILS DURING ONCE ONLY
				; WORK CORRECTLY. INHIBIT ACCOUNTING STORE
>
IFN M.KS10,<
	WREBR	0		;DO THIS IN CASE POWER UP. KS10 MICRO-CODE V111
				; HAS BUG THAT WILL CAUSE BOGUS PAR ERR
				; IF THIS ISN'T DONE
	WREBR	@.CPEBR-.CPCDB(T2) ;SET UP EXEC BASE REGISTER
	WRUBR	NULDOP		;SET UP USER BASE REGISTER TO NULL JOB
				; SO THAT MUUO'S & PAGE FAILS WORK DURING ONCE
	MOVEI	T1,.EPHSB	;SET UP HALT STATUS BLOCK
	WRHSB	T1		; DUMP ADDRESS
>
IFG <CPUN-1>,<
	MOVE	T2,BOOTWD
IFN M.KI10,<
	LSH	T2,-^D26	;GET S/N OF CPU WHICH BOOTS WAS EXECUTED ON
>
IFN M.KL10,<
	ANDI	T2,7777		;CLEAR ALL BUT SERIAL NUMBER
>
	SKIPGE	BOOTCP		;IS THERE ALREADY SOMEBODY AS THE BOOT CPU
	CAME	T2,.CPASN	;SAME AS THE CURRENT CPU?
	AOJA	T4,SYSTR2	;NO, THIS MUST BE CPU1
>
IFE <CPUN-1>,<
	MOVE	T2,.CPASN
>
	MOVEM	T2,SERIAL	;STORE FOR SECOND GETTAB
	MOVE	T1,.CPCPN	;OUR CPU NUMBER
	MOVEM	T1,BOOTCP	;NOBODY ELSE DURING SYSTEM STARTUP
IFN M.KL10!M.KS10,<
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT+NUPMPP	;SET UP FOR NULL JOB'S MAPPING
	HRLM	T1,NLUPMP+.MUPMP	;FOR .UPMP ADDRESSES DURING SYSINI
>
IFN FTKLP,<
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
	MOVEM	T1,NLUPMP+.UPMP/PAGSIZ
>
>
SYSTR2:
IFN FTMP,<
	SETOM	INTRST
>
	JRSTF	@T4		;DO CPU1 INITIALIZATION
SYSTR5:	HLRZ	T2,.CPCDB-.CPCDB(T2)
	JUMPN	T2,SYSTR3
	MOVEI	T2,.C0CDB
SYSTR6:	SKIPE	.CPOCB-.CPCDB(T2)
	JRST	SYSTR7
	MOVEM	T1,.CPASN-.CPCDB(T2)
	JRST	SYSTR4
SYSTR7:	HLRZ	T2,.CPCDB-.CPCDB(T2)
	JUMPN	T2,SYSTR6
IFN FTMP,<
	SETOM	INTRST
>
	HALT	.



APRRES::				;HERE ON TO RESTART
IFE FTMP,<
IFN M.KI10,<
	DATAO	PAG,.C0EBR
>
IFN M.KL10,<
	CONO	PAG,@.C0EBR
>
IFN M.KS10,<
	WREBR	@.C0EBR
>
	JRSTF	@[IC.UOU+AP0RES]
>;END IFE FTMP
IFN FTMP,<
	EXECAC
	JSP	T4,SYSTR0
IFG CPUN-1,<
	  JFCL
>
	XCT	.CPRES
>;END IFN FTMP

;HERE ON A RESTART AFTER SYSTEM SLEEP, REBOOT

SYSRST::EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;ALWAYS RESTART VIA SPRINI
	SETZM	MBTCOM		;MAKE SURE THAT DUMPED CRASHES DON'T LOOK REBOOTABLE
	SETZM	BOOTSA		;ZERO ADDRESS OF BOOTS/MONBTS SO WE DON'T JUMP TO EDDT
IFN FTKL10,<
	JSR	ZAPRH2		;MAKE SURE RH20S ARE IN A REASONABLE STATE
>;END IFN FTKL10
	MOVSI	T1,(CR.TSS)	;SUCCESSFUL DUMP BIT
	ANDCAB	T1,.CPRUN	;CLEAR THAT BECAUSE IT MUST HAVE BEEN OR WE WOULDN'T BE HERE
IFG <CPUN-1>,<
	TLNN	T1,(CR.RMV!CR.DET)	;REMOVED OR DETACHED CPU?
	JRST	SPRINI		;NO, REINITIALIZE
	MOVE	P,.CPNPD	;ANY OLD PUSH DOWN LIST WILL DO
	MOVEI	T1,[ASCIZ/?CPU removed.
/]
	PUSHJ	P,CTYTYP##	;EXPLAIN THE ERROR
	PUSHJ	P,RMVCPU##	;AND GO AWAY
>
;FALL INTO SPRINI ON SINGLE CPU SYSTEMS
SUBTTL INITIALIZATION ON STARTUP/RESTART AFTER SYSTEM SLEEP
;NON-BOOT PROCESSOR INITIALIZATION. REINITIALZATION FOR ALL CPUS
; AFTER SYSTEM SLEEP

SPRINI::CONO	PI,CLRPIS	;CLEAR PI AND PARITY ERROR FLAG
	CONO	APR,APRRST	;RESET EVERYTHING AND ENABLE CLOCK
IFN FTKL10,<
	EXECAC			;MAKE SURE AC BLOCKS ARE OK
>
	MOVSI	P,(CR.RMV!CR.DET) ;"CPU IS DOWN" OR "DETACHED" BITS
	TDNE	P,.CPRUN	;CAN THIS CPU RUN YET
	JRST	.-1		;NO, WAIT UNTIL IT CAN
	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
IFN FTKL10,<
	MOVE	T1,.CPCPN
	PUSHJ	P,DTEINI##
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL
>;END IFN FTKL10
IFG <CPUN-1>,<
	PUSHJ	P,PRTCPU##	;TELL OPR WHO WE ARE
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT RATHER THAT START OR RESTART?
	JRST	SPRIN1		;YES, DON'T WAIT FOR A BOOT CPU TO COME TO LIFE
	MOVE	12,[XWD ACLOOP##,2] ;LOAD AC'S WITH WAIT LOOP
	BLT	12,12		;CPU1 WILL WAIT UNTIL CPU0 IS GOING
	MOVE	12,[JRST SPRIN1] ;SET UP RETURN INSTRUCTION
	JRST	2		;ENTER LOOP

;INITIALIZE PD LIST
SPRIN1:	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
IFE FTKLP,<
	MOVE	T1,.CPMAP	;SAVE FIRST SLOT IN CPU1'S MAP TEMPORARRILY
	PUSH	P,.E0PM-.E0MP(T1) ;MAPINI CLOBBERS THIS
>;End IFE FTKLP
	PUSHJ	P,MAPINI##	;COPY THE BOOT CPU'S MAP INTO THE CURRENT CPU'S MAP

IFN FTKL10,<
	MOVEI	T1,LG.CSL!LG.CSW;CACHE STRATEGY LOOK, CACHE STRATEGY LOAD
	IORM	T1,.CPEBR	;MAKE SURE CURRENT CPU'S CACHE IS ON
>
	JRSTF	@[EXP IC.UOU+.+1] ;TURN ON USER IOT SO EXECUTE PAGED WORKS
				; CORRECTLY AND PROCEED WITH INITIALIZATION
	CLRPGT	(1)
	CONO	PI,10000	;AND CLEAR PI SYSTEM
IFE FTKLP,<
	MOVE	T1,.CPMAP	;RESTORE CONTENTS OF CPU1 EXEC MAP SLOT 0
	POP	P,.E0PM-.E0MP(T1) ;FALL INTO SPRIN2
>;End IFE FTKLP
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT?
	JRST	SPRIN5		;YES, DISKS ARE INITIALIZED
IFN FTAUTC,<
	PUSHJ	P,AUTCON##	;GO SEE WHAT DISKS, TAPES WE CAN TALK TO
>
SPRIN2:	MOVE	17,[ONCLOP##,,1] ;WAIT IN ACS FOR CPU0 TO REQUEST IO
	BLT	17,16		; DO IT (AT SPRIN3) WHEN REQUESTED
	SJSP	0,3
;HERE FROM LOOP IN THE ACS TO DO DISK I/O DURING ONCE-ONLY ON NON-BOOT CPUS
SPROIO::
SPRIN3:	MOVE	P,.CPNPD	;SET UP A PDL
	SKIPN	T1,ONCCOM	;WHAT CPU0 WANTS US TO DO
	JRST	SPRIN2		;NOTHING TO DO
	AOJE	T1,SPRIN2	;RESTARTED IF -1
	SOS	F,T1		;COMM WORD INTO F
	SOJE	T1,SPRIN5	;DONE IF +1
	PUSHJ	P,MAPINI##	;SOME OTHER NON BOOT CPU MAY
				; HAVE CHANGED MAPS
	PUSHJ	P,CPUDSP##	;GO DO SOME WORK
	JRST	SPRIN2		;AND WAIT SOME MORE
;HERE TO SET UP TO RUN NULL JOB, & SETUP PI
SPRIN5:	PUSHJ	P,MAPINI##
IFN FTKL10,<
	PUSHJ	P,CSDMP##	;ONCE ONLY/FILSER MAY HAVE DRAGGED
				; SOMETHING INTO THE CACHE
>
>
	MOVEI	T1,CCTYO##	;GET ADDRESS OF TYPEOUT ROUTINE
	MOVEM	T1,.CPTOA	; AND TELL SCNSER
	MOVEI	T1,COMTIV##	;GET ADDRESS OF COMMAND INPUT ROUTINES
	MOVEM	T1,.CPTIV	; AND TELL SCNSER TO USE LDB'S NOW.
	SETZM	.CPTNT		;JUST STARTING
	MOVE	J,.CPCPN	; FOR THIS CPU
	SETZM	CLKMIN(J)	;CLEAR MIN REQUEST
IFN FTMP,<
	SETOM	.CPSCD		;CLEAR SCHED NESTING
	SETZM	.CPNBI		;CLEAR NUMBER OF BROKEN INTERLOCKS
	SETOM	.CPDLK		;CLEAR DSKOFF NESTING
>;END IFN FTMP
	SETOM	.CPDWD		;GIVE UP DIE RECURSION INTERLOCK
	SETZM	.CPAEF		;CLEAR CPU ERROR/SWEEP FLAGS
	HRRZS	.CPMPC		;CLEAR SERIOUS MEMORY PARITY HALT FLAG
				; HALT AFTER PRINTING ON CPU0 CTY
	MOVE	T1,TIME		;GET CURRENT TIME
	MOVEM	T1,.CPTML	;STORE FOR TICKS GONE BY
	MOVE	T2,TICSEC	;TICK PER SECOND
	LSH	T2,-1		;DIVIDE BY 2
	ADD	T1,T2		;AND ROUND
	IDIV	T1,TICMIN	;T2 = PARTIAL MINUTE (IN TICKS)
	IDIV	T2,TICSEC	;T2 = SECONDS, T3 = REMAINDER IN TICKS
	SUBI	T2,^D60		;COMPUTE TIME TO NEXT MINUTE
	MOVNM	T2,.CPSEC	;STORE FOR ONCE-A-MINUTE UPDATE
	SUB	T3,TICSEC	;TIME TO NEXT SECOND
	MOVNM	T3,.CPHTM	;STORE FOR ONCE-A-SECOND UPDATE
	MOVEI	T1,SR.STS!SR.DIE!SR.ACL ;CLEAR THESE BITS WHEN WE
	ANDCAM	T1,.CPSBR	; RESTART THE PROCESSOR
IFG <CPUN-1>,<
	MOVEI	J,JOBMAX	;MAX JOB NO.
	MOVSI	T1,(SP.CJ0)	;JOB RUNNING ON CPU1 BIT
	LSH	T1,@.CPCPN
SPRLP1:	ANDCAM	T1,JBTSPS(J)	;CLEAR FOR ALL JOB IN SYSTEM
				; (IN CASE THIS IS A 450 RESTART ON CPU1)
	SOJGE	J,SPRLP1	;MORE?
>
IFN FTKL10,<
	APRID	T3		;PROCESSOR HARDWARE OPTIONS
	DMOVE	T1,[M.EBPS	;ASSUME A MODEL A PROCESSOR
		M.MBPS]
	TRNE	T3,ID.XKL	;IS IT A MODEL B PROCESSOR?
	DMOVE	T1,[^D30*M.EBPS/^D25 ;YES, USE DIFFERENT EBOX/MBOX CALABRATION CONSTANTS
		^D30*M.MBPS/^D25]
	MOVEM	T1,.CPEBS	;STORE AS EBOX TICS/SEC
	MOVEM	T2,.CPMBS	;STORE AS MBOX TICS/SEC
	IDIV	T1,TICSEC	;AND NOW GET EBOX COUNTS/JIFFY
	IMULI	T1,.EBCPT	;MULTIPLY BY EBOX COUNTS/TICK
	MOVEM	T1,.CPEBJ	;STORE IN CDB VARIABLE
	MOVE	T1,.CPMBS	;GET MBOX TICKS/SECOND
	IDIV	T1,TICSEC	;GET MBOX COUNTS/JIFFY
	IMULI	T1,.MBCPT	;MULTIPLY BY MBOX COUNTS/TICK
	MOVEM	T1,.CPMBJ	;SAVE
	PUSHJ	P,SETCLK	;SETUP CLOCKS, PI, APR
IFN FTKS10,<
	PUSHJ	P,UBAPIS	;MAKE SURE UBA'S HAVE A PIA
>
IFN FTKL10,<
	PUSHJ	P,RNXSAK##	;INSURE ALL RP20 DX20'S ARE RUNNING
>
	HLRZ	U,SYSUNI##	;FIRST UNIT IN THE SYSTEM
	MOVN	J,TICSEC	;AVOID BRKLOK
	MOVEM	J,.CPOK		;CALLS BY THE BOOT CPU
IFN FTMP,<
IFG	M.CPU-1,<
	CPLOCK	(SCD)	;CROCK TO INSURE MC AVAILABLE
>
	SKIPL	MCREQ##	; BEFORE CALL TO ATTCPD
IFG	M.CPU-1,<
	JRST	[CPUNLK (SCD)
                 JRST .-2]
>
IFLE	M.CPU-1,<
	  JRST	.-1
>
SPRIN7:	HRRZ	J,UNIKON##(U)	;KONTROLLER DATA BLOCK
	LDB	T1,KOYCPU##	;CPU THIS CONTROLLER LIVES ON
	CAME	T1,.CPCPN	;CURRENT CPU?
	JRST	SPRIN8		;NO, ONWARD AND UPWARD
	PUSHJ	P,ATTCPD##	;YES, ATTACH THE UNIT
	  JFCL			;DON'T CARE
	  JFCL			;THIS ONE EITHER
SPRIN8:	HLRZ	U,UNISYS##(U)	;NEXT UNIT IN THE SYSTEM
	JUMPN	U,SPRIN7	;GO IF NOT THE LAST
IFG	M.CPU-1,<
	CPUNLK	(SCD)
>
>
	SETZB	S,P1		;ALWAYS CALL INI ROUTINE ONCE
	HLRZ	P3,HNGLST	;LOOK ONLY AT REAL HARDWARE
SPRIN9:	MOVE	F,P3		;SETUP F FOR INI CODE
	MOVE	P3,DEVSER(P3)	;ADDRESS OF DEVICE DISPATCH VECTOR
IFN FTMP,<
	LDB	T1,DEYCPF	;CPU OWNING THE DEVICE
	CAMN	T1,.CPCPN	;CURRENT CPU?
>;END IFN FTMP
	CAIN	P1,(P3)		;YES, ALREADY CALLED INI ROUTINE?
	JRST	SPRI10		;YES, SKIP ON
	MOVSI	T1,DVMTA	;SPECIAL CHECK FOR MAGTAPE
	TDNN	T1,DEVMOD(F)	;ALWAYS DO INITIALIZATION FOR MAGTAPE
	SKIPN	.CPAID		; (SEE TPMINI) OR IF OTHER DEVICES
	CAIA			; HAVEN'T BEEN INITIALIZED YET
	JRST	SPRI10		; OTHERWISE SKIP ON
	PUSHJ	P,DINI(P3)	;NO, CALL INI ROUTINE
	  HRRZ	P1,P3		;NEEDN'T CALL IT AGAIN
SPRI10:	HLRZS	P3		;NEXT DDB
	JUMPN	P3,SPRIN9	;LOOP IF THERE IS ONE
IFN FTAUTC&FTMP,<
	PUSHJ	P,T1CINI##	;MARK PAGTAB SO DX10 DATA BASE WILL NEVER BE UNCACHED
>
IFN FTKL10,<
PPCPT1::PUSHJ	P,STAPPC##	;PATCH TO JFCL TO INHIBIT STARTING PRIMARY PROTOCOL
	  JFCL
>
IFN FTKS10,<
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE
>
	SETOM	.CPAID		;INDICATE DEVICES HAVE ALREADY BEEN INITIALIZED
	MOVSI	T1,(CR.SPD)	;SUPPENDED BIT
	TDNE	T1,.CPRUN	;RESTARTING AFTER SYSTEM SLEEP?
	PUSHJ	P,DSKRCL	;YES, GENERATE A FREE INTERRUPT FROM ALL DSKS
				; SO FILIO WILL REREAD THE HOME BLOCK AND
				; VERIFY THAT PACKS WEREN'T MOVED WHILE ASLEEP
	MOVSI	T1,(CR.SPD)	;SUPPENDED BIT
IFN FTNET,<
	TDNE	T1,.CPRUN	;IF RESTARTING,
	PUSHJ	P,FEKCPW##	; TELL THE FEK'S
>
	ANDCAM	T1,.CPRUN	;CLEAR IT SINCE RESUMING
IFG <CPUN-1>,<
	MOVE	J,.CPJOB	;IF A RESTART AND A JOB WAS RUNNING,
	SKIPE	JBTADR(J)	; AND HASN'T ALREADY BEEN ZAPPED,
	PUSHJ	P,CPUZAP##	; ZAP IT AND INFORM THE USER
	SETZM	.CPJOB		;NO PREVIOUS JOB
	SETZM	.CPDRQ		;NO MORE DISKS TO RESCUE
>
	SJSP	U,NULJB1	;GO START NULL JOB
SETCLK:
IFN FTEMRT,<
	PUSHJ	P,ACCMON##	;START UP ACCOUNTING METERS
	PUSHJ	P,CLREMB##	;CLEAR OUT E AND MBOX ACCOUNTING METERS
>;END IFN FTEMRT
>;END IFN FTKL10
	PUSHJ	P,SETIME	;TO INITILIZE 'GGTIME' CLOCK (IN SYSINI)
IFN FTKL10,<
	CONI	MTR,T1		;PRESERVE TIME BASE INFO
	CONO	MTR,APRCHN(T1)	;SETUP INTERVAL TIMER PI
IFG <CPUN-1>,<
	MOVE	T1,BOOTCP	;BOOT CPU
	MOVSI	T2,40000	;SUPPENDED BIT
	TDNN	T2,.CPRUN	;THERE MIGHT NOT BE A BOOT CPU AFTER A REBOOT
	CAMN	T1,.CPCPN	;ALSO COULD BE THE BOOT - WARM RESTART
	JRST	SETCL1		; SO DON'T WAIT ON IT
	LSH	T1,.CPSOF	;OFFSET TO ITS CDB
	SKIPE	T2,.C0TMF(T1)	;WAIT UNTIL CLOCK FLAG CLEARS, ZERO T2
	JRST	.-1
	SKIPN	.C0TMF(T1)	;TIME FROM SET UNTIL SET
	JRST	.-1
	SKIPE	.C0TMF(T1)
	AOJA	T2,.-1
	SKIPN	.C0TMF(T1)
	AOJA	T2,.-1
	MOVE	T3,.CPCPN	;OUR CPU NUMBER
	SUB	T3,BOOTCP	; MINUS THE BOOT CPU NUMBER
	SKIPG	T3		;IF NEGATIVE, (NEVER EQUALS ZERO)
	ADDI	T3,CPUN		; MODULO THE NUMBER OF CPU'S
	IMULI	T2,(T3)
	IDIVI	T2,CPUN		;FRACTION OF A TIC TO WAIT
	SOJG	T2,.		; BEFORE STARTING THE CLOCK
>
SETCL1:	MOVEI	T1,^D1666	;ASSUME 60HZ
	MOVE	T2,STATES
	TLNE	T2,(ST.CYC)	;IS OUR ASSUMPTION CORRECT?
	MOVEI	T1,^D2000	;NO, 2000 IS INTERVAL
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT(T1)	;START TIMER GOING
>
IFN FTKI10,<	CTY==120	;DEVICE CODE FOR CTY
	CONO	CTY,1200+SCNCHN
>
	CONO	APR,APRNUL
	CONO	PI,PI.CPI!PI.TNP!PI.ON!II.ACO!IFE FTKS10,<PI.EPE>
				;TURN ON ALL PI, ENABLE MEMORY PARITY
	DATAO	PI,[EXP 10]	;FOO
IFN FTKI10,<
	SJSP	U,NULJB1
>;End IFN FTKI10
	POPJ	P,

;SUBROUTINE TO DO A RECAL ON EVERY DISK THAT THE SYSTEM KNOWS ABOUT
; THIS WILL CAUSE A FREE INTERRUPT TO BE GENERATED BY EACH DISK WHICH
; WILL CAUSE FILIO TO REREAD AND VERIFY HOME BLOCKS ON EVERY PACK
; CURRENTLY SPINNING. THUS IF SOME PACKS WERE REMOVED OR MOVED DURING
; THE SYSTEM SLEEP OR POWER FAIL, THE OPERATOR WILL BE COMPLAINED AT
; AND THERE WILL BE NO CHANCE OF COMPROMISING DATA INTEGRITY.

DSKRCL:	MOVEI	U,SYSUNI##-UNISYS## ;START AT FIRST UNIT ON SYSTEM
DSKRC1:	HLRZ	U,UNISYS##(U)	;NEXT UNIT
	JUMPE	U,CPOPJ		;DONE IF LAST UNIT
	HRRZ	J,UNIKON##(U)	;KONTROLLER THIS UNIT IS CONNECTED TO
	MOVSI	T1,U2PNRM##	;FIXED MEDIA BIT
IFG <CPUN-1>,<
	LDB	T2,KOYCPU##	;CPU THAT THIS KONTROLLER IS ON
	CAMN	T2,.CPCPN	;THIS CPU?
>
	TDNE	T1,UNIDS2##(U)	;AND NOT FIXED MEDIA (THAT BETTER NOT MOVE)
	JRST	DSKRC1		;NEXT UNIT IF NOT THE RIGHT CPU OR FIXED MEDIA
	SKIPN	UNISTS##(U)	;DON'T RECAL IF NOT IDLE (POWER FAIL)
	PUSHJ	P,@KONRCL##(J)	;RECALIBRATE SO WE WILL GET A FREE INTERRUPT AND
				; REREAD THE HOME BLOCKS IN CASE A PACK WAS MOVED
	  JFCL			;DON'T CARE IF OFF-LINE
	JRST	DSKRC1		;LOOK AT NEXT UNIT
SUBTTL	EXEC DATA VECTOR SETUP


; HERE TO SET UP SOME EXEC DATA VECTOR QUANTITIES.  THESE VARIABLES
; ARE REQUIRED TO SET UP PAGING SO THAT GETTAB AND JOBPEK UUOS MAY
; BE SIMULATED ON A MONITOR CRASH FILE.  THESE WORDS CONTAIN CPU
; DEPENDANT INFORMATION.  THE EXEC DATA VECTOR FOR THE BOOT CPU, NOT
; THE CRASHING CPU, WILL BE POINTED TO BY .JBEDV IN JOBDAT.  ON ALL
; SYSTEMS, .JBEDV IS SET UP AT SYSTEM STARTUP.  ON MULTI-CPU SYSTEMS,
; .JBEDV IS RESET ON EVERY ROLE SWITCH.  .JBEDV (AND THE CPU DEPENDANT
; EDVS) WILL REQUIRE ADDRESS FIXUPS IF A "SET MEMORY OFFLINE" COMMAND
; IS EXECUTED.  THIS BE BECAUSE THE EDVS CONTAIN PHYSICAL ADDRESSES.
;
SETEDV::PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;SAVE T2
	MOVEI	T1,EDVSET	;POINT TO SUBROUTINE
	PUSHJ	P,CPUAPP	;EXECUTE IT OVER ALL CPUS
IFN FTMP,<
	SKPCPU	(0)		;ARE WE THE BOOT CPU?
	JRST	TTPOPJ		;NO--JUST RETURN
>
	MOVEI	T1,.CPEDV	;POINT TO OUR EDV BLOCK
	PUSHJ	P,EDVMAP	;MAP THE ADDRESS
	MOVEM	T2,.JBEDV##	;STASH IT AWAY FOR CURIOUS PROGRAMS
	JRST	TTPOPJ		;RESTORE ACS AND RETURN

EDVSET:	HRRZ	T2,.CPTYP-.CPCDB(P1) ;GET DEC CPU TYPE CODE
IFN FTKL10!FTKS10,<
	APRID	T1		;READ SERIAL NUMBER
	TLNE	T1,(ID.T2P)	;KL PAGING?
	TLO	T2,(ED.KLP)	;YES
>
IFN FTKL10,<
	TRNE	T1,ID.XKL	;EXTENDED KL10?
	TLO	T2,(ED.XKL)	;YES
>
	MOVEM	T2,.CPEDV-.CPCDB+.EDDAT(P1)	;SAVE DATA
	MOVE	T1,.CPEPT-.CPCDB(P1)		;GET VIRTUAL ADDRESS OF OUR EPT
	PUSHJ	P,EDVMAP			;MAP PHYSICAL
	MOVEM	T2,.CPEDV-.CPCDB+.EDEPT(P1)	;SAVE IT

IFE FTKLP,<SETZ T2,>
IFN FTKLP,<
	MOVEI	T1,.CPSPT-.CPCDB(P1)		;GET VIRTUAL ADDRESS OF OUR SPT
	PUSHJ	P,EDVMAP			;MAP PHYSICAL
>
	MOVEM	T2,.CPEDV-.CPCDB+.EDSPT(P1)	;SAVE IT
	SETZM	.CPEDV-.CPCDB+.EDCST(P1)	;NO CST NONSENSE ON TOPS-10
	POPJ	P,		;RETURN

EDVMAP:	MAP	T2,(T1)		;CONVERT VIRTUAL ADDRESS TO PHYSICAL
IFN FTKI10,<
	ANDI	T1,PG.BDY	;KEEP OFFEST INTO THE PAGE
	ANDI	T2,17777	;KEEP JUST THE PAGE NUMBER
	LSH	T2,P2WLSH	;CONVERT PAGE NUMBER TO ADDRESS
	IOR	T2,T1		;COMPLETE IT
> ;END IF FTKI10
IFN FTKL10!FTKS10,<
	TLZ	T2,(777B8)	;STRIP OFF PAGE MAP FLAGS
>
	POPJ	P,		;RETURN

;DTE20 DEVICE CODES FROM DTEPRM.MAC

	DTE0==200
	DTE1==204
	DTE2==210
	DTE3==214

;RH20 DEVICE CODES

	RH2==540
	RH21==544
	RH22==550
	RH23==554
	RH24==560
	RH25==564
	RH26==570
	RH27==574

;OTHER DEVICES

	FHD2==174	;DEVICE CODE FOR SECOND FIXED HEAD CONTROLLER
	DPC==250	;DISK PACK CONTROL - NOT IN MACRO.SVE FOR SPMON
	DPC2==254	;DEVICE CODE FOR SECOND DISK PACK CONTROLLER
	DPC3==260
	DPC4==264
	DAS==324
	FSD==270
	FSD2==274
	FSD3==360
	DAC==320
	DBS==334
	DBC==330
	DLC==64
	DLC2==164
	DLB==60
	DLB2==160
	CDR2==154
	LPT2==234
	LPT3==230
	LPT3==230
	PLT2==144
	DX10==220
;SUBROUTINE TO STORE INFORMATION IN THE CPU STATUS BLOCK

CPUSTS::
IFN M.KL10!M.KS10,<
	APRID	.CPAPD		;(0) APRID

>;END IFN M.KL10
IFN M.KI10,<
	CONI	PAG,.CPAPD	;(0) APR SERIAL NUMBER

>;END IFN M.KI10
	CONI	APR,.CPACN	;(1) CONI APR,
	CONI	PI,.CPPIC	;(2) CONI PI,
	DATAI	PAG,.CPPGD	;(3) DATAI PAG,
	CONI	PAG,.CPPGC	;(4) CONI PAG,
	MOVE	T1,[.UPMP+.UPMUO,,.CPUP0] ;(5) UPT LOCS 424-427
	BLT	T1,.CPUP0+3
IFN M.KL10,<
	RDERA	.CPERA		;(11) RDERA
	CONI	RH2,.CPRHC	;(12) CONI RH20, FOR ALL 8 RH'S
	CONI	RH21,.CPRHC+1
	CONI	RH22,.CPRHC+2
	CONI	RH23,.CPRHC+3
	CONI	RH24,.CPRHC+4
	CONI	RH25,.CPRHC+5
	CONI	RH26,.CPRHC+6
	CONI	RH27,.CPRHC+7
	CONI	DTE0,.CPDTC	;(22) CONI DTEn
	CONI	DTE1,.CPDTC+1
	CONI	DTE2,.CPDTC+2
	CONI	DTE3,.CPDTC+3
	HRLZ	T1,.CPEPT	;(26) EPT LOCS 0-37
	HRRI	T1,.CPEP0
	BLT	T1,.CPEP0+37
	MOVE	T1,.CPEPT	;(66) EPT LOCS 140-147
	HRLI	T1,140(T1)
	HRRI	T1,.CPEP1
	BLT	T1,.CPEP1+37
>
IFN M.KL10!M.KS10,<
	MOVE	T1,[.UPMP+500,,.CPUP1] ;(126) UPT LOCS 500-503
	BLT	T1,.CPUP1+3
	EXECAC	(6)		;(132) AC BLOCK 6, REGS 0-3 AND 12
	MOVEM	0,.CP6
	MOVEM	1,.CP6+1
	MOVEM	2,.CP6+2
	MOVEM	3,.CP6+3
	MOVEM	12,.CP6+4
	EXECAC	(7)		;(136) AC BLOCK 7, REGS 0-2
	MOVEM	0,.CP7
	MOVEM	1,.CP7+1
	MOVEM	2,.CP7+2
	DATAO	PAG,.CPPGD	;RESTORE ORIGIONAL AC BLOCK
>;END IFN M.KL10!M.KS10
IFN M.KL10,<
	PUSHJ	P,REDSBC	;READ SBDIAG INFO
>
REPEAT 0,<
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;MULTIPLY BY 2
	MOVE	T2,.CPSLF	;ADDRESS OF THIS CPU'S CDB
	ADDI	T2,.CPAPD-.CPCDB ;OFFSET OF CPU STATUS BLOCK IN CDB
	MOVEM	T2,110(T1)	;STORE ADDRESS OF CPU STATUS BLOCK FOR F/S
	MAP	T2,(T2)		;ABSOLUTE ADDRESS OF CPU STATUS BLOCK
	MOVEM	T2,111(T1)	;STORE IT FOR FIELD SERVICE
>;END REPEAT 0
	MOVEI	T1,SR.CSB	;SET FLAG TO INDICATE CPU
	IORM	T1,.CPSBR	;STATUS BLOCK READ ON THIS CPU
	POPJ	P,
IFN M.KL10,<
;ROUTINE TO CLEAR SBUS ERRORS IN EACH MEMORY CONTROLLER.  RETURNS
;CPOPJ ALWAYS AND PRESERVES ALL AC'S.

CLRSBD::PUSHJ	P,SAVE3		;SAVE P1-P3
	MOVSI	P1,-.SBNMC	;MAKE AOBJN POINTER TO ALL MEM CONTROLLERS
	MOVSI	P2,SB.CLR	;BIT TO CLEAR ALL ERRORS
CLRSB1:	DPB	P1,[POINT 5,P2,4] ;STORE MEMORY CONTROLLER NUMBER
	SBDIAG	P2		;CLEAR THE ERROR BITS
	AOBJN	P1,CLRSB1	;LOOP FOR ALL CONTROLLERS
	POPJ	P,		;RETURN


;ROUTINES TO PERFORM SBDIAG FUNCTIONS 0 AND 1 FOR EACH MEMORY CONTROLLER.
;CALL REDSBD TO JUST READ THE DATA.  CALL REDSBC TO READ THE DATA AND
;CLEAR THE ERRORS.  THE FORMAT OF THE SBDIAG STATUS BLOCK IS AS FOLLOWS:
;	WORD 0: -NUMBER OF DATA BLOCKS,,OFFSET TO FIRST BLOCK
;EACH DATA BLOCK HAS THE FOLLOWING FORMAT:
;	WORD 0: -NUMBER OF WORDS FOLLOWING,,CONTROLLER NUMBER
;	WORD 1: SBDIAG FUNCTION 0 FROM-MEMORY WORD
;	WORD 2: SBDIAG FUNCTION 1 FROM-MEMORY WORD
;DESTROYS T1, PRESERVES ALL OTHERS

REDSBD::TDZA	T1,T1		;CLEAR T1 AND SKIP
REDSBC::MOVSI	T1,SB.CLR	;BIT TO CLEAR ERRORS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	SETZM	.CPSBD		;CLEAR FIRST WORD OF BLOCK FOR COUNT
	MOVSI	P1,-.SBNMC	;AOBJN POINTER TO MEMORY CONTROLLERS
	MOVEI	P2,.CPSBD+1	;START FIRST BLOCK HERE
	HRLI	P2,-.SBFNC	;-FUNCTIONS TO LH
REDSB1:	MOVEI	P3,0		;SET TO BUILD TO-MEMORY WORD
	DPB	P1,[POINT 5,P3,4] ;STORE MEMORY CONTROLLER
	SBDIAG	P3		;DO FUNCTION 0
	PUSH	P,P4		;SAVE FUNCTION 0 FROM-MEMORY WORD
	JUMPE	T1,REDSB2	;AVOID 2ND SBDIAG IF NOT CLEARING CONTROLLER
	IOR	P3,T1		;SET SB.CLR
	SBDIAG	P3		;DO FUNCTION 0 TO CLEAR CONTROLLER
REDSB2:	TRO	P3,1		;MAKE IT FUNCTION 1
	SBDIAG	P3		;DO FUNCTION 1
	POP	P,P3		;RESTORE FUNCTION 0 FROM-MEMORY WORD
	SKIPN	P3		;ANYTHING THERE?
	JUMPE	P4,REDSB3	;NO, NO MEMORY CONTROLLER IF BOTH ZERO
	MOVEM	P3,1(P2)	;SAVE FUNCTION 0 WORD IN THE BLOCK
	MOVEM	P4,2(P2)	;  ALONG WITH FUNCTION 1 WORD
	HRRZM	P1,0(P2)	;SAVE CONTROLLER NUMBER AS WORD 0
	HLLM	P2,0(P2)	;MAKE IT -WORDS,,CONTROLLER
	AOS	.CPSBD		;COUNT THIS CONTROLLER
	ADDI	P2,.SBFNC+1	;INCREMENT TO NEXT BLOCK
REDSB3:	AOBJN	P1,REDSB1	;LOOP FOR NEXT CONTROLLER
	MOVN	P1,.CPSBD	;GET NUMBER OF BLOCKS WE STORED
	JUMPE	P1,CPOPJ	;LEAVE IT ZERO IF NONE
	HRLI	P1,1		;MAKE SWAPPED HEADER WORD
	MOVSM	P1,.CPSBD	;SAVE IN WORD 0
	POPJ	P,		;RETURN
>;END IFN M.KL10
;SUBROUTINE TO READ AND STORE DEVICE STATUS

DVCSTS::
IFN M.KI10!M.KL10,<
IFN M.KL10,<
	CONI	TIM,.CPTMR		;INTERVAL TIMER STATUS
	CONI	MTR,.CPMTR		;METER STATUS
>
	CONI	TTY,.CPTTY
	CONI	PTR,.CPPRA
	CONI	PTP,.CPPPA
	CONI	DLS,.CPDLS
	CONI	DAC,.CPDAC
	CONI	DAS,.CPDAS
	CONI	CR,.CPCRA
	CONI	LPT,.CPLPT
	CONI	PLT,.CPPLA
	CONI	TMS,.CPTMS
	CONI	TMC,.CPTMC
	CONI	DX10,.CPDX1
IFN M.KI10,<
	CONI	CCI,.CPCCI
>
	CONI	DSK,.CPDSK
	CONI	FHD2,.CPFH2
	CONI	FSD,.CPFSD
	CONI	FSD2,.CPFS2
	CONI	FSD3,.CPFS3
	CONI	DPC,.CPDPC
	CONI	DPC2,.CPDP2
	CONI	DPC3,.CPDP3
	CONI	DPC4,.CPDP4
	CONI	DBS,.CP2DS		;2ND TD10
	CONI	DBC,.CP2DC
	CONI	DLC,.CPDLC
	CONI	DLB,.CPDLB
	CONI	DLC2,.CPDC2
	CONI	DLB2,.CPDB2
	CONI	CDP,.CPCDP
	CONI	CDR2,.CPCRB		;CDR1
	CONI	LPT2,.CPLPB		;LPT1
	CONI	LPT3,.CPLPC		;LPT2
	CONI	PLT2,.CPPLB		;PLT1
IFN M.KI10,<
	DATAI	APR,.CPDST		;CONSOLE SWITCHES
>
IFN M.KL10,<
	DATAI	APR,.CPDAK		;ADDRESS BREAK CONDITIONS
>
	DATAI	DSK,.CPDDK
	DATAI	FHD2,.CPDH2
	DATAI	FSD,.CPDFS
	DATAI	FSD2,.CPDS2
	DATAI	FSD3,.CPDS3
	DATAI	DPC,.CPDDP
	DATAI	DPC2,.CPDD2
	DATAI	DPC3,.CPDD3
	DATAI	DPC4,.CPDD4
	DATAI	DLC,.CPDDC
	DATAI	DLB,.CPDDB
	DATAI	DLC2,.CPD2C
	DATAI	DLB2,.CPD2B
IFN M.KL10,<
	DATAO	RH2,RH2IVI
	DATAI	RH2,.CPIVI+1
	DATAO	RH21,RH2IVI
	DATAI	RH21,.CPIVI+3
	DATAO	RH22,RH2IVI
	DATAI	RH22,.CPIVI+5
	DATAO	RH23,RH2IVI
	DATAI	RH23,.CPIVI+7
	DATAO	RH24,RH2IVI
	DATAI	RH24,.CPIVI+11
	DATAO	RH25,RH2IVI
	DATAI	RH25,.CPIVI+13
	DATAO	RH23,RH2IVI
	DATAI	RH26,.CPIVI+15
	DATAO	RH27,RH2IVI
	DATAI	RH27,.CPIVI+17
>;END IFN M.KL10
>;END IFN M.KI10!M.KL10
IFN M.KS10,<
	RDINT	.CPTMR		;READ INTERVAL TIMER
	RDTIME	.CPTMB		;READ TIME BASE
	PUSH	P,.UPMP+.LMPFP
	PUSH	P,.UPMP+.LMPFW
	MOVE	T1,[-KSCTBL,,KSCTAB] ;POINTER TO DEVICE ADDRESS TABLE
	MOVE	T2,[EXP XC.UIO+KSCTRP] ;TRAP ADDRESS FOR NX DEVICES
	EXCH	T2,.UPMP+.LMPFN	;SET IT AND SAVE CURRENT ONE
	MOVEI	T3,.CPUB1	;FIRST STORE ADDRESS IN CDB SUB-TABLE
KSCLOP:	RDIO	T4,@(T1)	;READ SOME REGISTER
	MOVEM	T4,(T3)		;SAVE IT IN RIGHT SLOT
KSCTRP:	AOS	T3		;BUMP CDB ADDRESS
	AOBJN	T1,KSCLOP	;DO NEXT
	EXCH	T2,.UPMP+.LMPFN	;RESTORE TRAP ADDRESS
	JRST	KSCEND		;DONE

KSCTAB==.			;START OF KS10 DEVICE ADDRESS TABLE
UB1STS:	XWD	1,UNBSTW	;UBA1 STATUS REGISTER
UB3STS:	XWD	3,UNBSTW	;UBA3 STATUS REGISTER
RH1STS:	RH11CA			;RPCS1
RH1ST2:	RH11CA+10		;RPCS2
RH2STS:	RH21CA			;MTCS1
RH2ST2:	RH21CA+10		;MTCS2
LPTSTS:	LP11CA			;LPT CSRA
LPTST2:	LP11CA+2		;LPT CSRB
CDRSTS:	CD11BA			;CDR CDST
KSCEND==.			;END OF KS10 DEVICE ADDRESS TABLE
KSCTBL==KSCEND-KSCTAB	;LENGTH OF KS10 DEVICE ADDRESS TABLE
	POP	P,.UPMP+.LMPFW
	POP	P,.UPMP+.LMPFP
>;END IFN M.KS10
LENDVS==:<.-DVCSTS-1>B26
	MOVEI	T1,SR.DSB		;SET FLAG TO INDICATE
	IORM	T1,.CPSBR		;DEVICE STATUS BLOCK READ
	POPJ	P,

IFN M.KL10,<
RH2IVI:	740000,,0
>
;HERE FROM THE DIAG. UUO IN FILIO (FUNCTION 10) TO READ THE CPU STATUS
;BLOCK.
DIACSB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	MOVEI	T1,.ERCSB	;DAEMON ERROR CODE
	JRST	DIADS1		;JOIN COMMON CODE


;HERE FROM THE DIAG. UUO IN FILIO (FUNCTION 11) TO READ THE DEVICE
;STATUS BLOCK.
DIADSB::PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
	MOVEI	T1,.ERDSB	;DAEMON ERROR CODE
DIADS1:	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEEIM##	;PLACE IN DAEMON ERROR QUEUE
	JRST	CPOPJ1		;GIVE SUCCESS RETURN FROM UUO
;ROUTINE TO TYPE RELEVANT PARTS OF THE CPU STATUS BLOCK ON THE CTY
;WHEN A CRASH OCCURS.

TYPCSB::PUSHJ	P,INLMES##
	ASCIZ/

CPU Status Block on /
	PUSHJ	P,DAYTIME##	;TYPE CURRENT DATE/TIME
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
APRID = /
	MOVE	T1,.CPAPD	;GET APRID
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
ERA = /
	SKIPN	T1,.CPAER
	MOVE	T1,.CPERA	;GET ERA
	PUSHJ	P,HWDPNT##	;TYPE IT
>;END IFN M.KL10
	PUSHJ	P,INLMES##
	ASCIZ/
CONI APR, = /
	MOVE	T1,.CPACN	;GET CONI APR
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PI, = /
	SKIPN	T1,.CPCPI
	MOVE	T1,.CPPIC	;GET CONI PI
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PAG, = /
	MOVE 	T1,.CPPGC	;GET CONI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
DATAI PAG, = /
	MOVE	T1,.CPPGD	;GET DATAI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
AR ARX Data Word = /
	MOVE	T1,.CP7		;GET AC BLOCK 7 LOC 0
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
IO Page Fail Word = /
	MOVE 	T1,.CP7+2	;GET AC BLOCK 7 LOC 2
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/

SBUS Diags:

CNTRLR FNC 0          FNC 1
/
	PUSHJ	P,TYPSBD	;TYPE SBDIAG INFORMATION
>;END IFN M.KL10
	PJRST	CRLF##		;END WITH CRLF AND RETURN
;ROUTINE TO TYPE THE SBDIAG FUNCTIONS AND VALUES ON THE CTY WHEN
;A CRASH OCCURS.

IFN M.KL10,<
TYPSBD::PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;  AND P2
	MOVE	P1,.CPSBD	;GET -# BLOCKS,, OFFSET TO FIRST
	HRRZI	P2,.CPSBD(P1)	;POINT AT FIRST BLOCK
TYPSB1:	HLL	P2,0(P2)	;MAKE P2 BE AOBJN POINTER TO THIS BLOCK
	HRRZ	T1,0(P2)	;GET CONTROLLER LOGICAL ADDRESS
	PUSHJ	P,OCTPNT##	;PRINT IT
	HRRI	P2,1(P2)	;ADVANCE TO FIRST OF FUNCTION WORDS
TYPSB2:	PUSHJ	P,PRSPC##	;SEPARATE FIELDS WITH A SPACE
	MOVE	T1,0(P2)	;GET NEXT FUNCTION WORD
	PUSHJ	P,HWDPNT##	;TYPE IT
	AOBJN	P2,TYPSB2	;LOOP FOR ALL WORDS IN THIS BLOCK
	PUSHJ	P,CRLF##	;TYPE CRLF AT END OF LINE
	AOBJN	P1,TYPSB1	;LOOP FOR ALL BLOCKS
	POP	P,P2		;RESTORE P2
	POP	P,P1		;  AND P1
	POPJ	P,		;RETURN
>;END IFN M.KL10



;ROUTINE TO READ THE CPU AND DEVICE STATUS BLOCKS.
;CALL:	PUSHJ	P,RCDSTB
;	RETURN

RCDSTB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
IFN FTDAEM,<
	MOVEI	T1,.ERCSB	;CPU STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY FOR DAEMON
	MOVEI	T1,.ERDSB	;DEVICE STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY
>;END IFN FTDAEM
	POPJ	P,		;RETURN
SUBTTL STOP PROCEDURE WHEN SHUTTING DOWN SYSTEM
;TRANSFER HERE ON 404, 405, 406, OR 407 START OR LOCATION 30 BEING
;SET NON-ZERO.
;PROCEDURE TO SAVE CRASHED MONITOR ON DISK FOR LATER DEBUGGING UNDER
;TIMESHARING.  OPERATOR SHOULD:
;	1. TRY TO FORCE THE SYSTEM TO TAKE A DUMP BY CAUSING LOCATION
;	   30 TO BE SET NON-ZERO.  THIS CAN BE DONE FROM THE KEYS ON
;	   A KI10 OR THROUGH COMMANDS TO THE FRONT-END ON KL10 OR KS10
;	   SYSTEMS.
;	2. IF THIS DOESN'T WORK, TRY STARTING THE MACHINE AT 406 OR
;	   407 (FOR SINGLE CPU SYSTEMS).  THIS SHOULD GET US HERE.
;	3. IF ALL ELSE FAILS, LOAD BOOT WITH READ-IN OR VIA THE
;	   FRONT-END.  THIS HAS THE DISADVANTAGE THAT SOME MACHINE
;	   STATE, THE AC SETS, ETC. ARE LOST.
BOOTLN==1000	;NO OF WORDS (MAX) IN BOOTS CODE (BLOCK 4-7)

;HERE ON A 405 START TO SAVE THE MACHINE STATE AND JUMP INTO THE AC'S
STPCPU:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.DIE	;SET BIT TO FORCE CPNSER TO LOOP
	IORB	P1,.CPSBR	; IN THE AC'S UNTIL EXPLICITLY RESTARTED
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 404 START TO SET 30 TO -1 TO FORCE ALL OTHER CPU'S INTO
;THEIR AC'S
STPALL:	SETOM	CRSHWD		;FORCE ALL OTHER CPU'S INTO THE AC'S

;HERE ON A 406 START TO GET TO MONBTS ON THIS CPU REGARDLESS OF WHO
;THE BOOT CPU IS.
STPLDB:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.LBH	;SET BIT TO GET TO MONBTS ON THIS CPU
	IORB	P1,.CPSBR	; REGARDLESS OF WHO THE BOOT CPU IS
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 407 START OR 30 NON-ZERO AT APR INTERRUPT LEVEL
SYSTOP::DMOVEM	P1,RBTSVA	;SAVE P1, P2 IN A VERY TEMPORARY AREA
	JSP	P1,PAGENB	;MAKE SURE PAGING IS TURNED ON
	MOVE	P1,.CPSBR	;GET STATUS BITS
SYSTO1:	TRNE	P1,SR.ACL	;THIS CPU LOOPING IN THE AC'S?
	JRST	[DMOVE	P1,RBTSVA ;YES, AC'S SAVED BY AC LOOP SETUP
		 JRST SYSTO2]	;SO DON'T SAVE THEM AGAIN
	DMOVE	P1,RBTSVA	;RESTORE P1 AND P2
	JSR	.CPSVA		;SAVE ALL AC SETS

SYSTO2:	MOVE	P,.CPEPD	;SETUP P TO ERRPDL
	MOVEI	P1,SR.STS	;BIT SET IF MACHINE STATE ALREADY SAVED
	TDNN	P1,.CPSBR	;ALREADY SAVE MACHINE STATE?
	SKIPGE	BOOTCP		;NO, MAP SETUP YET?
	CAIA			;NO, CAN'T READ DATA BLOCKS
	PUSHJ	P,RCDSTB	;READ CPU AND DEVICE STATUS BLOCKS
	IORM	P1,.CPSBR	;SET THE BIT FOR THE NEXT TIME


				;FALL INTO REBOOT
;HERE ON ANY CPU FROM DIE OR FALL INTO FROM ABOVE TO RELOAD THE MONITOR.
;IN MULTIPROCESSOR SYSTEMS, ALL BUT THE BOOT CPU ARE DISPATCHED TO
;CP1CRS IN CPNSER.  IT IS THE CALLERS RESPONSIBILITY TO SAVE ALL AC
;SETS (WITH .CPSVA) BEFORE GETTING HERE.

REBOOT::EXECAC
	MOVE	P1,BOOTCP	;SAVE CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;CAUSE SYSTR1 TO NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P1,BOOTCP	;RESTORE BOOTCP
IFN FTKLP,<
	MOVE	P1,.CPXPT	;GET TRASHED SPT
	MOVEM	P1,.CPSPT	;RESTORE TRASHED SPT
>
IFN M.KI10!M.KL10,<
	DATAO	DLB,[0]
	DATAO	DLB2,[0]
>
IFN M.KL10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB	;WAIT UNTIL DONE
	JRST	.-1		; ..
	CONI	PAG,T1		;GET PAGING STATE
	TRZ	T1,LG.CSL!LG.CSW ;TURN OFF, LOOK AND LOAD
	CONO	PAG,(T1)	;MAINTAIN PAGING BUT WITHOUT CACHE
	JSR	ZAPRH2		;FIX UP RH20S
>
IFN M.KS10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	WRUBR	0		;SWEEP CACHE
>
	CONO	APR,AP0RST	;RESET SYSTEM
	CONO	PI,011577	;WIPEOUT PI-SYSTEM

IFN FTMP,<
IFG <CPUN-1>,<
	MOVEI	T1,SR.LBH	;DO WE WANT TO GET TO MONBTS ON THIS
	TDNE	T1,.CPSBR	;  CPU REGARDLESS OF WHO THE BOOT CPU IS?
	JRST	REBOO1		;YES, SKIP THE REST OF THE CHECKS
	SKIPL	BOOTCP		;MAP SETUP YET?
	SKPCPU(1)		;YES, ON ANY BUT THE BOOT CPU?
	CAIA			;NO, LOAD BOOTS AND RELOAD
	PJRST	CP1CRS##	;GO TO CPNSER AND LOOP IN THE AC'S
REBOO1:>>

;CALL TO METINI REMOVED SO METER POINTS WILL BE PRESERVED IN
;THE CRASH DUMP--THIS REQUIRES THAT NONE OF THE ROUTINES
;CALLED BELOW (E.G. GETZ) SHOULD CONTAIN METER POINTS.
;IFN FTMETR,<IFG M.METR,<
;	JSR	METINI##	;RELEASE ALL METER POINTS
;>>
	MOVE	P,.CPEPD	;SETUP P TO SPARE AREA
IFN M.KL10!M.KS10,<
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT+NUPMPP
	HRLM	T1,NLUPMP+.MUPMP	;SINCE SUNXMT NEEDS A UPT SETUP
>
IFN FTKLP,<
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
;*********
	MOVEM	T1,NLUPMP+370
>
>
BNXMTS::PUSHJ	P,SUNXMT##	;SETUP NXMTAB PATCHED OUT IF SYSTEM HAS
				; BEEN STARTED (PATCHED TO JFCL AFTER START)
IFE M.MBTS,<
IFN DPCN!RPXN!RHXN,<
	MOVEI	T1,BOOTCL	;SETUP LOWER CORE TO POINT TO CHANNEL
	HRRZM	T1,BOOTWD	; COMMAND LIST (MAKE SURE IN CASE
				; LOWER CORE WIPED OUT).  START UNIT 0, READ (LHT)

IFE M.KS10,<
	MOVEI	T1,200000	;PAGE 8191
	MOVEI	T2,NXMTAB+343	;STARTING WORD IN BIT MAP
	HRLOI	P2,17		;4096K-1
>
IFN M.KS10,<
	MOVEI	T1,20		;PAGE 2047
	MOVEI	T2,NXMTAB+70	;STARTING WORD IN BIT MAP
	HRLOI	P2,3		;512K-1
>
	PUSHJ	P,FINDHI	;FIND THE HIGHEST EXISTANT PAGE
	MOVE	P1,P2		;VIRTUAL ADDRESS-1 OF HIGHEST PAGE
	MOVE	P3,P2		;PHYSICAL ADDRESS-1 OF HIGHEST PAGE
	TLNN	P2,-1		;MORE THAN 256K?
	JRST	BNXMT1		;NO, USE PHYSICAL ADDRESSES

	MOVSI	T1,2000		;PAGE 511
	MOVEI	T2,NXMTAB+16	;STARTING WORD IN BIT MAP
	MOVEI	P2,777777
	PUSHJ	P,FINDHI	;FIND HIGHEST EXISTANT PAGE OR K
	EXCH	P2,P3		;P2=P.A.,P3=P.A..LT.256K



;STILL IN IFE M.MBTS CONDITIONAL
BNXMT1:	MOVSI	T1,-BTBLEN
KONLUP:	MOVE	T3,P2		;ASSUME BOOTS CAN BE READ INTO HIGHEST PHYSICAL PAGE
IFN M.KI10!M.KL10,<
	XCT	KONCNI(T1)	;CONI DEV,T4
	XCT	SKP22B(T1)	;SKIP IF A DF10C IN 22 BIT MODE
	SKIPA	T3,P3		;ITS NOT, READ BOOTS INTO 256K OR BELOW
>
	TLOA	T3,-BOOTLN_4	;IT IS, READ BOOTS INTO THE TOP OF CORE

	TLO	T3,-BOOTLN	;WORD COUNT 18 BIT STYLE
	MOVEM	T3,BOOTCL	;STORE IOWD
	MOVSI	T2,-10
UNILUP:	CONO	APR,AP0RST	;CLEAR THE WORLD
	SETZM	BOOTCL+1	;TERMINATE THE READ
	MOVE	T4,BTABLE(T1)
	PUSHJ	P,@0(T4)	;START THE READ
	MOVEI	T3,40000
	XCT	1(T4)		;WAIT TILL DONE
	SOJG	T3,.-1
	MOVE	P1,BOOTCL
IFN M.RH2P,<
	SUBI	P1,1
>
	LSH	P1,W2PLSH	;PHYSICAL PAGE BOOTS WAS READ INTO
IFE FTKLP,<
	MOVEI	P1,PM.ACC+PM.WRT+1(P1)
	HRRM	P1,.EPPM+177	;MAKE IT ADDRESSABLE
>
IFN FTKLP,<
	HRLI	P1,(<PM.DCD>B2+PM.WRT)
;*********
	MOVEM	P1,.EPMPA+777
>
	MOVEI	P1,776777	;VIRTUAL ADDRESS OF BOOTS
IFN M.KI10,<
	DATAO	PAG,.C0EBR	;CAUSE MAPPING TO BE IN EFFECT
>
IFN M.KL10,<
	CONO	PAG,LG.TEN+.EPMP/PAGSIZ
>
IFN M.KS10,<
	WREBR	SG.TEN+.EPMP/PAGSIZ
>

IFN M.RH2P,<
	XCT	4(T4)		;RESTORE LOGOUT AREA IF RH20
>
	MOVE	S,BOOTFI
	CAMN	S,1(P1)		;READ BOOTS?
	JUMPG	T3,UNICHK	;YES, IF DIDN'T TIME OUT
UNINXT:	AOBJN	T2,UNILUP	;NO, TRY NEXT UNIT
	AOBJN	T1,KONLUP	;TRY NEXT KONTROLLER
>
	MOVE	10,.+1
	STOPCD	10,HALT,BNF,	;++BOOTS NOT FOUND
UNICHK:	XCT	2(T4)		;BOOTS WAS READ, ANY DEVICE ERROR?
	JRST	UNINXT		;YES, TRY NEXT UNIT
				;ALL OK, FALL INTO BOOTYP
>;END IFE M.MBTS CONDITIONAL

BOOTYP:
IFN FTKL10,<
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL
>	;END IFN FTKL10
IFN FTKS10,<
	PUSHJ	P,DISKAL##	;DISABLE KEEP ALIVE FUNCTION
>
IFE M.MBTS,<			;INCORE BOOTS?
	MOVEI	T1,BOOTMS	;ADR OF MESSAGE SO OPER WILL
				;KNOW HE IS TALKING TO BOOTS
				;RATHER THAN A LOOP IN MONITOR
	PUSHJ	P,CTYTYP##	;TYPE ON CTY (RESPECTS T2)
>
	MOVE	T1,[POINT 7,BOOTXT]	;POINTER TO TEXT
	MOVE	T2,DEBUGF
	TLNE	T2,(DF.NAR)	;ALLOW AUTO-RELOAD?
	MOVEI	T1,0		;NOPE.
	TLNE	T2,(DF.RIP)	;IS THIS A FORCED RELOAD?
	JRST	BOOTSP		;YES. DON'T CHECK KSYS OR UPTIME
	SKIPG	ARFLAG		;SKIP IF .GT. 5 MIN UPTIME
	MOVEI	T1,0		;NO RELOAD--CLEAR POINTER
IFN FTKI10,<
	CONI	APR,T2		;READ SENSE SWITCHES
	TLNN	T2,(IP.SS5)	;IHIBIT AUTO-RELOAD IF SS5 IS SET
>
	SKIPGE	SYSKTM		;KSYS?
	MOVEI	T1,0		;YES, NO AUTOS
BOOTSP:	SKIPE	MBTCOM		;IF SUSPENDED,
	MOVEI	T1,0		; HAVE MONBTS PROMPT
IFE M.MBTS,<
	MOVEM	T1,1000(P1)	;STORE FOR BOOTS
>
IFN M.MBTS,<
	PUSH	P,T1		;SAVE FOR LATER
>
	MOVE	T1,LOCYER	;GET YEAR
	SUBI	T1,^D1970	;SUBTRACT BASE
	JUMPL	T1,BOOTST	;DON'T STORE IF BAD
	LSH	T1,5		;SHIFT OVER
	IOR	T1,LOCDAY	;ADD IN DAY
	LSH	T1,4		;AND
	IOR	T1,LOCMON	;MONTH
	HRLZM	T1,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	MOVE	T2,TIME		;GET TIME IN JIFFIES
	IDIV	T2,TICSEC	;CONVERT TO SECONDS TO FIT
	ADDI	T2,RLDTIM
	HRRM	T2,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	ADD	T1,T2		;ADD DATE AND TIME TOGETHER
	ADD	T1,CRSWHY	;PLUS STOPCD NAME
	HRRZ	T2,STATES	;GET SCHED SETTING
	HRRM	T2,CRSSTS	;SAVE FOR RELOAD
	ADD	T1,T2		;AND ADD INTO CHECKSUM
	ADDI	T1,507601	;ADD IN THE MAGIC CONSTANT
	HRLM	T1,CRSWHY	;SAVE CHECKSUM FOR ONCE AFTER
				; RELOAD SO IT CAN DEFEND AGAINST
				; JUNK OR NON-MONITOR PREDECESSORS.
BOOTST:
IFN M.MBTS,<
	POP	P,T1		;RESTORE POINTER TO BOOTXT
	PJRST	RLDMON##	;AND GO RELOAD MONITOR
>
IFE M.MBTS,<
	MOVE	P1,BOOTCL	;WHERE BOOTS WAS READ
	TLNE	P1,17		; ABOVE 256K?
	SKIPA	P1,[776777]	;YES
IFN M.KI10,<
	DATAO	PAG,[PG.LEB+0]	;NO, TURN OFF PAGING
>
IFN M.KL10,<
	CONO	PAG,0
IFN M.RH2P,<
	TRNN	P1,777		;IF READ FROM RH2P
	SUBI	P1,1		; ADDR IS 1 TOO HIGH
>
>
IFN M.KS10,<
	WREBR	0		;TURN OFF PAGING
>
	JRST	1(P1)		;GO START UP BOOTS.

BOOTMS:	ASCIZ	/
BOOTS
/

;STILL IN IFE M.MBTS CONDITIONAL

IFN DPCN,<
DPREAD:	MOVEI	T3,40(T2)
	ROT	T3,-6		;SEEK CYL 0
	XCT	3(T4)
	MOVEI	T3,^D100000
	SOJG	T3,.		;WAIT HALF A SECOND
	MOVEI	T3,(T2)
	ROT	T3,-6		;READ
	HRRI	T3,BOOTWD+45000	;DISABLE ERROR STOP
	XCT	3(T4)
	POPJ	P,		;AND RETURN
>

IFN RPXN,<
RPREAD:	MOVSI	T3,124000(T2)
	XCT	3(T4)		;DESIRED CYL = 0
	TDC	T3,[170000,,4]
	XCT	3(T4)		;DESIRED SECTOR = 4
	TDC	T3,[450000,,200075!BOOTWD_6]
	XCT	3(T4)		;READ, DXES
	POPJ	P,		; AND RETURN
RPCHEK:	MOVSI	T3,10000(T2)
	XCT	3(T4)		;DATAO STATUS
	IMULI	1
	XCT	5(T4)		;DATAI STATUS
	XCT	6(T4)		;CONSO
	TRNN	T3,40000	;ERR ON?
	AOS	(P)		;GOOD RETURN
	XCT	7(T4)		;CLEAR DONE (RH20)
	POPJ	P,		; AND RETURN

;STILL IN IFN RPXN
;STILL IN IFE M.MBTS CONDITIONAL
IFN M.RH2P,<
RH2RED:	XCT	7(T4)		;MASSBUS ENABLE
	MOVSI	T3,010000(T2)
	XCT	3(T4)
	IMULI	P,1		;READ STATUS REGISTER
	IMULI	P,1
	XCT	5(T4)
	ANDI	T3,10700
	CAIE	T3,10700	;DRIVE OK?
	POPJ	P,		;NO, DONT ATTEMPT TO READ
	MOVE	T3,BOOTCL
	TLNE	T3,100000
	TLC	T3,-BOOTLN_4	;TURN INTO RH20-STYLE IOWD
	TLO	T3,BOOTLN_4!400000
	TRNE	T3,777
	ADDI	T3,1		;RH20S LIKE ADDR, NOT ADDR-1
	MOVEM	T3,BOOTCL
	MOVE	U,[200000,,BOOTCL]	;INITIAL JUMP
	EXCH	U,(F)		;WHERE CHAN EXPECTS IT
	DMOVE	J,1(F)		;SAVE LOGOUT AREA (IN CASE NO PACK UP)
	MOVSI	T3,124400(T2)	;DESIRED CYL=0
	XCT	3(T4)
	TDC	T3,[170000,,4]	;DESIRED SECTOR =4
	XCT	3(T4)
	TDC	T3,[742000,,200075!<<<-BOOTLN/200>&1777>_6>]
	XCT	3(T4)		;START THE READ
	POPJ	P,
RH2RST:	MOVEM	U,(F)
	DMOVEM	J,1(F)
	POPJ	P,
>;END IFN M.RH2P
>;END IFN RPXN

;STILL IN IFE M.MBTS CONDITIONAL
IFN RHXN,<
RHREAD:	MOVSI	P2,1		;RH11 IS ON UBA #1
	MOVE	P1,BOOTCL	;GET DF10C STYLE IOWD
	AOS	P1		;ACCOUNT FOR FACT IOWD IS ADR-1
	MOVEI	T3,740100	;UNIBUS ADAPTER STATUS BITS
	WRIO	T3,763100(P2)	;CLEAR ADAPTER AND UNIBUS
	MOVEI	T3,40		;CONTROLLER CLEAR BIT
	WRIO	T3,776710(P2)	;AND RESET CONTROLLER
	LDB	T3,[POINT 3,T2,35] ;GET UNIT NUMBER
	WRIO	T3,776710(P2)	;SELECT UNIT NUMBER
	MOVEI	T3,21		;FUNCTION = READIN PRESET
	WRIO	T3,776700(P2)	;SET  UP THE UNIT
	MOVEI	T3,4		;SECTOR #4, TRACK #0
	WRIO	T3,776706(P2)	;SET UP SECTOR/TRACK ADDRESS
	LDB	T3,[POINT 14,P1,13] ;GET WORD COUNT (14 BITS)
	TRO	T3,740000	;LIGHT OTHER 4 BITS IN HALF WORD
	LSH	T3,1		;MAKE INTO 11 FORMAT
	WRIO	T3,776702(P2)	;WORD COUNT REGISTER
	LDB	T3,[POINT 13,P1,26] ;GET PAGE #PORTION OF IOWD
	TRO	T3,UNB36B!UNBVBT ;SET SOME NEEDED BITS
	WRIO	T3,763000(P2)	;USE FIRST PAGING RAM ADDRESS
	LDB	T3,[POINT 9,P1,35] ;GET LOW ORDER PORTION
	LSH	T3,2		;MAKE 11 STYLE
	WRIO	T3,776704(P2)	;LOAD UP BUS REGISTER
	MOVEI	T3,71		;READ FUNCTION
	WRIO	T3,776700(P2)	;START THE TRANSFER
	MOVEI	P1,200		;SET UP READY BIT FOR DONE CHECK
	POPJ	P,

RHCHEK:	PUSH	P,P1
	MOVEI	P1,140000		;ERROR BITS
	TION	P1,776700(P2)	;SKIP IF ANY ERROR
	AOS	-1(P)		;NONE, CPOPJ1 RETURN
	POP	P,P1
	POPJ	P,
>;END IFN RHXN

;STILL IN IFE M.MBTS CONDITIONAL
BTABLE:
IFN RPXN,<
	EXP	RPINST
	EXP	R2INST		;ALWAYS 2 - FSD0 MIGHT BE AN RS04
IFN M.RH2P,<
	EXP	RH2INST
	EXP	RH2IN2
>
>
IFN DPCN,<
	EXP	DPINST
IFG DPCN-1,<
	EXP	D2INST
>>
IFN RHXN,<
	EXP	RHINST
>
BTBLEN==.-BTABLE

IFN DPCN,<
DPINST:	EXP	DPREAD
	CONSO	DPC,10
	CONSZ	DPC,377720
	DATAO	DPC,T3
	JFCL

IFG DPCN-1,<
D2INST:	EXP	DPREAD
	CONSO	DPC2,10
	CONSZ	DPC2,377720
	DATAO	DPC2,T3
	JFCL
>>

;STILL IN IFE M.MBTS CONDITIONAL
IFN RPXN,<
RPINST:	EXP	RPREAD
	CONSO	FSD,10
	PUSHJ	P,RPCHEK
	DATAO	FSD,T3
	JFCL
	DATAI	FSD,T3
	CONSO	FSD,736320
	JFCL

R2INST:	EXP	RPREAD
	CONSO	FSD2,10
	PUSHJ	P,RPCHEK
	DATAO	FSD2,T3
	JFCL
	DATAI	FSD2,T3
	CONSO	FSD2,736320
	JFCL

IFN M.RH2P,<
RH2INST:EXP	RH2RED
	CONSO	RH2,10
	PUSHJ	P,RPCHEK
	DATAO	RH2,T3
	PUSHJ	P,RH2RST
	DATAI	RH2,T3
	CONSO	RH2,515000
	CONO	RH2,5410

RH2IN2:	EXP	RH2RED
	CONSO	RH21,10
	PUSHJ	P,RPCHEK
	DATAO	RH21,T3
	PUSHJ	P,RH2RST
	DATAI	RH21,T3
	CONSO	RH21,515000
	CONO	RH21,5410
>
>

IFN RHXN,<
RHINST:	EXP	RHREAD
	TION	P1,776700(P2)	;SKIP IF READY SET
	PUSHJ	P,RHCHEK
>

;STILL IN IFE M.MBTS CONDITIONAL
KONCNI:
IFN RPXN,<
	CONI	FSD,T4
	CONI	FSD2,T4
IFN M.RH2P,<
	MOVEI	F,.EPMP		;EPT+0 FOR 1ST RH20
	MOVEI	F,.EPMP+4	;EPT+4 FOR 2ND RH20
>
>
IFN DPCN,<
	CONI	DPC,T4
IFG DPCN-1,<
	CONI	DPC2,T4
>>

SKP22B:
IFN RPXN,<
	TLNN	T4,4000
	TLNN	T4,4000
IFN M.RH2P,<
	SKIPA			;RH20'S ARE ALWAYS 22-BIT
	SKIPA
>
>
IFN DPCN,<
	TLNN	T4,20
IFG DPCN-1,<
	TLNN	T4,20
>>

> ;END IFE M.MBTS CONDITIONAL
IFN FTKL10,<
;SUBROUTINE TO GET THE RH20S BACK INTO A KNOWN STATE
ZAPRH2:	0
	MOVEI	T1,540/4
	MOVE	T2,[CONO 540,(T3)]
ZPRH21:	DPB	T1,[POINT 7,T2,9]
	MOVEI	T3,2000		;MASSBUS INIT
	XCT	T2
	MOVEI	T3,20		;STO?
	XCT	T2
	MOVEI	T3,10		;CLEAR DONE
	XCT	T2
	CAIGE	T1,574/4
	AOJA	T1,ZPRH21	;LOOP FOR ALL RH20'S
	JRST	@ZAPRH2
>


IFE M.MBTS,<
;SUBROUTINE TO FIND THE HIGHEST ZERO BIT IN A TABLE
; CALL WITH T1=STARTING BIT POSITIONS, T2=STARTING WORD
; WITHIN THE TABLE, P2=THE ADDRESS REPRESENTED BY THE
; STARTING WORD NUMBER AND BIT POSITION. RETURNS
; P2=ADDRESS WHICH REPRESENTS THE FIRST ZERO FOUND IN THE TABLE
FINDHI:	SUBI	P2,PAGSIZ
	TDNN	T1,(T2)
	POPJ	P,
	SKIPGE	T1
	SUBI	T2,1
	ROT	T1,1
	JRST	FINDHI
>
;SUBROUTINE TO INSURE THAT PAGING IS ON WHEN WE COME THROUGH
;SYSTOP.
;CALL:	JSP	P1,PAGENB
;	RETURN HERE ALWAYS

PAGENB:	DMOVEM	T1,RBTSVA+2	;SAVE AC'S WHICH WILL BE
	DMOVEM	T3,RBTSVA+4	; DESTROYED BY SYSTR1
IFN FTKI10,<
	DATAI	PAG,T1		;GET CURRENT MAPPING
	TRNE	T1,PG.EAT	;PAGING ALREADY ON?
>
IFN FTKL10,<
	CONI	PAG,T1		;GET CURRENT MAPPING
	TRNE	T1,LG.TEN	;PAGING ALREADY ON?
>
IFN FTKS10,<
	RDEBR	T1		;GET CURRENT MAPPING
	TRNE	T1,SG.TEN	;PAGING ALREADY ON?
>
	JRST	PAGEN1		;YES, DON'T ALTER CURRENT STATE
	MOVE	P2,BOOTCP	;GET CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;MAKE SURE SYSTR1 WILL NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P2,BOOTCP	;RESTORE BOOTCP
PAGEN1:	DMOVE	T1,RBTSVA+2	;RESTORE T1,T2
	DMOVE	T3,RBTSVA+4	; AND T3,T4
	JRSTF	@P1		;RETURN

RBTSVA:	BLOCK	6		;STORE P1-P2 AND T1-T4 HERE
IFE M.MBTS,<
BOOTFI:	CONO	200000		;BOOTS FIRST INSTRUCTION
NXUNIT:	XWD	10000,0		;INCREMENT TO NEXT UNIT IN DATAO DPC,
>
ARFLAG::-5			;TESTED TO SEE IF AUTO RELOAD NEEDED
				; COUNTED UP ONE EVERY 60 SEC.

BTXLEN==:^D16			;MAX LENGTH OF BOOTXT
;THIS BLOCK MAY BE OVERWRITTEN BY ONCE
IFN M.KI10,<
BOOTXT::
>
IFN M.KL10!M.KS10,<
ZZ1==.
>
IFE FTEXE,<
	XP	UMERGE,CPOPJ	;NO MERGE. UUO
	ASCIZ	"/D SYSTEM.SAV[1,4] "
>
IFN FTEXE,<
	ASCIZ	"/D SYSTEM.EXE[1,4] "
>
IFN M.KI10,<
	BLOCK	BOOTXT+BTXLEN-.	;LEAVE ROOM FOR "/D DEVICE:FILNAM.EXT[PATH]
>
IFN M.KL10!M.KS10,<
	BLOCK	ZZ1+BTXLEN-.
ZZZ==.-1
IFN	<ZZ1&MPGSIZ-ZZZ&MPGSIZ>,<
	LOC	ZZZ&MPGSIZ
BOOTXT::
IFE FTEXE,<
	ASCIZ	"/D SYSTEM.SAV[1,4] "
>
IFN FTEXE,<
	ASCIZ	"/D SYSTEM.EXE[1,4] "
>
	BLOCK	BOOTXT+BTXLEN-.
>
IFE	<ZZ1&MPGSIZ-ZZZ&MPGSIZ>,<BOOTXT==:ZZ1>>

	$ABS
	LIT		;FORCE INITIALIZATION AND READ BOOTS LITERALS
			; INTO THE LOW SEGMENT
SUBTTL	COMMON SUBROUTINES


; SET UP AN INSTUCTION TO ENTER DDT VIA THE UNSOLICITED BREAKPOINT.
; THE CDBS ARE INITIALLY BUILT WITH .CPDDT CONTAINING A NOOP.  THE
; NOOP MUST BE A TRN.  THIS ALLOWS ANY ROUTINE TO DETERMINE IF IT'S
; CPU MAY ENTER EDDT BY DOING A SKIPL .CPDDT (TRN HAS THE SIGN BIT ON).
;
; DEBUGF CONTAINS A MASK OF THE CPUS WHICH MAY ENTER EDDT VIA THE
; UNSOLICITED BREAKPOINT.  INITIALLY, THIS MASK IS SET TO ALLOW
; BREAKPOINTS ON ALL CPUS, BUT MAY BE CHANGED AT ANY TIME.
;
	$HIGH

CPUDDT::MOVE	T1,DEBUGF	;GET DEBUGGING FLAGS
	ANDI	T1,DF.BPT	;KEEP JUST THE CPU BREAKPOINT MASK
	MOVE	T2,T1		;COPY MASK
	XOR	T1,BPTMSK	;COMPARE
	JUMPE	T1,CPOPJ	;RETURN IF NO CHANGE
	MOVEM	T2,BPTMSK	;SAVE NEW MASK
	MOVEI	T1,.C0CDB	;POINT TO START OF CDB CHAIN

CPUDD1:	MOVEI	T3,DF.BP0	;GET BIT FOR CPU0
	MOVN	T4,.CPCPN-.CPCDB(T1) ;GET A CPU NUMBER
	LSH	T3,(T4)		;SHIFT TO FIND THIS CPU'S BIT IN MASK
	TDNE	T3,DEBUGF	;WANT TO ALLOW BREAKPOINTS ON THIS CPU?
	SKIPA	T2,BPTXCT	;YES--GET INSTRUCTION TO ENTER DDT
	MOVE	T2,[BPTNOP]	;NO--GET SPECIAL NOOP
	MOVEM	T2,.CPDDT-.CPCDB(T1) ;SAVE INSTRUCTION
	HLRZ	T1,.CPCDB-.CPCDB(T1) ;GET ADDRESS OF NEXT CDB
	JUMPN	T1,CPUDD1	;LOOP FOR ALL CPUS
	POPJ	P,		;RETURN

BPTXCT::JSR	$0BPT##		;INSTRUCTION TO ENTER DDT
BPTNOP==<TRN	0,0>		;NOOP

	$ABS
BPTMSK:	EXP	-1		;MASK OF OLD CPU BREAKPOINT BITS
	$HIGH
SUBTTL COMMON SUBROUTINES


;ERROR RECOVERY - TRY TO START NULL JOB

NULJB1::SETZB	J,.CPJOB	;ZERO J AND JOB NUMBER FOR NULJOB
	JRST	NULJOB##	;GO RESTORE NULL JOB




;COMMON SUBROUTINE RETURNS

CPOPJ2::AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
RSKP::!				;FOR MACSYM USERS
CPOPJ1::AOSA	(P)		;SKIP SUBROUTINE RETURN
DPOPJ::	MOVEM	S,DEVIOS(F)	;DEPOSIT I/O STATUS WORD IN DDB
RTN::!
CPOPJ::	POPJ	P,

TPOPJ1::AOSA	-1(P)		;RESTORE T1 THEN SKIP RETURN
TTPOPJ::POP	P,T2
TPOPJ::	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
JPOPJ1::			;DUPLICATE NAME (PREFERRED)
IPOPJ1::AOS	-1(P)		;SET FOR SKIP RETURN
JPOPJ::				;DUPLICATE NAME (PREFERRED)
IPOPJ::	POP	P,J		;RESTORE J (USUALLY JOB OR HIGH SEG NUMBER)
	POPJ	P,
	POP	P,
T2POJ1::AOS	-1(P)
T2POPJ::POP	P,T2		;RESTORE T2
	POPJ	P,
MPOPJ::	POP	P,M
	POPJ	P,
WPOPJX::CAIA			;NETSER PUSHES THIS ADDR ON THE STACK THEN
WPOPJ1::AOS	-1(P)		; EVENTUALLY DOES A CPOPJ1 RETURN
WPOPJ::	POP	P,W
	POPJ	P,
T3POPJ::POP	P,T3
	POPJ	P,
P3POPJ::POP	P,P3
	POPJ	P,


FUPOJ1::POP	P,F
UPOPJ1::
LPOPJ1::AOSA	-1(P)		;SKIP AND RESTORE LINE
FUPOPJ::POP	P,F
UPOPJ::
LPOPJ::	POP	P,U		;RESTORE LINE AND RETURN
	POPJ	P,0		;RETURN
FPOPJ1::AOS	-1(P)
FPOPJ::	POP	P,F		;RESTORE F
	POPJ	P,0		;RETURN
ZPOPJ::	TDZA	T1,T1
M1POPJ::SETOM	T1
	POPJ	P,

;GENERATE AND/OR STORE UUO ERROR CODES
	ERCALC(ECDMAX)
	$ABS
IFE FTMETR,<
METER::				;DUMMY METER UUO
>

IFE M.MSG,<
	XP	MPXACT,CPOPJ1
	XP	CHKMPX,CPOPJ1
LGLMPX::
MPXIOS::
TSTMPX::
CLRST::
ERLST::
SENSE::
CONECT::
DEVUDX::
MOVHDR::
MSGBFE::
MSGOUT::
ZAPMPX::
MPXIOD::
MPXDIS::
MPXWAT::
MPXWAI::
>
	POPJ	P,		;THE NULL UUO
;ROUTINE TO SAVE ALL AC SETS IN .CPCAC AND .CPCA1.  RETURNS WITH
;NO AC'S IN ANY SET CHANGED AND THE FOLLOWING LOCATIONS SETUP:
;
;	.CPCPG - ARGUMENT TO DATAO PAG, TO RESTORE CURRENT AC SET
;	.CPACA - ADDRESS OF SAVED VALUES FOR CURRENT AC SET.
;
;CALL:
;		JSR	.CPSVA
;		RETURN HERE ALWAYS

SVSETS:	DATAI	PAG,.CPCPG	;SAVE CURRENT STATE OF AC BLOCKS
IFN FTKL10!FTKS10,<
	SAVE	(1,.CPCA1)	;SAVE ALL AC SETS
	SAVE	(2,.CPCA1+20)	;...
	SAVE	(3,.CPCA1+40)	;...
	SAVE	(4,.CPCA1+60)	;...
	SAVE	(0,.CPCAC)	;AND LEAVE AC SET 0 AC THE CURRENT ONE
	LDB	17,[POINT 3,.CPCPG,8] ;GET NUMBER OF CURRENT AC SET
	JUMPN	17,SVSET1	;GO IF NOT AC SET 0
	MOVEI	17,.CPCAC	;AC SET 0 IS SAVED AT .CPCAC
	JRST	SVSET2		;CONTINUE
SVSET1:	IMULI	17,20		;COMPUTE OFFSET INTO .CPCA1 OF THIS SET
	ADDI	17,.CPCA1-20	;COMPUTE ADDRESS OF THIS SET
SVSET2:
>
IFN FTKI10,<
	MOVEM	17,.CPCAC+17	;SAVE AC 17
	MOVEI	17,.CPCAC	;PLACE TO STORE REST OF AC'S
	BLT	17,.CPCAC+16	;SAVE THE REST
	DATAO	PAG,[PG.LUB!PG.AC1] ;MAKE AC SET 1 BE THE USER SET
	JRSTF	@[IC.UOU!.+1]	;MAKE EXCTUX WORK
	MOVEI	17,.CPCA1	;PLACE TO STORE USER SET
	EXCTUX	<BLT 17,.CPCA1+17> ;SAVE AC BLOCK 1
	MOVE	17,[PG.LUB+PG.LEB] ;GET LOAD LEFT AND LOAD RIGHT BITS
	IORM	17,.CPCPG	;AND SET FOR RESTORE
	MOVEI	17,.CPCAC	;ADDRESS OF SAVED AC BLOCK
>
	MOVEM	17,.CPACA	;SAVE ADDRESS OF WHERE AC SET WAS SAVED
	MOVE	17,.CPCAC+17	;RESTORE AC 17 OF SET 0
	DATAO	PAG,.CPCPG	;RESTORE CURRENT AC SET
	JRSTF	@.CPSVA		;RETURN TO CALLER
	$ABS
	LIT

;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS
;SAVEN IS CALLED AT THE BEGINNING OF A SUBROUTINE
;FOR CONVENIENCE NO MATCHING SUB IS NEEDED TO BE CALLED
;TO RESTORE THIS ACS.
;INSTEAD AN EXTRA RETURN IS PUT ON STACK
;5 CHAR NAME INDICATES IT VIOLATES
;SUBROUTINE CALLING CONVENTIONS
;CALL:	PUSHJ	P,SAVEN
;	RETURN	HERE IMMEDIATELY WITH EXTRA RETURN ON STACK
;	RESPECTS ALL ACS

;NOTE:	THIS CODE USES 1 LOC BEYOND END OF STACK BUT THEN PUSHES ON TOP OF IT
;SO GET OVERFLOW INTERUPT IF TOO FULL.  OK TO DO 1(P) SINCE THIS WORD WRITTEN ON OVERFLOW

	$HIGH
SAVE1::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,(P)		;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES1
	AOS	-1(P)
	JRST	RES1

SAVE2::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-1(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES2
	AOS	-2(P)
	JRST	RES2

SAVE3::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-2(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES3
	AOS	-3(P)
	JRST	RES3

SAVE4::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-3(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES4
	AOS	-4(P)
RES4:	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
P1POPJ::
RES1:	POP	P,P1
	POPJ	P,
;SUBROUTINE TO SAVE AND RESTORE TEMP ACS
;CALLED BY PUSHJ P,SAVT   RETURN EITHER CPOPJ OR CPOPJ1 WHEN THROUGH
SAVT::	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSH	P,T1		;AND T1
	MOVEM	T4,1(P)		;STORE PC
	MOVE	T4,-3(P)	;RESTORE T4
	PUSHJ	P,@1(P)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-4(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T1		;RESTORE T1
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
T4POPJ::POP	P,T4
	POPJ	P,		;AND RETURN

;SUBROUTINE TO SAVE AND RESTORE AC'S J AND W
SAVJW::	EXCH	J,(P)		;SAVE J AND GET THE RETURN
	PUSH	P,W		;SAVE W
	MOVEM	J,1(P)		;SAVE THE RETURN
	MOVE	J,-1(P)		;RESTORE J
	PUSHJ	P,@1(P)		;RETURN
	  SKIPA			;SKIP RETURN NO
	AOS	-2(P)		;SKIP RETURN YES
	POP	P,W		;RESTORE W
	PJRST	JPOPJ		;RESTORE J AND EXIT

;SUBROUTINE TO SAVE U,M, and W. USED MAINLY BY DECNET.
SAVUM::	EXCH	U,(P)		;SAVE U AND GET THE RETURN
	PUSH	P,M		;SAVE M
	PUSH	P,W		;SAVE W
	MOVEM	U,1(P)		;SAVE THE RETURN TO USER
	MOVE	U,-2(P)		;GET ORIGINAL VALUE OF U
	PUSHJ	P,@1(P)		;RETURN TO CALLING ROUTINE.
	 SKIPA			;NON-SKIP RETURN
	AOS	-3(P)		;SKIP RETURN, BUMP RETURN PC
	POP	P,W		;GET BACK VALUE OF W
	POP	P,M		;GET BACK VALUE OF M
	POP	P,U		;GET BACK VALUE OF U
	POPJ	P,		;RETURN TO TOP-LEVEL ROUTINE...

;COROUTINE TO SAVE AND RESTORE R
SAVR::	EXCH	R,(P)		;SAVE R, GET CALLER PC
	MOVEM	R,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	R,(P)		;RESTORE R
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RPOPJ
RPOPJ1::AOS	-1(P)
RPOPJ::	POP	P,R
	POPJ	P,

SAVP4::	EXCH	P4,(P)		;SAVE p4, GET CALLER PC
	MOVEM	P4,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P4,(P)		;GET BACK P4
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	 JRST	P4POPJ		;NON-SKIP RETURN
P4PPJ1:	AOS	-1(P)		;INCREMENT RETURN PC
P4POPJ:	POP	P,P4		;RESTORE OLD VALUE OF P4
	POPJ	P,

IFN FTKI10,<

.TRSET::PUSH	P,P4		;PRESERVE OLD P4
	MOVE	P4,P		;SETUP FRAME PTR
	ADD	P,(R)		;ALLOCATE SPACE
	PUSHJ	P,1(R)		;CONTINUE ROUTINE, EXIT VIA .+1
	 JRST[	MOVE P,P4	;CLEAR STACK
		POP P,P4	;RESTORE OLD P4
		POPJ P,]
	MOVE	P,P4		;HERE IF SKIP RETURN
	POP	P,P4
	JRST	CPOPJ1

.STKST::ADD	P,(R)		;BUMP STACK FOR VARIABLES USED
	PUSH	P,(R)		;SAVE BLOCK SIZE FOR RETURN
	PUSHJ	P,1(R)		;CONTINUE ROUTINE, EXIT TO .+1
	 JRST	STKRT0		; NON-SKIP RETURN COMES HERE
	POP	P,R		;SKIP RETURN COMES HERE-RECOVER COUNT
	SUB 	P,R		;ADJUST STACK TO REMOVE BLOCK
	JRST	CPOPJ1

STKRT0:	POP	P,R		;RECOVER COUNT
	SUB	P,R		;ADJUST STACK TO REMOVE BLOCK
	POPJ	P,		;DO NON-SKIP RETURN
>;KI10 version of .TRSET & .STKST

IFE FTKI10,<
;SUBROUTINE TO HANDLE "TRVAR" FOR DECNET. USES R AS A TRASH AC,
; AND P4 AS A FRAME POINTER.

.XTRST::
.TRSET::PUSH	P,P4		;SAVE THE OLD FRAME POINTER
	MOVE	P4,P		;MAKE A NEW FRAME POINTER
	ADJSP	P,@(R)		;ALLOCATE SIZE OFF OF STACK
	PUSHJ	P,1(R)		;AND RETURN TO USER
.TRRET:	 TRNA			;NON SKIP RETURN.
	 AOS	-1(P4)		;SKIP RETURN, BUMP RETURN PC
	MOVE	P,P4		;RESTORE STACK POINTER TO OLD POINTER
	POP	P,P4		;RESTORE OLD FRAME POINTER
	POPJ	P,		;AND RETURN
;SUBROUTINE TO HANDLE "STKVAR" FOR DECNET. USES R AS A TRASH AC

.XSTKS::
.STKST::ADJSP	P,@(R)		;ADD SOME WORDS ONTO THE STACK
	PUSH	P,(R)		;SAVE NUMBER OF WORDS ON STACK
	PUSHJ	P,1(R)		;AND RETURN TO CALLER
.STKRT:	JRST	.STKVT		;NON SKIP RETURN
	MOVN	R,(P)		;GET NEGATIVE WORDS SAVED
	ADJSP	P,-1(R)		;RETURN THEM, INCLUDING COUNT WORD
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN
.STKVT:	MOVN	R,(P)		;GET NEGATIVE WORDS SAVED
	ADJSP	P,-1(R)		;RETURN THEM
	POPJ	P,		;RETURN
>;END IFE FTKI10

;Extended BLT routine. Used mostly by DECnet.
XBLTAT::
XBLTA::
IFN FTKLP,<
	EXTEND T1,[XBLT]	;COPY FROM LAST MSD TO NEW USER DATA
>;END IFN FTKLP
IFE FTKLP,<
IFN FTKI10,<
	PUSH P,T2		;SAVE SOURCE
	ADDM T1,(P)		;POINT BEYOND LAST WORD COPIED
>;END IFN FTKI10
	HRLZS T2		;SOURCE IN LEFT HALF
	HRRI T2,(T3)		;DESTINATION IN LEFT HALF
	ADDI T3,(T1)		;LAST WORD BEYOND DESTINATION
	BLT T2,-1(T3)		;COPY THE WORDS
	SETZ T1,		;CLEAR NUMBER OF WORDS COPIED
IFE FTKI10,HLRZS T2		;AND LEAVE LAST SOURCE WORD COPIED HERE
IFN FTKI10,POP P,T2		;RESTORE COMPUTED LAST SOURCE WORD
>;END IFE FTKLP
	POPJ P,			;RETURN (IMPORTANT!)

;SUBROUTINE TO RETURN FROM DDT

GOBACK::SKIPL	.CPDWD
	JRST	DIECON##
	JRST	CLKDDR
IFN M.KI10!M.KL10,<
;ROUTINE TO COMPUTE THE NUMBER OF WORDS DESCRIBED IN AN IOLIST
;ENTER WITH T1=ADDR OF THE INITIAL CONTROL WORD
; AND WITH P1=LOC OF CHANNEL DATA BLOCK
;EXIT WITH T1=NUMBER OF GOOD WORDS TRNSFERRED
; T2=CORRECTIVE DATA FOR IOWD
; T3= N,,LOC OF FAILING IOWD   WHERE N=0 IF RH10, N=-1 FOR RH20
WRDCNT::TDZA	T2,T2
WRDCNX::MOVSI	T2,200000
	PUSHJ	P,SAVE4		;SAVE P1,P2
	MOVEI	P3,-1		;SET UP MASK
	HLLZ	P2,T2		;ASSUME 18 BIT CHAN
	SKIPGE	T2,CHB22B##(P1)	;IS IT?
	HRRI	P2,1		;NO, SET FOR 22-BIT
IFN FTKL10,<
	TLNE	T2,CP.RH2##	;RH20?
	HRROI	P2,2		;YES, SPECIAL STUFF
>
	ASH	P3,@ASH22B(P2)	;SHIFT MASK

	SETZ	P1,		;P1 WILL ACCUMULATE WRDCNT
	LDB	T3,CNTPT1(P2)	;L(IOWD)+1

	CAILE	T3,20		;IS IOWD LOC LEGAL?
	CAMLE	T3,SYSSIZ
	JRST	WRDCN5		;NO, WORD-COUNT=0
	LDB	T2,CNTPT2(P2)
	JUMPN	T2,WRDCN0

	MOVE	T3,T1		;YES, GET START OF LIST
WRDCNA:
	LDB	T2,CNTPT3(P2)
	JUMPN	T2,WRDCNB
	SKIPN	(T3)
	JRST	WRDCNC

	MOVE	T3,(T3)		;YES, GET ITS ADDRESS
	JRST	WRDCNA		;  AND TEST IT
WRDCNB:
	MOVE	T4,T3		;YES, SAVE LOC OF REAL IOWD IN T4
	AOJA	T3,WRDCNA	; AND TEST NEXT
WRDCNC:	AOS	T3,T4		;END - T3=L(LAST IOWD)+1
WRDCN0:
	LDB	T4,ADRPT2(P2)
	LDB	T2,ADRPT1(P2)	;LOC+1 OF GOOD DATA WRD
IFN FTKL10,<
	JUMPL	P2,[CAMLE T4,T2	;RH20 ADR IS 1 HIGHER
		    JRST WRDCN5	; SO EQUALS IS OK
		    MOVE P4,2(T1)  ;SAVE ENDING CHAN DATA FOR TEST
		    LDB T3,CNTPT2(P2)  ;WORDCOUNT
		    ADD T4,T3	;TOP ADDR +1 OF IOWD
		    JRST WRDCND]  ;CARRY ON
>

	CAML	T4,T2		;IS LAST DATA WRD IN BOUNDS?
	JRST	WRDCN5		;NO, ASSUME THAT IOWD IS NG
	HLRO	T3,-1(T3)	;MAYBE
	ASH	T3,@ASH22B(P2)	;WORD COUNT

	SUB	T4,T3		;LAST GOOD ADR IN IOWD+1
WRDCND:	CAMGE	T4,T2		;IS WORD IN BOUNDS?
	JRST	WRDCN5		;NO
	LDB	T1,ADRPT3(P2)

WRDCN1:	SKIPN	(T1)		;IS THERE AN IOWD?
	JRST	WRDCN5		;NO, THE DF10 LIED!
IFN FTKL10,<
	JUMPL	P2,[CAMN P4,(T1)	;THIS IOWD WHAT THE RH20 STORED?
		    JRST WRDCNF	;YES. THE LAST IOWD IS LAST IT DID
		    LDB T4,[POINT 11,(T1),13]
		    MOVNS	T4	;11 BITS OF NEGATIVE WDCNT
		    JRST	WRDCNE]
>
	HLRO	T4,(T1)		;WDCNT OF IOWD
	ASH	T4,@ASH22B(P2)	;WORD COUNT
WRDCNE:	LDB	T3,ADRPT3(P2)	;1ST ADDR OF IOWD -1

	TRNN	T4,(P3)		;IF RH 14 BITS=0
	JRST	WRDCN3		; ITS A CHAN JUMP
	CAMG	T2,T3		;GOOD DATA WD IN THIS IOWD?
	JUMPN	T3,WRDCN2	;YES, COUNT THE DATA AND STEP TO NEXT
	SUB	T3,T4		;MAYBE. ADR OF TOP WD IN IOWD
	CAMG	T2,T3		;LAST GOOD DATA IN IOWD?
	JRST	WRDCN4		;YES
WRDCN2:	SUB	P1,T4		;THIS IOWD IS GOOD. COUNT # OF WDS
	HRLS	T1		;SAVE LOC OF GOOD IOWD
	AOJA	T1,WRDCN1	;AND GO TEST NEXT IOWD
WRDCN3:	JUMPE	T3,WRDCN5	;DF10 BLEW IT IF THIS THE END OF THE LIST
	MOVE	T1,T3		;CHAN JUMP - SET T1 TO ADR
	JRST	WRDCN1		;OF IOWD AND TEST IT


;HERE WITH T1=LOC OF FAILING IOWD,  P1=NO OF WDS IN PREVIOUS IOWDS
;T2=TERMINATION WORD, T3=ADDR+COUNT
;I.E. ON RH10 T3=<LAST WORD>, ON RH20 T3=<LAST WORD>+1
WRDCN4:
;IF THE ERROR IS IN THE MIDDLE OF AN IOWD,
;THE RH10 STORES <LAST WORD XFERED>+1 IN THE
;TERMINATION WORD. BUT IF THE ERROR IS IN THE LAST
;SECTOR OF THE LAST IOWD, THEN THE RH10 MERELY
;STORES <LAST WORD XFERED>
	CAMN	T2,T3		;LAST SECTOR OF IOWD?
	TLNE	P2,600000	;AND RH10?
	CAIA			;NO, RH20 OR NOT LAST
	ADDI	T2,1		;YES, ADD FUDGE FACTOR
	LDB	T3,ADRPT3(P2)
	TLNN	P2,600000
	ADDI	T3,1
	SUB	T2,T3		;NO OF GOOD DATA WDS IN IOWD
	ADD	P1,T2		;P1=TOTAL GOOD WORDCOUNT
	JUMPE	P1,WRDCN6	;NO CORRECTION IF NO DATA
	CAIG	T2,1		;IF ONLY 1 WORD
	TRNE	P1,BLKSIZ##-1	;OR NOT AN EVEN MULTIPLE OF 200 WORDS
	JRST	WRDCN6		;NO CORRECTION DATA (CHANNEL BLEW IT)
	SUB	P1,T2		;NUMBER OF REMAINING WORDS
WRDCNF:	HLRZS	T3,T1		;ADDRESS OF IOWD
	LDB	T2,CNTPT3(P2)	;GET ORIGINAL COUNT OF THIS IOWD
	JUMPL	P2,WRDCN6	;GO IF RH20
	HLRO	T2,(T3)		;RH10, MUST GET +COUNT
	ASH	T2,@ASH22B(P2)
	MOVNS	T2
WRDCN6:	MOVEI	T3,T2		;T2 WILL GET THE ANSWER
	SKIPL	P2		;RH10?
	SKIPA	T4,T2		;YES, GET - COUNT
	MOVN	T4,T2		;NO, ALREADY HAVE -COUNT
	DPB	T4,CNTPT3(P2)	;SAVE LH CORRECTION DATA
	SKIPGE	T3,P2		;RH20?
	TLO	T2,700000	;YES, ALLOW FOR CARRY INTO BIT 2
	HRR	T3,T1		;RH OF CORRECTION DATA
	SKIPA	T1,P1		;TOTAL NO OF GOOD WORDS
WRDCN5:	SETZB	T1,T3		;WE LOSE, ZERO MEANINGFUL ACS
	POPJ	P,		;RETURN WITH ANSWER


ADRPT1::POINT	18,1(T1),35
	POINT	22,1(T1),35
	POINT	22,2(T1),35
ADRPT2::POINT	18,-1(T3),35
	POINT	22,-1(T3),35
	POINT	22,-1(T3),35
ADRPT3::POINT	18,(T1),35
	POINT	22,(T1),35
	POINT	22,(T1),35
CNTPT1::POINT	18,1(T1),17
	POINT	14,1(T1),13
	POINT	22,1(T1),35
MSK22B::XWD	0,-1
	XWD	17,-1
	XWD	17,-1
WDCPNT::POINT	18,0(P1),17
	POINT	14,0(P1),13
	POINT	14,0(P1),13
	POINT	14,0(P1),13
CNTPT2::POINT	18,-1(T3),17
	POINT	14,-1(T3),13
	POINT	11,-1(T3),13
CNTPT3::POINT	18,(T3),17
	POINT	14,(T3),13
	POINT	11,(T3),13
CNTPP2::POINT	11,P2,13
ADRPT4::POINT	18,T1,17
	POINT	14,T1,13
ASH22B::0
	0,,-4
	0,,-7
JMPRH2==:077760		;THESE (LH) BITS ARE 0 FOR AN RH20 JUMP-WORD
CNTFIL::0
	XWD	-1,740000

>;END IFN M.KI10!M.KL10

;SUBROUTINE TO EXECUTE A SUBROUTINE OVER ALL CPU'S
;CALLING SEQUENCE:
;	MOVEI	T1,SUBROUTINE TO BE EXECUTED, OR
;	HRROI	T1,IF SUBROUTINE SHOULDN'T BE EXECUTED ON THIS CPU
;	PUSHJ	P,CPUAPP
;SUBROUTINE IS CALLED WITH P1 POINTING AT A CPU CDB
; FOR WHICH THE DESIRED ACTION IS TO BE APPLIED

CPUAPP::PUSHJ	P,SAVE1		;SAVE P1
IFE CPUN-1,<
	JUMPL	T1,CPOPJ	;RETURN IF NOT TO BE APPLIED TO .CPSLF
	MOVEI	P1,.C0CDB	;ONLY CPU0
	JRST	(T1)		;DO IT
>
IFN CPUN-1,<
	TLZ	T1,377777	;ZERO @(?)
	PUSH	P,T1		;SAVE ADDRESS OF SUB
	MOVEI	P1,.C0CDB	;START WITH CPU0
CPUAP1:	SKIPGE	(P)		;CALL SUB ON SELF CPU?
	CAME	P1,.CPSLF	;OUR CPU?
	PUSHJ	P,@(P)		;NO, CALL THE SUBROUTINE
	  JFCL			;ALLOW FOR A SKIP RETURN
	HLRZ	P1,.CPCDB-.CPCDB(P1) ;NEXT CDB
	JUMPN	P1,CPUAP1	;NEXT CPU
	JRST	TPOPJ		;RETURN
>
;RMWDPB - SIMULATE CPNSER'S RMWDPB FOR WHEN CPNSER NOT LOADED.
;CALLING SEQUENCE:
;	FROM ...DPB - SEE MACRO IN S.MAC
;ALL ACS PRESERVED.

IFE <CPUN-1>,<IFN FTKLP&FTMP&FTDOTD,<
RMWDPB::PUSH	P,@(P)		;SAVE POINTER TO BYTE POINTER
	PUSH	P,@(P)		;SAVE BYTE POINTER
	PUSH	P,[DPB 0,-1(P)] ;A DEPOSIT BYTE INSTRUCTION
	PUSH	P,T1		;SAVE SCRATCH AC
	LDB	T1,[POINT 4,-3(P),12] ;FIND OUT WHICH AC
	DPB	T1,[POINT 4,-1(P),12] ;AC TO DO IN DPB INSTRUCTION
	POP	P,T1		;GET BACK ORIGINAL VALUE OF T1
	XCT	(P)		;DO THE DEPOSIT BYTE
	ADJSP	P,-4		;POP JUNK OFF STACK
	POPJ	P,

	>;END OF IFN FTKLP&FTMP&FTDOTD
>;END OF IFE <CPUN-1>
	$ABS			;MUST BE IN LOW SEG FOR ONCE REFERENCES

;SUBROUTINE TO REFERENCE A MEMORY LOCATION IN PHYSICAL MEMORY
;CALLING SEQUENCE:
;	MOVE	U,ABSOLUTE ADDRESS TO REFERENCE
;	PUSHJ	P,REFMEM
;	...	RETURN HERE
;T1 CONTAINS THE CONTENTS OF THE LOCATION SPECIFIED BY U

REFMEM::PUSH	P,P1		;CAN'T USE SAVE1
	MOVE	P1,U
	LSH	P1,W2PLSH
IFE FTKLP,<
	MOVEI	P1,PM.ACC+PM.WRT(P1)
>
IFN FTKLP,<
	HRLI	P1,(<PM.DCD>B2+PM.WRT)
>
	PUSH	P,P3
	MOVE	P3,.CPMAP
IFE FTKLP,<
	HRLM	P1,.EPPM-.EPMP(P3)
>
IFN FTKLP,<
	MOVEM	P1,.EUPMP/PAGSIZ(P3)
>
	CLRPGT	(0,.EUPMP)
	MOVE	P1,U
	ANDI	P1,PG.BDY
	IORI	P1,.EUPMP
IFN FTKL10!FTKS10,<
	MOVEI	P3,REFME2
IFE FTKLP,<
	HRLI	P3,(XC.UIO)
>
IFN FTKLP,<
	PUSH	P,.UPMP+.LMPFN+1
	MOVEM	P3,.UPMP+.LMPFN+1
>
	EXCH	P3,.UPMP+.LMPFN
	SETZ	T1,
>
	MOVES	T1,(P1)
IFN FTKL10!FTKS10,<
REFME2:	MOVEM	P3,.UPMP+.LMPFN
IFN FTKLP,<
	POP	P,.UPMP+.LMPFN+1
>
>
	POP	P,P3
	POP	P,P1
	POPJ	P,

	$HIGH
IFN M.KS10,<
;ROUTINE TO COMPUTE THE NUMBER OF WORDS TRANSFERRED IN THE LAST I/O OPERATION
;THROUGH THE UNIBUS ADAPTER LINKED TO THE CHANNEL DATA BLOCK POINTER TO BY
;P1. FINAL ADDRESS IS IN T1.
;RETURNS CPOPJ ALWAYS WITH THE NUMBER OF GOOD WORDS TRANSFERRED IN T1.

WRDCNT::HRRZ	T2,CHNIEA##(P1)	;GET INITIAL ELEVEN STYLE ADDRESS
	SUB	T1,T2		;SUBTRACT FROM FINAL ADDRESS
	LSH	T1,-2		;GET INTO TEN STYLE WORDS
	POPJ	P,		;AND RETURN

>;END IFN M.KS10
SUBTTL	DAEMON ERROR REPORT BLOCK

	$ABS
IFN FTDAEM,<
IFNDEF	ERPTMX,<ERPTMX==:^D80>	;LENGTH OF BLOCK FOR ERRORS

ERPTBK::BLOCK	ERPTMX		;BLOCK FOR ERRPT. UUO
ESVIDX::EXP	0		;POINTER FOR STORING IN ERPTBK
EPKIDX::EXP	0		;POINTER FOR PICKING UP FROM ERPTBK
ERRLAP::EXP	0		;COUNTER FOR OVERFLOWS OF ERPTBK (LOST ERRORS)
>
SUBTTL SYSTEM BYTE POINTERS

$HIGH

PUUOAC::POINT	4,M,12		;UUO AC FIELD
PIOMOD::POINT	4,S,35		;MODE BITS
XP PJBNLH,001100		;LEFT HALF OF "POINT 9,XXX,35"
PJOBN::	POINT	9,DEVJOB(F),35	;DEVICE JOB ASSIGNMENT
PUNIT::	POINT	9,DEVJOB(F),26	;DEVICE UNIT NUMBER
PJBSTS::POINT	JWSIZ,JBTSTS(J),JWPOS	;JOB WAIT STATE (QUEUE) CODE
				;IN JOB STATUS WORD
PJBST2::POINT	JS.SIZ,JBTST2(J),JS.POS	; JOB QUEUE NUMBER (NOT STATE CODE)
PJ2ST1::POINT	JS.SIZ,JBTST2(T1),JS.POS ;SAME AS PJBST2 FOR IDX T1
JBYEWT::POINT	ESLPSZ,JBTST2(J),ESLPBP	;EVENT WAIT REASON
JBYICC::POINT ICCSIZ,JBTSTS(J),ICCPOS  ;POINTER TO HIGH
				; SEGMENT IN CORE COUNT
PDVSTA::POINT	6,DEVSTA(F),35	;STATION NUMBER OF DEVICE
PBUFSZ::POINT	17,DEVCHR(F),35	;BUFFER SIZE
PDVTIM::POINT	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
					;BE ACTIVE BEFORE BEING DECLARED
					;HUNG. N MEANS 2^N-1 SECONDS
PDVCNT::POINT	7,DEVCHR(F),16	;COUNTED DOWN EACH SECOND,
				;1 TO 0 TRANSITION MEANS HUNG DEVICE
IADPTR::POINT	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
				; ON THIS DEVICE (DECTAPE ONLY)
IFN FTSPL,<
DEYSPL::POINT	8,DEVSPL(F),17	;SPOOL BIT ASSOCIATED WITH DEVICE
>
DEYTYP::POINT	8,DEVTYP(F),9	;POINTER TO DEVICE-TYPE BIT (+.TYVAR & .TYRAS)

PDVTYP::POINT	6,DEVTYP(F),9	;JUST DEVICE TYPE
PCORSZ::POINT	CRSIZ,JBTADR(J),CRPOS	;BYTE POINTER TO LOW OR HIGH SEG CORE SIZE-1

	$ABS
CORE2P::POINT	CTNBPE,CORTAB	;BYTE POINTER TO CORE ALLOCATION TABLE
	$HIGH

COREP::	POINT	CTNBPE,CORTAB	;CTNBPE BIT POINTER TO CORE ALLOCATION TABLE
PDYQT2::POINT	PDSQNT,.PDQNT(T2),PDNQNT
PDYQNT::POINT	PDSQNT,.PDQNT(W),PDNQNT ;POINTER TO QUANTUM RUN TIME FOR JOB
PDYIPT::POINT	PDSIPT,.PDIPT(W),PDNIPT ;POINTER TO INCORE PROTECT TIME
PDYIP2::POINT	PDSIPT,.PDIPT(T1),PDNIPT ;POINTER TO INCORE PROTECT TIME
PDYDPT::POINT	9,.PDDFL(W),8	;DEFAULT PROTECTION
PDYBFN::POINT	9,.PDDFL(W),35	;DEFAULT NUMBER OF DISK BUFFERS
IFN FTFDAE,<
PDYFSP::POINT	9,.PDDFL(W),26	;FILE DAEMON SUPPLIED PROTECTION
>
PIEVM::	POINT	9,DEVEVM(F),8	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE
				; EXEC MAP ALLOCATED TO THIS DEVICE FOR BUFFERED INPUT
PIEVMS::POINT	9,DEVEVM(F),17	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR BUFFERED INPUT
POEVM::	POINT	9,DEVEVM(F),26	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE
				; EXEC MAP ALLOCATED TO THIS DEVICE FOR BUFFERED OUTPUT
POEVMS::POINT	9,DEVEVM(F),35	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR BUFFERED OUTPUT
	XP	PDEVM,POEVM	;VIRTUAL PAGE NUMBER OF STARTING PAGE IN THE EXEC
				; MAP ALLOCATED TO THIS DEVICE FOR DUMP I/O
	XP	PDEVMS,POEVMS	;NUMBER OF PAGES IN THE EXEC MAP ALLOCATED TO
				; THIS DEVICE FOR DUMP I/O
PDVESE::POINT	9,DEVESE(F),35	;EXTENDED ERROR STATUS
IFN FTMP,<
DEYCPF::POINT	3,DEVCPU(F),2	;1ST CPU OWNING DEVICE
DEYCPS::POINT	3,DEVCPU(F),5	;2ND CPU OWNING DEVICE
DEYPCL::POINT	3,DEVCPU(F),8	;0 FOR NON-Q PROTOCOL, CPU DOING IO FOR QUEUED
DEYCPU::POINT	3,DEVCPU(F),11	;CPU WHICH LAST DID INPUT OR OUTPUT UUO
MPYNRN::POINT	6,JBTSPS(J),5	;NOT RUNNABLE ON CPUN FIELD
>
NFYPGS::POINT	MCPSIZ,JBTPDB(J),MCPBPP ;POINTER TO NUMBER OF FUNNY PAGES
IFYPGS::POINT	MCPSIZ,JBTPDB(J),IMCPBP ;NUMBER OF FUNNY PAGES TO SWAP IN

	IFG	SYS50N, <	;SWAPPING SYSTEM ?
	INMSK==:000777		;RH MASK TO IMGIN
	INLEFT==:12		;NUMBER OF BITS TO SHIFT TO LEFT JUSTIFY IN RH
IMGIN::	POINT	9,JBTSWP(J),35	;BYTE POINTER FOR # 1K BLOCKS OF CORE
				;WHEN JOB OR HIGH SEG NEXT SWAPPED IN
				;NON-ZERO ONLY WHEN SWAPPED OUT
IMGOUT::POINT	9,JBTSWP(J),26	;BYTE POINTER FOR # 1K BLOCK OF DISK
				;WHEN JOB OR HIGH SEG HAS IMAGE ON DISK
				;ZERO MEANS NO DISK SPACE ALLOCATED
	OUTMSK==:777000		;RH MASK TO IMGOUT. USED TO TEST FOR 0
				; (IE NO DISK SPACE)
IMGINT::POINT	9,JBTSWP(F),35	;POINTER TO INCORE IMAGE
IMGIP3::POINT	9,JBTSWP(P3),35
>

JBYSPR::POINT	JBSSPR,JBTSTS(J),JBNSPR	;HIGH SEG ACCESS PRIVILEGES


IFG SYS50N,<			;SWAPPING SYSTEM?
IFN LEVDN,<JBYSUN::POINT	3,JBTSWP(J),4
JBYLKN::POINT	13,JBTSWP(J),17
>	;END CONDITIONAL ON LEVDN
>	;END OF CONDITIONAL ON 10/50S
IFN FTWATCH,<		;WATCH JOB STATISTICS FEATURE?
JBYWCH::POINT	23,JBTWCH(J),35	;BYTE POINTER TO TIME OF DAY STARTED WAITING
				;END FT WATCH
>
	JBYLCR::POINT	9,JBTLIM(J),^L<JB.LCR>+8 ;CORE LIMIT POINTER
JBYLTM::POINT	36-^L<JB.LTM>,JBTLIM(J),35 ;TIME LIMIT POINTER

IFN FTNSCHED,<
JBYCLS::POINT 5,JBTSCD(J),17	;POINTER TO CLASS FOR JOB.
JBYCL1::POINT 5,JBTSCD(T1),17	;DITTO FOR IDX T1
JBYCL4::POINT 5,JBTSCD(T4),17	;DITTO FOR IDX T4
>;END IFN FTNSCHED

PDVIAD::POINT 22,DEVIAD(F),35	;POINTER FOR STORING EVA OF CURRENT INPUT BUFFER
PDVOAD::POINT 22,DEVOAD(F),35	;POINTER FOR STORING EVA OF CURRENT
				; OUTPUT BUFFER

JBYLSA::POINT 13,JBTAD2(J),35  ;POINTER TO PHYSICAL PAGE NO. OF FIRST PAGE
				; OF THIS LOW SEGMENT
JBYHSA::POINT 13,JBTHSA(J),35	;POINTER TO PHYSICAL PAGE NO. OF FIRST PAGE
				; OF THIS HIGH SEGMENT
JBYHSO::POINT 9,JBTUPM(J),8	;VIRTUAL PAGE NUMBER OF HIGH SEGMENT ORIGIN
JBYLSS::POINT 9,JBTAD2(J),17	;NO. OF PAGES-1 IN THE LOW SEGMENT THE
				; LAST TIME THE MAP WAS SET UP
JBYHSS::POINT 9,JBTUPM(J),8	;NO. OF PAGES-1 IN THE HIGH SEGMENT THE
				; LAST TIME THE MAP WAS SET UP
LSTBAS::POINT 7,.PDACS+ACTSTL-1(W),34  ;LAST BYTE IN ACCOUNT STRING

JBYDEB::POINT 2,JBTST2(J),2	;DEFERRED ECHO BITS
	$ABS
SUBTTL PI CHANNEL SAVE/RESTORE
;DEFINE PI CHANNEL SAVE AND RESTORE ROUTINES IF A DEVICE IS ON THE CHANNEL

	PDL==201		;LENGTH OF INTERRUPT PI PUSH DOWN LIST

DEFINE CHAN (PI)<
;	XLIST
	IFNDEF	HIAC'PI,<HIGHAC==:13>
	IFDEF	HIAC'PI,<
	IFGE	HIAC'PI-10,<HIGHAC==:HIAC'PI>
	IFL	HIAC'PI-13,<HIGHAC==:13>
>	;IFDEF
	IFG	RTTRPN,<HIACBL==17>
	IFE	RTTRPN,<HIACBL==HIGHAC>
CH'PI::	0		;PC STORED HERE BY JSR ON INTERRUPT TO CHANNEL PI
IFE FTKLP,<
	JEN	@CH'PI		;LAST INSTRUCTION ON CONSO DEV, CHAIN
>
IFN FTKLP,<
	0
	EXP	IC.UOU
	EXP	.+1
	XJEN	CH'PI
>

DEFINE FSTCHN,<
ZZS==0
IFN M.KL10!M.KS10,<
IFE <PI&7-SCNCHN>,<ZZS==2>	;USE EXEC AC BLOCK 2 ON SCANNER CHANNEL
IFE <PI&7-DSKCHN>,<ZZS==3>	;USE EXEC AC BLOCK 3 ON DSK CHANNEL
IFE <PI&7-NETCHN>,<ZZS==4>	;USE EXEC AC BLOCK 4 ON NETWORK
>
>

DEFINE INTL.(X)<INTL'X>

DEFINE INTL<
	<IFN <PI&7>-DSKCHN,<INTL'PI>>
	+<IFE <PI&7>-DSKCHN,<INTL.(\DSKCHN)>>
>

DEFINE INTO.(X)<INTO'X>
DEFINE INTO<
	<IFN <PI&7>-DSKCHN,<INTO'PI>>
	+<IFE <PI&7>-DSKCHN,<INTO.(\DSKCHN)>>
>
;CHAN DEFINITION CON'T ON NEXT PAGE
;CONTINUE CHAN DEFINITION

;HERE FROM AN INTERRUPT ROUTINE WHICH HAS FOUND ITS DEVICE NEEDS SERVICE
;SAVE ACS 0 THRU HIGHAC, CALLED BY JSR, SETS UP P TO PUSH DOWN LIST FOR THIS PI
	FSTCHN		;ZZS NON-ZERO IF SCANNER OR DSK PI SAVE ROUTINE

SAV'PI::	0		;CALLED BY JSR
IFN M.KL10,<
	DATAI	PAG,SVPG'PI	;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)		;SET EXEC AC BLOCK
;	XLIST
>
IFN M.KS10,<
	RDUBR	SVPG'PI		;REMEMBER OLD AC BLOCK #
	EXECAC	(ZZS)
	XLIST
>
IFE ZZS,<
	MOVEM	HIGHAC,SVAC'PI+HIGHAC	;SAVE AC HIGHAC
IFG RTTRPN,<
	SKIPN	HIGHAC,.CPRTT	;ALWAYS SAVE ACS IF RTTRP IS IN PROGRESS
>
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF EXEC MODE
	JRST	SAV'PI'A	;NO, DON'T NEED TO SAVE AC'S
	MOVEI	HIGHAC,SVAC'PI	;SETUP TO SAVE 0 THRU HIGHAC-1
	BLT	HIGHAC,SVAC'PI+HIGHAC-1	;SAVE ACS
>
SAV'PI'A:MOVE	P,C'PI'PDP	;SETUP PUSH DOWN POINTER
	MOVSI	(IC.UOU)	;TURN ON USER IOT SO XCT PAGED WILL
	HLLM	SAV'PI		; REFERENCE USER RATHER THAN EXEC VIRTUAL MEMORY
IFN M.KL10,<
	MOVE	[LG.LPC!LG.LUB!LG.IAM]
	XORM	SVPG'PI
>
IFN FTMP,<
	AOSE	INTL		;WAIT FOR INTERLOCK
	LSTALL
IFN M.KI10,<
	CONI	PAG,INTO
>
IFE M.KI10,<
	APRID	INTO
>
>
	JRST	2,@SAV'PI	;RETURN TO CALLER AND PROCESS INTERRUPT

;HERE FROM INTERRUPT ROUTINE WHEN IT HAS FINISHED SERVICING INTERRUPT
;RESTORE ACS AND DISMISS INTERRUPT
;USUALLY TRANSFERRED TO BY POPJ P,

	$HIGH
RET'PI::
IFN FTMP,<
	SETOM	INTO		;NO LONGER OWN
	SETOM	INTL		;GIVE UP INTERLOCK
>
IFE ZZS,<
IFN M.KI10,<
IFG RTTRPN,<
	SKIPN	HIGHAC,.CPRTT	;RESTORE SAVED ACS IF RTTRP IS IN PROGRESS
>
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF USER MODE
	JEN	@CH'PI		;YES, AC'S WEREN'T SAVED
>
IFN M.KL10,<
IFG RTTRPN,<
	SKIPN	HIGHAC,.CPRTT	;RESTORE SAVED ACS IF RTTRP IS IN PROGRESS
>
	MOVE	HIGHAC,CH'PI	;GET INTERRUPT PC
	TLNE	HIGHAC,(XC.USR)	;WAS THE INTERRUPT OUT OF USER MODE?
	JRST	CH'PI'XIT	;YES--AC'S WERE NOT SAVED
>
	MOVSI	HIGHAC,SVAC'PI	;RESTORE ACS 0 THRU HIGHAC
	BLT	HIGHAC,HIGHAC
>
IFN M.KL10,<
CH'PI'XIT:
	DATAO	PAG,SVPG'PI	;RESTORE OLD AC BLOCK #
>
IFN M.KS10,<
CH'PI'XIT:
IFE ZZS,<
	WRUBR	SVPG'PI		;RESTORE OLD AC BLOCK #
>
IFN ZZS,<
	MOVE	17,SVPG'PI	;CONTENTS OF THE UBR AT THE INTERRUPT
	TLZ	17,(SG.LUB)	;ONLY RESTORE AC SETS
	WRUBR	17		;RESTORE ACS AT INTERRUPT TIME
>
>
C'PI'JEN::
IFE FTKLP,<
	JEN @CH'PI	;DISMISS INTERRUPT ON THIS PI CHANNEL
>
IFN FTKLP,<
	XJEN	CH'PI
>
	$ABS

IFG RTTRPN,<
IFN M.KI10,<
		RTPOPN==24
>	;END IFN M.KI10
IFN M.KL10,<
	RTPOPN==27+IFN FTKLP,<1>
>	;END IFN M.KL10
IFN M.KS10,<
	RTPOPN==0
>
		RETPD'PI==:C'PI'PD1+RTPOPN
		RTOFST==:CHD'PI-CHND'PI

CHND'PI::	HRROI P,RETPD'PI
		IFLE PI-AP0CHN,<JSP J,DSMAPR>
		IFG  PI-AP0CHN,<JSP J,DISMIS>
RTRT'PI::	MOVSI 17,SVAC'PI	;RESTORE AL OF THE AC'S
		BLT 17,17
IFN M.KL10,<
		DATAO PAG,SVPG'PI	;RESTORE AC BLOCK
>	;END IFN M.KL10
IFN M.KS10,<
		WRUBR	SVPG'PI		;RESTORE AC BLOCK
>
IFE FTKLP,<
		JEN @CH'PI		;DISMISS
>
IFN FTKLP,<
		XJEN	CH'PI
>

RTSV'PI::	0			;COME HERE TO SAVE ALL AC'S
IFN M.KL10,<
		DATAI PAG,SVPG'PI	;SAVE AC BLOCK
		EXECAC			;SET EXEC AC BLOCK
>	;END IFN M.KL10
IFN M.KS10,<
		RDUBR	SVPG'PI		;SAVE AC BLOCK
		EXECAC			;SET EXEC AC BLOCK
>
		MOVEM 17,SVAC'PI+17	;SAVE 17
		MOVEI 17,SVAC'PI	;SET UP BLT POINTER
		BLT 17,SVAC'PI+16	;SAVE THE AC'S
		MOVE P,C'PI'PDP		;SET UP P POINTER
		MOVSI (IC.UOU)		;TURN ON USER IOT SO PAGED XCT
		HLLM RTSV'PI		; WILL REFERENCE USER VIRTUAL
		JRST 2,@RTSV'PI		;RETURN TO CALLER

CHD'PI::		EXP ENBSTD
		Z	;STORAGE LOCATION FOR PROTECTION-RELOCATION VALUE.
		Z	;STORAGE LOCATION FOR APR ENABLE BITS.
>	;IFG RTTRPN

IFN M.KL10!M.KS10,<
SVPG'PI::	BLOCK	1
>
SVAC'PI::	BLOCK HIACBL+1	;PLACE TO SAVE ACS 0 THRU HIGHAC
C'PI'PDP::	XWD -PDL+1,.+1		;INITIAL PUSH DOWN POINTER
C'PI'PD1::	EXP RET'PI	;FIRST WORD ON LIST,
				; POPJ WILL RETURN TO DISMISS INTERRUPT
	BLOCK	PDL-1		;PUSHDOWN LIST SPACE
	LIST
>	;END OF CHAN DEFINITION

;SET USED'N TO BE NON-ZERO FOR ALL CHANNELS
;THAT NEED CHANNEL SAVE ROUTINES
;THIS INCLUDES ALL CHANNELS WHICH RTTRP MAY USE
IFN FTRTTRP,<
	DEFINE	SETUSED(PI)
	<CUSD'PI==:USED'PI
	IFE	USED'PI,<IFDEF UNIQ'PI,<IFE UNIQ'PI,<USED'PI=:-1>>
IFN M.TD10,<
IFE PI-DADCHN,<CUSD'PI==:1	;DON'T ALLOW FAST BLOCK MODE ON DTA DATA CHN
>>
					IFNDEF UNIQ'PI,<USED'PI=:-1>>
>	;DEFINE SETUSED

	ZZ==-1
	REPEAT M.CPU,<
	ZZ==ZZ+2
	REPEAT 6,<
	SETUSED(\ZZ)
	ZZ==ZZ+1
>>
>	;IFN FTRTTRP
IFN M.KL10!M.KS10,<
IFG CPUN-1,<LOC	<.+777>&777000>
CSHFIR==:.
;NULL JOB DUMP AC AREA:

DEFINE NULDAC(N)<
NU'N'DAC::BLOCK	20
	XP NU'N'DAT,NU'N'DAC-20
>
ZZ==0
REPEAT M.CPU,<
	NULDAC(\ZZ)
ZZ==ZZ+1
>
ERPDLL==43
ERRPLL==:-ERPDLL+1
DEFINE PDLDEF(N)<
IFE N,<
ERRPDL::
>
ER'N'PDL::
	BLOCK	ERPDLL
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>
>;END IFN M.KL10!M.KS10

MNULPD=:-161+1			;LENGTH OF NULL PDL

DEFINE PDLDEF(N)<
IFE N,<
NULPDL::
>
NU'N'PDL::
MNU'N'PD==MNULPD
	BLOCK	-MNULPD
>
ZZ==0
REPEAT M.CPU,<
PDLDEF (\ZZ)
ZZ==ZZ+1
>
IFLE <CPUN-1>,<NU1PDL==:NULPDL>
;GENERATE THE CHANNEL SAVE ROUTINE ONLY FOR PI WHICH NEED THEM (ASGSAV MACRO USED)

;GENERATE NULL CHANNEL SAVE ROUTINES FOR THOSE CHANNELS NOT USED

DEFINE NULL (PI)<
CH'PI::	0
IFE FTKLP,<
	JEN	@CH'PI
>
IFN FTKLP,<
	0
	EXP	0
	EXP	.+1
	XJEN	CH'PI
>
>

	DEFINE	USED(PI)<
		IFN USED'PI, <CHAN PI>
		IFE USED'PI, <NULL PI>
	>;END DEFINE USED
	ZZ==0
	REPEAT M.CPU,<
	ZZ==ZZ+1
	REPEAT 7,<
		USED \ZZ
	ZZ==ZZ+1
	>
	>
;NOW DEFINE DURING PASS 1 A FEW NECESSARY SYMBOLS

	DEFINE	DEFCHL(A,B)
<	A'CHL==:CH'B>

	DEFINE CALCHL(A,B)<
		DEFCHL (<A'B>,\A'B'CH1)
	>;END DEFINE CALCHL
	ZZ==0
	REPEAT M.CPU,<
		CALCHL(AP,\ZZ)
		CALCHL(CK,\ZZ)
	ZZ==ZZ+1
	>;END REPEAT M.CPU

SUBTTL	GENERATE COMMON INTERRUPT ROUTINES FOR ALL PROCESSORS

;MACRO FOR CTY INTERRUPTS ON KI10'S

DEFINE	GCTYI(CPU,CHN),<
IFN FTKI10,<
CTY==120
CT'CPU'INT::CONSO	CTY,50
	JRST	.-1
	JSR	SAV'CHN
	MOVEI	U,CT'CPU'LIN
	PJRST	CTYINT##
>> ;END FTKI10 AND DEFINE GCTYI

;MACRO TO MAKE THE INTERRUPT SKIP CHAIN ENTRY'S FOR THE NETSER
; SOFTWARE INTERRUPT. (ONE ENTRY PER CPU)

DEFINE	GCNET(CPU,CHN),<
IFN M.NET,<
NT'CPU'INT::SKIPN	.CPNTF
	JRST	.-1
	JSR	SAV'CHN
	PJRST	NETINT##
>> ;END M.NET AND DEFINE GCNET

;MACRO TO GENERATE CLOCK (CH7) INTERRUPT CHAIN

DEFINE	GCCLK(CPU),<
CK'CPU'INT:SKIPN	.CPCKF
	JRST	.-1
	JRST	CLKINT##
> ;END GCCLK MACRO



;NOW EXPAND ALL THE ABOVE MACROS FOR EACH CPU IN THE CONFIG.
	$HIGH

ZZ==0
REPEAT CPUN,<
	GCTYI(\ZZ,\<ZZ*10+SCNCHN>)
	GCNET(\ZZ,\<ZZ*10+NETCHN>)
	GCCLK(\ZZ)
ZZ==ZZ+1
> ;END REPEAT CPUN
	$ABS



	SUBTTL	COMMAND TABLE



;BITS CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE

NOCORE==:1B18	;NO CORE NEEDED FOR COMMAND
NOJOBN==:1B19	;NO JOB NUMBER NEEDED FOR COMMAND
NOLOGIN==:1B35	;JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT==:1B34	;COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
NORUN==:1B33	;AN EXPLICIT ^C MUST BE TYPED BY USER BEFORE COMMAND
		; IS EXECUTED IF JOB IS RUNNING
		; JOB MUST BE SWAPPED IN IF IT HAS LOGICAL CORE
INCORE==:1B32	;COMMAND MUST BE DELAYED IF JOB HAS LOGICAL CORE
		; WHICH IS ON DISK OR ON ITS WAY IN OR OUT.
		; JOB WILL BE SWAPPED IN (SEE DLYCOM)
		; AND IS NOT SITTING QUIETLY IN CORE(IE NO SWAPPING TRANSFER)
NXONLY==:1B31	;NOT LEGAL IF EXECUTE ONLY PROGRAM
NBATCH==:1B30	;NOT LEGAL FROM BATCH JOB


;BITS PLACED IN LH(M) AND CHECKED AFTER RETURN FROM COMMAND SETUP ROUTINE

CUSTMR==:1B29	;RESERVED TO CUSTOMERS
NOINCK==:1B28	;NO CHECK FOR JOB INITIALIZATION (JNA=0)
NOCRLF==:1B27	;NO PRINTING OF CRLF
NOPER==:1B26	;NO PRINTING OF PERIOD
TTYRNU==:1B25	;SET TTY TO USER MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNC==:1B24	;KEEP TTY IN COMMAND MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNW==:1B23	;SET TTY TO USER LEVEL AND IO WAIT IF IT WAS IN IOW BEFORE
CMWRQ==:1B22	;REQUEUE JOB AFTER COMMAND WAIT
NOMESS==:1B21	;NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR OR TYPE WATCH BEGIN.
NOCRLP==:NOCRLF!NOPER!	;NEEDED FOR INTERNAL
TTYRNM==:TTYRNW!NOMESS	;TTY TO USER MODE AND NO MESSAGE
ERRFLG==:1B20	;COMMAND ERROR
REPEAT 0,<
SACFLG==:1B20	;COMMAND EXECUTED IN AN ALTERNATE CONTEXT, BIT IS TIME-SHARED
		; WITH ERRFLG AND MUST BE CLEARED BEFORE COMMAND DISPATCH
>
SACFLG==:0
NOLOGC==:1B20	;NO LOGICAL-NAME COMMAND CAN BE SUBSTITUTED FOR THIS ONE
RUNFLG==:NOCORE!NOPER!TTYRNU!NOACT!NORUN!INCORE!NOCRLF
ECMFLG==:NOCRLF!NOPER!NOMESS!TTYRNC


;FLAG BITS IN LH(M)

FLMCOM==:1B18	;1=COMMAND, 0=UUO
FLMCLV==:1B19	;COMMAND RUNNING AT COMMAND LEVEL

;UNIQUENESS BITS IN RH OF SIXBIT NAME
UNIQ.1==:1B32	;UNIQUE TO 1 CHAR.
UNIQ.2==:1B33	;UNIQUE TO 2 CHARS.
UNIQ.3==:1B34	;UNIQUE TO 3 CHARS.
UNIQ.4==:1B35	;UNIQUE TO 4 CHARS.
DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <AD>,<C  NM,AD,FL,UN>
  IFB  <AD>,<
    IFB  <PR>,<C  NM,RUNAME,FL,UN>
    IFNB <PR>,<
      IFIDN <NM>,<PR>,<C  NM,RUNAME,FL,UN>
      IFDIF <NM>,<PR>,<C  NM,%'PR,FL,UN>
    >
  >
>


DEFINE NAMES<
	C	<>,CBLANK,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOCRLF!NOLOGC
	C	START,START,NOPER!TTYRNU!INCORE!NOACT!NORUN!NOLOGIN!NOJOBN
	C	.HALT,STOPF,NOCORE!NOJOBN!NOLOGIN!NOINCK!CMWRQ!NOLOGC
	C	HALT,STOP,NOCORE!NOJOBN!NOLOGIN!NOINCK!CMWRQ,,HALTXT
	C	KJOB,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NOPER!NOCRLF!NOMESS!INCORE!NORUN!NOLOGC,uniq.1
	C	R,RCOM,NOCORE!NOPER!TTYRNU!NOACT!NORUN!INCORE
	C	RUN,RUNCOM,NOCORE!NOPER!TTYRNU!NOACT!NORUN!INCORE,UNIQ.2
	C	CORE,CORE,NOCORE!CMWRQ!INCORE!NOACT
	C	GET,GET,RUNFLG,UNIQ.1!UNIQ.2
	C	SAVE,CSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY
	C	SSAVE,SSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY

IFN FTEXE,<
	C	MERGE,CMERGE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY
IFN FTOSAVE,<
	C	NSAVE,NSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY
	C	OSAVE,SAVEO,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY
	C	NSSAVE,NSSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY
	C	OSSAVE,SSAVE1,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NXONLY
>
>	;END OF IFN FTEXE
	C	CONTINUE,CONT,NOPER!TTYRNW!INCORE!NORUN!NOJOBN!NOLOGIN!NOINCK,,CONTXT
	C	JCONTINUE,JCONT,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	.FCONT,FCONT,NOPER!NOCRLF!NOMESS!NORUN!INCORE!CMWRQ!NOJOBN!NOLOGIN!NOINCK!NOLOGC,,FCOTXT

	C	D,DCOM,CMWRQ!INCORE!NXONLY
	C	E,ECOM,NOCRLF!CMWRQ!INCORE!NXONLY

	C	PJOB,PJOBX,NOCORE!NOJOBN!NOLOGIN!NOINCK
IFN FTMODM!FTNET,<
	C	.HELLO,HELLO,RUNFLG!NOLOGIN!NOLOGC
	C	.BYE,BYECOM,NOCORE!NOLOGIN!NOJOBN!NOINCK!NOLOGC
>
	C	DEASSI,DEASSIG,NOCORE!NOINCK!INCORE!CMWRQ,UNIQ.3
	C	ASSIGN,ASSIGN,NOCORE!INCORE!CMWRQ
IFN FTNET,<
	C	.NETLD,RUNNET,RUNFLG!NOLOGIN!NOLOGC
	C	NODE,NODE.C,INCORE!CMWRQ!NOCORE!NOPER!NOCRLF!NOLOGIN,UNIQ.2
>	;END FTNET
	C	DDT,DDTGO,NOPER!TTYRNU!INCORE!NORUN!NOLOGIN!NOJOBN
	C	.BPT,CDBPT,INCORE!CMWRQ!NOCORE!NOJOBN!NOLOGI!NOINCK!NOCRLP!NOMESS
	C	FINISH,CFINI,TTYRNU!NOACT!INCORE!NORUN!NOPER!NOCRLF
	C	CLOSE,CLSCOM,TTYRNU!NOACT!INCORE!NORUN!NOPER!NOCRLF

	C	REENTER,REENTER,TTYRNU!NOPER!INCORE!NORUN!NOLOGIN!NOJOBN
	C	CSTART,STARTC,TTYRNC!INCORE!NOACT!NORUN!NBATCH
	C	CCONTINUE,CONTC,TTYRNC!INCORE!NORUN!NBATCH
	C	DETACH,DETACH,NOCORE!NOINCK!NBATCH!NOLOGIN
	C	ATTACH,ATTACH,NOCORE!NOLOGIN!NOINCK!NBATCH
IFN FTDHIA,<
	C	XCHNGE,XCHUNI,NOCORE!NOJOBN!NOLOGIN!NOINCK
>

	C	ENABLE,ENABLE,NOCORE
	C	DISABL,DISABL,NOCORE

	C	DAYTIME,DAYTIM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	.RESTA,RESTRT,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOLOGC
	C	TIME,RUNTIM,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C	RESOURCES,FREDEV,NOCORE!NOJOBN!NOLOGIN!NOINCK
IFN FTWATCH,<
	C	USESTAT,USECOM,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOPER!NOMESS!NOLOGC
>

IFN FTVERS,<
	C	VERSION,VERCOM,CMWRQ!INCORE,,VERTXT
>
IFN FTDSTT,<
	C	DSK,DSKCOM,NOCORE!NOINCK
>
	C	MOUNT,MNTCOM,RUNFLG,UNIQ.2
	C	DISMOUNT,MNTCOM,RUNFLG,UNIQ.3!UNIQ.4
IFN FTMDA,<
	C	ALLOCA,RUNMDA,RUNFLG
	C	DEALLO,RUNMDA,RUNFLG
	C	SHOW,RUNMDA,RUNFLG
	C	CANCEL,RUNMDA,RUNFLG
	C	MODIFY,RUNMDA,RUNFLG
>
	C	QUEUE,RUNQUE,RUNFLG!NOLOGIN,,QUEUE
	C	CPUNCH,RUNQUE,RUNFLG!NOLOGIN
	C	PLOT,RUNQUE,RUNFLG!NOLOGIN
	C	PRINT,RUNQUE,RUNFLG!NOLOGIN
	C	PUNCH,RUNQUE,RUNFLG!NOLOGIN
	C	SUBMIT,RUNQUE,RUNFLG!NOLOGIN
	C	TPUNCH,RUNQUE,RUNFLG!NOLOGIN

	C	SEND,SEND,NOCORE!NOLOGIN!NOINCK!NBATCH

	C	.TYPE,RETYPE,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOCRLF!NOMESS!NOPER!NOLOGC
IFN	FTMIC,<
	C	COJOB,RUNMIC,RUNFLG
	C	WHENEVER,RUNMIC,RUNFLG
	C	ON,RUNMIC,RUNFLG
	C	LET,RUNMIC,RUNFLG
	C	IF,RUNMIC,RUNFLG
	C	GOTO,RUNMIC,RUNFLG
	C	BACKTO,RUNMIC,RUNFLG
	C	OPERATOR,RUNMIC,RUNFLG
	C	NOOPERATOR,RUNMIC,RUNFLG
	C	ERROR,RUNMIC,RUNFLG
	C	NOERROR,RUNMIC,RUNFLG
	C	SILENCE,RUNMIC,RUNFLG
	C	PLEASE,RUNPLS,RUNFLG,,PLSTXT
	C	REVIVE,RUNMIC,RUNFLG
	C	MIC,RUNMIC,RUNFLG
	C	DO,RUNMIC,RUNFLG
>		;END OF FTMIC STUFF
	C	SCHEDULE,SKEDUL,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	LOGIN,CLOGIN,RUNFLG!NOLOGIN,uniq.3,LOGTXT
	C	LOGOUT,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NOPER!NOCRLF!NOMESS!INCORE!NORUN!NOLOGC

	C	REASSI,REASS,NOCORE!NOACT!INCORE!CMWRQ!NORUN

	C	SET,SET,NOCORE!NOJOBN!NOLOGIN!NOINCK

	C	TTY,TTYCMD,NOCORE!NOLOGIN!NOJOBN!NOINCK
	C	TERMINAL,TTYCMD,NOCORE!NOLOGIN!NOJOBN!NOINCK
IFN FTNET,<
	C	LOCATE,CLOCATE,NOCORE!INCORE
	C	WHERE,CWHERE,INCORE!CMWRQ!NOCORE!NOLOGIN
	C	NETWORK,RUNAME,RUNFLG!NOLOGIN,UNIQ.3!UNIQ.4,NETTXT
>
	C	INITIA,RUNAME,RUNFLG!NOLOGIN,UNIQ.1!UNIQ.2!UNIQ.3!UNIQ.4,INITIA
	C	DIRECT,RUNAME,RUNFLG,UNIQ.2!UNIQ.3!UNIQ.4
	C	HELP,RUNAME,NOCORE!NOLOGIN!SACFLG!NOPER!TTYRNU!NOCRLF!NOACT!NORUN!INCORE
	C	SYSTAT,RUNAME,RUNFLG!NOLOGIN!SACFLG,,SYSTXT
	C	FILE,RECALL,RUNFLG
IFE FTMIC,<
	C	PLEASE,RUNAME,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!NBATCH,,PLSTXT
>
	C	FUDGE,RUNPIC,RUNFLG
	C	CREF,RUNAMC,RUNFLG
	C	SOS,RUNAME,RUNFLG
	C	ACCOUNT,CACCT,NOCORE
	C	SESSION,CSESSN,RUNFLG

	C	DECLARE,RUNAME,RUNFLG

	C	.RUN,RUNAME,RUNFLG!NOLOGIN!NOLOGC,,.RNTXT
    ifn stupid,<
	C	AMIS,RUNAME,RUNFLG
	C	CD,RUNAME,RUNFLG
	C	DISCON,RUNAME,RUNFLG!NOLOGIN
	C	EDIT,RUNAME,RUNFLG
	C	FCOPY,RUNFUR,RUNFLG
	C	FDELETE,RUNFUR,RUNFLG
	C	FRENAME,RUNFUR,RUNFLG
	C	MF,RUNAME,RUNFLG
	C	MR,RUNAME,RUNFLG
	C	NCOPY,RUNNFT,RUNFLG
	C	NDIRECT,RUNNFT,RUNFLG
	C	NTYPE,RUNNFT,RUNFLG
	C	LIST,RUNTYP,RUNFLG
	C	PATH,RUNAME,RUNFLG
	C	SWETEX,RUNAME,RUNFLG
	C	TEX,RUNAME,RUNFLG
	C	TYPE,RUNAME,RUNFLG
	C	WHOIS,RUNAME,RUNFLG
	C	KOM,RUNAME,RUNFLG!NOLOGIN
	C	XYZZY,RUNAME,RUNFLG!NOLOGIN
	C	ZOO,RUNAME,RUNFLG!NOLOGIN
    >;ifn stupid
    ifn fthistory,<
	C	.CEDIT,CARROW,NOCORE!NORUN!NBATCH!INCORE
	C	RECALL,CARROW,NOCORE!NORUN!NBATCH!INCORE
	C	AGAIN,CAGAIN,NOCORE!NORUN!NBATCH!INCORE,,
	C	HISTORY,CHISTORY,NOCORE!NORUN!NBATCH!INCORE,,
    >;ifn fthistory
    ifn stupid,<		;More strange commands.
	C	LINK,LNKCMD,NOCORE!NBATCH		;[link]
	C	BREAK,LNKBRK,NOCORE!NBATCH!NOLOGIN	;[link]
	C	REMARK,RUNAME,RUNFLG!NBATCH!NOLOGIN	;[link]
	C	IMPCOM,RUNAME,RUNFLG!NOLOGIN		;[arpa]
	C	TELNET,IMPCOM,RUNFLG ;I'm used to typing TELNET.	[JMR]
	C	.FTPSV,%FTPSRV,RUNFLG!NOLOGIN		;[arpa]
	C	FTP,RUNAME,RUNFLG			;[arpa]
	c	ms,runame,runflg
	c	mail,runame,runflg			;tittut JP
	C	FINGER,RUNAME,RUNFLG!NOLOGIN	;person finder, local & arpa
	C	konto,runame,runflg!nologin!nbatch	; plat
    >;ifn stupid
SPCCMD			;;EXPAND USER DEFINED COMMANDS
IFN FTPATT,<
	C	.PATCH,CPOPJ,NOCORE!NOJOBN!NOLOGIN!NOINCK
>
	C	.PLRUN,RUNCOM,RUNFLG,,PLNTXT
	C	COMPILE,CCLRUN,RUNFLG,,COMPIL
	C	DEBUG,CCLRUN,RUNFLG
	C	EXECUTE,CCLRUN,RUNFLG
	C	LOAD,CCLRUN,RUNFLG

	C	CREATE,CCLRUN,RUNFLG
	C	DELETE,CCLRUN,RUNFLG
    ife stupid,<
	C	EDIT,CCLRUN,RUNFLG
	C	LIST,CCLRUN,RUNFLG
    >;stupid
	C	MAKE,CCLRUN,RUNFLG
	C	RENAME,CCLRUN,RUNFLG
	C	TECO,CCLRUN,RUNFLG,UNIQ.2!UNIQ.3
    ife stupid,<
	C	TYPE,CCLRUN,RUNFLG
    >;stupid
	C	COPY,CCLRUN,RUNFLG
	C	PRESERVE,CCLRUN,RUNFLG
	C	REWIND,CCLRUN,RUNFLG
	C	UNLOAD,CCLRUN,RUNFLG
	C	ZERO,CCLRUN,RUNFLG
	C	SKIP,CCLRUN,RUNFLG
	C	BACKSPACE,CCLRUN,RUNFLG,UNIQ.2!UNIQ.3!UNIQ.4
	C	EOF,CCLRUN,RUNFLG
	C	PROTECT,CCLRUN,RUNFLG
	C	LABEL,CCLRUN,RUNFLG

	C	CTEST,CCLRUN,RUNFLG	;ALWAYS LAST CCLRUN

>
DEFINE SNAMES,<
IFN FTWATCH,<
	C	WATCH,SETWAT,NOCORE
>
  ifn stupid,<
	C	PPN,SETPPN,NOCORE
	C	crash,shtcmd,nocore!nojobn!nologin!noinck
  >;stupid
	C	TIME,SETRTM,NOCORE

IFN FTSPL,<
	C	SPOOL,SETSPL,NOCORE
	C	CDR,SETCDR,NOCORE
>
	C	SCHEDULE,SETSCD,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	CORMAX,SETMAX,NOCORE!NOJOBN!NOLOGIN!NOINCK
IFN FTLOCK,<
	C	CORMIN,SETMIN,NOCORE!NOJOBN!NOLOGIN!NOINCK
>
	C	DAYTIM,SETDAY,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	DATE,SETDAT,NOCORE!NOJOBN!NOLOGIN!NOINCK

	C	OPR,SETOPR,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	TTY,TTYCMD,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	TERMINAL,TTYCMD,NOCORE!NOJOBN!NOLOGIN!NOINCK
IFN FTHPQ,<
	C	HPQ,HPQCMD,NOCORE
>
	C	DENSITY,MTADEN,NOCORE!INCORE!CMWRQ!NOACT
	C	BLOCKSIZE,MTABLK,NOCORE!INCORE!CMWRQ!NOACT
	C	FORMAT,MTAMOD,NOCORE!INCORE!CMWRQ!NOACT
IFN FTDX10,<
	C	RETRY,MTARTY,NOCORE!INCORE!CMWRQ!NOACT
>

IFN FTMP,<
	C	CPU,CPUCMD,NOCORE
>
	C	NOMESS,DSKSIL,NOCORE!NOJOBN!NOLOGIN!NOINCK
IFN FTDPRI,<
	C	DSKPRI,DSKPRI,NOCORE
>
	C	DSKFUL,FULSTP,NOCORE
	C	BREAK,SETBRK,NOCORE
	C	VMMAX,SETVMX,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C	VIRTUAL,SETUVC,NOCORE
	C	PHYSICAL,SETUPC,NOCORE

IFN FTNET!FTDECNET,<
	C	HOSTESS,DAASTH,RUNFLG!NOLOGIN
>
IFN FTMONL!FTMOFFL,<
	C	MEMORY,SETMEM,NOCORE!NOLOGIN!INCORE!CMWRQ
>
	C	DEFER,SETDFC,NOCORE
	C	NODEFER,SETNDC,NOCORE
	C	DEFAULT,SETDFL,NOCORE!NOLOGIN
IFN FTKL10!FTKS10,<
	C	FLOATING,SETFPC,NOCORE
>
	C	DDT,SETBPT,NOCORE
	C	EDDT,SETEBP,NOCORE!NOLOGIN!NOJOBN!NBATCH
IFN FTPATT,<
	C	CTEST,CPOPJ,NOCORE!NOJOBN!NOLOGIN!NOINCK	;ALWAYS LAST
>
>	;CLOSE DEFINITION OF SNAMES
;GENERATE TABLE OF SIXBIT COMMAND NAMES
DEFINE C(A,B,D,E,F)<
IFNB<F>,<F::>
	<SIXBIT /A/>
>
XALL

COMTB2::SNAMES
DISPL2==:.-COMTB2	;LENGTH
COMMX2==:<DISPL2-1>B26
COMTAB::NAMES
LASCCL==:.
DISPL==:.-COMTAB	;LENGTH OF TABLE
COMMXL==:<DISPL-1>B26
	$HIGH
;GENERATE THE DISPATCH TABLE PLUS SPECIAL BITS

DEFINE C(A,B,D,E,F) <
 IF2,<IFNDEF B,<EXTERN B>>
	XWD	D,B		;A
>


DISP2::	SNAMES
DEFINE C(A,B,D,E,F) <
 IF2,<IFNDEF B,<EXTERN B>>
  IFG .-DISP-COMPIL+COMTAB,<
    IFDIF <B><CCLRUN>,<PRINTX ? B DOES NOT PRECEDE CCLRUN IN COMTAB>>
  IFLE .-DISP-COMPIL+COMTAB,<
	XWD	D,B		;A
>>


DISP::	NAMES


;AND ONE MORE FOR AN UNKNOWN COMMAND DISPATCH

COMERD::XWD	NOCORE+NOJOBN+NOLOGIN+NOINCK,NOCOM##
;GENERATE TABLE OF UNIQUENESS BITS FOR SIXBIT COMMAND NAMES
DEFINE C(A,B,D,E,F)<
	ZZ==ZZ_6+E
	Z6==Z6+1
IFE Z6-6,<EXP ZZ
	Z6==<ZZ=0>>
>

	ZZ==<Z6==0>		;INITIALIZE

UNQTAB::NAMES
	IFN Z6,<EXP	ZZ>		;LAST ONES

	ZZ==<Z6==0>
UNQTB2::SNAMES
	IFN Z6,<EXP	ZZ>
;GENERATE COMMAND DISPATCHES FOR USER DEFINED COMMANDS

DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFB  <AD>,<
    IFNB <PR>,<
      IFDIF <NM>,<PR>,<
        IFNDEF %'PR,<
%'PR:	MOVE	P2,[SIXBIT/PR/]
	JRST	RUNAME##
        >
	IFDEF	%'PR,<
          IFE	%'PR-.,<
%'PR:	MOVE	P2,[SIXBIT/PR/]
	JRST	RUNAME##
          >
        >
      >
    >
  >
>


	SPCCMD


	SALL

IMPCOM:	MOVE	P2,[SIXBIT 'IMPCOM'] ;					[JMR]
	JRST	RUNAME##

%tsmtp:	move	p2,[sixbit 'tsmtp']
	jrst	runame##

%FTPSRV:MOVE	P2,[SIXBIT 'FTPSRV']
	JRST	RUNAME##

runnft:	movsi	p2,'NFT'
	jrst	runame##

RUNTYP:	SKIPA	P2,[SIXBIT 'TYPE']
RUNFUR:	MOVSI	P2,'FUR'
	JRST	RUNAME##

;TABLE OF PRIVILEGED CUSPS
;USED TO TURN ON JACCT WHEN R OR RUN COMMAND OR RUN UUO

PRVTAB::
LGONAM::SIXBIT	/LOGOUT/	;NAME FOR "LOGOUT" (TURN OFF JLOG TOO)
	SIXBIT	/LOGIN/
ifn stupid,<
	sixbit	/mail/
	sixbit	/msgh/
	sixbit	/whois/
	sixbit	/kill/
>;stupid additions.
	SIXBIT	/UMOUNT/
IFN FTDAEM,<
	SIXBIT	/DAEMON/
>
	SIXBIT	/SYSTAT/	;FOR PEEK UUO PRIVILEGE

IFN FTNET,<			;FOR REMOTE SPOOLERS TO
	SIXBIT	/NETLDR/	;PREVENT ABUSE OF THIS CAPABILITY.
  IFN FTKS10,<
	SIXBIT	/KDPLDR/	;KMC-11 MICRO-CODE LOADER TO RUN ON FRCLIN
  >;IFN FTKS10
>;IFN FTNET
IFN FTDN60,<			;IF WE HAVE A DN60...
	SIXBIT	/D60RTV/	; RETRIEVAL PGM MUST HAVE FULL FILE ACCESS
>
IFN FTMBTS,<
CCPNAM::SIXBIT/CRSCPY/		;AUTO CRASH COPY PROGRAM. (MAY BE CHANGED
				;WITH MONGEN BY DEFINING THE SYMBOL CPYNAM
				;IN THE SIXBIT DEFINITION SECTION TO BE THE NAME
				;OF THE PROGRAM TO RUN)
>

DEFINE UCMDNM(NM,PR,AD,FL,UN,PV),<
  IFNB <PV>,<EXP SIXBIT/PV/>
>

	SPCCMD			;GENERATE PRVTAB ENTRIES FOR USER

				;  DEFINED COMMANDS
IFN FTPATT,<0>			;SAVE A WORD FOR PATCHING OVER
IFN FTCIMP,<			;[arpa]
PRVNLG==:.-PRVTAB		;[arpa] PAST THIS POINT, GIVE JACCT ONLY IF NOT LOGGED IN
	SIXBIT	/IMPCOM/	;[arpa] IMPCom for some FTPSRV related reason
	SIXBIT	/FTPSRV/	;[arpa] FTPSrv so it can ChgPPn to 70,70
	sixbit	/tsmtp/		;[pl}t] kludge smtp services
>				;[arpa]
PRVTBL==:.-PRVTAB			;NO.  OF PRIVILEGED CUSPS
DAASTH::
IFE M.NET!M.DECN,<		;IF NO NETWORK SUPPORT
	JSP	T1,ERRMES##	;CAN'T DO THESE IF NO NETWORK
	ASCIZ	|No network software|
> ;END IFN M.NET!M.DECN

IFN M.NET!M.DECN,<		;IF NETWORKS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	PUSHJ	P,CTEXT1##	;GET NEXT ARGUMENT
	JUMPE	T2,NOTENF##	;IF NO ARGUMENT
	MOVE	T1,T2		;T1=NAME
	PUSHJ	P,CVTOCT##	;CONVERT IF NUMBER
	  JFCL			;MUST BE A NUMBER
IFN M.NET,<IFN M.DECN,<
	NETOFF			;INTERLOCK
	PUSHJ	P,SRCND0##	;SEARCH ANF TABLE
	  PJRST	HOST.D		;IF NOT FOUND
	NETON			;FREE INTERLOCK
>;END IFN M.DECN
	PJRST	HOST.A##	;ANF HOST
>;END IFN M.NET

IFN M.DECN,<
HOST.D:	IFN M.NET,<NETON>
HOSTD0:	PUSHJ	P,[SE1ENT	;GET INTO SECTION 1
		PJRST SCTN2A##]	;CONVERT NODE NAME TO NODE ADDRESS
	  JRST	[MOVE T1,NRTUNN## ;GET POINTER TO ERROR MESSAGE SAYING
		PJRST ERRMES##]	;NO SUCH NODE.
;endast f|r peter olofssons accounting
ife stupid,<
	MOVSI	T1,LDLNRT##	;LETS SEE IF WE ARE ALREADY NRTED IN
	TDNE	T1,LDBTTW##(U)	;AND DON'T ALLOW IT IF SO
	 JRST	[MOVEI T1,[	;NRTED IN, DON'T LET HIM NRT OUT
		ASCIZ \Cannot SET HOST to a DECnet node from a NRT line\]
		PJRST ERRMES##]	;&&ADD CODE HERE TO DISCONNECT LINE&&
>;endif, more power to the users

	MOVSI	P2,(SIXBIT "NRT");PROGRAM NAME
	MOVE	T1,JBTSTS(J)	;JOB STATUS WORD
	TLNN	T1,JLOG		;LOGGED IN
	SKIPE	STHFLG		; OR NOT REQUIRED
	PJRST	RUNAME##	;RUN NRT PROGRAM
	MOVEI	T1,LOGPLM##	;ELSE TYPE
	PJRST	ERRMES##	; "LOGIN PLEASE"
>
>

	$ABS


IFN FTKL10,<IFG CPUN-1,<
	LOC <.+777>&777000
>
CSHLAS==:.-1			;CACHE FROM CSHFIR TO HERE
>
	SUBTTL	UBA MAPPING REGISTER ASSIGNMENTS
IFN M.KS10,<

DEFINE XX (UBA,DEV,ADR,NUM),<
    IFNDEF UB'UBA'IMR,<UB'UBA'IMR==<7000000&ADR>+UBAEXP>
	DEV'IMR==:UB'UBA'IMR	;INITIAL MAPPING REGISTER
	DEV'IEA==:<DEV'IMR&77>*UBAMUL	;INITIAL PDP-11 ADDRESS
	DEV'MRC==:NUM	;NUMBER OF MAPPING REGISTERS
    IFG <<UB'UBA'IMR&77>+DEV'MRC-UBAPGS>,<
	DEV'MRC==:UBAPGS-<UB'UBA'IMR&77>
    >;IFG
	UB'UBA'IMR==UB'UBA'IMR+DEV'MRC
>;DEFINE XX

DEFINE X (DEV,ADR,NUM),<
IFN NUM,<
	Z=ADR/1000000
    IFLE Z,<PRINTX NONEXISTENT UBA FOR ADR>
	XX (\Z,DEV,ADR,NUM)
>;IFN NUM
>;DEFINE X

    IF1,<
	X RH1,RH11CA,UBAPGS	;DISK RH11
	X LP0,LP11CA,<2*LPTN>	;LP20
	X CD0,CD11BA,<2*CDRN>	;CD20
	X RH2,RH21CA,20		;TAPE RH11
	X KMC,KMC1BA,<KDLPPL*M.KDUP>	;KMC-11S DRIVING DUP-11S
	X DMR,DMR1BA,<DMRPPL*M.DMRN>	;DMR11 lines

	PURGE UB1IMR,UB3IMR
    >;IF1
>;IFN M.KS10

SUBTTL	COMMON -- CODE IN COMMON TO BUILD FEK'S

	FEKFST==:0		;START CHAIN OF FEKS BY ASSUMING
				;  THAT NO FEK'S WILL BE DEFINED

DEFINE FEKGEN(NAM,NM,TYPE,CPU,UNIT),<	;;MACRO DO LAY OUT FEK BLOCKS

;;ARGUMENTS ARE:
;;	NAM	3 CHARACTER GENERIC FEK TYPE (IE D8S)
;;	NM	3 CHARACTER "PARTICULAR" NAME FOR THIS FEK (IE "S01")
;;	TYPE	LEGAL NAME OF FEK (IE. NULL, KMCDUP DTE20 ...)
;;	CPU	NUMBER OF THE CPU THAT THIS FEK IS ON

;;FIRST VERIFY THAT THE FEK IS ONE OF A VALID TYPE
IFDIF <TYPE>,<NULL>,<
  IFDIF <TYPE>,<DL10>,<
    IFDIF <TYPE>,<DTE20>,<
      IFDIF <TYPE>,<KMCDUP>,<
	IFDIF <TYPE>,<DMR11>,<
	  PRINTX ? Illegal third argument TYPE to FEKGEN macro.?
	>;DMR11
      >;KMCDUP
    >;DTE20
  >;DL10
>;NULL

DEFINE X(OFFSET,EXPR)<		;;MACRO TO SET SELECTED LOCATIONS IN THE BLOCK
	LOC NM'FEK+OFFSET	;;GO TO THE RIGHT WORD
	EXPR			;;ASSEMBLE IN THE EXPRESSION
>

  IFNDEF NAM'DSP,<EXTERNAL NAM'DSP> ;;RESOLVE DISPATCH VECTOR ADDRESS

  Q==0				;;DEFINE DEFAULT FEKBLK BITS
IFIDN <TYPE>,<NULL>,<
  Q==<FK.NUL!FK.ONL!FK.NID>	;;STATUS BITS FOR NULL FEK
>;NULL

NM'FEK::BLOCK	0		;;RESERVE STORAGE FOR THIS FEK

	X	FEKBLK,<XWD Q,FEKFST>	;;STATUS BITS AND LINK TO LAST FEK
	X	FEKDSP,<PUSHJ P,NAM'DSP>;;ONCE-ONLY CODE
	X	FEKUNI,<XWD CPU,UNIT>	;;XWD CPU,UNIT
	X	FEKHTM,<EXP 0>		;;INITIALIZE WITH HUNG TIME OF ZERO
	X	FEKIAD,<EXP 0>		;;NO INPUT BUFFERS
	X	FEKBSI,<EXP -1>		;;INPUT IS IDLE
	X	FEKOAD,<EXP 0>		;;NO OUTPUT BUFFERS
	X	FEKOCT,<EXP 0>		;;NO OUTPUT BUFFERS
	X	FEKODN,<EXP 0>		;;NO EMPTY OUTPUT BUFFERS EITHER
	X	FEKBSO,<EXP -1>		;;OUTPUT IS IDLE

IFIDN <TYPE>,<DTE20>,<			;;IF THIS IS A DTE 20
	X	FEKIBP,<EXP 0>		;;WE HAVE NO INPUT BYTE POINTER
	X	FEKAKC,<EXP 0>		;;THE "ACK" INTERLOCK IS FREE
>

	LOC	NM'FEK+FEKLEN	;;GO TO THE END OF THE BLOCK
	FEKFST==:NM'FEK		;;REDEFINE THE "FIRST" FEK TO KEEP CHAIN ALIVE
	PURGE	X		;;UNDEFINE THE "X" MACRO
>;FEKGEN
SUBTTL	DN87 (ANF-10) AND DN60 (IBM) FEKS
	$ABS

;NOW DEFINE 4 HELPER MACROS.  ONE EACH FOR DN87(85), DC76, DN60 AND DN6S
;NOTE -- THESE FEKS MAY ONLY GO ON CPU #0.

DEFINE	FEK85(P),<		;;MACRO TO BUILD DN85 FEKS
  IRP P,<			;;FOR EACH ARGUMENT,
    IFE <TP.DL'P-TP.D85>,<	;;  IF THE -11 IS A DN85 (DN87),
      FEKGEN (D85,D8'P,DL10,0,0)	;;  THEN BUILD THE FEK, AND
      EXTERN D85INT>>>		;;  MAKE SURE THE SERVICE ROUTINE IS LOADED

DEFINE	FEK76(P),<		;;MACRO TO BUILD DC76 FEKS
  IRP P,<			;;FOR EACH ARGUMENT,
    IFE <TP.DL'P-TP.D76>,<	;;  IF THIS -11 IS SUPPOSED TO BE A DC76
      FEKGEN (D76,D8'P,DL10,0,0)	;;  THEN BUILD THE FEK, AND
      EXTERN D76INT>>>		;;  MAKE SURE THE SERVICE ROUTINE IS LOADED


DEFINE FEK60(P),<		;;MACRO FOR DN60 FEKS (DL-10 BASED IBM COMM)
  IRP P,<			;;FOR EACH POSSIBLE -11,
    IFE <TP.DL'P-TP.D60>,<	;;IF THIS -11 IS TO BE A DN60,
      FEKGEN (D60,D8'P,DL10,0,0)	;;  THEN BUILD IT'S FEK, AND
      EXTERN D60SER,D6DINT>>>	;;  MAKE SURE THE SERVICE ROUTINES ARE IN

;NOW ACTUALLY BUILD THE FEKS.

	FEK85 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DN87(85) FEKS
	FEK76 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DC76 FEKS
	FEK60 <0,1,2,3,4,5,6,7>	;;LEGAL FRONT ENDS FOR DN60 FEKS
IFN FTKL10,<
;NOW BUILD THE DN87S AND DN60S FEKS (DTE-20 BASED ANF AND IBM FRONT ENDS)
;NOTE -- THESE FEKS MAY BE ON ANY CPU.

DEFINE	FEK8S(CPX,DTX),<		;;MACRO TO BUILD DTE-BASED FEKS
  IFE <M'CPX'DTX'DTE-DT.ANF>,<		;;IF THIS IS AN ANF-10 DTE
    FEKGEN(D8S,S'CPX'DTX,DTE20,CPX,0)	;;  BUILD THE FEK (UNI SETUP LATER)
    EXTERN D8SINT>>			;;  AND FORCE LOADING OF D8SINT

DEFINE	FEK6S(CPX,DTX),<		;;MACRO TO BUILD DTE-BASED FEKS
  IFE <M'CPX'DTX'DTE-DT.IBM>,<		;;IF THIS IS AN IBM DTE
    FEKGEN(D6S,S'CPX'DTX,DTE20,0,0)	;;  BUILD THE FEK (UNI SETUP LATER)
    EXTERN D60SER,D6SINT>>		;;  AND FORCE LOADING OF IBM CODE

;NOW FOR ALL CPUS, FOR ALL DTES, BUILD THEIR FEKS

ZZ==0
REPEAT CPUN,<Z=0			;;FOR ALL CPUS,
    REPEAT 4,<				;;  FOR EACH DTE ON THIS CPU
	FEK6S(\ZZ,\Z)			;;  BUILD A FEK IF THERE IS AN -11
	FEK8S(\ZZ,\Z)			;;  BUILD A FEK IF THERE IS AN -11
	Z==Z+1>				;;STEP TO THE NEXT DTE
    ZZ=ZZ+1>				;;  AND STEP TO THE NEXT CPU
> ;IFN FTKL10
;Define the DMR11 FEKs
;Put them so they will be after the KDPs for FEK2LN
IFN M.DMRN,<
	EXTERN	D8RINT,DMRINT,DMRSER	;;  Load the service routines
  IFN M.DN6R,<
	EXTERN	D6RINT>			;; Load service routine for IBM

DEFINE FEK8R(N),<
	FEKGEN(D8R,DR'N,DMR11,0,DMR'N)>
ZZ==0

REPEAT M.DMRN,<
	FEK8R(\ZZ)
	ZZ==ZZ+1>
>;IFN M.DMRN

;DEFINE THE KMC/DUP-11 FEK'S
;FOR NOW, THE NAMES ARE JUST DK<NNM>FEK

IFN M.KDUP,<				;;IF THERE ARE KMC/DUP-11 FEK'S

DEFINE FEK8K(N),<			;;DEFINE A HELPER MACRO TO DEFINE FEK'S
    FEKGEN(D8K,DK'N,KMCDUP,0,KDL'N'PG)	;;  BUILD THE D8K FEK
    EXTERNAL D8KINT,KDPINT,KDPSER>	;;  ANDFORCE LOADING

ZZ==0					;;COUNTER FOR FEK NUMBER
REPEAT M.KDUP,<				;;FOR ALL KMCDUP FEK'S
	FEK8K(\ZZ)			;;  BUILD THE FEK
	ZZ==ZZ+1>			;;  AND STEP TO THE NEXT

>;M.KDUP



;BUILD THE "NULL" FEK.

IFN M.NET,<
	FEKGEN(NLF,NL0,NULL,-1,0)		;;GENERATE THE NULL FEK'S FEK
	EXTERN NULFEK			;;  AND LOAD THE SERVICE ROUTINE
>;M.NET
IFN FTNET!FTDN60,<
	$HIGH

IFN FTKL10,<
;GENERATE TABLE TO MAP FROM DTE AND CPU # TO FEK ADDRESS

DEFINE	FEKPNT(DTX,CPX),<
    ZZQ==0
    IFE	<M'CPX'DTX'DTE-DT.ANF>,<ZZQ==S'CPX'DTX'FEK>
    IFE	<M'CPX'DTX'DTE-DT.IBM>,<ZZQ==S'CPX'DTX'FEK>
    EXP ZZQ
>

DTEFEK::
Z==-4
REPEAT	CPUN,<
	CONC(<DTEFEX+>,\<Z==Z+4>,<(P1)>)
>

DTEFEX:
ZZ==0				;CPU INDEX
REPEAT	CPUN,<			;FOR ALL CPUS
    ZZZ==0			;DTE INDEX
    REPEAT 4,<			;FOR ALL DTE'S
	FEKPNT(\ZZZ,\ZZ)	;BUILD THE NEXT POINTER
	ZZZ==ZZZ+1>		;STEP TO THE NEXT DTE
    ZZ==ZZ+1>			;STEP TO THE NEXT CPU
>;END IFN FTKL10
>;END IFN FTNET!FTDN60
	SUBTTL	KDP BLOCKS FOR THE KMC-11/DUP-11
	$ABS

IFN M.KDUP,<			;ONLY ASSEMBLE IF WE HAVE KMC-DUPS

;SINCE THE KS-10 MAY HAVE AT MOST ONE KMC-11, THIS CODE DOES NOT
;  EASILY PROVIDE FOR MORE THAN ONE "KDP" BLOCK.

KDPTBL::EXP	KDP0		;WE ONLY HAVE ONE KDP(KMC)
KDPMAX==:0			;THE HIGHEST ONE IS "0"

DEFINE	X(OFFSET,VALUE),<	;;HELPER MACRO FOR FILLING IN KDP BLOCK
	LOC	KDP0+OFFSET	;;GO TO THE APPROIATE LOCATION IN THE BLOCK
	VALUE			;;AND ASSEMBLE IN THIS "VALUE"
>
DEFINE	XX(DUPN),<		;;HELPER MACRO FOR FILLING IN KDPKDL SUB-TABLE
	X(KDPKDL+DUPN,<XWD DK'DUPN'FEK,KDL'DUPN'PG>) ;; FILL IN FEK AND PAGE
>
;NOW LAY OUT THE KDP BLOCK
KDP0::	X(KDPCSR,<EXP KMC1BA>)	;CSR ADDRESS OF THE KMC-11
	X(KDPVEC,<EXP KMC1IV>)	;INTERRUPT VECTOR ADDRESS
	X(KDPIMR,<EXP KMCIMR>)	;ADDRESS OF INITIAL MAPPING REGISTER
	X(KDPIEA,<EXP KMCIEA>)	;INITIAL ELEVEN ADDRESS
	X(KDPDPN,<EXP M.KDUP>)	;NUMBER OF DUP-11'S ON THIS KMC
	X(KDP1DP,<EXP DUP1BA>)	;BASE ADDRESS OF THE FIRST DUP-11
	X(KDPNUM,<EXP 0>)	;NUMBER OF THIS KDP

Q==0				;NOW LOOP OVER ALL KDL(DUPS) START WITH ZERO
REPEAT M.KDUP,<
	XX(\Q)			;BUILD THE NEXT KDL ENTRY (XWD FEK,KDL)
	Q==Q+1			;STEP TO THE NEXT KDL
>				;LOOP UNTIL DONE
;NOW LAY OUT THE INTERRUPT ROUTINES (THEY LIVE IN THE KDP BLOCK)
	X(KDPIVA,<EXP 0>)	;VECTOR A.  JSR COMES HERE
	EXCH	T1,KDP0+KDPIVA	;SAVE T1, GET ADDR WE INTERRUPED OUT OF
	MOVEM	T1,SCNCHL	;PUT IT BACK WHER A POPJ WILL RETURN
	MOVE	T1,KDP0+KDPIVA	;GET T1 BACK
	JSR	SCNSAV		;GO SAVE THE AC'S
	MOVEI	W,KDP0		;LOAD W FOR D8KINT
	JRST	KDPAIV##	;GO TO THE INTERRUPT VECTOR "A" ROUTINE

	X(KDPIVB,<EXP 0>)	;VECTOR B.  JSR COMES HERE
	EXCH	T1,KDP0+KDPIVB	;SAVE T1, GET ADDR WE CAME FROM
	MOVEM	T1,SCNCHL	;SAVE ADDR FOR WHEN WE EXIT INTERRUPT
	MOVE	T1,KDP0+KDPIVB	;GET T1 BACK
	JSR	SCNSAV		;SAVE THE AC'S
	MOVEI	W,KDP0		;LOAD W FOR D8KINT
	JRST	KDPBIV##	;GO TO INTERRUPT VECTOR "B" CODE

	LOC	KDP0+KDPLEN	;SKIP OVER THE BLOCK
	PURGE	X,XX		;UNDEFINE THE "HELPER" MACROS
>;M.KDUP
IFE M.KDUP,<			;IF NO KDP'S
	TSTKDP==:CPOPJ		;DEFAULT KDP CHECK ROUTINE
	KDPSEC==:CPOPJ		;KDP ONCE/SECOND ROUTINE
	ZAPKDP==:CPOPJ		; KDP KILL ROUTINE
>
	SUBTTL	DMR Blocks for the DMR11 lines

IFE M.DMRN,<			;IF NO DMR'S
	TSTDMR==:CPOPJ		;DEFAULT DMR CHECK ROUTINE
	DMRSEC==:CPOPJ		;DMR ONCE/SECOND ROUTINE
	ZAPDMR==:CPOPJ		;DMR KILL ROUTINE
>
IFN M.DMRN,<
	DEFINE	X(N),<EXP	DMR'N>
ZZ==0
DMRTBL::REPEAT	M.DMRN,<
	X(\ZZ)
	ZZ==ZZ+1>

	DEFINE	X(N,OFFSET,VALUE),<;;Standard macro
	LOC	DMR'N+OFFSET
	VALUE>

	DEFINE	XX(N,FT,DEF),<
IFNDEF DMR'N'FT,<DMR'N'FT==<DEF>>
IFN DMR'N'FT,<ZZZ==ZZZ+DMRS'FT>>

	DEFINE $DMR(N),<
DMR'N::	X(N,DMRUSR,<EXP	M.'N'DMR>)	;;Initial use of this line
	X(N,DMRCSR,<EXP	DMR1BA+<N*10>>)	;;CSR address of this DMR
	X(N,DMRVEC,<EXP	DMR1IV+<N*10>>)	;;Vector
	X(N,DMRMAP,<EXP DMRIMR+<N*DMRPPL>>)	;;UBA mapping register address
	X(N,DMREAD,<EXP	DMRIEA+<N*UBAMUL*DMRPPL>>) ;;11 address of this DMR's com region
	X(N,DMRTAD,<EXP	DMR'N'PG>)	;;10 address of this DMR's com region
	X(N,DMRLIN,<XWD	M.KDUP+N,N>)	;;Line # on node,,DMR #
	X(N,DMRIVA,<EXP 0>)		;;Vector "A" Interrupt header
		EXCH	T1,DMR'N+DMRIVA	;;Get interrupt PC
		MOVEM	T1,SCNCHL	;;Save for SCNSAV
		MOVE	T1,DMR'N+DMRIVA	;;Restore T1
		JSR	SCNSAV		;;Get our AC block
		MOVEI	W,DMR'N		;;Point to this DMR block
		MOVE	F,DMRTAD(W)	;; and communications page
		JRST	DMRAIV##	;;Process interrupt
	X(N,DMRIVB,<EXP 0>)		;;Vector "B" Interrupt header
		EXCH	T1,DMR'N+DMRIVB	;;Get interrupt PC
		MOVEM	T1,SCNCHL	;;Save for SCNSAV
		MOVE	T1,DMR'N+DMRIVB	;;Restore T1
		JSR	SCNSAV		;;Get our AC block
		MOVEI	W,DMR'N		;;Point to this DMR block
		MOVE	F,DMRTAD(W)	;; and communications page
		JRST	DMRBIV##	;;Process interrupt
	ZZZ==0
	XX(N,HD,0);;Default HDX setting
	XX(N,SW,0);;Default switched line setting
	XX(N,LS,1);;Default Long start select
	XX(N,MT,0);;Default maintenance mode
	X(N,DMRSTS,<EXP	ZZZ>)		;;Initial status
	X(N,DMRFEK,<EXP	DR'N'FEK>)	;;Address of our FEK
	X(N,DMRLEN,<BLOCK 0>)
	>;Define $DMR

ZZ==0
REPEAT M.DMRN,<
	$DMR(\ZZ)
	ZZ==ZZ+1>
	PURGE	X,$DMR,XX,ZZZ
>;IFN M.DMRN
SUBTTL	MUUO PROCESSING

	$HIGH
MUUO:
IFE FTKLP,<
	EXECAC			;SET UP EXEC UUO AC BLOCK
>
IFN FTKLP,<
	DATAO	PAG,[LG.LAB+LG.LPC+1B11] ;EXEC ACS+PCS=0
>
IFN FTKLP,<
	JRSTF	@[XWD XC.UOU,.+1];HAVE TO DO THIS BY HAND
>
	MOVE	T1,.UPMP+.UPMUP-IFN FTKLP,<1>	;GET THE MUUO PC FLAGS
	MOVE	R,.CPADR
	TLNN	T1,(XC.USR)	;WAS THE MUUO DONE IN USER MODE?
	JRST	UUOSY1##	;NO, DISPATCH TO EXEC MODE MUUO HANDLER
	JUMPE	R,MUUO1		;IS THERE A JOB DATA AREA FOR THE JOB DOING THE UUO?
				;NO, MUST BE THE DOORBELL OR ERROR IN THE
				; NULL JOB
	AOS	.CPTUC		;ACCUMULATE THE NUMBER OF UUOS ON THIS CPU
	MOVE	P,[XWD MJOBPD##,.JDAT+JOBPDL##]
	MOVEI	F,0		;FLAG NO DDB IN CASE ILLEGAL UUO
	MOVE	J,.CPJOB	;JOB NUMBER OF CURRENT JOB
	JRST	UUOSY1##	;DISPATCH TO MUUO HANDLER

MUUO1:
IFE FTKLP,<
	MOVE	T1,.UPMP+.UPMUO	;WAS THIS THE DOORBELL UUO ISSUED BY THE NULL JOB?
>
IFN FTKLP,<
	HRLZ	T1,.UPMP+.UPMUO
	IOR	T1,.UPMP+.UPMUE
>
	CAME	T1,WAKINS##	;DOORBELL CALLI
	STOPCD	.+1,STOP,UNJ,	;NO, ILLEGAL NULL JOB UUO
MUUO1A:
IFN FTMP,<
	AOS	.CPNDB		;COUNT NUMBER OF DOORBELLS
	MOVE	P,.CPNPD
	JRSTF	@[IC.UOU+.+1]
	MOVE	T1,.CPQPC
	TDNN	T1,DOORBL
	JRST	MUUO1B
	ANDCAM	T1,DOORBL
	PUSHJ	P,DSKTIC##
	PUSHJ	P,TAPTIC##
MUUO1B:	MOVE	T1,.CPSCC
	TDNN	T1,DOORBL
	JRST	[USERAC
		IFE FTKLP,<JEN @.UPMP+.UPMUP>
		IFN FTKLP,<XJEN .UPMP+.UPMUO>]
	ANDCAM	T1,DOORBL
>
IFE FTKLP,<
	MOVE	T1,.UPMP+.UPMUP	;GET THE NULL JOB WAKEUP PC
	MOVEM	T1,.CPPC	;STORE IT AS THE CURRENT PC FOR THIS CPU
>
IFN FTKLP,<
	DMOVE	T1,.UPMP+.UPMUO
	DMOVEM	T1,.CPPC
>
	JRST	CLKSPD##	;DISPATCH TO THE SCHEDULAR SINCE SOME
				; JOB IS POSSIBLY NOW RUNNABLE ON THIS CPU
UMPRET::			;HERE ON RETURN FROM MUUO PROCESSING
	POP	P,.UPMP+.UPMUP	;RESTORE THE MUUO PC
IFN FTKLP,<
	POP	P,.UPMP+.UPMUO	;RESTORE FLAGS
>
IFN	FTHPQ,<
	SKIPGE	SCDRTF		;HPQ JOB WAKE UP AND IN CORE?
	  PUSHJ	P,USCHD1##	;YES
>
	USERAC			;RESET USER AC BLOCK
IFE FTKLP,<
	JEN	@.UPMP+.UPMUP	;DISMISS TO THE USER
				;MUST BE JEN, NOT JRSTF SINCE WE MAY COME THRU
				; HERE AT PI 7 IF TRAPPING AT USER
>
IFN FTKLP,<
	XJEN	.UPMP+.UPMUO
>
	$LIT			;FORCE LITERALS INTO THE HIGH SEGMENT

SUBTTL	APR INTERRUPTS
;DEFINE MACRO TO CALL KL OR KI OR KS CODE FOR EACH CPU
DEFINE KILS(N)<
	IFN	M.KI10,<KI(N)>
	IFN	M.KL10,<KL(N)>
	IFN	M.KS10,<KS(N)>
>				;END KILS MACRO DEF

	$ABS
	IFN	M.KL10,<
APRCLK::				;PLACE FOR PDP-11 APR CLOCK TO GO TO
	IFG	CPUN-1,<
	SKPCPU	(0)
	JRST	AP1IN2
>
	JRST	AP0IN2

;HERE TO TRY TO CONTINUE THE SYSTEM AFTER A CLOCK ERROR STOP
APRWRS::EXECAC			;GET CORRECT AC SET
	CONO	APR,200000	;CLEAR THE WORLD (ACTUALLY, RSX20F ALREADY DID)
	CONO	PI,CLRPIS
	CONO	PAG,0
	JSP	T4,SYSTR0	;SETUP PAGING, FIND OUT WHAT CPU WE ARE
	  JFCL			;DON'T CARE WHETHER BOOT OR NOT
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	MOVEI	P,WRSPTB-1(T1)	;SETUP A VERY SHORT STACK
	LSH	T1,1		;DOUBLE WORD PC
	LDB	T2,[POINT 18,WRSLOC(T1),35] ;CODE FOR RESTART
	DMOVE	T3,WRSLOC(T1)	;GET DOUBLE WORD PC
IFE FTKLP,<
	MOVEM	T4,@.CPKAF
>
IFN FTKLP,<
	DMOVEM	T3,@.CPKAF	;STORE IN KAF LOC
>
	CAIN	T2,.WRKAC	;IF KAF, REPORT AS SUCH
	JRST	KAFSTP
	CAIE	T2,.WRPTO	;IF PROTOCOL TIMED OUT, CAN'T RECOVER
	TLNN	T3,(XC.USR)	;PC IN USER MODE?
	STOPCD	(.,CPU,WRF,WRSF);++WARM RESTART FAILED
	SKIPN	J,.CPJOB	;NULL JOB RUNNING?
	JRST	SPRINI		;YES, JUST RESTART IT
	HRRZ	T1,JBTUPM(J)	;USER PROCESS TABLE
IFN FTKLP,<
	HRRM	T1,.CPSPT	;SETUP SPT
>
	TLO	T1,(LG.LUB)	;LOAD USER BASE REGISTER
	DATAO	PAG,T1		;ZAP, ADDRESSABLE
	MOVE	P,[MJOBPD##,,.JDAT+JOBPDL##] ;ESTABLISH A USER CONTEXT STACK
IFN FTKLP,<
	PUSH	P,T3		;SAVE FLAGS
>
	PUSH	P,T4		;AND PC
IFN FTMP,<
	SETZM	.CPNBI		;SINCE ESSENTIALLY STARTING OVER, NO BROKEN INTERLOCKS
>;END IFN FTMP
	PUSHJ	P,SETCLK	;SETUP CLOCKS, APR, AND PI
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL, MAKE SURE 20F IN SAME STATE
	PUSHJ	P,STAPPC##	;NOW, START PRIMARY PROTOCAL
	  JFCL			;WHO KNOWS
	STOPCD	(.,JOB,WRJ,WRSF);++WARM RESTART GOT JOB

;HERE TO PRINT WARM RESTART CODE

WRSF:	PUSHJ	P,INLMES##	;TELL WHAT'S BEING REPORTED
	ASCIZ	/code = /
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;TIMES 2
	LDB	T1,[POINT 18,WRSLOC(T1),35] ;WARM RESTART CODE
	PJRST	PRTDI8##	;REPORT IT

WRSPTB:	REPEAT	CPUN,<
	BLOCK	1		;VERY SHORT PDL TO USE DURING WARM RESTART
>
	LIT
>	;END IFN M.KL10

IFN M.KL10!M.KS10,<
KAFSTP:STOPCD	(.,CPU,KAF)		;++KEEP ALIVE FAILURE
>;END M.KL10!M.KS10

IFN M.KL10!M.KI10,<
IOPSTP:	STOPCD	(.,CPU,IOP)		;++I/O PAGE FAILURE
>
	$HIGH
;DEFINE KI10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KI(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: CONO	PI,II.CPF!XI.CPE  ;CLEAR POWER FAIL, PAR ERR
	CONO	APR,IP.CTE!IP.CAE!IP.ECI!IP.CIO!IP.CNM	;CLEAR TIMEOUT ENABLE,
				;CLEAR AUTO RESTART ENABLE, ENABLE CLOCK INT., CLEAR
				; IO PAGE FAIL, CLEAR NON EX MEM

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT: CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
IFN FTMP,<
IFG <CPUN-1>,<
	SKIPE	CPNDDT		;ANY CPU HIT A BREAKPOINT?
	JRST	CPNBPT##	;YES, WAIT FOR IT
>>
AP'N'BCK::CONSZ	APR,IP.TTO!IP.PAR!IP.PWF!IP.ABK!IP.IOF  ;TIMER TIMEOUT,
				; MEM PAR, POWER FAIL, ADDRESS BREAK, IO PAGE FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2:: MOVEM	P,.C'N'SP	;SAVE AC P
IFE N,<	CONI	APR,P		;GET SENSE SWITCHES
	TLNN	P,(IP.SS6)	;SEE IF 6 SET
	SKIPE	CLKDDT		;OR 21 NON-ZERO
	JRST	.+2		;YES--GO TO EDDT
	JRST	CLKDDR		;NO--PRECEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::>
	MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSH	P,P4		;SAVE P4
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P4,(P)		;RESTORE P4
AP'N'EPF:MOVE	P,.C'N'SP	;RESTORE P
AP'N'EXT: CONO	APR,AP'N'CHN+AP'N'CHN_3  ;SET APR PI AND ERROR PI
	JEN	@AP'N'CHL	;DISMISS INTERRUPT

;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,IP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,IP.TTO!IP.IOF	;TIMER RUNOUT OR IO PAGE FAIL?
	JRST	AP'N'NHT	;YES
	CONSZ	APR,IP.PAR	;NO, PARITY?
	JRST	AP'N'IN2	;YES, GO PROCESS
	AOS	.C'N'ABC	;NO, MUST BE ADDRESS BREAK
	DATAI	APR,.C'N'ABA	;READIN SWITCHES TO DETERMINE ADDRESS TO DISPLAY
	DATAO	PI,@.C'N'ABA	;DISPLAY CONTENTS OF EFFECTIVE ADDRESS
				; USING ALL EXEC ACS
	CONO	APR,IP.CAB!IP.NXM	;CLEAR ADDRESS BREAK AND NON EX MEM
				; (IN CASE OF SYSTEM PROGRAMMER ERROR)
	JRST	AP'N'EXT	;DISMISS INTERRUPT
AP'N'PWF:MOVEM	P,.C'N'SP	;SAVE P
	MOVE	P,AP'N'PDP	;USE PDL TO SAVE STATE
	CONI	PI,1(P)		;STATE OF THE PI SYSTEM
	CONO	PI,1177		;NO MORE PIS
	DATAI	PAG,2(P)	;EUBR
	MOVEM	17,22(P)	;SAVE EXEC'S ACS
	MOVEI	17,3(P)
	BLT	17,21(P)
	MOVEI	17,23(P)	;SAVE USER'S ACS
	JRSTF	@[IC.UOU+.+1]	;TURN USER IOT ON SO SAVING USER ACS WORKS
	MOVSI	16,17777
	TDNN	16,2(P)		;UPM ZERO?
	TDZA	16,16		;YES, DON'T SAVE AC'S
	MOVSI	16,(PG.LUB)	;NO, SET UP FOR RESTORE
	IORM	16,2(P)		;REMEMBER FOR RESTORE
	SKIPE	16		;DON'T SAVE AC'S IF NO USER
	EXCTUX	<BLT 17,42(P)>
	MOVSI	16,(JRST)
IFN FTMP,<
	HLLM	16,.CPRES
>
IFE FTMP,<
	HLLM	16,ARSLOC
>
	CONO	APR,IP.SAE	;ENABLE AUTO-RESTART
	CONO	PI,II.CPF	;CLEAR POWER FAIL
	MOVEI	17,400000	;ABOUT 200 MILLISECONDS
	SOJG	17,.		;WAIT AWHILE
	JRST	APRRES		;POWER DIDN'T REALLY FAIL, RESTORE STATE AND CONTINUE
AP'N'RES:MOVE	P,AP'N'PDP	;WHERE SAVED STATE IS
	MOVE	17,2(P)
	DATAO	PAG,17		;RESTORE THE UBR
	MOVSI	17,23(P)	;RESTORE USER'S ACS
	SKIPGE	2(P)		;DON'T RESTORE IF NO USER
	EXCTXU	<BLT 17,17>
	MOVSI	17,3(P)		;RESTORE EXEC'S ACS
	BLT	17,16
	MOVE	P,AP'N'PDP
	MOVEI	17,177
	AND	17,1(P)
	TRO	17,PI.EPE+PI.TNP+PI.ON
	CONO	PI,(17)		;RESTORE THE PI SYSTEM
	CONO	APR,IP.CTE!IP.SAE!IP.ECI!IP.CIO!IP.CNM
	MOVSI	17,(HALT)
IFN FTMP,<
	HLLM	17,.CPRES
>
IFE FTMP,<
	HLLM	17,ARSLOC
>
	MOVE	17,22(P)
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	JRST	AP'N'EPF	;DISMISS

AP'N'NHT:MOVEM	P,.C'N'SP	;GET A VALID PDL
	MOVE	P,AP'N'PDP
	JRST	IOPSTP		;MUST BE I/O PAGE FAIL
>				;END KI MACRO

;DEFINE KL10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KL(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: CONO	APR,LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF
				;CLEAR AUTO RESTART ENABLE, ENABLE CLOCK INT., CLEAR
				; IO PAGE FAIL, CLEAR NON EX MEM

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT: CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	CONSO	APR,LP.CSD
	JRST	AP'N'IN1
	CONO	APR,LP.CSF+LP.CSD+AP'N'CHN
	AOS	.CPCSN
	EXCH	T1,.CPSCS
	IORM	T1,DOORBL
	EXCH	T1,.CPSCS
IFE FTKLP,<
	JEN	@AP'N'CHL
>
IFN FTKLP,<
	XJEN	AP'N'CHL
>
AP'N'IN1: CONSZ	APR,LP.NXM!LP.CDP!LP.ADP!LP.SBE!LP.PAR!LP.PWF!LP.IOF	;TIMER TIMEOUT,
				; MEM PAR, POWER FAIL, ADDRESS BREAK, IO PAGE FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2::
IFE FTKLP,<
	MOVEM	P,.C'N'SP	;SAVE AC P
>
IFN FTKLP,<
	DMOVEM	P,.C'N'SP	;SAVE AC P
>
AP'N'CLK:
IFE N,<	SKIPN	CLKDDT		;IS 21 NON-ZERO
	JRST	CLKDDR		;NO--PRECEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::>
	MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSH	P,P4		;SAVE P4
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P4,(P)		;RESTORE P4
AP'N'EPF:
IFE FTKLP,<
	MOVE	P,.C'N'SP	;RESTORE P
>
IFN FTKLP,<
	DMOVE	P,.C'N'SP	;RESTORE P
>
AP'N'EXT: CONO	APR,AP'N'CHN  ;SET APR PI
IFE FTKLP,<
	JEN	@AP'N'CHL	;DISMISS INTERRUPT
>
IFN FTKLP,<
	XJEN	AP'N'CHL
>

;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,LP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,LP.ADP!LP.CDP!LP.IOF ;ADDRESS OR CACHE DIRECTORY PARITY?
	JRST	AP'N'NHT	;GO DO DIAG INST'S AND HALT
	CONSZ	APR,LP.NXM	;NXM?
	JRST	AP'N'NXM	;YES, DO SPECIAL STUFF ON KL
	CONSZ	APR,LP.PAR	;NO--MB PARITY ERROR?
	JRST	AP'N'IN2	;YES, GO PROCESS
	CONSZ	APR,LP.SBE	;SBUS ERROR?
IFE M.MOS,<
	JRST	AP'N'NHT	;YES, JUST DO DIAG INST'S AND HALT
	JRST	AP'N'EXT	;DISMISS INTERRUPT
>
IFN M.MOS,<
	JRST	[CONO APR,LP.CSF+LP.SBE ;CLEAR SBUS ERROR EARLY IN CASE OF SINGLE BIT
		 MOVEM P,.CPSP	; ERROR IN ERROR ANALYSIS CODE
		 MOVE P,AP'N'PDP;SETUP A PUSH DOWN LIST
		 PUSHJ P,SBERR##;DO ERROR ANALYSIS AND RECORD ERRORS FOR THGA
		 MOVE P,.CPSP	;RESTORE P
		 JRST AP'N'EXT]	;EXIT INTERRUPT
>
;HERE ON NXM - CLEAR MB PARITY ERROR AND SBUS ERROR, SWEEP CACHE
AP'N'NXM:: CONO	APR,LP.CSF!LP.PAR!LP.SBE  ;CLEAR ALL BUT INTERESTING STUFF
	SWPUA			;SWEEP THE CACHE SINCE NXM LEAVES
				; BAD PARITY IN CACHE
	CONSZ	APR,LP.CSB	;WAIT FOR FINISH
	JRST	.-1
	JRST	AP'N'IN2	;GO DO A NXM THING

;HERE TO HALT ON APR ERROR CONDITION--DO SBDIAG AND RDERA FIRST
AP'N'NHT:MOVEM	P,.C'N'SP	;GET A VALID PDL
	MOVE	P,AP'N'PDP
	CONSZ	APR,LP.IOF	;IO PAGE FAILURE?
	JRST	IOPSTP		;YES, GO HALT
	RDERA	.C'N'AER	;READ ERA INTO CPU DATA BLOCK
	CONI	APR,.C'N'AEF	;SAVE CONI APR,
	SBDIAG	.C'N'SB0	;GET SBDIAG FUNCTIONS 1+2
	SBDIAG	.C'N'SB1	;
	SWPUA			;CACHE SWEEPS SO WE CAN SEE DATA
	CONSZ	APR,LP.CSB
	JRST	.-1
	CONSZ	APR,LP.SBE	;SBUS ERROR?
	STOPCD	(.,CPU,SB'N)	;++SBUS ERROR ALONE
	CONSZ	APR,LP.CDP	;CACHE DIR. PAR.?
	STOPCD	(.,CPU,CD'N)	;++CACHE DIRECTORY PARITY ERROR
				;MUST BE ADDR PARITY ERROR
	STOPCD	(.,CPU,AD'N)	;++ADDR. PARITY ERROR

;KL10 INTERVAL TIMER INTERRUPT HANDLER
	$ABS

TM'N'INT::0
IFE FTKLP,<
	JRST	TM'N'IN0
>
IFN FTKLP,<
	0
	EXP	IC.UOU
	EXP	TM'N'IN0
>

;KL10 KEEP-ALIVE FAILURE TRAP HANDLER

AP'N'KAF:0
IFN FTKLP,<
	0
	EXP	IC.UOU
	EXP	AP'N'KA0
AP'N'KA0:>
	MOVEM	P,KF'N'SVP		;;SAVE P
	MOVEI	P,KF'N'PDL-1		;;SETUP NEW P
	JRST	KAFSTP			;;GIVE STOPCD
KF'N'PDL:BLOCK	1
KF'N'SVP:BLOCK	1			;;SAVE P HERE
	$HIGH
TM'N'IN0:
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
IFN FTMP,<
IFG <CPUN-1>,<
	SKIPE	CPNDDT		;ANY CPU HIT A BREAKPOINT?
	JRST	CPNBPT##	;YES, WAIT FOR IT
>>
AP'N'BCK::
IFN FTKLP,<
	DMOVEM	P,.C'N'SP	;SAVE P
	DMOVE	P,TM'N'INT	;STORE PC
	DMOVEM	P,@.C'N'CHL	;SAVE AT APR PI CHANNEL JSR ADDRESS
>
IFE FTKLP,<
	MOVEM	P,.C'N'SP	;SAVE P
	MOVE	P,TM'N'INT	;STORE PC
	MOVEM	P,@.C'N'CHL	;SAVE AT APR PI CHANNEL JSR ADDRESS
>
	MOVSI	P,(ST.CYC)	;50 HZ POWER?
	TDNE	P,STATES	;SKIP IF NO
	JRST	[MOVEI	P,^D2000 ;50HZ, SO SETUP 20000 USECS
		 JRST	TM'N'IN1] ;AND SET THAT AS NEW INTERVAL
	MOVEI	P,^D1666	;60HZ, SO ASSUME LEAP JIFFY
	AOSG	.C'N'TCT	;COUNT TRIAD COUNTER (-1,0,1)
	AOJA	P,TM'N'IN1	;NOT LEAP TICK UNLESS TRIAD COUNT IS 1
	SETCMM	.C'N'TCT	;COUNT REACHED 1, SET BACK TO -2
TM'N'IN1:CONO	TIM,TO.CTD!TO.SIT(P)	;SET INTERVAL OF TIMER AGAIN
	SETOM	.C'N'TIM	;SOFTWARE CLOCK FLAG FOR KL'S
	JRST	AP'N'CLK	;GO JOIN MAIN STREAM OF EVENTS
AP'N'PWF:CONI	PI,AP'N'PD1+1	;SAVE STATE OF PI SYS
	CONO	PI,PI.OFF	;TURN OFF INTERRUPTS
	MOVEM	P,.C'N'SP	;SAVE P
	MOVE	P,.CPEBR	;GET CURRENT EBR
	ANDI	P,-1-<LG.CSL!LG.CSW> ;TURN OFF CACHE
	CONO	PAG,(P)		;...
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB
	JRST	.-1
	DATAI	PAG,AP'N'PD1+2	;SAVE UBR, CURRENT, PREVIOUS AC BLKS
	CONI	MTR,AP'N'PD1+3
	MOVE	P,.C'N'SP
	JSR	.CPSVA		;SAVE ALL AC SETS
	MOVSI	P,(JRST)
IFN FTMP,<
	HLLM	P,.CPRES
>
IFE FTMP,<
	HLLM	P,ARSLOC
>
	MOVEI	P,AP'N'PD1+4	;GET A STACK
	PUSHJ	P,DTEPWF##	;TELL F.E. WE HAVE A POWER FAILURE
	MOVEI	17,700000
	SOJG	17,.		;MAKE SURE POWER HAS FAILED
	JRST	APRRES		;IT HASN'T
AP'N'RES:SWPIA			;CLEAR OUT CACHE
	CONSZ	APR,LP.CSB
	JRST	.-1
	CONO	PAG,@.CPEBR	;TURN ON CACHE, TRAP ENABLE
	MOVE	P,AP'N'PD1+1	;GET CONI PI WORD
	ANDI	P,377		;JUST SYS ON, OFF AND CHANNELS ON, OFF
	CONO	PI,PI.TNP(P)	;TURN ON CHANNELS AND SYS, IF IT WAS ON BEFORE
	MOVE	P,AP'N'PD1+2	;GET UPT INFO
	TRO	P,LG.IAM	;INHIBIT UPDATING OF ACCOUNTING METERS
	DATAO	PAG,P		;RESTORE UBR FOR METERS
	MOVE	P,AP'N'PD1+3	;GET CONI MTR,
	CONO	MTR,MO.LAC(P)	;LOAD ACCOUNTING CONTROL, PI
	MOVSI	P,(HALT)
IFN FTMP,<
	HLLM	P,.CPRES
>
IFE FTMP,<
	HLLM	P,ARSLOC
>
	MOVEI	P,AP'N'PD1+4	;GET A STACK
	PUSHJ	P,DTEPFC##	;RE-ESTABLISH PRIMARY PROTOCOL
	JSR	ZAPRH2		;PUT RH20'S BACK TOGETHER
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	RESTOR	(0,.CPCAC)
	RESTOR	(1,.CPCA1)
	RESTOR	(2,.CPCA1+20)
	RESTOR	(3,.CPCA1+40)
	RESTOR	(4,.CPCA1+60)
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT!^D1667
	DATAO	PAG,AP'N'PD1+2
	CONO	APR,AP'N'NUL	;CLEAR POWER FAIL, ENABLE FOR GOOD STUFF
	JRST	AP'N'EXT	;BYE.
> ;END KL10 MACRO
;DEFINE KS10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KS(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: WRAPR	SP.CSF+SP.NXM+SP.HMP+SP.SMP+SP.PWF
				;CLEAR NXM, HARD & SOFT PARITY, POWER FAILURE

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT::CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
AP'N'BCK::CONSZ	APR,SP.NXM!SP.HMP!SP.PWF ;NXM, HARD PARITY OR POWER FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2::MOVEM	P,.C'N'SP	;SAVE AC P
	CONSO	APR,SP.ITI	;CLOCK TICK?
	JRST	AP'N'IN3	;NO, PROCEED
	MOVSI	P,(ST.CYC)	;50 HZ POWER?
	TDNE	P,STATES	;SKIP IF NO
	JRST	[MOVEI	P,<^D20> ;50HZ, SO SETUP 20 MILLISECS
		 JRST	TM'N'IN1] ;AND SET THAT AS NEW INTERVAL
	MOVEI	P,<^D16>	;60HZ, SO ASSUME LEAP JIFFY
	AOSG	.C'N'TCT	;COUNT TRIAD COUNTER (-1,0,1)
	SKIPA	P,[<^D17>] 	;NOT LEAP TICK UNLESS TRIAD COUNT IS 1
	SETCMM	.C'N'TCT	;COUNT REACHED 1, SET BACK TO -2
TM'N'IN1:ADDM	P,.C'N'LMC	;ADD THIS INTERVAL TO LEAP MSEC COUNT
	SKIPL	.C'N'LMC	;IS IT STILL NEGATIVE?
	ADDI	P,1		;NO--IT'S TIME FOR A LEAP MSEC
	LSH	P,<^D12>	;SHIFT TO LOAD INTO TIMER REGISTER
	WRINT	P		;SET INTERVAL OF TIMER AGAIN
	WRAPR	SP.CSF!SP.ITI	;CLEAR INTERVAL TIMER INTERRUPT FLAG
	SETOM	.C'N'TIM	;SET SOFTWARE CLOCK TICK FLAG
	SKIPGE	P,.C'N'LMC	;IS THIS A LEAP MSEC?
	JRST	TM'N'IN2	;NO--GO ON
	ADD	P,[-^D1024]	;YES--COMPUTE NEXT LEAP MSEC COUNT
	MOVEM	P,.C'N'LMC	;RESET IT
TM'N'IN2:SKIPN	CLKDDT		;IS 21 NON-ZERO
	JRST	CLKDDR		;NO--PROCEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::
AP'N'IN3::MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P,.C'N'SP	;RESTORE P
AP'N'EXT:WRAPR	AP'N'CHN	;SET APR PI
	JEN	@AP'N'CHL	;DISMISS INTERRUPT
;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,SP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,SP.NXM!SP.HMP ;NXM OR PARITY ERROR?
	JRST	AP'N'IN2	;YES--GO PROCESS IT
	JRST	AP'N'EXT	;DISMISS INTERRUPT

	DEFINE ZERO(X),<
	EXECAC	(X)
	SETZ	0,
	MOVEI	17,1
	BLT	17,17
>
AP'N'PWF:RDPI	AP'N'PD1+1	;SAVE STATE OF PI SYS
	WRPI	PI.OFF		;TURN OFF PI'S
	RDUBR	AP'N'PD1+2	;SAVE UBR, CURRENT, PREVIOUS AC BLKS
	RDTIME	AP'N'PD1+3	;SAVE TIME BASE
	JSR	.CPSVA		;SAVE ALL AC SETS
	MOVE	P,[JRST APRRES]	;POWER FAIL AUTO RESTART INTSTRUCTION
	MOVEM	P,ARSLOC	;SET IT UP
	HALT			;STOP
				;FE RESTARTS US AT 70 WHICH EVENTUALLY
				; GETS US HERE
AP'N'RES:WRUBR	AP'N'PD1+2	;RESTORE UBR AND AC BLOCKS IN USE
	SETZ	0,		;CLEAR CURRENT AC BLOCK FOR USE
	MOVEI	17,1		;...
	BLT	17,17		;...
	MOVEI	P,AP'N'PD1+5	;GET A STACK
	PUSHJ	P,UBAPIS	;RESET UBA'S
	MOVE	T1,AP'N'PD1+1	;GET CONI PI WORD
	ANDI	T1,377		;JUST SYS ON, OFF AND CHANNELS
	WRPI	PI.TNP(T1)	;RESTORE PI SYSTEM
	MOVEI	T1,<^D16>B23	;RESTART INTERVAL TIMER
	WRINT	T1		;SET IT
	MOVE	T1,[HALT ARSLOC];HALT AT 70 INSTRUCTION
	MOVEM	T1,ARSLOC	;DISABLE 70 RESTART
	HRRZ	U,OPRLDB	;OPR'S LDB
	MOVEI	T1,[ASCIZ /
%POWER FAIL RESTART
/]
	PUSHJ	P,CONMES##	;ANNOUNCE RESTART
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE FUNCTION
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	RESTOR	(0,.CPCAC)	;RESTORE AC'S
	RESTOR	(1,.CPCA1)
	RESTOR	(2,.CPCA1+20)
	RESTOR	(3,.CPCA1+40)
	RESTOR	(4,.CPCA1+60)
	ZERO	(5)		;CLEAN OUT REST OF AC BLOCKS
	ZERO	(6)
	ZERO	(7)
	WRUBR	AP'N'PD1+2	;RESTORE UBR AND AC BLOCKS IN USE
	WRTIME	AP'N'PD1+3	;RESTORE TIME BASE
	WRAPR	AP'N'NUL	;CLEAR POWER FAIL, ENABLE FOR GOOD STUFF
	JRST	AP'N'EXT	;BYE.

;KS10 KEEP-ALIVE FAILURE TRAP CODE
	$ABS
AP'N'KAF:0
	MOVEM	P,KF'N'SVP
	MOVEI	P,KF'N'PDL-1
	JRST	KAFSTP
KF'N'PDL:BLOCK	1
KF'N'SVP:BLOCK	1
	$HIGH


;ROUTINE TO SET UP PI ASSIGNMENTS ON UBA'S
UBAPIS::PUSHJ	P,SAVT		;SAVE T REGS
	MOVE	T1,[1,,UNBSTW]	;UBA #1 STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UBA #1 THERE?
	  JRST	UBAPI0		;NO--SO DON'T TRY TO INIT IT
	MOVSI	T2,1		;UBA #1
	MOVEI	T1,UBINIT	;UNIBUS INIT
	WRIO	T1,UNBSTW(T2)	;DO IT
	MOVEI	T1,UBA1PI	;UBA #1 PI
	IORI	T1,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T1,UNBSTW(T2)	;SET UP AND INIT UBA #1
UBAPI0:	MOVE	T1,[3,,UNBSTW]	;UBA #3 STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UBA #3 THERE?
	  POPJ	P,		;NO--SO DON'T TRY TO INIT IT
	MOVSI	T2,3		;UBA #3
	MOVEI	T1,UBINIT	;UNIBUS INIT
	WRIO	T1,UNBSTW(T2)	;DO IT
	MOVEI	T1,UBA3PI	;UBA #3 PI'S
	IORI	T1,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T1,UNBSTW(T2)	;SET UP AND INIT UBA #3
	POPJ	P,		;RETURN
>;END KS10 MACRO
;GENERATE APR INTERRUPT CODE DEPENDING ON CPUN AND KI VS KL VS KS
ZZ==0
REPEAT CPUN,<				;NO OF CPUS IN SYSTEM
	KILS(\ZZ)			;GENERATE INTERRUPT CODE
	ZZ==ZZ+1			;STEP TO NEXT CPU NUMBER
>
	$ABS
SUBTTL EXTERNS TO FORCE LIBRARY LOADING
;GENERATE EXTERNAL GLOBALS TO CAUSE LOADING OF PROPER ROUTINES FROM
; MONITOR LIBRARY TAPE IF THERE IS ONE


;ALWAYS LOAD CLOCK1,COMCON,CORE1,ERRCON,JOBDAT,ONCE,PATCH,UUOCON,DATMAN,TMPUUO,
; AND EITHER KLSER OR KISER

EXTERNAL VMSER,VMDTJB
IFN M.KI10,<
EXTERNAL KISER
>
IFE M.KL10,<
	XP	DTE.,CPOPJ	;NO DTE. UUO
>
IFN M.KL10,<
EXTERNAL KLSER,DTESER,TTDINT,FEDSER
IFN M.MOS,<
EXTERNAL MOSSER
>
>
IFN M.KS10,<
EXTERNAL KSSER
>
EXTERNAL CLOCK1,COMCON,CORE1,ERRCON,ONCE,PATCH,UUOCON,DATMAN,TMPUUO

;LOAD FILE SERVICE ROUTINES, REFRESHER & ONCMOD (EXTRA ONCE ONLY CODE) FOR LEVEL D
;LEVEL D ALSO REQUIRES COMMOD, WHICH IS A SEPARATE FILE OF DISK PARAMETERS
;UNLESS SYMBOL FTCMBTH IS DEFINED, IN WHICH CASE THEY ARE HERE IN COMMON
	IFN	LEVDN,<EXTERNAL FILFND,FILIO,FILUUO,ONCMOD,REFSTR
		IFNDEF FTCMBTH,<EXTERN COMMOD>>

;LOAD DDT
	IFG	DDTN, <EXTERNAL DDTX>
	IFE	DDTN, <
		XP DDTEND,0	;ONCE REFERENCES END OF DDT
		XP DDTX,0	; AND ALSO ITS ENTRY POINT.
		XP $1B,0	; AND ALSO BREAKPOINTS
		>

;LOAD SCHEDULER FOR NON-SWAPPING OR SWAPPING SYSTEM
	EXTERNAL SCHED	;SCHED
		IFN LEVDN,<EXTERNAL SWPSER	;IO HANDLER FOR LEVEL D SWAPPER>


	EXTERNAL SEGCON
;SATISFY GLOBAL NEEDED FOR USER MODE ONCE ONLY - NEVER CALLED BY EXEC MONITOR
	XP	USRCPY,CPOPJ
SUBTTL METCON LINKAGE AND TABLES
;LOAD OR FAKE METCON DEPENDING ON FTMETR & M.METR

IFN FTMETR,<
IFG M.METR,<
;-----------THIS CODE IF ASSEMBLE (F.MAC) = YES; LOAD (MONGEN) = YES
	EXTERN	METCON


>	;IFG M.METR

IFE M.METR,<
;-----------THIS CODE IF ASSEMBLE = YES; LOAD = NO

METINI::0
	JRST	@METINI
METREL==:CPOPJ
METER==:CPOPJ		;ERROR RETURN TO METER. UUO
MPDPRA==:0
MPDPAR==:0

		;FAKE MPTAB
DEFINE METERP (N)<
MP'N=:[0]
>
RADIX 10
SALL
METERP 1
METERP 2
METERP 3
METERP 4
METERP 5
RADIX 8

>	;IFE M.METR
>	;IFN FTMETR
	$HIGH
SUBTTL	DK10 INTERRUPT SERVICE
IFN M.KI10,<
;-------REAL TIME CLOCK (DK10) SERVICE
;	MUST FOLLOW METER-POINT DEFINITION SO MEP3 DEFINED

IFN M.RT0!M.RT1,<		;MONGEN COND. ASSEMBLY

;-------INITILIZATION FOR RTC

;ON SYSTEM RESTART (E.G. AFTER CRASH) RTCINI MUST BE CALLED AFTER METINI
;   SINCE THE RTC SERVICE ROUTINE CONTAINS METER POINTS
;
;	MOVE	F,DDBADDR
;	JSR	RTCINI(F)

;-------INTERRUPT SERVICE (PURE PART)
;	F ADDRESSES DDB, T1 IS SAVED

RTCINT::MOVE	T1,RTCPRD##(F)	;GET PERIOD
	XCT	RTCSNO##(F)	;OVERFLOW?
	MOVSI	T1,1		;YES PERIOD=2^18
	ADDM	T1,RTCTIM##(F)	;UPDATE TIME
	JRST	RTCXIT##(F)	;CLEAR IRP. & EXIT

>		;IFN M.RTC
;INITIALIZATION FOR TIME ACCOUNTING
;  TIME (TIME OF DAY) MUST HAVE BEEN SET UP
;  STATES BIT ST.HPT DETERMINES WHETHER DK10 OR APR CLOCK IS USED.

;
;	MOVE	P4,CDBADDR
;	PUSHJ	P,SETIME
;	---			;RETURN-DESTROYS F,T1,T2

SETIME::
IFN M.RTC,<
	MOVSI	T1,(ST.HPT)	;HIGH PRECISION TIME?
	TDNN	T1,STATES	;   (BIT DETERMINED BY MONGEN)
	JRST	SETIM6		;NO-INIT. FOR APR CLOCK
	SKIPN	F,.CPRTC	;YES-IS THERE A DK10 DDB
	JRST	SETIM6		;NO MONGEN & ONCE SHOULD CATCH THIS!!
	MOVEM	F,.CPRTD	;YES-SET UP DDB ADDRESS
	MOVEI	T1,^D100000	;SET UNITS/SEC
	MOVEM	T1,RTCUPS
	PUSHJ	P,GETIMI	;SET DK10 TIME
	MOVEM	T1,RTCTIM##(F)
	MOVEM	T1,RTCLGT##(F)
	MOVEM	T1,.CPXTM	; & CDB INTERVAL COUNTER
	JSR	RTCINI##(F)	;START THE CLOCK
	POPJ	P,

SETIM6:	ANDCAM	T1,STATES	;CLEAR HIGH PREC. TIME IN STATES
	SETZM	.CPRTD		;DDB ADDR=0 FOR APR CLOCK
	MOVE	T1,TICSEC	;UNITS/SEC=LINE FREQ.
	MOVEM	T1,RTCUPS
	PUSHJ	P,GETIMI	;SET CDB INTERVAL COUNTER
	MOVEM	T1,.CPXTM
	POPJ	P,

>				;IFN M.RTC

IFE M.RTC,<
	PUSHJ	P,GETIMI
	MOVEM	T1,.CPXTM
	POPJ	P,
>				;IFE M.RTC
;RETURN T1=TIME OF DAY IN 'RTUPS' UNITS/SEC.
;  DESTROYS T2,F
;  REQUIRES P4 TO BE SETUP
;  GETIME MUST BE INITIALIZED WITH SETIME BEFORE USE

RTUPS=:	^D100000		;RESOLUTION (UNITS/SEC) OF TIME RETURNED BY GETIME
				; INDEPENDENT OF CLOCK USED
				;NOTE - RUNTIM UUO (JOBTIM: IN UUOCON) DEPENDS ON
				; RTUPS BEING AN INTEGRAL MULTIPLE OF ^D100000

IFN RTUPS-<RTUPS/^D100000>*^D100000,<
PRINTX	%GETIME:  JOBTIM requires RTUPS to be multiple of OF ^D100000>
RTUPS3==: RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==: RTUPS/^D100000
GETIME::

;-------CODE FOR DK10 (100KHZ) TIME ACCOUNTING-------

IFN M.RTC,<

	SKIPN	F,.CPRTD	;GET DK10 DDB ADDR.
	JRST	GETIM6		;0 MEANS USE APR CLOCK
GETIM2:	XCT	RTCSON##(F)	;IS DK10 ON?
	JSR	RTCINI##(F)	;NO - START IT

GETIM3:	MOVE	T2,RTCTIM##(F)	;GET TIME (AT LAST IRP.)
	XCT	RTCDAI##(F)	;GET CURRENT TIME
	ADD	T1,T2		;ADD HI & LOW ORDERS.
	CAME	T2,RTCTIM##(F)	;WAS I INTERRUPTED?
	JRST	GETIM3		;YES - TRY AGAIN
	CAMGE	T1,RTCLGT##(F)	;DON'T RETURN A TIME LESS
	MOVE	T1,RTCLGT##(F)	;  THAN THE LAST ONE
	MOVEM	T1,RTCLGT##(F)	;  & REMEMBER THIS ONE AS LAST ONE
	POPJ	P,

>	;IFN M.RTC

;-------CODE FOR APR CLOCK (60/50 HZ) TIME ACCOUNTING-------

GETIMI:				;CALLED BY SETIME TO INIT STUFF
GETIM6:	MOVE	T1,TIME
	MULI	T1,RTUPS	;CONVERT TO RTUPS UNITS
	DIV	T1,TICSEC
	POPJ	P,

RTCMAX::RTUPS*^D3600*^D24	;WRAPAROUND TIME (MIDNIGHT)


;HERE FROM CLOCK1 AT MIDNIGHT


IFN M.RTC,<
RTCDAY::MOVN	T1,RTCMAX	;RESET DK10 TIMES
	SYSPIF
IFN M.RT0,<
	SKIPN	F,.C0RTD
	JRST	RTCDA1
	ADDM	T1,RTCTIM##(F)
	ADDM	T1,RTCLGT##(F)
IFN M.METR,<ADDM T1,LASTM>
>
RTCDA1:
IFN M.RT1,<
	SKIPN	F,.C1RTD
	JRST	RTCDA2
	ADDM	T1,RTCTIM##(F)
	ADDM	T1,RTCLGT##(F)
>
RTCDA2:	SYSPIN
	POPJ	P,
>	;IFN M.RTC


IFE M.RTC,<RTCDAY==:CPOPJ>

;FAST GETIME FOR METER.UUO (RT0 ONLY I.E. ONLY CPU0 SHOULD USE THIS)
;	USES ONLY T1,T3

IFN M.METR,<
IFN M.RT0,<
METIME::MOVE	T3,RT0TIM##
	RT0DTI##,,T1		;DATAI RT0,T1
	ADD	T1,T3
	CAME	T3,RT0TIM##
	JRST	METIME
	CAMGE	T1,LASTM	;DON'T RETURN A TIME
	MOVE	T1,LASTM	;LESS THAN LAST ONE
	MOVEM	T1,LASTM	;+ REMEMBER THIS ONE AS LAST ONE
	POPJ	P,

	$ABS
LASTM:	0			;LAST TIME FOR METIME
>				;IFN M.RT0

IFE M.RT0,<METIME==:CPOPJ>
>				;IFN M.METR
>;END IFN M.KI10
SUBTTL	KL10 SYSTEM TIME BASE ROUTINES
IFN M.KL10,<

;THESE ROUTINES PERFORM THE SAME FUNCTIONS AS THE DK10 ROUTINES DO
; FOR THE KI10. THEY ALSO INITIALIZE THE ACCOUNTING METERS.

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MUL	T1,[RTUPS*^D10]	;CONVERT TO 1 USEC UNITS FOR TIME BASE
	ASHC	T1,<^D35-TB.LTP>;ACCOUNT FOR COUNTS/TICK
	CONO	MTR,MO.TOF!MO.CTB ;TURN OFF TIME BASE, CLEAR IT.
	MOVE	T3,.CPEPT	;ADDRESS OF THIS PROCESSOR'S EPT
	DMOVEM	T1,.E0HTB-.E0MP(T3) ;STORE UNIVERSAL DATE TIME BASE (RUNS OUT IN 5028
	MOVEI	T2,MO.LAC!MO.AO!MO.AEN!MO.AIP	;INITIALIZE ACCOUNTING
	MOVEI	T1,ST%XPI	;CHECK IF PI TIME IS EXCLUDED
	TDNE	T1,CNFST2	;SKIP IF IT IS NOT EXCLUDED
	TRZ	T2,MO.AIP	;IT IS, DO NOT INCLUDE
	CONO	MTR,MO.TON(T2)	;TURN TIME BASE ON, DO GOOD STUFF
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,


RTUPS==:^D100000	;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	ASHC	T3,<TB.LTP-^D35>	;ACCOUNT FOR COUNT/TIME BASE TICK
	DDIV	T1,RTCMTT	;DIVIDE BY RTCMAX*10, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND USECS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D10		;CONVERT TO RTUPS UNITS (10 USECS)
	MOVE	T1,T3		;AND GET FINAL ANSWER IN T1
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	2,203565660000	;RTUPS*^D3600*^D24*^D10 (MICROSECS/DAY)
RTCDAY==:CPOPJ

IFN M.METR,<
METIME::PUSH	P,T2		;FOR METER UUO
	PUSHJ	P,GETIME
	JRST	T2POPJ
>;END IFN M.METR
IFE M.METR,<
	METIME==:CPOPJ		;IN CASE NO METER UUO
>;END IFE M.METR

>;END IFN M.KL10
SUBTTL	KS10 SYSTEM TIME BASE ROUTINES
IFN M.KS10,<

;THESE ROUTINES PERFORM THE SAME FUNCTIONS AS THE DK10 ROUTINES DO
; FOR THE KA10 AND KI10.

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MULI	T1,^D1000	;MILLISECOND RESOLUTION
	ASHC	T1,^D12		;ACCOUNT FOR COUNTS/TICK
	WRTIME	T1		;LOAD TIME BASE
	MOVEI	T1,<^D17>B23	;INTERVAL FOR TIMER
	WRINT	T1		;LOAD INVERVAL FOR TIMER
	WRAPR	SP.CSF+SP.ESF+SP.ITI+AP0CHN ;TURN INTERVAL TIMER ON
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,		;END RETURN


RTUPS==:^D100000	;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	DDIV	T1,RTCMTT	;DIVIDE BY TICS/DAY, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND TICS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D41		;CONVERT TO RTWPS UNITS
	MOVE	T1,T3		;GET INTO T1 (IN 10 USEC UNITS)
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	12,117226200000	;CLOCK TICS PER DAY AT 4.1 MHZ
RTCDAY==:CPOPJ

IFN M.METR,<
METIME::PUSH	P,T2		;MUST SAVE T2 FOR METCON CALLS
	PUSHJ	P,GETIME	;GET TIME IN T1
	JRST	T2POPJ		;RESTORE T2 AND RETURN
>;END IFN M.METR
IFE M.METR,<
	METIME==:CPOPJ		;IN CASE NO METER UUO
>;END IFE M.METR

>;END IFN M.KS10
;DEFINE DUMMY INTERNALS IF FTMBTS IS ON BUT M.MBTS IS 0

IFE FTMBTS,<
IFN M.MBTS,<
PRINX ?FTMBTS MUST BE ON FOR MONBTS
>>

IFN FTMBTS,<
IFN M.MBTS,<
	EXTERN	MONBTS		;FORCE LOADING OF MONBTS
>
IFE M.MBTS,<
	XP	REMSDL,CPOPJ
	XP	SDLREM,CPOPJ
	XP	ADDSDL,CPOPJ1
	XP	SDLADD,CPOPJ
	XP	BUGDMP,CPOPJ
	XP	FNDSDL,M1POPJ
	XP	SDLUNI,CPOPJ
	XP	PAGRPL,CPOPJ
	XP	SLPDMP,CPOPJ
>>
;DEFINE GLOBALS IF NO MOS MEMORY SUPPORT
IFN M.KL10,<IFE M.MOS,<
	XP	DIAGTM,CPOPJ
	XP	DIAGVM,CPOPJ
>>


SUBTTL PROCESSOR STUFF

;MAKE SURE THAT PROPER VERSION OF FEATURE SWITCH FILES WERE USED TO ASSEMBLE
;THE REST OF THE MONITOR
;THE LOADER WILL PRINT MUL. DEF. GLOBAL IF A MISTAKE HAS BEEN MADE

;DUAL PROCESSOR SYSTEM ROUTINE GETS LOADED HERE

IFG <CPUN-1>,<
	EXTERN	CPNSER
>

	IFE	COREN, <COREN==^D256_K2PLSH	;NO RESTRICTION IF 0 TYPED>
	XP	USRLIM,COREN	;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF
					; CORE FOR ANY SINGLE USER
					; ONCE ONLY CODE CAN ALTER THIS VALUE
					; (PATCH RH CORLIM IN SYSINI)


	$ABS

;NOTE: THESE SYMBOLS WILL GO AWAY SOON SO THAT AP.??? SYMBOLS
; WILL BE USED INSTEAD AS DEFINED IN S.MAC
;APR AND PI BITS

;APR BITS FOR BOTH PDP-6 AND KA10


	CLKBIT==:1
	REPEAT	7-CK0CHN, <CLKBIT==:CLKBIT*2>
	REQCLK==:PI.IIO+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	ZZ==1
	REPEAT	7-SCNCHN,<ZZ==ZZ*2>
	REQCTY==:PI.IIO+ZZ	;FOR KL10 CTY, MUST INTERRUPT ON SCANNER PI BY HAND
	CLRCTY==:II.CPP+ZZ	;CLEAR PSEUDO-CTY INTERRUPT (KL10)

	CLRPIS==:611577		;CLEAR THE PI SYSTEM
IFN M.KL10!M.KS10,<CLRPIS==:11577>
	AP0NUL==:433550+AP0CHN	;RESET APR FOR NULL JOB
				; CLEAR EVERYTHING BUT DON'T I/O RESET
IFN CP0KIN,<AP0NUL==:IP.CTE+IP.CAE+IP.ECI+XP.CCF+IP.CAB+IP.CIO+IP.CNM+AP0CHN_3+AP0CHN>
IFN CP0KLN,<AP0NUL==:LP.ESF!LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.CDP+LP.ADP+LP.CSD+AP0CHN>
IFN CP0KSN,<AP0NUL==:SP.ESF!SP.CSF!SP.PWF!SP.ITI!SP.FEI+AP0CHN>
	AP0RST==:AP0NUL+200000	;RESET APR FOR SYSINI (I/O RESET TOO)
	NXM==:10000		;NON-EX MEM (APR STATUS WORD)
IFN M.KI10,<NXM==:IP.NXM>
IFN M.KL10,<NXM==:LP.NXM>
IFN M.KS10,<NXM==:SP.NXM>
;NOW HARDWARE BITS WHICH DEPEND ON SOFTWARE CONFIGURATION:

	XP	XI.RQC,REQCLK	;CONO PI.XI.RQC REQUESTS CLK INTERRUPT
	XP	II.CCI,II.CPP+CLKBIT
XP XC.UOU,UIOMOD

;DEFINE APR SYMBOLS FOR PDP-6 VS KA10 FOR CPU 0

	XP	PIPROG,77400	;PI STATUS REGISTER
				;ONES IF ANY PI'S IN PROGRESS
				;DO NOT DEFINE IF PDP-6 SO UNDEFINED
				;GLOBAL WILL BE CLUE TO PDP-6 USER
				;TO CHANGE CODE
	A0.NOT==PIPROG-<400_<7-AP0CHN>>	;DEFINE ALL PI IN PROGRESS FLAGS EXCEPT
				; APR FOR HALT TEST IN APRINT.
	A0.APP==1_<7-AP0CHN+10>	;CPU0 APR PI IN PROGRESS
	A0.NOC==:PIPROG-<400_<7-CK0CHN>> ;PI-IN-PROG EXCEPT CLOCK
	A0.ACO==1_<7-AP0CHN>	;CPU0 APR CHANNEL ON
	XP	SYSOFF,<177_-AP0CHN>+PI.TFP ;TURNS OFF ALL PI CHANNELS BELOW
				; THE APR CHANNEL.  USED BY INTERLOCK
				; MACROS AND DEPENDS ON NOONE ATTEMPTING
				; TO OBTAIN OR WAITING FOR AN INTERLOCK
				; AT OR ABOVE THE APR CHANNEL
	XP	SYSON,<177_-AP0CHN>+PI.TNP

IFN CP0KIN!CP0KLN!CP0KSN, <A0.FOV==000	;PC CHANGE CANNOT BE ENABLED ON PDP-6, BECAUSE
				; IT MAKES MONITOR TRAP ALSO>
;DEFINE APR SYMBOLS FOR CPU'S GREATER THAN 1

DEFINE APRDEF(X)<
	A'X'.NOT==PIPROG-<400_<7-AP'X'CHN>>
	A'X'.APP==1_<7-AP'X'CHN+10>
	A'X'.FOV==0
	A'X'.ACO==1_<7-AP'X'CHN>
IFN M.KI10,<AP'X'NUL==:IP.CTE+IP.CAE+IP.ECI+XP.CCF+IP.CAB+IP.CIO+IP.CNM+AP'X'CHN_3+AP'X'CHN>
IFN M.KL10,<AP'X'NUL==:LP.ESF!LP.CSF!LP.SBE!LP.NXM!LP.PAR!LP.IOF!LP.PWF+LP.CDP+LP.ADP+LP.CSD+AP'X'CHN>
	AP'X'RST==:AP'X'NUL+200000
>;END DEFINE APRDEF

ZZ==1
REPEAT <M.CPU-1>,<
	APRDEF	(\ZZ)
ZZ==ZZ+1
>

APRNUL==:AP0NUL
APRRST==:AP0RST
APRCHN==:AP0CHN
;IF THERE IS ONLY ONE CPU IN THIS SYSTEM DEFINE ALL NECESSARY GLOBALS

IFE <CPUN-1>,<			;NO SECOND CPU?
IFN FTKL10!FTKS10,<
STMPEC::MOVE	P4,.C0EPT
IFE FTKLP,<
	MOVEI	P4,.E0LM(P4)
>
	DPB	P3,P2
	CLRPGT	(0)
	POPJ	P,
>
IFN FTMP,<

	XP	MSCHED,SCHEDJ##
	XP	CP1CRS,SAVPC2##
	XP	BECOM0,CPOPJ
	XP	BRKLOK,CPOPJ
	XP	BRKSIW,CPOPJ
	XP	UXITMP,CPOPJ1
	XP	MSTUUO,CPOPJ
	XP	CP0RC,CPOPJ1
	XP	CP1AC,CPOPJ1
	XP	SPSTOP,CPOPJ1
	XP	DPXST,CPOPJ
	XP	CLRJSP,CPOPJ
	XP	SETJSP,CPOPJ
	XP	ALLJSP,CPOPJ
	XP	DXRUN,CPOPJ1
	XP	CPUOFS,CPOPJ
	XP	CPUFND,CPOPJ
	XP	CPUDET,CPOPJ
	XP	CPUATT,CPOPJ
	XP	GETMM,CPOPJ1
	XP	GIVMM,CPOPJ
	XP	SCDMM,CPOPJ1
	XP	MMOWN,CPOPJ1
	XP	DIFMM,CPOPJ
	XP	UIFMM,CPOPJ
	XP	REMMM,CPOPJ
	XP	GGVMM,CPOPJ
	XP	UPMM,CPOPJ
	XP	TGVMM,CPOPJ
	XP	DWNMM,CPOPJ
	XP	UPMC,CPOPJ
	XP	DWNMC,CPOPJ
	XP	LOKSCD,CPOPJ
	XP	ULKSCD,CPOPJ
	XP	SBSCD,CPOPJ
	XP	CLRCCB,CPOPJ
	XP	CPUCMD,CPOPJ
	XP	CPLCK,CPOPJ1
	XP	MAPUEC,CPOPJ
	XP	MAPUC,CPOPJ
	XP	CP1MFL,SAVPC2##
	XP	CHKDIE,CPOPJ
	XP	ONCPU0,CPOPJ
	XP	CP1STP,CPOPJ1
	XP	SETCPF,CPOPJ
	XP	SETCPP,CPOPJ
	XP	SCDSS1,CPOPJ
	XP	SETQPB,CPOPJ
	XP	ONCPUL,CPOPJ
	XP	ONCPUD,CPOPJ
	XP	ONCPUS,CPOPJ1
	XP	ONCPUN,CPOPJ
	XP	SETCPN,CPOPJ
	XP	CP1CHK,CPOPJ
	XP	CHKCPI,CPOPJ1
	XP	CHKCP,CPOPJ1
	XP	BUFSSN,CPOPJ1
	XP	RWRTCH,CPOPJ
	XP	MAPINI,CPOPJ
;LOCATIONS IN SLAVE CDB WHICH ARE CHECKED INDIVIDUALLY BY MASTER:
;FOLLOWING LOC ALWAYS ZERO (SINCE NO CPU1)
.E1IL==:0
.E1MP==:0
JBTST3==:0
.C1STS::			;SLAVE STOP TS WORD CHECKED IN UUOCON
.C1PUC::0			;SLAVE UUO COUNT CHECKED IN UUOCON
TWOMAS::
TWOCHK::JRST	(T1)		;GIVE OR RETURN
ONCCHK::0			;CHECK FOR TWO CPU0'S

IFN M.KL10,<
	XP	CLCSN,CPOPJ	;IF CPNSER NOT LOADED AND KL10
	XP	SETCSN,CPOPJ
	XP	SETCSJ,CPOPJ
	XP	SCDCSH,CPOPJ1
	XP	SWPCSH,CPOPJ1
	XP	CTXSWP,CPOPJ
	XP	CSREQS,CPOPJ
	XP	CLRCSH,CPOPJ
	XP	CKCP1C,CPOPJ
	XP	CHKSWS,CPOPJ
	XP	CHKCSH,CPOPJ
	XP	CHKCSH,CPOPJ
	XP	SETCSB,CPOPJ
	XP	UNCACH,CPOPJ
	XP	MLSCSH,CPOPJ1
CKNBF::
CHKNB::	HRLZ	T1,DEVNBF(F)
	HRRZS	DEVNBF(F)
	ADDM	T1,DEVNBF(F)
STONBF::POPJ	P,
DT1CMD::
DT1MTD::0
>;END IFN M.KL10

CHKCPU::SETZ	T1,
	JRST	CPOPJ1
LOKDPI::CONO	PI,SYSOFF
	POPJ	P,
LOKBTI::
LOKSPI::CONO	PI,PI.OFF
BCOM0::
UNLSPT::POPJ	P,
IFN M.NET,<
LOKNPI::CONO	PI,NETPIF
	POPJ	P,
UNLNPI::CONO	PI,NETPIN
	POPJ	P,
> ;END M.NET
LOKSCI::CONO	PI,SCNPIF
	POPJ	P,
UNLSCI::CONO	PI,SCNPIN
	POPJ	P,


CRESET::
IFN FTTRPSET,<
	SETZM	.C0STS
>
	POPJ	P,
>	;END IFN FTMP
	XP	LSTCPU,CPOPJ1
	XP	ANYRUN,CPOPJ1
	XP	SETCPU,CPOPJ1
	XP	SETCRN,CPOPJ1
	XP	SETCDN,CPOPJ
	XP	CPSCHK,CPOPJ1
	XP	SCDOWN,CPOPJ1
ANYCPU::CAME	J,.CPJOB
	AOS	(P)
	POPJ	P,		;TURN ON DEVICE PI LEVEL
UNLDPI::
ONPOPD::CONO	PI,SYSON
	POPJ	P,
ONPOPB::
UNLBTI::
ONPOPJ::
UNLSPI::CONO	PI,PI.ON
	POPJ	P,
GIVLOK::NTGIVE
	POPJ	P,
>	;END IFE CPUN-1


;INTERNAL HERE FOR 10/40N, MUST BE SAME AS IN COMMOD

	FNCEXC==:1		;EXECUTE ONLY
	FNCRED==:2		;READ
	FNCALL==:3		;ALLOCATE
	FNCDLL==:4		;DEALLOCATE
	FNCAPP==:5		;APPEND
	FNCUPD==:6		;UPDATE
	FNCCRE==:7		;CREATE
	FNCSUP==:10		;SUPERSEDE
	FNCTRN==:11		;TRUNCATE
	FNCCAT==:12		;CHANGE ATTRIBUTES(EXCEPT PRIVILEGE,NAME,DIR)
	FNCDEL==:13		;DELETE
	FNCCNM==:14		;CHANGE NAME
	FNCCPR==:15		;CHANGE PRIVILEGE
	SUBTTL	REAL TIME TRAPPING
IFN FTRTTRP,<
IFG RTTRPN,<
	EXTERN	RTTRP
	$HIGH

IFE FTKLP,<
RTMCAN==:.UPMP+.UPMUO
RTMUAC::POINT	4,.UPMP+.UPMUO,12	;UUO AC FIELD
RTMUOC::POINT	9,.UPMP+.UPMUO,8	;UUO OPCODE FIELD
>
IFN FTKLP,<
RTMCAN==:.UPMP+.UPMUE
RTMUAC::POINT	4,.UPMP+.UPMUO,30	;UUO AC FIELD
RTMUOC::POINT	9,.UPMP+.UPMUO,26	;UUO OPCODE FIELD
>

;TRPGO IS ENTERED FROM THE CHANNEL SAVE ROUTINE DURING A REAL TIME DEVICE
; INTERRUPT. RELAVENT LOCATIONS FROM THE USER PAGE MAP PAGE, TRPFLG, AND
; LOCATION 61 ARE SAVED. THE REAL TIME USER'S UPMP AND TRAP LOCATIONS ARE
; SETUP AND CONTROL IS TRANSFERRED TO THE USER'S INTERRUPT ROUTINE IN USER
; MODE.

TRPGO::
IFN M.KI10,<
	DATAI	PAG,1(P)	;SAVE THE CURRENT CONTENTS OF THE USER BASE
				; REGISTER ON THE STACK
>
IFN FTKLP,<
	MOVE	T1,.CPSPT	;SPT
	MOVEM	T1,1(P)		;SAVE THAT
	MOVE	T1,RELTB1##(J)	;REAL TIME PROGRAM'S PROCESS TABLE
	HRRM	T1,.CPSPT	;PART OF MAKING THE JOB ADDRESSABLE
>
	DATAO	PAG,RELTB1##(J)	;SETUP THE INTERRUPT LEVEL USER'S BASE REGISTER
	ADD	P,[XWD 22,22]	;OFFSET THE STACK FOR SAVING BACKGROUND
				; CONTEXT OF THE INTERRUPT LEVEL USER
	MOVSI	T1,.UPMP+.UPPFT	;STARTING AT THE PAGE FAULT TRAP INSTRUCTION
	HRRI	T1,-20(P)	; THROUGH THE PUBLIC TRAP NEW MUUO PC
	BLT	T1,(P)		; SAVE THE BACKGROUNG UPMP
	MOVE	T1,[XWD RTTUPM,.UPMP+.UPPFT]
	BLT	T1,.UPMP+437	;SETUP THE INTERRUPT LEVEL UPMP
IFN M.KL10,<
	PUSH	P,.UPMP+.LMPFW	;SAVE PAGE FAIL WORD
	PUSH	P,.UPMP+.LMPFP	; AND OLD P.F. PC
	PUSH	P,.UPMP+.LMPFN	; AND NEW P.F. PC
IFN FTKLP,<
	PUSH	P,.UPMP+.LMPFN+1; ..
>
	MOVE	T1,[IFE FTKLP,<IC.UOU>+RTTILM]	;WHERE TO GO ON ILM
	MOVEM	T1,.UPMP+.LMPFN+IFN FTKLP,<1>	;STORE THAT
>
	HRRI	T1,RTTAOF	;ADDRESS OF INTERRUPT LEVEL ARITHMETIC
				; EXCEPTION PROCESSING ROUTINE
IFN M.KI10,<HLL T1,-17(P)>	;USERS ARITHMETIC ENABLE (JFCL OR MUUO)
IFN M.KL10,<HLL T1,-22(P)>
	MOVEM	T1,.UPMP+.UPAOT	;ENABLE OR DISABLE INTERRUPT LEVEL ARITHMETIC
				; TRAPPING
	PUSH	P,.CPDMI	;SAVE 61
	PUSH	P,.CPRTT	;AND LOWER LEVEL TRPFLG
	HRLI	J,400000	;MAKE TRPFLG NEGATIVE, USER MODE OFF
				; FOR CHN TEST ON WHETHER TO SAVE ACS
	MOVEM	J,.CPRTT	;SETUP TRPFLG FOR THIS INTERRUPT LEVEL USER
	MOVE	T1,DISMT1##(J)	;GET THE DISMISS INSTRUCTION FOR THIS INTERRUPT
				; LEVEL
	MOVEM	T1,.CPDMI	;STORE IT IN 61
	JRST	2,@TRPTB1##(J)	;ENTER THE USER'S INTERRUPT ROUTINE IN USER MODE

;DISMIS IS ENTERED FROM THE CHANNEL DISMISS ROUTINE BY A JSP J,DISMIS.
; THE STATE OF THE MACHINE IS RESTORED AND THE ROUTINE RETURNS TO THE
; CHANNEL DISMISS ROUTINE TO RESTORE THE AC'S AND DISMISS THE INTERRUPT.

DSMAPR:
DISMIS:	POP	P,.CPRTT	;RESTORE LOWER LEVEL TRPFLG
	POP	P,.CPDMI	;RESTORE 61
IFN M.KL10,<
IFN FTKLP,<
	POP	P,.UPMP+.LMPFN+1
>
	POP	P,.UPMP+.LMPFN	;RESTORE NEW P.F. PC
	POP	P,.UPMP+.LMPFP	;RESTORE OLD P.F. PC
	POP	P,.UPMP+.LMPFW	;RESTORE P.F. WORD
>
	SUB	P,[XWD 20,20]	;SET STACK OFFSET FOR RESTORING BACKGROUND
				; UPMP
	MOVSI	T1,(P)		; ..
	HRRI	T1,.UPMP+.UPPFT	;STARTING AT PAGE FAULT TRAP INSTRUCTION
	BLT	T1,.UPMP+437	; RESTORE UPMP THROUGH PUBLIC TRAP NEW MUUO PC
IFN M.KI10,<
	MOVE	T1,[EXP PG.LUB+PG.LEB]
	IORM	T1,-1(P)	;SET TO RESTORE BACKGROUND UBR AND EBR
	DATAO	PAG,-1(P)	;RESTORE BASE REGISTERS
>
IFN FTKLP,<
	MOVE	T1,-1(P)	;SPT AT INTERRUPT
	HRRM	T1,.CPSPT	;RESTORE THAT
>
	JRST	(J)		;RESTORE AC'S AND DISMISS THE INTERRUPT

;INTERRUPT LEVEL USER PAGE MAP PAGE

RTTUPM:	RTTILM
	RTTAOF
	RTTPOF
	JFCL
	0
	0
	IC.UOU+RTTILM
	RTTILM
	EXP	IFE FTKLP,<IC.UOU>+MUUO
	EXP	IFE FTKLP,<IC.UOU>+KTUUO
	EXP	IFE FTKLP,<IC.UOU>+SNTUUO
	EXP	IFE FTKLP,<IC.UOU>+STUUO
	EXP	IFE FTKLP,<IC.UOU>+RTCNTU
	EXP	IFE FTKLP,<IC.UOU>+KTUUO
	EXP	IFE FTKLP,<IC.UOU>+RTPNTU
	EXP	IFE FTKLP,<IC.UOU>+KTUUO

;HERE ON A UUO AT INTERRUPT LEVEL

RTCNTU:RTPNTU:
IFE FTKLP,<
	MOVE	17,.UPMP+.UPMUP	;AC 17 = MUUO PC
	JRST	UUOHND##	;DISPATCH TO THE UUO HANDLER
>
IFN FTKLP,<
	MOVE	17,.UPMP+.UPMUP	;30 BIT PC, NOT REALLY, MUST BE IN SECTION 0
	HLL	17,.UPMP+.UPMUO	;UUO FLAGS
	JRSTF	@[IC.UOU+UUOHND##] ;TURN ON USRIOT BY HAND AND DISPATCH TO UUO HANDLER
>


;HERE ON AN ARITHMETIC EXCEPTION AT INTERRUPT LEVEL

RTTAOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.AOV+AP.FOV;REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON A PUSH DOWN LIST OVERFLOW AT INTERRUPT LEVEL

RTTPOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.POV	;TELL USER THE REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON AN ILLEGAL MEMORY REFERENCE (PAGE FAULT) AT INTERRUPT LEVEL

RTTILM:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
IFN M.KL10,<
IFE FTKLP,<
	MOVE	T1,.UPMP+.LMPFP	;GET PF OLD PC
	MOVEM	T1,.UPMP+.UPMUP	;STORE IT IN A COMPATABLE PLACE
>
IFN FTKLP,<
	MOVE	T1,.UPMP+.LMPFP
	MOVEM	T1,.UPMP+.UPMUO
	MOVE	T1,.UPMP+.LMPFP+1
	MOVEM	T1,.UPMP+.UPMUP
>
>
	MOVEI	T1,AP.ILM	;TELL USER THE REASON FOR THE TRAP
ERRGO:	MOVEM	J,.CPRTS	;SAVE AN AC
	MOVE	J,.CPRTT	;GET INDEX INTO REAL TIME BLOCK
	EXCH	T1,.JDAT+.JBCNI##
	EXCH	T1,.UPMP+.UPMUP	;GET THE TRAP PC
IFN FTKLP,<
	HLL	T1,.UPMP+.UPMUO	;FLAGS
>
	EXCTXU	<MOVEM T1,@APRTB1##(J)>
	HRR	T1,APRTB1##(J)	;ADDRESS OF THE USER'S TRAP HANDLING ROUTINE
	HRRI	T1,1(T1)	;CLEAR ALL FLAGS WHICH COULD CAUSE A TRAP
	TLZ	T1,(XC.OVF+XC.FOV+XC.TRP+XC.FUF+XC.NDV)
	EXCH	T1,.UPMP+.UPMUP	;RESTORE T1 AND STORE PC
	MOVE	J,.CPRTS	;RESTORE J
	JRSTF	@.UPMP+.UPMUP	;AND ENTER USER'S TRAP HANDLING ROUTINE

	$ABS
	RTINIC==:1			;FLAG SYSINI TO CALL INITIALIZATION ROUTINE

ENBSTD==470550+AP0CHN

MRTRPN==:-RTTRPN
RTBSIZ==:20+IFN FTKLP,<3>
RTBLK::	BLOCK	RTTRPN*RTBSIZ
>>
IFE FTRTTRP,<IFN RTTRPN,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTRTTRP=-1
>>
IFN FTRTTRP,<IFE RTTRPN,<
CHAINT==:CPOPJ
RTBLK==:CPOPJ
RTLINK==:CPOPJ
SAV41==:CPOPJ
SAV61==:CPOPJ
CHNTAB==:CPOPJ
RTBSIZ==:CPOPJ
BLKENB==:CPOPJ
RTINIC==:0			;FLAG SYSINI NOT TO CALL INITIALIZATION ROUTINE
>>

	;CREATE JBTRTD TABLE ONLY IF THERE ARE REAL TIME DEVICES OR
	;HIGH PRIORITY QUEUES OR THE HIBERNATE-WAKE FEATURE.
	;LH(JBTRTD) = REAL TIME STATUS BITS FOR HPQ AND HIBERNATE-WAKE
	;RH(JBTRTD) = COUNT OF REAL TIME DEVICES OWNED BY EACH JOB

ZZ=0
IFN FTRTTRP,<IFG RTTRPN,<ZZ==ZZ+1>>
IFN SYS50N,<IFN FTHPQ,<IFG HPQN,<ZZ==ZZ+1>>>
	ZZ==ZZ+1

IFG ZZ,<JBTRTD:: BLOCK JOBN
ITMRTD==:JOBMXL
CLRRTD::SETZM	JBTRTD(J)
>

IFLE ZZ,<JBTRTD::0		;FOR GETTAB
ITMRTD==:JOBMXL
CLRRTD::JFCL
>


;JBTRTD BIT DEFINITIONS

;BITS 27-35	ARE THE COUNT OF THE NUMBER OF REAL TIME DEVICES OWNED BY THIS JOB

;BITS 23-26	ARE TEMPORARY HPQ (SHARABLE DEVICE OWNER)

;BITS 15-17	ARE THE HIBERNATE PROTECTION CODE FOR THIS JOB

;BIT 14		IS TTY INPUT ACTIVITY ENABLE - CHARACTER MODE
;BIT 13		IS TTY INPUT ACTIVITY ENABLE - LINE MODE

;BIT 12		IS PTY ACTIVITY ENABLE

;BIT 11		IS I/O ACTIVITY ENABLE

;BIT 10 IF HIBER UUO AC IS AN ALIAS FOR IPCACE IN JBTRTD
;BIT 10		IS THE WAKE BIT - THIS BIT IS SET TO WAKE THE JOB UP BY HIBER

;BITS 6-9	ARE THE CURRENT HIGH PRIORITY QUEUE POSITION OF THIS JOB

;BITS 2-5	ARE THE CONSOLE COMMAND SETTING OF HPQ FOR THIS JOB

;BIT 1 IS IPCF EVENT ENABLE
;BIT 0 IS ONLY AN EXEC PROCESS CAN WAKE THE JOB
;BIT 0 OF HIBER UUO AC ARG IS 1 IF JOB IS TO BE SWAPPED IMMEDIATELY
;BUT NEVER STORED IN JBTRTD


	$HIGH
TTIALE==:20		;TTY INPUT ACTIVITY - LINE MODE
TTIACE==:10		;TTYINPUT ACTIVITY - CHARACTER MODE
TTILCE==:TTIALE!TTIACE	;TTY INPUT - LINE AND CHARACTER MODE ENABLE
PTYWUE==:40		;PTY WAKE UP ENABLE BIT
IOACE==:100		;I/O ACTIVITY ENABLE BIT
WAKEB==:200		;WAKE UP BIT

IFN FTIPCF,<
	IPCACE==:200000	;IPC EVENT ENABLE
	IPCUUB==:200	;USERS ARG FOR IPC ACTIVITY
>
MONHBR==:400000		;ONLY THE MONITOR CAN WAKE THIS JOB
			; (STORED IN JBTRTD)
HBRSWP==:400000		;SWAP ME OUT IMMEDIATELY
			; (NOT STORED IN JBTRTD)
HBRSEC==:200000		;TIME IS IN SECONDS

HIBPRT::POINT	7,JBTRTD(J),17	;HIBERNATE PROTECTION CODE


IFN FTHPQ,<
HPQPNT::POINT	4,JBTRTD(J),9	;CURRENT HIGH PRIORITY QUEUE
HPQPT1::POINT	4,JBTRTD(T1),9
HPQPT2::POINT	4,JBTRTD(T2),9
HPQSPT::POINT	4,JBTRTD(J),5	;HIGH PRIORITY QUEUE SET BY CONSOLE COMMAND
HPQPN3::POINT	4,JBTRTD(T3),9
HPQMSK==:170000			;BIT FIELD OF CONSOLE COMMAND HPQ
HPUMSK==:(17B9)		;CURRENT HPQ MASK
>
IFE FTHPQ,<
XP HPQMSK,0			;NO MASK IF NO HIGH PRIORITY QUEUE
>
IFE RTTRPN,<
RTREL==:CPOPJ
RTTRP==:CPOPJ
>

IFE FTLOCK,<
LOKJOB==:CPOPJ
UNLOK.==:CPOPJ
IFN LOKN,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTLOCK=-1
>>

IFN LOKN,<
	EXTERN	LOKCON
PDLPNO==:.UUPMP/PAGSIZ

LOKINC==:1			;FLAG SYSINI TO CALL INITIALIZATION ROUTINE
>
IFN FTLOCK,<

	IFE	LOKN,<

LOKJOB::MOVEI	T1,0		;ERROR CODE 0 MEANS NOT IMPLEMENTED
	JRST	STOTAC##
UNLOCK::MOVSI	T1,NSHF!NSWP
	ANDCAM	T1,JBTSTS(J)
	UNLOK.::
LOCK0::!
IFN FTMOFFL,<
CKMOL::
NEWCMX::
CKLJB::
MEMOFL::
>
UNLOKH::POPJ	P,
LOKCHK==:CPOPJ1
LOKEVC==:CPOPJ
SETLPR==:CPOPJ1
LOKHGH==:CPOPJ1
LOKSWP==:CPOPJ1
LOKINC==:0			;FLAG SYSINI NOT TO CALL INITIALIZATION ROUTINE
EVLPTR==:0
LOKINS==:0			;EXEC PC ON MEM TRAP IF NO LOCK BLT
>
IFNDEF CMNN,<CMNN==0>
LOKASK==:LOKN
LOKMAX==:CMNN

IFE CMNN,<LOKMAX==:-1>
>
SUBTTL HIGH PRIORITY QUEUE UUO

IFN SYS40N,<HPQN==0>		;NO HIGH-PRIORITY QUEUE IN 10/40 SYSTEMS.
IFNDEF HPQN,<HPQN==5>		;DEFAULT VALUE IS 5 HP QUEUES
IFN SYS50N,<
IFN FTHPQ,<IFG HPQN,<

HPQ::	PUSHJ	P,HPQST1	;CHECK HPQ LEGALITY
	JRST	RTM1##		;NO, GIVE ERROR RETURN
	JUMPE	T2,CPOPJ1	;IF NO PRIVILEGES DONT RESCHEDULE
	SYSPIF
	SKIPN	SCDRTF		;IS THERE A FORCED SCHEDULE BEING DONE
	SETOM	SCDRTF		;NO, SO START ONE
	SYSPIN
	SETOM	.CPHQU		;FLAG HPQ UUO DONE SO SCHEDULER WILL
				; REQUEUE CURRENT JOB TO NEW HPQ
	JRST	CPOPJ1		;SKIP RETURN TO USER


HPQPRV:	POINT	4,JBTPRV(J),3+^L<PVHPQ>-^D18	;MAXIMUM HPQ ATTAINABLE BY THIS JOB


HPQSET:	TDZA	T2,T2		;SKIP JACCT TEST
HPQST1:	MOVSI	T2,JACCT	;SET FOR JACCT TEST
	MOVE	T3,JBTPPN(J)	;GET JOB'S ACCOUNT
	CAME	T3,FFAPPN##	;IF OPERATOR ("FULL FILE ACCESS"), OR
	TDNE	T2,JBTSTS(J)	;IF JACCT
	SKIPA	T2,[HPQN]	;ASSUME HIGH
	LDB	T2,HPQPRV	;GET HPQ PRIVILEGES FOR THIS JOB
	CAMLE	T1,T2		;IS THIS JOB PRIVILEGED ENOUGH?
	POPJ	P,		;NO, GIVE ERROR RETURN

	SKIPL	T1		;CORRECT FORMAT?
	CAILE	T1,HPQN		;LEGAL QUEUE?
	POPJ	P,		;NO
	DPB	T1,HPQPNT	;YES, STORE NEW HPQ VALUE
	JRST	CPOPJ1		;GIVE SUCCESSFUL RETURN

HPQCMD::PUSHJ	P,DECIN1##	;PICK UP HPQ VALUE IN T2
	JRST	.+2		;NO ARGUMENT, ASSUME 0
	PJRST	COMERA##	;ILLEGAL ARGUMENT
	MOVE	T1,T2		;
	PUSHJ	P,HPQSET	;GO CHECK HPQ LEGALITY
	PJRST	PRIERR##	;NOT LEGAL!
	DPB	T1,HPQSPT	;STORE THIS NEW VALUE
	POPJ	P,		;RETURN

>>>

IFE HPQN,<
	HPQ==:CPOPJ

HPQCMD::PJRST	COMERA##
>


ifn stupid,<
shtcmd::pushj	p,decin1##	;pick up argument value in t2
	popj	p,		;no argument, foo! return
	popj	p,		;illegal character found
	caie	t2,^d0814	;check for 'secret pasword'
	popj	p,		;return
	STOPCD	CPOPJ##,STOP,XYX, ;So, lets relaod the system, NOW.
>;stupid



IFN SYS50N,<
IFE FTHPQ,<IFG HPQN,<
PRINTX? ;PLEASE ASSEMBLE SOURCES WITH FTHPQ = -1
>>>
SUBTTL	PROCESS DATA BLOCK
;PDB
;PROTOTYPE PROCESS DATA BLOCK
;THIS DESCRIBES THE FORMAT OF A PDB, AND IS THE PDB FOR THE NULL JOB
; IF PDBS ARE SWAPPED. IT IS THE PROTOTYPE PDB IF PDBS ARE BUILT
; IN CORE.


PDBPRO::PHASE	0
.PDBEG:!BLOCK	1
XP	.PDIPT,.PDBEG		;IN CORE PROTECT TIME -- NUMBER OF
				; JIFFIES BEFORE JOB CAN BE SWAPPED OUT.

XP	.PDQNT,.PDBEG		;QUANTUM RUN TIME -- JIFFIES UNTIL
				; JOB SHOULD GO TO DIFFERENT RUN QUEUE

.PDCNO::!BLOCK	1		;USER'S CHARGE NUMBER


.PDKCT::!BLOCK	1		;PRODUCT OF CORE LENGTH (IN K) * NUMBER OF CLOCK TICKS
				; PROGRAM USED CPU.  USED FOR TIME ACCOUNTING.


.PDNM1::!BLOCK	1		;FIRST HALF OF USER'S NAME IN SIXBIT
.PDNM2::!BLOCK	1		;SECOND HALF OF USER'S NAME


.PDRTM::!BLOCK	1		;TOTAL RUNTIME SINCE LAST RUNTIME OR KJOB
				;NULL TIME FOR TOTAL SYSTEM IS KEPT FOR JOB 0
				;COUNTED BY BOTH CPU'S
				;SEE .CPNUL FOR INDIVIDUAL NULL TIME
.PDTTM::!BLOCK	1		;TOTAL RUNTIME SINCE LAST KJOB IN JIFFIES
.PDTT2::!BLOCK	1		;ADDITIONAL RUNTIME IN JIFFIES *10^-5
IFN FTKL10,<
.PDEBT::!BLOCK	1		;(KL10) TOTAL EBOX TIME USED IN JIFFIES
.PDEB2::!BLOCK	1		;REMAINDER IN EBOX COUNTS
.PDMBT::!BLOCK	1		;(KL10) TOTAL MBOX TIME USED IN JIFFIES
.PDMB2::!BLOCK	1		;REMAINDER IN MBOX COUNTS

>;END IFN FTKL10

.PDPGM::!BLOCK	1		;PROGRAM TO RUN ON CONTROL-C OR

				; RUN COMMAND

.PDABS::!BLOCK	1		;ADDRESS BREAK SETTINGS (ZERO IF USER IS
				; NOT ENABLED FOR ADDRESS BREAK).  1B0=1
				; IF BREAKING ON INSTRUCTION FETCH, 1B1=1
				; IF BREAKING ON DATA FETCH, 1B2=1 IF
				; BREAKING ON A WRITE, 1B6 (USER PAGING)
				; ALWAYS A 1, BIT 18-35=BREAK
				; ADDRESS

.PDCVL::!BLOCK	1		;CVPL,,CPPL
.PDMVL::!BLOCK	1		;MVPL,,MPPL

.PDDVL::!BLOCK	1		;POINTER TO TABLE OF POINTERS TO DDBS
				;  OWNED BY THIS JOB AND HAVING
				;  LOGICAL NAMES, OR ZERO IF NO
				;  SUCH DDBS, OR -1 IF TOO MANY TO
				;  FIT IN THE TABLE.

IFN FTIPCF,<
;NOTE THAT THE FOLLOWING 3 ITEMS MUST REMAIN IN THE ORDER
; .PDIPC, .PDIPA, .PDIPQ - THE SAME ORDER AS .EPIPC,.EPIPA,.EPIPQ

.PDIPC::!BLOCK	1		;LH=POINTER TO FIRST PACKET
				;RH=SEND AND RECEIVE COUNTERS
.PDIPA::!BLOCK	1		;IPCF STATISTICS
.PDIPQ::!BLOCK	1		;FLAGS AND QUOTAS
.PDIPI::!BLOCK	1		;PID OF THIS JOB'S SYS:INFO
.PDIPN::!BLOCK	1		;LH=POINTER TO LAST IN QUEUE
				;LH=0
>
IFN FTEQDQ,<
.PDEQJ::!BLOCK	1		;LH=0
				;RH=POINTER TO JOB QUEUE
.PDEQQ::!BLOCK	1		;LH=FLAGS
				;RH=ENQ QUOTA
;FLAGS IN LEFT HALF OF PDEQQ:
EQ.HBS==:(1B0)			;THE QUOTA HAS BEEN SET
>
.PDJSL::!BLOCK	<.SLWDJ>	;JOB SEARCH LIST
.PDJSE==:.			;FIRST WORD PAST SEARCH LIST

.PDNET==:.			;LEFT HALF IS THE ADDRESS OF A DDB WHICH
				; HAS AN ACTIVE CONNECT/DISCONNECT IN PROCESS.
.PDSCX::!BLOCK	1		;RIGHT HALF WORD IS ADDRESS OF JOB'S SAVED CONTEXT
IFN FTIPCF,<
.PDEPA::!BLOCK	1		;RIGHT HALF IS ADDRESS OF PACKET SENT IN RESPONSE TO AN
				; EXEC PSUEDO-PROCESS IPCF MESSAGE
>
IFN FTDHIA,<
.PDDIA::!BLOCK	1		;LOC OF DIAG. DDB FOR JOB
>
.PDSTR::!BLOCK	1		;STR PROGRAM CAME FROM
.PDNAM::!BLOCK	1		;NAME OF THE PROGRAM
.PDDIR::!BLOCK	1		;DIRECTORY PROGRAM CAME FROM
.PDSFD::!BLOCK	MAXLVL		;PATH TO PROGRAM
.PDDFL::!BLOCK	1		;WORD CONTAINING USER DEFINED DEFAULTS
				; 0-8 = DEFAULT FILE PROTECTION (MUST BE HIGH 9 BITS)
				; 1B9 IS NON-ZERO IF DEFAULT PROTECTION WAS SPECIFIED
				; 1B10 IS NON-ZERO IF FILE DAEMON SPECIFIED PROTECTION
				; 1B11 USE DEFAULT FILE SPEC ON RUN,GET
				; 1B12 DON'T ASK ABOUT DETACHED JOBS ON "LOGIN"
				; 18-26 = FILE DAEMON SUPPLIED PROTECTION
				; (MUST BE HIGH 9 BIT OF RH)
				; 27-35 DEFAULT NUMBER OF DISK BUFFERS

.PDCAP::!BLOCK	1		;MAXIMUM PRIVILEGES ALLOWED

.PDACS::!BLOCK	ACTSTL		;ACCOUNT STRING
.PDVKC::!BLOCK	1		;VIRTUAL TIME-CORE INTEGRAL

.PDUUC::!BLOCK	1		;COUNT OF UUOS DONE BY THIS JOB

IFN FTHPQ,<
.PDHZF::BLOCK	1		;ORIGINAL VALUE OF TIME IF FIT WAS
				; ZEROED BY HPQ JOB
>
IFN FTPSCD,<
.PDPST::BLOCK	1		;NEGATIVE OF SWAPOUT TIME
>
.PDOBI::BLOCK	1		;OPERATOR/BATCH INFO
IFN FTMDA,<
.PDSTM::BLOCK	1		;TIME OF LAST RESET
>
.PDLBS::BLOCK	1		;DEFAULT SIZE OF LARGE DISK BUFFER
				;LH=SET BY UUO, RH=SET BY COMMAND
.PDSAC::BLOCK	1		;ADDRESS OF ALTERNATE CONTEXT BLOCK
.PDQSN::BLOCK	1		;LH=FILE DAEMON SEQUENCE NUMBER
				;RH=QUEUE.  UUO SEQUENCE NUMBER
.PDOSL::BLOCK	1		;OLD-STYLE LIB PPN
.PDSJB::BLOCK	1		;PTR TO DECNET SESSION CONTROL JOB BLOCK
.PDCMN::BLOCK	1		;AOBJN POINTER TO USER-DEFINABLE COMMAND NAMES
.PDUNQ::BLOCK	1		;POINTER TO LOCAL UNQTAB,,TABLE OF UDC BLOCKS
ifn stupid,<
.PDPRO::BLOCK	2		;ASCIZ prompter.
>;stupid
ifn fthistory,<
.PDCHA::BLOCK	1		;Storage for command history.  Only
.PDCHF::BLOCK	1		; referenced in CMDHIS module.
.PDCHP::BLOCK	1
>;fthistory
.PDLEN==:.-.PDBEG		;LENGTH OF A PDB IN WORDS
PDBWDS==:.PDLEN!1777		;SIZE OF PDB IN WORDS ROUNDED UP TO
				; A PAGE BOUNDARY. THE WHOLE PROTO
				; PDB WILL MOVE TO COMMON FOR KI-10
				; NEEDS.
PDBPGS==:PDBWDS/1777		;SIZE OF PDB IN PAGES.
PDB4WD==:<.PDLEN+3>/4		;NUMBER OF 4 WORD BLOCKS REQUIRED FOR A PDB
.PDLE4==:4*PDB4WD		;LENGTH INCLUDING SPARE WORDS AT END OF LAST BLOCK

	BLOCK	.PDLE4-.PDLEN	;DEFINE UNUSED WORDS FOR PATCHING
	DEPHASE
	$ABS
	SUBTTL	SCHEDULER QUEUE DEFINITIONS
	;(10/40 SCHEDULER QUEUES ARE LOCATED IN CLKCSS)

IFN SYS50N,<

;SHARABLE DEVICE JUST BECOME AVAILABLE
;APPROPRIATE ENTRY IS SET NON-ZERO WHEN SCHEDULER SHOULD LOOK
;AT THAT QUEUE TO FIND A JOB TO RUN

DEFINE X(A,B,C)
<A'Q==:ZZ
ZZ==ZZ+1>
ZZ==0
QUEUES
DEFINE X(A,B,C)
<A'Q==:.-AVALTB+ZZ
A'AVAL::0
>


AVALTB::RWAITS	;GENERATE THE AVAL FLAGS
LOC=.-AVALTB+ZZ

XP AVTBMQ,AVALTB-ZZ
;TABLE CONTAINING JOB NUMBER OF THE OWNER OF A
; SHARABLE RESOURCE.  THE RIGHT HALF WORD CONTAINS
; THE JOB NUMBER OF THE JOB THAT CURRENTLY
; OWNS THE RESOURCE OR ZERO IF THE RESOURCE IS
; AVAILABLE.  THE LEFT HALF WORD CONTAINS THE JOB
; NUMBER OF THE LAST JOB WHICH GAVE UP THE RESOURCE.
; THIS TABLE IS USEFUL FOR DEBUGGING AND REQUIRED
; SO THAT IN THE EVENT OF CATASTROPIC ERROR, E.G.,
; SWAP READ ERROR, THE RESOURCE MAY BE FREED UP.

DEFINE X(A,B,C)
<	ZZ==ZZ+1>

ZZ==0
	QUEUES

DEFINE X(A,B,C)
<A'USER::	0
>
USRTAB::RWAITS
XP USTBMQ,USRTAB-ZZ

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS


DEFINE X(A,B,C)
<A'Q==:LOC
LOC==LOC+1
>
	CODES

XP MXCODE,LOC-1	;MAX. JOB STATE CODE
;ANY QUEUES GREATER THAN CMQ MUST BE PROCESSOR QUEUES
CMQ==:LOC		;COMMAND DELAY QUEUE
LOC=LOC+1
PQ1==:LOC
LOC=LOC+1
PQ2==:LOC
LOC=LOC+1

DEFINE HPQCOD(A)
<	HPQ'A==LOC
	LOC==LOC+1>
IFG HPQN,<ZZ==1
	REPEAT	HPQN,<HPQCOD(\ZZ)
		ZZ==ZZ+1
			>
			>

;DEFINE SYMBOLS FOR PQ2 SUBQUEUES. SQ0=-1, SQ1=-2, ETC.
; USED FOR NEGATIVE INDICES TO JBTSQ.

	DEFINE	CLSGEN(A)
	<SQ'A==:A+1>

	ZZ==0
	REPEAT	M.CLSN,<
	CLSGEN(\ZZ)
	ZZ==ZZ+1>
	$HIGH
;PUT JOB DOWN A Q IF EXCEEDS QUANT. TIME
QRQTAB::XWD	PQ2,-PQ2	;FROM PQ1
	XWD	PQ2,-PQ2	;FROM PQ2
QTTAB::
DEFINE HPQTTB(A)
<	XWD HPQ'A,-HPQ'A>
IFG HPQN,<ZZ==1
	REPEAT	HPQN,<HPQTTB(\ZZ)
		ZZ==ZZ+1
			>
			>
XP QRQTBL,QRQTAB-PQ1		;TABLE MINUS OFFSET

	$ABS
; BASE QUANTA FOR QUEUES
QADTAB::QQRUN1			;PQ1
RNQUNT::<3*JIFSEC>/4		;PQ2
QQSTAB::
DEFINE HPQJIF(A)
<	EXP JIFY'A>
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ==HPQN-ZZ
	HPQJIF(\ZZZ)
		ZZ==ZZ+1
			>
			>

DEFINE JIFDEF(A)
	<JIFY'A==A*2>
	ZZ==1
REPEAT HPQN,<JIFDEF(\ZZ)
	ZZ==ZZ+1>
XP QADTBL,QADTAB-PQ1		;TABLE MINUS PQ1
; MULTIPLIER TABLE FOR RUN QUANTA BY QUEUES
QRANGE:: ^D45		;RANGE IN K BETWEEN SMALLEST AND LARGEST QUANTUM
			;  RUN TIME ASSIGNMENT

; ENTRIES ARE RANGE IN TICKS BETWEEN SMALLEST QUANTUM TO ASSIGN (QADTAB)
;  AND LARGEST QUANTUM TO ASSIGN (QMXTAB)
QMLTAB::0			;PQ1
	<3*JIFSEC>/4		;PQ2
REPEAT	HPQN,<	0			;NO MULTIPLIER FOR HPQS
>
XP QMLTBL,QMLTAB-PQ1		;TABLE MINUS PQ1

;MAXIMUM ALLOWABLE RUN QUANTO FOR QUEUES
QMXTAB::QQRUN1			;PQ1
	<JIFSEC*3>/2		;PQ2
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ==HPQN-ZZ
	HPQJIF(\ZZZ)
		ZZ==ZZ+1
			>
			>
XP QMXTBL,QMXTAB-PQ1		;TABLE MINUS PQ1
	$HIGH
ISCAN::	;SCAN FOR INPUT - GETTAB TABLE 45

DEFINE HPQSCN(A)
<	XWD -HPQ'A,QFOR##>
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
		>
		>

	XWD	-CMQ,QFOR##	;MONITOR COMMAND WHICH NEEDS CORE IMAGE IN CORE
	XWD	-PQ1,IQFOR##	;GET PEOPLE WHO GETSEGED FIRST
	XWD	-PQ2,IGFOR##	;BUT JUST THOSE WITH QUANTA LEFT
FISCAN::XWD	-PQ1,OQFOR##
IFE FTNSCHED,<
	XWD	-PQ2,FOQFOR##	;FAIRNESS HERE
>
IFN FTNSCHED,<
	XWD	-PQ2,FSQFOR##	;FAIRNESS HERE
>
	XWD	-PQ2,IQFOR##
IFN FTNSCHED,<
	XWD	-PQ2,BQFOR##
>
ISTMXL==:<.-ISCAN-1>B26	;MAKE ENTRY IN GETTAB FOR INPUT SWAP SCAN LIST
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
	Z		;FINAL ZERO TO FLAG END

ISCAN1::		;ALTERNATE INPUT SCAN
IFG HPQN,<ZZ==0
	REPEAT	HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
		>
		>

	XWD	-CMQ,QFOR##	;MONITOR COMMAND WHICH NEEDS CORE IN
IFE FTNSCHED,<
	XWD	-PQ2,FOQFOR##
>
IFN FTNSCHED,<
	XWD	-PQ2,FSQFOR##
>
	XWD	-PQ1,OQFOR##
	XWD	-PQ2,IGFOR##
	XWD	-PQ1,IQFOR##
	XWD	-PQ2,IQFOR##
IFN FTNSCHED,<
	XWD	-PQ2,BQFOR##
>
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
	Z		;FINAL ZERO TO FLAG END

;TABLE FOR SCHED. FUNCTION 30 (SELECT ON A /CPU BASIS ORDER OF Q SCAN
CPSCAN::SSCAN		;SUBFUNCTION 0,SCAN USING SSCAN,(P01,PQ2)
	SSCAN1		;SUBFUNCTION 1,SCAN USING SSCAN1,(PQ2,PQ1)
IFN FTPATT,<
	Z		;PATCH SPACE
	Z
>
CPSTBL==:.-CPSCAN-1	;LENGTH
	$ABS
	SSCN=:-3		;SECONDARY SCAN TABLE ADDRESS
	EXP	SSCAN1
	MFC=:-2		;MAXIMUM FAIRNESS COUNT
	EXP	SFC0
	FSCN=:-1		;ENTRY IN SCAN TABLE OF FIRST FAIR LOCATION
	EXP	FSCAN
SSCAN::			;SCHEDULER SCAN LIST - GETTAB TABLE 47
DEFINE HPQSCN(A)
<	XWD -HPQ'A,IQFOR##>
IFG HPQN,<ZZ=0
	REPEAT	HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ=ZZ+1
		>
		>

	XWD	-PQ1,IQFOR##	;SCHEDULER'S SCAN FOR NEXT JOB TO RUN
FSCAN:
IFE FTNSCHED,<
	XWD	-PQ2,IRRFOR
>
IFN FTNSCHED,<
	XWD	-PQ2,ISSFOR##
	XWD	-PQ2,IBBFOR##
>
SSTMXL==:<.-SSCAN-1>B26	;MAX ENTRY FOR GETTAB
IFN FTPATT,<
	Z		;FOR PATCHING
	Z
>
	Z		;FINAL ZERO TO FLAG END
;SLAVE PROCESSOR SCAN TABLE FOR CPU SCHEDULING


	EXP	SSCAN		;SECONDARY SCAN TABLE FOR SLAVE
	EXP	SFC1		;MAXIMUM FAIRNESS COUNT
	EXP	FSCAN1		;ENTRY POINT IN SCAN TABLE OF FIRST FAIR TABLE
SSCAN1:

	IFG	HPQN,<
		ZZ==0
		REPEAT HPQN,<ZZZ=HPQN-ZZ
			HPQSCN(\ZZZ)
			ZZ==ZZ+1
			>
			>

IFE FTNSCHED,<
	XWD	-PQ2,IRRFOR
>
IFN FTNSCHED,<
	XWD	-PQ2,ISSFOR##
>
FSCAN1:	XWD	-PQ1,IQFOR##	;IF NO JOBS TRY PQ1
IFN FTNSCHED,<
	XWD	-PQ2,IBBFOR##
>
IFN FTPATT,<
	Z		;FOR PATCHING
	Z
>
	0
	$HIGH
LSCAN::			;SCAN FOR LOST TIME
DEFINE HPQSCN(A)
<	XWD -HPQ'A,OQFOR##>
IFG HPQN,<
	ZZ==0
	REPEAT HPQN,<ZZZ=HPQN-ZZ
		HPQSCN(\ZZZ)
		ZZ==ZZ+1
			>
		>
	XWD	-PQ1,OQFOR##	;PQ1 NO CORE FORWARD
IFE FTNSCHED,<
	XWD	-PQ2,OQFOR##	;PQ2 NO CORE FORWARD
>
IFN FTNSCHED,<
	XWD	-PQ2,OSSFOR##	;PQ2 NO CORE SUB QUEUES FORWARD
				;INCLUDES NO CORE BACKGROUND BATCH
>
	0
;NOTE - FOR BEST RESULTS OSCAN SHOULD BE IN
; REVERSE ORDER OF ISCAN, ELSE SCHEDULER BINDS

OSCAN::	;SCAN FOR OUTPUT - GETTAB TABLE 46
	XWD	-STOPQ,IQFOR##	;UNRUNABLE JOBS FIRST
	XWD	-SLPQ,IQFOR##
	XWD	-EWQ,IQFOR##	;EVENT WAITERS
IFN FTDAEM,<	XWD	-JDCQ,IQBAK1##>
	XWD	-TIOWQ,IQFOR##	;TTY IOW
ifn FtCimp,<	xwd	-iwtq,iqfor##>		;[arpa]
IFN FTDAEM,<	XWD	-JDCQ,IQFOR1##>
OTHQUE==.-1
PQ2QUE:	XWD	-PQ2,OLFOR##	;INCLUDES -PQ2,IQBAK AS SUBCASE
PQ1QUE:	XWD	-PQ1,IQBAK##
CMQUE:	XWD	-CMQ,IQBAK##

DEFINE HPQSCN(A)
<HPQU'A:	XWD -HPQ'A,IQBAK##>
IFG HPQN,<ZZ=1
	REPEAT	HPQN,<HPQSCN(\ZZ)
		ZZ=ZZ+1
		>
		>

OSTMXL==:<.-OSCAN-1>B26		;MAX. ENTRY IN GETTABS
IFN FTPATT,<
	Z			;PATCH SPACE
	Z
>
	Z			;FINAL ZERO TO FLAG END
; TABLE OF WHAT QUE ENTRY IS LAST TO SCAN FOR SWAP OUT
OSCANT::OTHQUE			;WHERE TO STOP IF NOT CMQ OR PROCESSOR QUEUE
	CMQUE			;WHERE TO STOP IF CMQ
	PQ1QUE			;WHERE TO STOP IF PQ1
	PQ2QUE			;WHERE TO STOP IF PQ2
	DEFINE HPQSTP(A)
<	HPQU'A>
IFG HPQN,<
	ZZ=1
	REPEAT HPQN,<HPQSTP(\ZZ)
		ZZ=ZZ+1
>
>
OSCNTQ=:OSCANT+1-CMQ		;MAKE AN INDEX INTO STOP TABLE
>				;END 10/50 QUEUE DEFINITIONS
; SPECIAL SCAN TABLE FOR DECREMENTING IN CORE PROTECT TIMES
; PROCESSOR QUEUES MUST BE IN REVERSE ORDER SO THAT REQUEING
; DUE TO EXPIRATION OF ICPT DOES NOT PUT JOB WHERE WE WILL SEE
; IT AGAIN (QUEUES ARE ALSO SCANNED IN REVERSE)
; MUST ALSO CONTAIN ANY OTHER PHYSICAL QUEUE WHICH IS ALLOWED TO
;  RETAIN ICPT. CURRENTLY THIS IS ONLY SLP AND EW.

DCSCAN::EXP	-EWQ		;EVENT WAIT QUEUE
	EXP	-SLPQ		;SLEEP QUEUE
	EXP	-PQ2		;PQ2
	EXP	-PQ1		;PQ1
	DEFINE HPQSCN(A)
<	EXP	-HPQ'A>
IFG HPQN,<
ZZ==1
	REPEAT HPQN,<HPQSCN(\ZZ)
		ZZ==ZZ+1
>
>
IFN FTPATT,<
	0
	0
>
	0
IFN FTNSCHED,<
$ABS
;SUBQUEUE INPUT SCAN TABLE
;
;FOR GENERATING PRIMARY SCAN TABLE, ENTRIES CONTAIN:
; PRIORITY COUNTER IN LEFT HALF,
; SUBCLASS NUMBER IN RIGHT HALF.
;
;FOR GENERATING SECONDARY INPUT SCAN, ENTRIES CONTAIN:
; MINUS SUBQUEUE NUMBER IN LEFT HALF,
; SECONDARY QUOTA IN RIGHT HALF.

SQSCAN::BLOCK	M.CLSN

SQCNT::	0			;COUNTER OF LOCATIONS LEFT IN PRIMARY SCAN TABLE
SQPNT::	0			;POINTER TO CURRENT LOC IN PRIMARY SCAN TABLE
SQSUM::	0			;SUM OF SECONDARY PERCENTS
SQSAVJ::0			;NUMBER OF CLASS ALREADY SCANNED
SCNJIL::0			;TIME TO STOP SCANNING JBTJIL
SCNSWP::0			;# TICS SAME PRIMARY SUBQUEUE HAS BEEN SCANNED
SCNBBS::0			;TIME TO SWAP NEXT BB JOB
BBFIT::	0			;NON-ZERO IF BACKGROUND BATCH JOB BEING FIT
BBFLAG::0			;NON-ZERO IF BACKGROUND BATCH QUEUE BEING SCANNED

>;END IFN FTNSCHED
$ABS
SEED::	377775			;SEED FOR RANDOM NUMBER
$HIGH
IFN FTNSCHED,<
$ABS
;SUBQUEUE SCAN TABLE FOR CPU0
;
;ENTRIES CONTAIN:
; MINUS SUBQUEUE NUMBER.
; TABLE TERMINATES WITH A ZERO.

SSSCAN::BLOCK	M.CLSN
	0			;ZERO TERMINATES TABLE
SSCNT::	0			;COUNTER OF ENTRIES LEFT IN PRIMARY SCAN TABLE
SSPNT::	0			;POINTER TO PRIMARY SCAN TABLE FOR CPU0
SSSUM::	0			;SUM OF SECONDARY PERCENTS
IFN FTMP,<
;SUBQUEUE SCAN TABLE FOR CPU1
SSSCN1::BLOCK	M.CLSN
	0			;ZERO TERMINATES TABLE
SSPNT1::0			;POINTER TO PRIMARY SCAN TABLE FOR CPU1
>
;PRIMARY SCAN TABLE
;STROED AS 101 5-BIT ENTRYES, ONE FOR EACH PERCENT OF THE SYSTEM RESOURCES
; ENTRY 101 IS A DUPLICATE OF ENTRY 1.
PSQTAB::BLOCK	^D15		;ROOM FOR 101 ENTRIES
$HIGH
>;END IFN FTNSCHED

SUBTTL MINIMUM CORE USAGE DATA TABLES

;TABLE OF INDICES TO FIRST POSITION ON TABLES BELOW FOR VARIOUS KONTROLLER TYPES
TYPTAB::EXP	FRSTDR##	;TYPE 0 (DR) FUTURE DRUM, IF ANY
	EXP	FRSTFH##	;TYPE 1 (FH) BURROUGHS DISK OR BRYANT DRUM
	EXP	FRSTDP##	;TYPE 2 (DP) RP10 KONTROLLER RP01, RP02, RP03 DRIVES
	EXP	FRSTMD##	;TYPE 3 (MD) BRYANT MASS DISK
	EXP	FRSTFS##	;TYPE 4 (FS) RH10/RS04
	EXP	FRSTRP##	;TYPE 5 (RP) RH10/RP04
	EXP	FRSTRN##	;TYPE 6 (RN) RP20

;TABLES COMPUTED BY ONCMOD
;UNITS ARE MICROSECONDS

;AVERAGE TIME PER PAGE (K) TABLE COMPUTED BY ONCMOD

MCUATP:: Z			;FUTURE DRUM
	Z			;DITTO
	Z			;RD10
	Z			;RM10B
	Z			;RP01
	Z			;RP02
	Z			;RP03
	Z			;DUAL POSITIONER MD10
	Z			;SINGLE POSITIONER MD10
	Z			;RS04
	Z			;RP04
	Z			;RP06
	Z			;RM03
	Z			;RP07
	Z			;RP20

;AVERAGE LATENCY TIME TABLE COMPUTED BY ONCMOD

MCUALT:: Z			;FUTURE DRUM
	Z			;DITTO
	Z			;RD10
	Z			;RM10B
	Z			;RP01
	Z			;RP02
	Z			;RP03
	Z			;DUAL POSITIONER MD10
	Z			;SINGLE POS. MD10
	Z			;RS04
	Z			;RP04
	Z			;RP06
	Z			;RM03
	Z			;RP07
	Z			;RP20
	$LIT		;GENERATE ALL LITERALS BEFORE RELOC
	LOLOC==ABSLOC-COMORG

	$LOW
IFN M.MBTS,<			;FORCE TO PAGE BOUNDARY SO MONBTS
	.TEXT	"/NEWPAGE:LOW"	;STARTS ON ONE
MBTRLC==:<<ABSLOC+777>/1000>*1000
				;DEFINE THIS SYMBOL SO WE GET MULTIPLY
				; DEFINED GLOBALS FROM LINK IF MONBTS IS
				; NOT LOADED AFTER COMMON
>
IFNDEF	FTCMBTH,<END	SYSTRT>	;END UNLESS ASSEMBLING COMMONS TOGETHER
