TITLE LOKCON -  MODULE FOR LOCKING JOBS IN CORE - V237
SUBTTL J. FLEMMING  TS     26 JULY 83
	SEARCH	F,S
	$RELOC
	$HIGH




;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>
;
;
; DATE		LOAD	EDIT #
; ----		----	------
;
;14-OCT-80	70122	177
;21-OCT-80	70123	200
;9445
;02-12-80	70127	201
;9484-
;20-JAN-81	70135	202
;27-JAN-81	70136	203
;03-FEB-81	70137	204
;9555-
;12-MAY-81	70155	205
;9720-9726-
;09-JUN-81	70161	206
;9749-
;21-JUL-81	70167	207
;9833-
;18-AUG-81	70173	210	
;9874-
;22-SEP-81	70175	211
;29-SEP-81	70176	212
;27-OCT-81	70113	213
;02-NOV-81	70114	214
;01-DEC-81	70115	215
;10001
;08-DEC-81	70121	216
;29-DEC-81	70124	217
;10022
;12-JAN-82	70126	220
;19-JAN-82	70127	221
;10050
;2-FEB-82	70131	222
;10069
;9-FEB-82	70132	223
;16-FEB-82	70133	224
;10102
;11-MAY-82	70146	225
;10244
;13-JUL-82	70157	226
;10309
;20-JUL-82	70160	227
;10315
;28-SEP-82	70172	230
;10428
;05-OCT-82	70173	231
;10437
;11-JAN-83	70120	232
;10566
;18-JAN-83	70121	233
;10566
;09-MAR-83	70130	234
;10650
;17-MAY-83	70142	235
;10765
;12-JUL-83	70151	236
;10850
;26-JUL-83	70153	237
;10883
;
;


XP VKILOK,237			;PUT VERSION NUMBER IN STORAGE MAP

ENTRY	LOKCON			;ENTRY POINT SYMBOL SO LOADER WILL LOAD LOKCON
				; IN A LIBRARY SEARCH

LOKCON::;ENTRY POINT SYMBOL TO CAUSE LOADING OF LOKCON


SUBTTL SWAP - USER PROGRAM SWAPPING ROUTINES

;ROUTINE TO MOVE A JOB TO A PREDETERMINED PLACE IN CORE AND LOCK IT THERE
;CALLING SEQUENCE:
;	HRRZ	AC,JOB NUMBER
;	HRL	AC,HIGH SEGMENT NUMBER
;	MOVSM	AC,LOCK
;OR IF LOW SEGMENT ONLY JOB
;	HRRZ	AC,JOB NUMBER
;	MOVEM	AC,LOCK
;AND
;	MOVEI	P1,LOK
;	IORM	P1,JBTSTS(AC)	;SO SCHEDULAR WON'T RUN THE JOB
;AND
;	MOVE	AC,DESIRED PROTECTION/RELOCATION FOR HIGH SEGMENT OR JOB IF NONE
;	MOVEM	AC,LOKREL
;	PUSHJ	P,WSCHED
;RETURN HERE WHEN JOB (BOTH LOW AND HIGH SEGMENTS) ARE IN PLACE AND LOCKED
;NOTE:	LOW SEGMENT GOES
;	ABOVE THE HIGH SEGMENT
;
;CALLED FROM SCHED WHEN SWAPPER IS IDLE

LKERR1==1
LKERR2==2
LKERR3==3
LKERR4==4
LKERR5==5
LKERR6==6

LKB==1
LKEB==2
LKPB==4
LKCB==10
LOCK0::	SE1ENT			;LOCK MUST RUN IN SECTION 1, SINCE PAGTAB AND
				;MEMTAB SIT IN ANOTHER SECTION (MDSEC2)
IFN FTMOFFL,<
	MOVE	J,LOCK##	;-1 IF SETTING MEMORY OFF LINE
	AOJE	J,[HLRZ P2,LOKREL##
		   SKIPN MOFLPG##
		   JRST LOCK2	;GO IF NOT SETTING MONITOR MEMORY OFF-LINE
		   LDB P2,[POINT 14,MEMSIZ##,26]
		   LDB P3,[POINT 9,SYSSIZ##,26]
		   SUB P2,P3	;FORCE EVERYTHING OUT IF SETTING MONITOR MEMORY OFF
		   JRST LOCK3]
>
	HRRZ	J,LOCK##	;SEGMENT NUMBER OF SEGMENT TO BE LOCKED
LOCK1:	SKIPN	JBTADR##(J)	;IS THIS SEGMENT IN CORE?
	JRST	[HRRZ J,LASLOK## ;NO, GO CAUSE IT TO BE SWAPPED IN
		 S0JRST FIT1##]
	MOVSI	T1,(JS.SIP)	;HAS CORE IN CORE BUT SWAPPING COULD BE IN PROGRESS
	TDNE	T1,JBTST2##(J)	;IS IT?
	POPJ	P,		;YES,WAIT UNTIL SWAPPING I/O IS DONE
	LDB	P2,IMGIN##	;NUMBER OF PAGES IN THE SEGMENT
	LDB	T1,NFYPGS##
	CAIG	J,JOBMAX##	;IS THIS A LOW SEGMENT?
	ADD	P2,T1		;YES, ACCOUNT FOR THE UPMP SIZE
LOCK2:	HRRZ	P3,LOKREL##	;PAGE NUMBER OF STARTING PAGE THIS SEGMENT
				; IS TO BE LOCKED IN
LOCK3:	SKIPGE	T1,@[IW MDSEC2,PAGTAB(P3)] ;PAGE ON THE FREE CORE LIST?
	JRST	LOCK13		;YES, LOOP ON
IFN FTIPCF,<
	TLNE	T1,IPCBIT	;AN IPCF PAGE?
	JRST	DELIPP		;YES, SWAP IT OUT
>
IFN FTMOFFL,<
	SKIPGE	LOCK##		;SETTING MEMORY OFF-LINE?
	TLNN	T1,LKBITS	;YES, IGNORE MONITOR AND NON-EXISTANT PAGES
	SKIPA	P1,P3		;NO, PAGE NUMBER TO P1
	JRST	LOCK13		;LOOK AT THE NEXT PAGE
>
IFE FTMOFFL,<
	MOVE	P1,P3		;ITS NOT A FREE PAGE, SEE WHO IT BELONGS TO
>
	LSH	P1,P2WLSH##	;CONVERT PAGE NUMBER TO AN ABSOLUTE ADDRESS
	PUSHJ	P,CPIASN##	;FIND THE SEGMENT NUMBER OF THE SEGMENT
				; CONTAINING THIS PAGE
	  TDZA	T2,T2		;NOT IN ANY SEGMENT - IT SHOULD BE ON THE
				; FREE CORE LIST
	JUMPG	J,LOCK4		;WAS A SEGMENT CONTAINING THIS PAGE FOUND?
	SKIPN	J,T2		;OR IS THE PAGE SOME JOBS UPMP?
	STOPCD	.,STOP,SNF,	;++SEGMENT NOT FOUND
LOCK4:	HRRZ	T1,LOCK##	;T1 = SEGMENT NUMBER OF SEGMENT BEING LOCKED
	CAIN	T1,(J)		;PAGE FOUND CONTAINED IN SEGMENT BEING LOCKED?
	JRST	LOCK13		;YES, NO ACTION NECESSARY
	CAIG	J,JOBMAX##	;IS THE SEGMENT CONTAINING THE PAGE WHICH
				; MUST BE MOVED A HIGH SEGMENT?
	JRST	LOCK10		;NO, JUST SWAP THIS SEGMENT OUT
	MOVE	P1,JBTSTS##(J)	;P1 = INCORE COUNT FOR THIS HIGH SEGMENT
	TLNE	P1,SWP		;ALREADY SWAPPING THIS HI SEG OUT?
	POPJ	P,		;YES, GO AWAY UNTIL THE SWAP COMPLETES
	TRNE	P1,ICCMSK	;IS THIS A DORMANT OR IDLE HIGH SEGMENT?
	JRST	LOCK6		;NO, MUST SWAP OUT THE LOW SEGMENTS SHARING
				; IT TO MAKE IT GO AWAY
LOCK5:	S0PSHJ	FREC4##		;ITS DORMANT OR IDLE - GO DELETE IT FROM CORE
	 S0JRST	FORIDL##	;IDLE WITH NO COPY ON THE DISK - WRITE ENABLED
	  JRST	LOCK0		;THE SEGMENT HAS BEEN DELETED FROM CORE - TRY AGAIN
LOCK6:	MOVE	T2,J		;SAVE HIGH SEGMENT NUMBER
	MOVE	J,HIGHJB##	;FIND A JOB SHARING IT
LOCK7:	SKIPLE	T1,JBTSGN##(J)	;THIS JOB HAVE A HIGH SEGMENT?
	CAIE	T2,(T1)		;YES, IS IT THE ONE WE WANT TO SWAP?
	JRST	LOCK9		;NO, LOOK AT NEXT JOB
	SKIPE	JBTADR##(J)	;IS JOB IN CORE?
	JRST	LOCK8		;YES, GO SEE IF IT CAN BE SWAPPED OUT
	MOVE	T2,J		;SAVE JOB NUMBER BEFORE CALLING DECCNT
	EXCH	J,T1		;J=HIGH SEG T1=JOB
	S0PSHJ	DECCNT##	;MAKE SURE IN-CORE COUNT IS DECREMENTED
	  JFCL			;ALREADY DECREMENTED OR JUST WENT TO ZERO
	HRRZS	J		;GET RID OF HIGH SEGMENT FLAGS
	JUMPE	T1,LOCK5	;NO MORE JOBS SO SWAP OUT HIGH SEG
	EXCH	J,T2		;GET READY TO LOOK AT NEXT JOB
	JRST	LOCK9		;GO DO IT
LOCK8:	MOVE	T1,JBTSTS##(J)	;GET JOB STATUS
	TLCE	T1,SWP!NSWP	;IS IT LOCKED AND SWAPPED?
	TLNE	T1,SWP!NSWP	;IF BOTH, SWAPPING IT WON'T HELP
	CAIA
	JRST	LOCK9		;SO LOOK AT NEXT JOB
	TRNE	P1,ICCMSK-1	;IN CORE COUNT = 1?
	CAME	J,LOCK##	;IF NOT, IS THIS THE JOB WE'RE LOCKING?
	JRST	LOCK11		;NO, SWAP OUT THE JOB
LOCK9:	SOJG	J,LOCK7		;LOOK AT NEXT JOB

	STOPCD	.,STOP,SSO,	;++SEGMENT SWAPPED OUT
LOCK10:
IFN FTMP,<
	PUSHJ	P,ANYRUN##	;RUNNING ON CPU1?
	  JRST	LOCK12		;YES
>
LOCK11:	MOVSI	T1,(JS.SIP)	;SWAPPING I/O IN PROGRESS BIT
	TDNE	T1,JBTST2##(J)	;JOB CURRENTLY BEING SWAPPED?
	POPJ	P,		;YES, WAIT FOR I/O TO COMPLETE
	S0JRST	FORCE0##	;NO, SWAP HIM NOW
LOCK12:	MOVEM	J,SW0JOB##	;TELL CPU1 TO STOP RUNNING THE JOB
	POPJ	P,		;AND RETURN
LOCK13:	AOS	P3		;NEXT PHYSICAL PAGE WHICH MUST BE FREED
	SOJG	P2,LOCK3	;LOOP UNTIL ALL NECESSARY PAGES ARE AVAILABLE
IFN FTMOFFL,<
	SKIPGE	T1,LOCK##	;LOCK IS -1 IF SETTING MEMORY OFF
	AOJE	T1,SETMFL	;GO MOVE THE MONITOR AND SET MEMORY OFF
>
;ALLOCATE CORE, BLT SEGMENT INTO PLACE, AND LOCK IT
	HRRZ	J,LOCK##	;SEGMENT NUMBER OF SEGMENT BEING LOCKED
	CAILE	J,JOBMAX##	;IS IT A HIGH SEGMENT?
	JRST	LOCK14		;NO, DON'T NEED TO ADDRESS THE UPMP
	CAME	J,.CPJOB##	;IS THIS THE CURRENT JOB? IF SO UPMP IS ADDRESSABLE
	PUSHJ	P,SVEUB##	;MAKE THE UPMP ADDRESSABLE
LOCK14:	MOVE	R,JBTADR##(J)	;ANYACT REQUIRES THAT R BE SETUP
	S0PSHJ	ANYACT##	;ANY ACTIVE I/O?
	  POPJ	P,		;YES, TRY AGAIN NEXT CLOCK TICK
	HRRZ	J,LOCK##	;SEGMENT NUMBER OF SEGMENT BEING LOCKED
	MOVEI	P1,0		;P1 = RELATIVE PAGE NUMBER WITHIN THE SEGMENT
				; START AT RELATIVE PAGE ZERO
	HRRZ	P2,LOKREL##	;P2 = DESIRED PHYSICAL PAGE NUMBER
	CAILE	J,JOBMAX##	;IS THIS SEGMENT A LOW SEGMENT?
	JRST	LOCK16		;NO, NEEDN'T WORRY ABOUT MOVING THE UPMP
	HRRZ	T1,JBTUPM##(J)	;PAGE NUMBER OF UPMP
	PUSHJ	P,SETMAP
IFN FTKLP,<
	PUSHJ	P,SCPAGS##	;FIND LAST PAGE IN PAGTAB CHAIN
	HRRZ	T2,JBTUPM##(J)	;PAGE NUMBER OF PROCESS TABLE
	HRRZ	T3,@[IW MDSEC2,PAGTAB(T2)] ;PAGE MAP PAGE
	HRRM	T3,@[IW MDSEC2,PAGTAB(T1)] ;LINK PAGE MAP PAGE TO THE END
					      ;OF PAGTAB CHAIN
	HLLZS	@[IW MDSEC2,PAGTAB(T2)] ;UNLINK IT FROM PROCESS TABLE CHAIN
>
	HRRZ	T1,JBTUPM##(J)
	LDB	P3,JBYLSA##	;PAGE NUMBER OF FIRST PAGE OF THE JOB
	CAIN	T1,(P2)		;IS THE UPMP ALREADY IN PLACE?
	TDZA	P3,P3		;YES, DOESN'T NEED TO BE MOVED
	PUSHJ	P,PAGMOV	;MOVE THE UPMP TO THE DESIRED POSITION
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT(P2)
	HRLM	T1,.EUPMP+.MUPMP;MAKE THE UPMP ADDRESSABLE IN ITS NEW
				; POSITION THROUGH THE PER PROCESS MAP
IFN FTKL10,<
	HRRM	T1,.EUPMP+.MUUPM
>
>
IFN FTKLP,<
	MOVE	T1,P2
	HRLI	T1,(<PM.DCD>B2+PM.WRT)
	MOVEM	T1,.EUPMP+.UPMP/PAGSIZ##
	MOVEM	T1,.EUPMP+.UUPMP/PAGSIZ##
>
	CAIE	P2,(P3)		;WAS THE UPMP EXCHANGED WITH THE FIRST PAGE
				; OF THE LOW SEGMENT (PAGE CONTAINING JOB
				; DATA AREA)?
	JRST	LOCK15		;NO
	MOVE	T1,.CPMAP##
IFE FTKLP,<
	HRRZ	T1,.MECKS(T1)
	HRRM	T1,.EUPMP+.MJDAT;YES, MAKE THE JOB DATA AREA ADDRESSABLE
				; THROUGH THE PER PROCESS MAP
>
IFN FTKLP,<
	MOVE	T1,.ECKSM/PAGSIZ##(T1)
	MOVEM	T1,.EUPMP+.JDAT/PAGSIZ##
>
	DPB	T1,JBYLSA##
LOCK15:	MOVEI	T1,UPMPSZ##	;+ SIZE OF THE UPMP IN THE RIGHT HALF
	ADDM	T1,LOKREL##	;UPDATE LOKREL TO REFLECT THE FACT THAT
				; THE UPMP IS IN PLACE AND LOCKED
	HLLZS	@[IW MDSEC2,PAGTAB(P2)] ;SIGNAL ONLY THIS PAGE IS ALLOCATED
	MOVSI	T1,LOKPHB	;AND INDICATE THAT THE UPMP IS LOCKED
	IORM	T1,@[IW MDSEC2,PAGTAB(P2)] ; IN PHYSICAL MEMORY
	HRRM	P2,JBTUPM##(J)	;STORE THE NEW PAGE NUMBER OF THE UPMP
	PUSHJ	P,STEUB##	;AND MAKE THE UPMP ADDRESSABLE THROUGH
				; THE PER PROCESS MAP (CLEAR THE AM)
	HRRZ	P2,LOKREL##	;P2 = PHYSICAL PAGE WHERE FIRST PAGE OF THE
				; LOW SEGMENT SHOULD GO
LOCK16:	LDB	P3,IMGIN##	;NUMBER OF PAGES IN THE SEGMENT
	CAILE	J,JOBMAX##
	JRST	LOCK17
	LDB	T1,NFYPGS##
	ADDI	P3,-UPMPSZ##(T1)
	PUSHJ	P,NXTWSB##
	MOVSI	P4,400000
	JRST	LOCK18
LOCK17:	MOVE	T2,P1
	PUSHJ	P,SNPAGS##
	CAIE	T1,(P2)
	PUSHJ	P,PAGMOV
	JUMPN	P1,LOCK19
	DPB	P2,JBYHSA##
	JRST	LOCK19
LOCK18:	PUSHJ	P,PGMOVE
	JUMPN	P1,LOCK19
IFE FTKLP,<
	MOVEI	T4,PM.ACC+PM.WRT(P2)
	HRRM	T4,.UPMP+.MJDAT	;AND MAKE THE JOB DATA ADDRESSABLE
>
IFN FTKLP,<
	MOVE	T4,P2
	HRLI	T4,(<PM.DCD>B2+PM.WRT)
	MOVEM	T4,.UPMP+.JDAT/PAGSIZ##
>
	DPB	T4,JBYLSA##
	PUSHJ	P,NEWMAP	;CLEAR THE AM SO NEW MAPPING IS IN EFFECT
LOCK19:	MOVSI	T4,LOKPHB	;INDICATE THIS PAGE IS LOCKED IN PHYSICAL MEMORY
	SKIPE	P1		;SKIP IF FIRST PAGE OF THE SEGMENT
	IORM	T4,@[IW MDSEC2,PAGTAB-1(P2)] ; CONTIGIOUSLY
	ADDI	P1,1		;NEXT RELATIVE PAGE WITHIN THE SEGMENT
	ADDI	P2,1		;STEP TO NEXT TARGET PAGE
	SOJE	P3,LOCK20
	CAILE	J,JOBMAX##
	JRST	LOCK17
	PUSHJ	P,FPNSHS
	PUSHJ	P,NXTWS2##
	JRST	LOCK18
LOCK20:	IORM	T4,@[IW MDSEC2,PAGTAB-1(P2)] ;INDICATE LAST PAGE OF SEGMENT
	MOVSI	T1,NSHF!NSWP	;AFTER ALL THAT WORK
	IORM	T1,JBTSTS##(J)	; MAKE SURE THE SEGMENT DOESN'T SWAP
IFN FTKLP,<
	CAILE	J,JOBMAX##	;LOCKING A LOW SEGMENT?
	JRST	LOCK21		;NO
	MOVE	T2,.UPMP+.UPMAP/PAGSIZ## ;PAGE MAP
	TLO	T2,(PM.PUB+PM.CSH) ;ALWAYS CACHED AND PUBLIC IN SECTION TABLE
	MOVEM	T2,.UPMP+540	;STORE AS POINTER TO SECTION 0 PAGE MAP
	PUSHJ	P,NEWMAP	;ZAP PAGING MEMORY
	HRRZS	T2		;JUST PAGE NUMBER
	PUSHJ	P,LKPSP##	;FIND AND LINK AROUND IT
	HLLZS	@[IW MDSEC2,PAGTAB(T2)] ;LAST PAGE IN LOW SEGMENT CHAIN
	HRRZ	T1,JBTUPM##(J)	;PROCESS TABLE
	HRRM	T2,@[IW MDSEC2,PAGTAB(T1)] ;LINK PAGE MAP ONTO
					      ;PROCESS TABLE CHAIN
LOCK21:>
	HLRZS	J,LOCK##	;GET THE SEGMENT NUMBER OF THE LOW SEGMENT
				; IF THERE IS ONE LEFT TO BE LOCKED
	JUMPE	J,LOCK22	;JUMP IF DONE
	HLRZS	LOKREL##	;STARTING PAGE NUMBER FOR THE LOW SEGMENT
	JRST	LOCK1		;AND GO TRY TO LOCK IT
LOCK22:	MOVEI	T1,LOK		;SET TO MAKE JOB RUNABLE AGAIN
	HRRZ	J,LASLOK##	;GET THE JOB NUMBER OF JOB ISSUING LOCK UUO
	ANDCAM	T1,JBTSTS##(J)	;TURN OFF LOK SO SCHEDULAR WILL RUN THE JOB AGAIN
	MOVSI	T1,SWP		;ASSUME THE HIGH SEGMENT GOT SWAPPED WHILE
				; LOCKING THE LOW SEGMENT
	SKIPG	T2,JBTSGN##(J)	;DOES THE JOB HAVE A REAL HIGH SEGMENT?
	POPJ	P,		;NO, RETURN
	HRRZS	T2		;CLEAN OUT LH OF JBTSGN SO WE CAN INDEX
	SKIPN	JBTADR##(T2)	;IS THE HIGH SEGMENT IN CORE
	IORM	T1,JBTSTS##(J)	;TURN ON SWP SO THE SCHEDULAR WON'T RUN
				; THE JOB UNTIL THE HIGH SEGMENT GETS SWAPPED IN
	MOVE	T1,HIGHJB##	;HIGHEST NUMBERED JOB
	MOVSI	T3,SEGMB		;SIGNAL TO MAP HIGH SEGMENT
LOCK23:	SKIPLE	T4,JBTSGN##(T1)	;GET HIGH SEGMENT OF ALL JOBS
	SKIPN	JBTADR##(T1)	;IGNORE IF NOT IN CORE
	JRST	LOCK24
	CAME	J,T1		;DON'T DO IT TO OUR JOB
	CAIE	T2,(T4)		;SAME HIGH SEGMENT AS OURS?
	JRST	LOCK24		;NO. LOOK AT NEXT ONE
	IORM	T3,JBTSGN##(T1)
LOCK24:	SOJG	T1,LOCK23	;LOOP FOR ALL JOBS
	POPJ	P,		;AND RETURN

IFN FTIPCF,<
;HERE WHEN AN IPCF PAGE WAS IN THE ROAD
DELIPP:	TLNE	T1,LOKPHB	;TURNED ON WHILE SWAPPING I/O IS IN PROGRESS
				; SO WE DON'T TRY TO SWAP OUT THE PAGE TWICE
	POPJ	P,		;I/O IN PROGRESS, WAIT FOR IT TO COMPLETE
	HRRZ	T2,P3		;ARGUMENT FOR IPCSSP
	PUSHJ	P,IPCSSP##	;GET SWAPPING SPACE
	S0PSHJ	MAKSLE##	;MAKE THE SWPLST ENTRY
	HRRZ	T2,P3		;RESTORE PHYSICAL PAGE NUMBER
	S0PSHJ	LOKIPC##	;FIND ENTRY IN AN IPCF QUEUE AND REPLACE PHYSICAL
				; PAGE WITH DISK ADDRESS
	  STOPCD	(.,STOP,IPU) ;++IPCF PAGE UNOWNED
	S0JRST	SQOUT##		;START THE PAGING IO
				; WAIT FOR THE PAGE TO GO AWAY
>
IFN FTMOFFL,<
SETMFL:
;HERE TO MOVE THE MONITOR IF NECESSARY
	SKIPN	P4,MOFLPG##	;ANY OF THE PAGES BEING SET OFF CONTAIN MONITOR CODE?
	JRST	SETM21		;NO, THEN THIS IS EASY
IFN FTKL10&FTMBTS,<
;FIRST MOVE ANY PAGES WHICH ARE REALLY MONITOR PAGES BUT DON'T APPEAR IN ANY MAP
SETMF1:	MOVEI	T1,0		;STARTING AT PAGE 0
	LDB	T2,[POINT 14,MEMSIZ##,26] ;LOOK TO THE TOP OF CORE
SETMF2:	MOVE	T3,@[IW MDSEC2,PAGTAB(T1)] ;CURRENT PAGTAB ENTRY
	TLC	T3,MONTRB+NXMBIT;COMPLEMENT BITS
	TLCN	T3,MONTRB+NXMBIT;THIS PAGE A MONITOR PAGE BUT NOT IN ANY MAP?
	JRST	SETMF4		;YES, SEE IF IT MUST BE MOVED
SETMF3:	HRRZS	T1		;CLEAR LEFT HALF JUNK - USED AS A TEMP BELOW
	CAIGE	T1,-1(T2)	;REACHED TOP OF MEMORY?
	AOJA	T1,SETMF2	;NO, LOOK ON
	JRST	SETM12		;YES, ALL PAGES HAVE BEEN MOVED
;FOUND FIRST, NOW DETERMINE THE RANGE
SETMF4:	HRLS	T1		;FIRST PAGE SEEN IN THE LEFT HALF
SETMF5:	CAIN	T2,1(T1)	;AT THE TOP OF MEMORY?
	AOJA	T1,SETMF6	;YES, HIGHEST PAGE + 1 IN THE RANGE
	HRRZ	T3,T1		;INDEX INTO PAGTAB
	MOVE	T3,@[IW MDSEC2,PAGTAB(T3)] ;NEXT PAGTAB ENTRY
	TLC	T3,MONTRB+NXMBIT;ALSO A MONITOR PAGE NOT IN A MAP?
	TLCN	T3,MONTRB+NXMBIT;SKIP IF NOT
	AOJA	T1,SETMF5	;FIND THE HIGHEST PAGE
;HERE WHEN THE RANGE OF PAGES HAS BEEN DETERMINED, SEE IF THEY OVERLAP THE
; RANGE OF PAGES BEING SET OFF-LINE
SETMF6:	HRRZ	T3,LOKREL##	;FIRST PAGE BEING SET OFF-LINE
	HLRZ	T4,LOKREL##	;NUMBER OF PAGES BEING SET OFF-LINE
	ADDI	T4,(T3)		;HIGHEST PAGE + 1 BEING SET OFF-LINE
	CAIL	T3,(T1)		;BOTTOM OF MOFFL .LE. TOP OF UNMAPPED PAGES?
	JRST	SETMF3		;YES, THEY DON'T OVERLAP SO LOOK ON
	MOVSS	T1		;BOTTOM PAGE IN UNMAPPED PAGE RANGE
	CAIG	T4,(T1)		;LOWEST PAGE ABOVE RANGE BEING SET OFF-LINE?
	JRST	SETM12		;YES, DONE SINCE ABOVE REGION BEING SET OFF
;HERE TO COMPUTE THE NUMBER OF UNMAPPED PAGES WHICH OVERLAP THE MEMORY OFF-LINE
; RANGE
	HRRZ	P1,T1		;LOWEST UNMAPPED PAGE
	HLRZ	P2,T1		;HIGHEST UNMAPPED PAGE
SETMF7:	CAIL	P1,(T3)		;BELOW RANGE BEING SET OFF-LINE?
	CAIL	P1,(T4)		;OR ABOVE RANGE BEING SET OFF-LINE?
	CAIA			;NOT IN OFF-LINE RANGE
	SOS	P4		;DECREMENT NUMBER OF MONITOR PAGES BEING SET OFF
	CAIE	P1,-1(P2)	;LOOKED AT THE ENTIRE RANGE OF UNMAPPED PAGES
	AOJA	P1,SETMF7	;NO, LOOK AT THE NEXT PAGE
	HLRZ	P1,T1		;HIGHEST UNMAPPED PAGE
	SUBI	P1,(T1)		;NUMBER OF PAGES TO MOVE (MUST MOVE THEM ALL
				; EVEN IF ONLY A FEW OVERLAP SINCE PHYSICAL
				; CONTIGUITY MUST BE MAINTAINED)
	LDB	P2,[POINT 14,SYSSIZ##,26] ;STARTING AT SYSSIZ
SETMF8:	MOVEI	P3,0		;NUMBER OF CONTIGUOUS FREE PAGES SEEN
SETMF9:	HRRZ	T2,P2		;MAKE AN INDEX INTO PAGTAB
	CAILE	T3,(P2)		;ABOVE RANGE BEING SET OFF-LINE?
	CAILE	T4,(P2)		;NO, WITHIN RANGE BEING SET OFF-LINE?
	SKIPL	@[IW MDSEC2,PAGTAB(T2)] ;NOT WITHIN RANGE, IS THE PAGE FREE?
	JRST	SETM11		;NO, LOOK HIGHER UP
	TLNN	P2,-1		;FIRST PAGE OF THE HOLE?
	HRLS	P2		;YES, REMEMBER START OF HOLE
	AOS	P3		;NUMBER OF PAGES SEEN SO FAR IN THIS HOLE
	CAIGE	P3,(P1)		;ENOUGH PAGES SEEN TO MOVE THE UNMAPPED PAGES?
	AOJA	P2,SETMF9	;NO, SEE IF THERE ARE MORE PAGES AVAILABLE
;HERE WHEN ENOUGH FREE PAGES HAVE BEEN FOUND TO MOVE THE UNMAPPED PAGES
; T1 = TOP,,BOTTOM OF UNMAPPED PAGES, P1 = NUMBER OF PAGES TO MOVE,
; P2 = BOTTOM,,TOP OF HOLE
	PUSH	P,P1		;SAVE COUNT (NEED P1 FOR PAGFRE)
	MOVEI	P1,0		;NEVER A PREDECESSOR IN PAGFRE
	HLRZS	P2		;STARTING DESTINATION PAGE
	HRRZ	P3,T1		;STARTING SOURCE PAGE
SETM10:	HRRZ	T1,P3		;NEXT SOURCE PAGE
	PUSH	P,@[IW MDSEC2,PAGTAB(T1)] ;SAVE PAGE DESCRIPTOR BITS
					     ;(MONTRB+NXMBIT)
	PUSHJ	P,PAGFRE	;MOVE THE PAGE AND FIX PAGTAB
	  STOPCD	(.,STOP,CMP) ;++CAN'T MOVE PAGE
	POP	P,T1		;GET BACK PAGE DESCRIPTOR BITS
	HLLM	T1,@[IW MDSEC2,PAGTAB(P2)] ;FIX UP DESTINATION PAGTAB ENTRY
	HRRZ	T1,P2		;DESTINATION PAGE
	IDIVI	T1,^D36		;BIT POSITION, INDEX INTO NXMTAB
	MOVE	T2,BITTBL##(T2)	;BIT WITHIN THE WORD
	IORM	T2,NXMTAB##(T1)	;MARK THE PAGE AS NON-EXISTANT IN ITS NEW POSITION
	HRRZ	T1,P3		;SOURCE PAGE
	IDIVI	T1,^D36		;BIT POSITION, INDEX
	MOVE	T2,BITTBL##(T2)	;BIT WITHIN THE WORD
	ANDCAM	T2,NXMTAB##(T1)	;NOW MARK THE SOURCE PAGE AS EXISTANT
;TO GENERALIZE THIS FOR MANY THINGS RESIDING IN UNMAPPED PAGES, MAKE THE
; FOLLOWING CODE LOOP OVER A TABLE OF POINTERS TO PHYSICAL STARTING ADDRESSES
; OF DATA CONTAINED IN UNMAPPED PAGES
	MOVE	T1,UCDADR##	;PHYSICAL ADDRESS OF DX20 MICROCODE
	LSH	T1,W2PLSH##	;PAGE NUMBER
	HRRZ	T2,P2		;DESTINATION PAGE
	LSH	T2,P2WLSH##	;DESTINATION PHYSICAL ADDRESS
	CAIN	T1,(P3)		;WAS THIS THE PAGE MOVED?
	MOVEM	T2,UCDADR##	;YES, STORE NEW STARTING PHYSICAL ADDRESS
	AOS	P2		;NEXT DESTINATION PAGE
	SOSLE	(P)		;ALL THE UNMAPPED PAGES BEEN MOVED?
	AOJA	P3,SETM10	;NO, MOVE THE NEXT SOURCE PAGE
	POP	P,(P)		;POP OFF JUNK
	JRST	SETMF1		;THESE PAGES HAVE BEEN MOVED, LOOK FOR MORE
SETM11:	HRRZS	P2		;NEXT FREE PAGE IS THE BEGINNING OF A HOLE
	CAIE	P2,-1(T2)	;REACHED THE TOP OF MEMORY
	AOJA	P2,SETMF8	;NO, LOOK FOR THE NEXT HOLE
	STOPCD	(.,STOP,NCC)	;++NOT ENOUGH CONTIGUOUS FREE CORE
>; END FTKL10&FTMBTS
SETM12:	JUMPE	P4,SETM21	;GO IF ALL PAGES SET OFF WERE UNMAPPED
	MOVEI	P1,0		;FOR PAGFRE
	LDB	P2,[POINT 14,MEMSIZ##,26]
	HLRZ	P3,LOKREL##	;NUMBER OF PAGES TO BE SET OFF
	MOVNS	P3		;MAKE IT NEGATIVE
	HRL	P3,LOKREL##	;STARTING PAGE NUMBER
	MOVSS	P3		;MAKE AN AOBJN POINTER
SETM13:	HRRZ	T1,P3		;COPY PAGE NUMBER
	SSX	T1,MDSEC2	;MAKE AN INDEX INTO PAGTAB WITH IT
	MOVE	T1,PAGTAB(T1)	;GET PAGTAB ENTRY FOR THIS PAGE
	TLNE	T1,MONTRB	;DOES THIS PAGE CONTAIN MONITOR CODE?
	JRST	SETM14		;YES
	AOBJN	P3,SETM13	;NO, LOOK AT THE NEXT PAGE
	STOPCD	.,STOP,MMR,	;++MOVING MONITOR PAGE NOT REQUIRED
;HERE WHEN A MONITOR PAGE HAS BEEN FOUND WITHIN THE RANGE BEING SET
; OFF-LINE, MOVE THE PAGE TO THE HIGHEST POSSIBLE FREE PAGE WHICH DOES
; NOT OVERLAP THE PAGES BEING SET OFF-LINE. THIS TENDS TO KEEP THE MONITOR
; AS HIGH IN CORE AS POSSIBLE SO THAT MORE SPACE IS AVAILABLE FOR
; LOCKING BELOW 112K AND HELPS TO KEEP THE MONITOR FROM BEING WRITTEN
; INTO WITH AN ABSOLUTE ADDRESS WHICH CAN ONLY BE DONE IF ITS BELOW 112K
SETM14:	HRRZ	T1,LOKREL##	;LOWEST PAGE BEING SET OFF LINE
	HLRZ	T2,LOKREL##	;NUMBER OF PAGES BEING SET OFF LINE
	ADDI	T2,-1(T1)	;HIGHEST PAGE BEING SET OFF LINE
	SUBI	P2,1		;CANDIDATE FOR WHERE TO MOVE THIS PAGE
	CAIL	P2,(T1)		;IS CANDIDATE BELOW FIRST PAGE BEING SET OFF?
	CAILE	P2,(T2)		;OR ABOVE LAST BEING SET OFF?
	SKIPL	@[IW MDSEC2,PAGTAB(P2)] ;YES, IS THE CANDIDATE PAGE FREE?
				; IF NOT, IT MUST CONTAIN A PAGE OF THE MONITOR
	JRST	SETM14		;NO, LOOK AT THE NEXT CANDIDATE
	HRRZ	T1,P3		;PART OF P3 TO BE USED AS AN INDEX
	SSX	T1,MDSEC2	;MAKE IT A REAL POINTER TO PAGTAB/MEMTAB
	PUSH	P,PAGTAB(T1)	;SAVE BITS FOR THIS PAGE
	HRRZ	T1,P3		;SOURCE PAGE
	PUSHJ	P,PAGFRE	;MOVE THE PAGE
	  STOPCD	.,STOP,FPN,	;++FREE PAGE NOT FOUND
;HERE WITH SOURCE PAGE IN RH(P3), DESTINATION PAGE IN P2, FIND THE
; SOURCE PAGE IN THE EXEC MAP AND MAP THE DESTINATION PAGE THROUGH THAT
; MAP SLOT
	MOVE	T1,MONVFF##	;1ST VIRTUAL ADDRESS ABOVE MONITOR
IFE FTKLP,<
	SUBI	T1,PAGTAB
>
IFN FTKLP,<
	SUBI	T1,MONORG##	;NUMBER OF WORDS (BOTTOM OF HISEG)
>
	LSH	T1,W2PLSH##	;NUMBER OF PAGES TO WORRY ABOUT
IFE FTKLP,<
IFE PAGTAB&1000,<
	MOVE	T2,[POINT 18,.E0PM##-.E0MP##+<PAGTAB-400000>/<2*1000>]
>
IFN PAGTAB&1000,<
	MOVE	T2,[POINT 18,.E0PM##-.E0MP##+<PAGTAB-400000>/<2*1000>,17]
>
>
IFN FTKLP,<
	MOVE	T2,[POINT 36,MONORG##/PAGSIZ##]
>
	ADD	T2,.CPMAP##
SETM15:	ILDB	T3,T2		;GET THE NEXT MAP ENTRY
	ANDI	T3,17777	;CLEAR ACCESS BITS
	CAIN	T3,(P3)		;IS THIS THE PAGE WHICH WAS JUST MOVED?
	JRST	SETM20		;YES
	SOJG	T1,SETM15	;LOOP OVER ALL OF THE MONITORS PAGES
IFN FTKLP,<
	MOVE	T1,.CPEPT##	;PAGE MAY BE IN A NON-ZERO SECTION
	ADDI	T1,2		;START AT SECTION 2
SETM16:	SKIPN	T2,SECTAB(T1)	;SECTION EXIST?
	JRST	SETM19		;NO
	MOVE	T3,.CPMAP##	;ADDRESS OF OUR MAP
	MOVEM	T2,.EUPMP/PAGSIZ##(T3) ;MAKE THE SECTION MAP ADDRESSABLE
	ANDI	T2,17777	;CLEAR ACCESS BITS
	CAIE	T2,(P3)		;IS THIS THE PAGE BEING SET OFF-LINE?
	JRST	SETM17		;NO
	MOVSI	T2,(POINT 36,0,35) ;YES, SECTION MAP IS BEING SET OFF-LINE
	HRRI	T2,SECTAB(T1)	;BYTE POINTER TO THE SLOT IN THE SECTION TABLE
	JRST	SETM20		;REMAP THE PAGE
SETM17:	PUSHJ	P,NEWMAP	;TO LOOK AT THE SECTION MAP
	MOVE	T2,[POINT 36,.EUPMP] ;BYTE POINTER TO THE SECTION MAP
	MOVEI	T3,^D512	;512 PAGES/SECTION
SETM18:	ILDB	T4,T2		;NEXT ENTRY IN THE SECTION MAP
	ANDI	T4,17777	;CLEAR ACCESS BITS
	CAIN	T4,(P3)		;PAGE THATS BEING SET OFF-LINE?
	JRST	SETM20		;YES
	SOJG	T3,SETM18	;NO, LOOP OVER THE ENTIRE SECTION
SETM19:	MOVE	T3,.CPEPT##	;ADDRESS OF OUR PROCESS TABLE
	CAIGE	T1,MXSECN(T3)	;LOOKED AT ALL SECTIONS?
	AOJA	T1,SETM16	;NO, LOOK AT THE NEXT ONE
>
	STOPCD	.,STOP,MPN,	;++MONITOR PAGE NOT FOUND
;HERE WITH THE BYTE POINTER TO THE EXEC MAP SLOT IN T2
SETM20:	LDB	T1,T2		;GET THE CURRENT CONTENTS OF THE MAP SLOT
	AND	T1,[-1,,760000]	;GET THE ACCESS BITS
	ADDI	T1,(P2)		;NEW PAGE NUMBER PLUS ACCESS BITS
	DPB	T1,T2		;STORE NEW PHYSICAL PAGE NUMBER
	PUSHJ	P,NEWMAP	;CAUSE NEW MAPPING TO BE IN EFFECT SINCE
				; PAGTAB MAY HAVE BEEN MOVED
	POP	P,T1		;MONITOR PAGE+CACHE BITS
	HRRZ	T2,P2		;GET INDEX INTO PAGTAB (LH P2 MAY HAVE JUNK)
	HLLM	T1,@[IW MDSEC2,PAGTAB(T2)] ;REMEMBER THAT
	SOJG	P4,SETM13	;MOVE THE NEXT MONITOR PAGE
;HERE WHEN ALL PAGES TO BE SET OFF LINE ARE FREE AND ANY MONITOR
; PAGES WHICH NEEDED TO BE HAVE BEEN MOVED
SETM21:	HRRZ	T1,LOKREL##	;FIRST PAGE TO BE SET OFF LINE
	IDIVI	T1,^D36		;BIT POSITION AND WORD NUMBER WITHIN NXMTAB
				; CORESPONDING TO THE FIRST PAGE SET OFF
	MOVE	T2,BITTBL##(T2)	;BIT MASK CORRESPONDING TO BIT POSITION
	HLRZ	T3,LOKREL##	;NUMBER OF PAGES TO SET OFF
SETM22:	IORM	T2,NXMTAB##(T1)	;MAKE THE PAGE APPEAR TO BE NON-EXISTANT
	ROT	T2,-1		;NEXT BIT POSITION IN NXMTAB
	SKIPGE	T2		;PASSED A WORD BOUNDARY?
	ADDI	T1,1		;YES, BUMP TO THE NEXT WORD IN NXMTAB
	SOJG	T3,SETM22	;MARK ALL PAGES IN THE REQUEST AS OFF LINE
	SETZM	LOCK##		;INDICATE SUCCESS
	MOVEI	T1,LOK		;ALLOW JOB TO RUN AND/OR COMMAND TO COMPLETE
	HRRZS	J,LASLOK##	;JOB NUMBER OF JOB SETTING MEMORY OFF
	ANDCAM	T1,JBTSTS##(J)	;CLEAR THE BIT
	PJRST	CPINXF##	;FIXUP PAGTAB, CORTAL, BIGHOL, CORMAX, MAXMAX, ETC.
> ;END FTMOFFL


;SUBROUTINE TO SEE IF TARGET PAGE IS ON THE FREE CORE LIST AND
; EXCHANGE IT WITH THE CURRENT PAGE IF SO
;ENTER WITH T1= CURRENT PAGE WHERE JOB IS
; ENTER P2= PAGE WE WANT TO PUT JOB AT
;EXIT CPOPJ1 IF THE TARGET PAGE IS ON THE FREE CORE LIST AND THE
; EXCHANGE HAS TAKEN PLACE

PAGFRE:	MOVEI	T3,PAGPTR##	;PRESET PREDECESSOR
	SKIPN	T2,PAGPTR##	;START LOOKING AT 1ST FREE PAGE
	POPJ	P,		;NONE FREE
PAGFR1:	CAIN	P2,(T2)		;TARGET PAGE ON FREE LIST?
	JRST	PAGFR2		;YES
	XMOVEI	T3,@[IW MDSEC2,PAGTAB(T2)] ;NO, SET PRED.
	SSX	T2,MDSEC2	;POINT TO SECTION CONTAINING PAGTAB
	SKIPL	T2,PAGTAB(T2)	;STEP TO NEXT PAGE IN FREE LIST
	STOPCD	.,STOP,FPF,	;++PAGE ON THE FREE LIST ISN'T FREE!
	TRNE	T2,-1		;END OF FREE LIST?
	JRST	PAGFR1		;NO, TEST THIS FREE PAGE
	POPJ	P,		;YES, TARGET PAGE ISNT FREE

;HERE WHEN TARGET PAGE IS ON THE FREE-PAGE LIST
;EXCHANGE TARGET PAGE AND CURRENT PAGE ON THE FREE LIST
PAGFR2:	JUMPE	P1,PAGFR4
	LDB	T4,JBYLSA##
	CAILE	J,JOBMAX##
	LDB	T4,JBYHSA##
PAGFR3:	SKIPGE	T2,@[IW MDSEC2,PAGTAB(T4)]
	STOPCD	.,STOP,PFS,	;++PAGE IS FREE IN SEGMENT
	HRRZS	T2		;WE DON'T NEED PAGTAB BITS HERE.
	CAIE	T1,(T2)
	SKIPA	T4,T2
PAGFR4:	SKIPA	T2,@[IW MDSEC2,PAGTAB(T1)]
	JRST	PAGFR3
	PUSHJ	P,FIXPTB
	MOVSI	T2,FREPAG
	HLLM	T2,@[IW MDSEC2,PAGTAB(T1)]
	PUSHJ	P,BLTPAG	;MOVE CURRENT PAGE TO TARGET PAGE (DATA)
	PJRST	CPOPJ1##	;AND SKIP-RETURN
;CALL THIS ROUTINE WHEN THE TARGET PAGE ISN'T ON FREE-LIST
;NOTE THAT THE PAGE IS THEREFORE IN THIS SEGMENT'S MAP
PAGFND:	LDB	T2,JBYLSA##	;ASSUME ITS A LOW SEGMENT
	CAILE	J,JOBMAX##	;IS IT?
	LDB	T2,JBYHSA##	;NO
	SETZ	T4,		;NO PREDECESSORS YET
	CAIE	T2,(P2)		;IS THE TARGET PAGE THE 1ST PAGE OF THE SEG?
	JRST	PAGFD1		;NO
	MOVE	T2,@[IW MDSEC2,PAGTAB(T1)] ;YES, GET SUCC TO CURRENT PAGE
	EXCH	T2,@[IW MDSEC2,PAGTAB(P2)] ;STORE AS SUCC TO TARGET PAGE
	HRRM	T2,@[IW MDSEC2,PAGTAB(T1)] ;SUCC TO TARGET TO CURRENT SUCC
	JRST	PAGFD2		;AND SKIP SOME MAGIC

;HERE WHEN THE TARGET PAGE ISN'T THE 1ST PAGE OF THE SEGMENT
PAGFD1:	HRRZ	T3,T2		;SET PREDECESSOR
	JUMPE	T3,CPOPJ##	;ERROR IF LAST PAGE OF SEGMENT
	HRRZ	T2,@[IW MDSEC2,PAGTAB(T3)] ;NOT LAST, GET NEXT PAGE
	CAIN	T2,(T1)
	HRR	T4,T3
	CAIN	T2,(P2)		;IS THIS THE TARGET PAGE?
	HRL	T4,T3
	SKIPE	P1
	TRNE	T4,-1
	TLNN	T4,-1
	JRST	PAGFD1		;NO, TRY AGAIN
	SKIPGE	T2,@[IW MDSEC2,PAGTAB(T1)] ;GET SUCCESSOR TO CURRENT PAGE
	STOPCD	.,STOP,NPF,	;++NEXT PAGE FREE
	HLRZ	T3,T4
IFN FTKLP,<ADD	T3,[EXP MDSEC2+PAGTAB]>
IFE FTKLP,<ADDI T3,PAGTAB>
	PUSHJ	P,FIXPTB
PAGFD2:	CAIG	J,JOBMAX##	;IF A LOW SEGMENT,
	PUSHJ	P,FIXMAP	;FIND THE DESTINATION PAGE AND FIX THE MAP
	PUSHJ	P,EXCHPG	;EXCHANGE DATA OF CURRENT AND TARGET PAGES
	JRST	CPOPJ1##	;AND GIVE GOOD RETURN
;SUBROUTINE TO MAKE TARGET AND SOURCE PAGES ADDRESSABLE IN EXEC
; VIRTUAL MEMORY
;CALLING SEQUENCE:
;	MOVE	T1,ABSOLUTE PAGE NUMBER OF SOURCE PAGE
;	MOVE	P2,ABSOLUTE PAGE NUMBER OF TARGET PAGE
;	PUSHJ	P,SETMAP
;RETURN HERE, SOURCE AND TARGET PAGES ADDRESSABLE THROUGH .ECKSM AND
; .EUPMP RESPECTIVILY

SETMAP:	PUSHJ	P,SAVE1##
	MOVE	P1,.CPMAP##
IFE FTKLP,<
	TRO	T1,PM.ACC+PM.WRT;ACCESS ALLOWED AND WRITABLE
	HRRM	T1,.MECKS(P1)
	MOVEI	T1,PM.ACC+PM.WRT(P2)
	HRLM	T1,.MEUPM(P1)
>
IFN FTKLP,<
	HRLI	T1,(<PM.DCD>B2+PM.WRT)
	MOVEM	T1,.ECKSM/PAGSIZ##(P1)
	HRR	T1,P2
	MOVEM	T1,.EUPMP/PAGSIZ##(P1)
>
;	PJRST	NEWMAP
NEWMAP:	CLRPGT	(0)		;CLEAR THE ASSOCIATIVE MEMORY
				; SO THE NEW MAPPING WILL BE IN EFFECT
	POPJ	P,		;RETURN

;SUBROUTINE TO BLT SOURCE PAGE TO TARGET PAGE WHICH WAS ON THE FREE CORE LIST
;CALLING SEQUENCE:
;	MOVE	T1,ABSOLUTE PAGE NUMBER OF THE SOURCE PAGE
;	MOVE	P2,ABSOLUTE PAGE NUMBER OF THE TARGET PAGE
;	PUSHJ	P,BLTPAG
;RETURN HERE, SOURCE PAGE BLTED TO TARGET PAGE FROM FREE CORE LIST

BLTPAG:	PUSHJ	P,SETMAP	;MAKE THE SOURCE AND DESTINATION PAGES ADDRESSABLE
	MOVSI	T1,.ECKSM	;ADDRESS OF THE SOURCE PAGE
	HRRI	T1,.EUPMP	;ADDRESS OF THE DESTINATION PAGE
;THIS LABEL IS TO DETECT MEMORY PARITY ERROR IN EXEC MODE DURING BLT OF USER CORE
LOKINS::BLT	T1,.EUPMP+PAGSIZ##-1
	POPJ	P,		;MOVE THE PAGE AND RETURN
;SUBROUTINE TO EXCHANGE SOURCE AND TARGET PAGES WHEN THEY ARE BOTH CONTAINED
; WITHIN THE CURRENT SEGMENT
;CALLING SEQUENCE:
;	MOVE	T1,ABSOLUTE PAGE NUMBER OF THE SOURCE PAGE
;	MOVE	P2,ABSOLUTE PAGE NUMBER OF THE TARGET PAGE
;	PUSHJ	P,EXCHPG
;RETURN HERE, SOURCE AND TARGET PAGES HAVE BEEN EXCHANGED

EXCHPG:	PUSHJ	P,SETMAP	;MAKE THE SOURCE AND DESTINATION PAGES ADDRESSABLE
	MOVNI	T1,PAGSIZ##	;- THE NUMBER OF WORDS TO EXCHANGE
	HRLZS	T1		;T1 = AN AOBJN POINTER
EXCHP1:	MOVE	T2,.EUPMP(T1)	;GET A DATA WORD FORM THE DESTINATION PAGE
	EXCH	T2,.ECKSM(T1)	;EXCHANGE IT WITH THE WORD FROM THE SOURCE PAGE
	MOVEM	T2,.EUPMP(T1)	;WORD FROM SOURCE PAGE TO DESTINATION PAGE
	AOBJN	T1,EXCHP1	;EXCHANGE THE ENTIRE PAGES
	POPJ	P,		;AND RETURN
;SUBROUTINE TO FIND THE TARGET PAGE ON THE FREE CORE LIST OR WITHIN
; THE CURRENT SEGMENT AND MOVE/EXCHANGE THE SOURCE TO/WITH THE TARGET AS
; APPROPRIATE
;CALLING SEQUENCE:
;	MOVE	T1,ABSOLUTE PAGE NUMBER OF THE SOURCE PAGE
;	MOVE	P2,ABSOLUTE PAGE NUMBER OF THE TARGET PAGE
;RETURN HERE - THE SOURCE PAGE HAS BEEN MOVED TO THE TARGET DESTINATION

PAGMOV:	PUSHJ	P,PAGFRE	;IS THE DESTINATION PAGE ON THE FREE CORE
				; LIST? IF SO, MOVE SOURCE PAGE TO DESTINATION
				; PAGE AND FIXUP PAGTAB
	  SKIPA			;TARGET PAGE NOT ON FREE CORE LIST
	POPJ	P,		;PAGE IS IN PLACE
	PUSHJ	P,PAGFND	;THE DESTINATION PAGE IS NOT ON THE FREE
				; CORE LIST SO IT MUST BELONG TO THIS SEGMENT
				; FIND IT WITHIN THE SEGMENT, FIXUP PAGTAB
				; AND EXCHANGE THE SOURCE AND TARGET PAGES
	  STOPCD	.,STOP,PNP,	;++PAGE NOT PRESENT
	POPJ	P,		;RETURN



;SUBROUTINE TO DETERMINE IF THE CURRENT PAGE MUST BE MOVED AND IF SO,
; MOVE IT
PGMOVE:	PUSHJ	P,SAVT##
	LDB	T1,T4
	ANDI	T1,17777
	PUSH	P,T4
	CAIE	T1,(P2)
	PUSHJ	P,PAGMOV
	LDB	T1,(P)
	AND	T1,[-1,,760000]
	IORI	T1,(P2)
IFN FTKL10!FTKS10,<
	HRRZ	T2,M
	MOVSI	T3,(JS.NCS)
	CAIGE	T2,.MCFV/PAGSIZ##
	TDNN	T3,JBTST2##(J)
	CAIA
	TDZ	T1,[PM.CSH]
>
	DPB	T1,(P)
	PUSHJ	P,NEWMAP
	JRST	TPOPJ##
;SUBROUTINE TO FIND THE PAGE A PAGE WAS EXCHED WITH AND FIX THE
; MAP SLOT FOR THAT PAGE
FIXMAP:	PUSH	P,T1		;SAVE NEW PHYSICAL PAGE NUMBER
	SKIPE	T1,P1		;IS THIS FIRST PAGE OF SEGMENT (JOB DATA?)
	MOVEI	T1,(M)		;NO, GET PAGE NUMBER FROM M
FIXMA1:	PUSHJ	P,GTPME##	;GET BYTE POINTER TO SLOT IN PAGE MAP
	JUMPE	T2,FIXMA2	;NO ENTRY? TRY NEXT
	ANDI	T2,17777	;FIND OUT WHICH PHYSICAL PAGE THIS WAS
	CAIE	T2,(P2)		;IS THIS THE PHYSICAL PAGE WE ARE LOOKING FOR?
	JRST	FIXMA2		;NOPE, TRY NEXT ONE.
	LDB	T1,T4		;GET THE PAGE ENTRY
	AND	T1,[-1,,760000]	;WE ONLY WANT HIS FLAGS
	IORI	T1,@(P)		;ADD IN NEW PHYSICAL PAGE NUMBER
	DPB	T1,T4		;AND PUT IT BACK IN THE MAP
	POP	P,T1		;RESTORE..
	PJRST	NEWMAP		;AND CLEAR THE PAGER
FIXMA2:	CAIGE	T1,.UPMVP/PAGSIZ## ;LOOKED AT ALL OF THEM?
	AOJA	T1,FIXMA1	;LOOP OVER NEXT PAGE
	STOPCD	.,STOP,XPW,	;++ EXCHANGED PAGE WENT AWAY

;SUBROUTINE TO FIX UP PAGTAB AFTER EXCHANGING PAGES
;NOTE THAT T3 IS LOADED WITH THE ACTUAL ADDRESS OF AN ENTRY IN PAGTAB,
;AND NOT AN OFFSET INTO PAGTAB.
FIXPTB:	HRL	T2,@[IW MDSEC2,PAGTAB(P2)]
	PUSH	P,T4		;SAVE WHILE WE MANGLE IT
	SSX	T4,MDSEC2	;SECTION PAGTAB IS IN
	SKIPE	P1
	HRRM	P2,PAGTAB(T4)
	POP	P,T4		;GET BACK ORIGINAL CONTENTS
	HRRM	T1,(T3)
	CAIN	P2,(T2)
	HRR	T2,T1
	HRRZM	T2,@[IW MDSEC2,PAGTAB(P2)]
	HLRZS	T2
	CAIN	T2,(T1)
	MOVE	T2,P2
	HRRM	T2,@[IW MDSEC2,PAGTAB(T1)]
	POPJ	P,


SUBTTL ERRCON - ERROR HANDLING CODE

;ROUTINE TO CHECK IF JOB HAS BOTH SEG LOCKED
;CALL:	MOVE	J,JOB NUMBER
;	PUSHJ	P,LOKCHK
;	  BOTH LOCKED - J PRESERVED
;	NEITHER OR ONLY ONE LOCKED - J PRESERVED

LOKCHK::SE1ENT			;JUST TO MARK THAT ALL LOKCON RUNS EXTENDED
	PUSHJ	P,SAVE2##	;SAVE P1-P2
	MOVSI	P1,NSHF!NSWP	;NO SHUFFLING OR SWAPPING BITS
	TDNE	P1,JBTSTS##(J)	;LOW SEG LOCKED?
	POPJ	P,		;YES
	SKIPG	P2,JBTSGN##(J)	;NO, DOES JOB HAVE A HIGH SEG?
	 JRST	CPOPJ1		;NO, THAT MEANS IT CAN'T BE LOCKED
	HRRZS	P2		;CLEAN OUT LEFT HALF SO CAN USE AS INDEX
	TDNN	P1,JBTSTS##(P2)	;HAS HISEG, IS IT LOCKED?
	AOS	(P)		;NEITHER LOCKED, SKIP RETURN
	POPJ	P,
	
;SUBROUTINE TO DETERMINE IF A SEGMENT IS LOCKED IN CONTIGUOUS EXEC
; VIRTUAL MEMORY
;CALLING SEQUENCE:
;	MOVE	J,SEGMENT NUMBER
;	PUSHJ	P,LOKEVC
;	...	RETURN HERE IF SEGMENT IS NOT LOCKED IN EVM
;	...	RETURN HERE IF SEGMENT IS LOCKED IN EVM

LOKEVC::SE1ENT			;HAVE TO LOOK AT PAGTAB
	PUSHJ	P,SAVE2##	;SAVE P1-P2
	LDB	P1,JBYLSA##	;ASSUME A LOW SEGMENT (GET ABSOLUTE PAGE NUMBER OF
				; FIRST PAGE OF THE LOW SEGMENT)
	CAILE	J,JOBMAX##	;IS IT A HIGH SEGMENT
	LDB	P1,JBYHSA##	;YES, GET ABSOLUTE PAGE NUMBER OF FIRST PAGE
				; OF THE HIGH SEGMENT
	MOVSI	P2,LOKEVB	;BIT INDICATING PAGE IS LOCKED IN EVM
	TDNE	P2,@[IW MDSEC2,PAGTAB(P1)] ;IS IT?
				; (IF FIRST PAGE IS LOCKED ALL MUST BE)
	AOS	(P)		;YES
	POPJ	P,		;GIVE LOCKED OR NOT LOCKED RETURN
SUBTTL UUOCON - UUO HANDLING ROUTINES

;ROUTINE TO SET UP CALL TO SWAPPER FOR LOCKING A JOB IN CORE
;CHECKS VALIDITY OF REQUEST AND TRIES TO FIND A PLACE TO PUT THE
;JOB IN CORE.  
;THE CALLING JOB IS PUT AS LOW CORE IN AS
;POSSIBLE. 
;CALLING SEQUENCE
;	PUSHJ	P,LOKJOB
;	ERROR RETURN
;	NORMAL RETURN (NSHF+NSWP SET)


LOKJOB::SE1ENT			;MARK THE FACT THAT LOKCON RUNS EXTENDED
	MOVE	T2,.UPMP+.UPVRT	;VIRTUALOSITY
	SKIPLE	T3,JBTSGN##(J)	; A HIGH SEGMENT?
	TLNE	T3,SHRSEG	;YES, IS IT SHARABLE?
	JRST	[TRNE T1,-1	;YES, LOCKING THE LOW SEGMENT?
		 JUMPN T2,RTZER## ;NOT IMPLEMENTED IF VIRTUAL
		 JRST LOKJO1]	;SEE IF SEGMENT(S) CAN BE LOCKED
	JUMPN	T2,RTZER##	;NOT IMLEMENTED IF VIRTUAL
	TLNE	T1,LKB		;A NON-SHARABLE HIGH SEGMENT
	TRNN	T1,LKB		;ARE BOTH SEGMENTS TO BE LOCKED?
	JRST	RTZER##		;NO, NOT IMPLEMENTED
LOKJO1:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	MOVSI	T1,PVLOCK	;BIT DENOTING PRIVILEDGES TO LOCK
	PUSHJ	P,PRVBIT##	;IS THIS USER A SUFFICIENT WHEEL?
	  SKIPA			;YES, PROCEED
	JRST	ERROR1		;NO, NOT PRIVILEGED ERROR RETURN
LOKJ0Z:	PUSHJ	P,GETTAC##	;RESTORE THE USER'S ARGUMENT

	JUMPL	T1,[PUSHJ P,LOKARG	;JUMP IF NEW STYLE ARGUMENT LIST
		      JRST STOTAC## ;MALFORMED ARGUMENT LIST, GIVE ERROR RETURN
		    JRST .+1]	;CONTINUE PROCESSING
LOKRET:	MOVSI	P1,NSHF!NSWP	;LOCKED BITS
	MOVE	T2,J		;SAVE JOB NUMBER
	MOVEI	T3,0		;ASSUME NO HIGH SEGMENT ADDRESS
	SKIPG	J,JBTSGN##(J)	;GRAB HIGH SEGMENT NUMBER IF ANY
	JRST	LOKJO2		;NO HIGH SEGMENT
	TLO	J,(1B0)		;MAKE THIS AC A VALID INDEX. THIS WORKS SINCE
				;1B0 IS SPYSEG, WHICH NOONE TESTS FURTHER DOWN.
	LDB	T3,JBYHSA##	;PHYSICAL ADDRESS OF HIGH SEGMENT
	TLNE	T1,LKB		;USER LOCKING HIGH SEGMENT?
	TDNN	P1,JBTSTS##(J)	;ALREADY LOCKED?
	JRST	HGHADR		;NO. GET ADDRESS ANYWAY
	MOVE	T4,@[IW MDSEC2,PAGTAB(T3)] ;GET STATUS OF LOCKED SEGMENT
	PUSHJ	P,ARGCK1	;OK TO LOCK AGAIN?
	  JRST	ERROR7		;NOT OK. ARGUMENT IS INCORRECT
IFN FTKL10!FTKS10,<
	TLNE	J,LOKSEG	;ALREADY LOCKED, BUT FOR THIS JOB?
	JRST	HGHADR		;YES, ALREADY LOCKED FOR THIS JOB
>
	MOVSI	T4,LOKSEG	;NO, WELL NOW IT IS
	IORM	T4,JBTSGN##(T2)
IFN FTKL10!FTKS10,<
	PUSHJ	P,CHKCS2	;SET CACHE BIT IN JBTSGN
	PUSHJ	P,MAPHGH##	;COPY CACHE BIT TO UPMP
	JRST	LOKJ0Z		;RESTORE AC'S AND START OVER
>
HGHADR:	TLNN	T1,LKEB		;LOCKED IN EVM?
	LDB	T3,[POINT 9,JBTADR##(J),26] ;YES, PROVIDE EVA TO USER
LOKJO2:	EXCH	J,T2		;J=JOB, T2=HIGH SEGMENT NUMBER
	TRNN	T1,LKB		;LOCK THE LOW SEGMENT?
	JRST	LOKJO3		;NO
	TDNN	P1,JBTSTS##(J)	;IS THE LOW SEGMENT ALREADY LOCKED?
	JRST	LOKJO4		;YES
LOKJO3:	TLNN	T1,LKB		;LOCK THE HIGH SEGMENT?
	JRST	ERROR0		;NO, NOTHING TO DO
	JUMPE	T3,ERROR0	;JUMP IF NO HIGH SEGMENT
	TDNE	P1,JBTSTS##(T2)	;ALREADY LOCKED?
	JRST	ERROR0		;YES, GO CHECK OUT LOW SEGMENT
	HRRZ	J,T2		;SAVE HIGH SEGMENT NUMBER
LOKJO4:	TLZ	T1,-1-<LKB>
	MOVEI	F,0		;INDICATE NO DDB
	PUSHJ	P,CAWAIT##	;YES, WAIT UNTIL ITS DONE
	SETZB	P4,T4		;ZERO LARGEST JOB SEEN SO FAR
	PUSH	P,J		;SAVE J
	MOVEI	J,1		;FIND THE LARGEST JOB NOT LOCKED
LOKJO5:	CAMN	J,.CPJOB##	;DON'T CONSIDER JOB BEING LOCKED
	JRST	LOKJO7
	MOVE	T2,JBTSTS##(J)	;IS THIS JOB LOCKED?
	TLNE	T2,NSHF!NSWP
	TDZA	T2,T2
	PUSHJ	P,SEGSIZ##	;NOT LOCKED, FIND OUT HOW BIG IT IS
	PUSH	P,J		;SAVE LOW SEGMENT NUMBER
	SKIPG	J,JBTSGN##(J)	;DOES IT HAVE A REAL HIGH SEGMENT?
	JRST	LOKJO6		;NO
	HRRZS	J
	MOVSI	P2,NSWP!NSHF
	MOVE	P1,.CPJOB##	;GET OUR JOB #
	HRRZ	P1,JBTSGN##(P1)	;GET OUR HISEG #
	TLNE	T1,LKB		;IF LOCKING OUR HISEG
	CAIE	P1,(J)		;AND HE IS USING IT
	TDNE	P2,JBTSTS##(J)	;OR IT IS ALREADY LOCKED
	JRST	LOKJO6		;THEN IGNORE THIS HISEG
	MOVE	P2,T2		;COUNT THE SIZE OF THE HIGH SEGMENT
	PUSHJ	P,SEGSIZ##
	ADDI	T2,(P2)		;T2_SIZE OF THE JOB
LOKJO6:	LSH	T2,P2WLSH##
	CAMLE	T2,P4		;LARGEST SO FAR?
	MOVE	P4,T2		;YES, SAVE ITS SIZE
	POP	P,J		;RESTORE JOB NUMBER
LOKJO7:	CAMGE	J,HIGHJB##	;LOOKED AT ALL JOBS YET?
	AOJA	J,LOKJO5	;NO
	MOVE	J,(P)
	PUSHJ	P,SEGSIZ##	;SIZE OF THIS SEGMENT IN PAGES
	LSH	T2,P2WLSH##	;SIZE IN WORDS
	HRRI	T1,-1(T2)	;SIZE-1 OF HIGH OR LOW SEGMENT
	TLZE	T1,LKB		;HIGH SEGMENT TO BE LOCKED?
	CAILE	J,JOBMAX##	;LOW SEGMENT ALREADY LOCKED?
	JRST	LOKJO8		;YES, JUST LOCK THE HIGH SEGMENT
	MOVSI	P2,NSHF!NSWP	;HIGH SEGMENT MAY ALREADY BE LOCKED
	SKIPG	P1,JBTSGN##(J)	;DOES THE JOB HAVE A HIGH SEGMENT?
	 JRST	LOKJO8		;NO, DON'T WORRY ABOUT IT.
	HRRZ	T2,P1		;MAKE AN INDEX WITH SEGMENT NUMBER
	TDNE	P2,JBTSTS##(T2)	;IS THE HIGH SEGMENT ALREADY LOCKED?
	JRST	LOKJO8		;NEEDN'T BE CONCERNED ABOUT THE HIGH SEGMENT
	HRLI	P1,(J)		;P1_JOB#,,HIGH SEGMENT#
	MOVEM	P1,(P)		;SAVE IT
	HLRZ	P1,JBTADR##(T2)	;SIZE OF THE HIGH SEGMENT
	ADDI	T1,1(P1)	;ADD IT TO THE TOTAL
LOKJO8:	PUSHJ	P,LRGHOL	;COMPUTE THE NUMBER OF PHYSICAL PAGES AVAILABLE
				; FOR LOCKING
	POP	P,P1		;RESTORE JOB#,,HIGH SEGMENT#
	SUBI	T2,1(T1)	;T2 = AMOUNT OF CORE LEFT IF THIS JOB IS LOCKED
	CAMGE	T2,P4		;WILL ALL EXISTING JOBS BE ABLE TO RUN IN
				; THE AMOUNT OF CORE WHICH WILL REMAIN?
	JRST	ERROR2		;NO, CAN'T LOCK THE JOB
	CAMGE	T2,CORMIN##	;WOULD LOCKING THIS JOB MAKE CORMAX .LT.
				; CORMIN?
	JRST	ERROR3		;YES, TELL THE USER HE LOST
	MOVEM	T2,MAXMAX##	;LARGEST LEGAL CORMAX
	HRRZ	T1,CORLIM##	;UPPER BOUND ON CORMAX
	LSH	T1,P2WLSH##	;CONVERT TO NUMBER OF WORDS MAX
	CAMLE	T1,T2		;NUMBER OF PHYSICAL PAGES WHICH WILL REMAIN
				; AFTER LOCKING .GT. MAX CORMAX?
	MOVE	T1,T2		;YES, NEW CORMAX = NUMBER OF PHYSICAL PAGES
				; LEFT AFTER LOCKING
	MOVEM	T1,CORMAX##	;STORE THE UPDATED VALUE OF CORMAX
	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER
	MOVSI	T1,LOKSEG	;ASSUME THE HIGH SEGMENT IS BEING LOCKED
	CAILE	P1,JOBMAX##	;IS IT?
	IORM	T1,JBTSGN##(J)	;YES, INDICATE HIGH SEGMENT IS LOCKED FOR
				; THIS JOB
	MOVEM	J,LASLOK##	;REMEMBER THE JOB NUMBER OF THE LAST JOB
				; ISSUING A LOCK UUO
	PUSHJ	P,GETTAC##	;RESTORE THE USER'S ARGUMENT
	JUMPL	T1,LOKEXT	;IF NEGATIVE, PROCESS NEW STYLE ARGUMENT LIST
;DISPATCH TO DO VARIOUS TYPES OF LOCK FOR EACH SEGMENT
IFN FTKL10!FTKS10,<
	PUSHJ	P,CHKCSH	;CHECK WHETHER THE CACHE SHOULD BE ON OR OFF
>
	CAIG	P1,JOBMAX##	;IS THE HIGH SEGMENT TO BE LOCKED?
	JRST	LOKJO9		;NO
	TLCE	T1,LKB+LKEB+LKPB;DOES THE USER WANT IT LOCKED IN PLACE?
	TLNE	T1,LKB+LKEB+LKPB; ..
	JRST	LOKJO9		;NO, SOME OTHER VARIETY OF LOCKING
	HRRZ	J,P1		;YES, J = HIGH SEGMENT NUMBER
	PUSHJ	P,LOKINP	;LOCK THE HIGH SEGMENT IN PLACE
	HLRZS	P1		;P1 = LOW SEGMENT NUMBER OR ZERO IF THE
				; LOW SEGMENT ISN'T TO BE LOCKED
	JUMPE	P1,LOKJ17	;JUMP IF LOW SEGMENT ISN'T TO BE LOCKED
LOKJO9:	PUSHJ	P,GETTAC##	;RESTORE THE USER'S ARGUMENT
	TRCE	T1,LKB+LKEB+LKPB;DOES THE USER WANT THE LOW SEGMENT LOCKED
	TRNE	T1,LKB+LKEB+LKPB; IN PLACE?
	JRST	LOKJ10		;NO, TRY SOME OTHER VARITY OF LOCKING
	HRRZ	J,P1		;YES, J = LOW SEGMENT NUMBER
	PUSHJ	P,LOKINP	;LOCK THE LOW SEGMENT IN PLACE
	JRST	LOKJ17		;AND FINISH UP
LOKJ10:	PUSHJ	P,GETTAC##	;RESTORE USER'S ARGUMENT
	MOVEI	T2,0		;ASSUME ONLY THE HIGH SEGMENT IS TO BE LOCKED
	TLNE	P1,-1		;LOCKING BOTH SEGMENT?
	MOVE	T2,[XWD LKPB,LKPB]
	CAIG	P1,JOBMAX##	;LOCKING ONLY THE LOW SEGMENT?
	MOVEI	T2,LKPB		;YES
	SKIPN	T2		;SKIP IF LOCKING ONLY LOW SEGMENT OR BOTH
	MOVSI	T2,LKPB		;LOCKING ONLY THE HIGH SEGMENT
	TDNE	T1,T2		;EITHER SEGMENT TO BE LOCKED PHYSICALLY CONTIGUOUS?
	JRST	LOKJ14		;THE USER DOES NOT REQUIRE PHYSICAL CONTIGUITY,
				; CHECK FOR CONTIGUOUS IN EVM
	PUSHJ	P,LOKPHY	;ATTEMPT TO LOCK THE JOB IN PHYSICALLY CONTIGUOUS
				; MEMORY
	  JRST	ERROR5		;COULDN'T MAKE IT, GIVE THE USER AN ERROR RETURN
	CAIG	P1,JOBMAX##	;LOCKING A HIGH SEGMENT?
	JRST	LOKJ12		;NO, PROCEED
	HLRZ	T3,T1		;YES, T3 = PHYSICAL PAGE NUMBER OF FIRST PAGE OF
				; THE HIGH SEGMENT
	PUSH	P,T1		;SAVE FIRST PAGE OF HIGH SEGMENT,,FIRST
				; PAGE OF LOW SEGMENT
	PUSHJ	P,GETTAC##	;RESTORE THE USER'S ARGUMMENT
	HRRZ	J,P1		;J = HIGH SEGMENT NUMBER
	TLNE	T1,LKEB		;DOES THE USER ALSO REQUIRE THAT THE HIGH
				; SEGMENT BE CONTIGUOUS IN EVM?
	JRST	LOKJ11		;NO, PROCEED
	PUSHJ	P,LKEVC		;IS THE SEGMENT ALSO CONTIGUOUS IN EVM
				; BY VIRTUE OF BEING BELOW 112K?
	  JRST	[POP 	P,T1	;NO, RESTORE ADDRESSES OF SEGMENTS
		TLZ	T1,-1	;INDICATE HIGH SEGMENT NOT ALREADY LOCKED IN EVM
		JRST	LOKJ12]	;SEE ABOUT THE LOW SEGMENT
LOKJ11:	POP	P,T1		;RESTORE THE ADDRESSES OF THE SEGMENTS
	HLRZS	P1		;P1 = LOW SEGMENT NUMBER OR ZERO IF LOW
				; SEGMENT IS NOT TO BE LOCKED
	JUMPE	P1,LOKJ17	;ALL DONE IF LOW SEGMENT IS NOT TO BE LOCKED
LOKJ12:	HRRZ	T3,T1		;T3 = PHYSICAL PAGE NUMBER OF FIRST PAGE OF
				; THE LOW SEGMENT
	PUSH	P,T1		;SAVE ADDRESSES OF THE SEGMENTS
	PUSHJ	P,GETTAC##	;RESTORE THE USER'S ARGUMENT
	HRRZ	J,P1		;J = LOW SEGMENT NUMBER
	CAILE	P1,JOBMAX##	;LOCKING THE HIGH SEGMENT ALSO?
	HLRZ	J,P1		;YES, THEN THE LOW SEGMENT NUMBER IS IN
				; THE LEFT HALF
	JUMPE	J,LOKJ13	;GO IF NOT LOCKING LOWSEG
	TRNE	T1,LKEB		;DOES THE USER REQUIRE THAT THE LOW SEGMENT
				; BE LOCKED IN CONTIGUOUS EVM?
	JRST	LOKJ13		;NO, CONTINUE
	PUSHJ	P,LKEVC		;IS THE LOW SEGMENT ALREADY LOCKED IN
				; CONTIGUOUS EVM BY VIRTUE OF BEING LOCKED
				; IN PHYSICALLY CONTIGUOUS MEMORY BELOW 112K?
	  JRST	[POP	P,T1	;NO, RESTORE SEGMENTS ADDRESSES
		TRZ	T1,-1	;INDICATE THAT THE LOW SEGMENT IS NOT
				; ALREADY CONTIGUOUS IN EVM
		JRST	LOKJ15]	;GO MAKE IT CONTIGUOUS IN EVM
LOKJ13:	POP	P,T1		;YES, RESTORE SEGMENTS ADDRESSES
	CAMN	J,P1		;IS THERE STILL A HIGH SEGMENT TO WORRY ABOUT?
	JRST	LOKJ17		;NO, FINISH UP
	JRST	LOKJ15		;YES
LOKJ14:	MOVEI	T1,0		;INDICATE THAT NEITHER SEGMENT IS ALREADY
				; LOCKED IN EVM
LOKJ15:	MOVE	P2,T1		;P2 = SEGMENTS ADDRESSES IF LOCKED ALREADY
	PUSHJ	P,GETTAC##	;RESTORE THE USER'S ARGUMENT
	TDCE	T1,[XWD LKEB,LKEB]
	TDNE	T1,[XWD LKEB,LKEB]
	SKIPA			;THE USER WANTS ONE OR BOTH SEGMENTS
				; LOCKED IN CONTIGUOUS EXEC VIRTUAL MEMORY
	JRST	LOKJ17		;ALL DONE
	PUSHJ	P,GETTAC##	;RESTORE USER'S ARGUMENT
	EXCH	T1,P2		;T1 REFLECTS THE PROGRESS SO FAR
	CAILE	P1,JOBMAX##	;LOCKING ONLY THE LOW SEGMENT?
	TLNE	T1,-1		;NO, IS THE HIGH SEGMENT ALREADY LOCKED?
	JRST	LOKJ16		;GO CHECK THE LOW SEGMENT
	TLNE	P2,LKEB		;LOCK THE HIGH SEGMENT VIRTUALLY CONTIGUOUS?
	JRST	LOKJ16		;NO
	PUSH	P,T1		;SAVE THE ADDRESS OF THE LOW SEGMENT
	HRRZ	J,P1		;J = THE HIGH SEGMENT NUMBER
	PUSHJ	P,LOKEVM	;ATTEMPT TO LOCK THE HIGH SEGMENT IN EVM
	  JRST	ERROR4		;NOT ENOUGH EVM
	HRLM	T1,(P)		;STORE THE EVA OF THE HIGH SEGMENT
	POP	P,T1		;RESTORE THE ADDRESSES OF THE SEGMENTS
	HLRZS	P1		;P1 = LOW SEGMENT NUMBER OF LOW SEGMENT IS
				; TO BE LOCKED
	JUMPE	P1,LOKJ17	;ALL DONE IF NOT LOCKING LOW SEGMENT
LOKJ16:	TRNN	P2,LKEB		;LOCK THE LOW SEGMENT VIRTUALLY CONTIGUOUS?
	TRNE	T1,-1		;YES, IS THE LOW SEGMENT ALREADY LOCKED IN EVM?
	JRST	LOKJ17		;YES, FINISH UP
	PUSH	P,T1		;SAVE THE ADDRESSES OF THE SEGMENTS
	MOVE	J,.CPJOB##	;J = LOW SEGMENT NUMBER
	PUSHJ	P,LOKEVM	;ATTEMPT TO LOCK THE LOW SEGMENT IN EVM
	  JRST	ERROR4		;NOT ENOUGH EVM
	HRRM	T1,(P)		;STORE THE EVA OF THE LOW SEGMENT
	POP	P,T1		;RESTORE THE ADDRESSES OF THE SEGMENTS
LOKJ17:	PUSHJ	P,CAFREE##	;RETURN THE LOCK RESOURCE
	S0PSHJ	SETRLH##
	PUSHJ	P,GETTAC##
	JUMPGE	T1,LOKRET	;GO IF NO LOCK EXTENSION
	PUSHJ	P,RASBAD	;GET PHYSICAL PAGE NUMBER
	  JFCL			;RASBAD SKIPS
	PJRST	STOTC1##	;STORE ANSWER, SKIP RETURN
;SUBROUTINE TO LOCK A SEGMENT IN PLACE
;CALLING SEQUENCE:
;	MOVE	J,SEGMENT NUMBER OF SEGMENT TO BE LOCKED IN PLACE
;	PUSHJ	P,LOKINP
;RETURN HERE, SEGMENT IS LOCKED IN PLACE

LOKINP:	MOVEI	T3,LOKIPB	;BIT INDICATING PAGE IS LOCKED IN PLACE
	PUSHJ	P,LOKBTS	;TURN IT ON FOR EVERY PAGE IN THE SEGMENT
	MOVEI	T1,0		;ADDRESS WHERE SEGMENT IS LOCKED IS ZERO
				; SINCE NOTHING ELSE IS MEANINGFUL
	POPJ	P,		;RETURN

LOKARG:	HRRI	M,(T1)		;POINT AT USER'S ARGUMENT LIST
	HLRE	T2,T1		;- LENGTH OF THE ARGUMENT LIST
	CAME	T2,[-2]		;MUST BE EXACTLY 2 WORDS LONG
	JRST	LOKAR1		;BAD ARGUMENT LIST
	PUSHJ	P,GETWDU##	;GET THE FIRST ARGUMENT (FUNCTION)
	JUMPL	T1,LOKAR1	;CAN'T BE NEGATIVE
	CAIL	T1,MXLFCN	;IS IT A LEGAL FUNCTION?
	JRST	LOKAR1		;NO, BAD ARGUMENT LIST
	ROT	T1,-1		;DIVIDE BY 2, SAVE THE REMAINDER IN HIGH BIT
	SKIPGE	T1		;SKIP IF AN EVEN FUNCTION
	SKIPA	T1,LOKFCN(T1)	;ODD FUNCTION, GET DISPATCH ADDRESS
	MOVS	T1,LOKFCN(T1)	;EVEN FUNCTION, GET DISPATCH ADDRESS
	TRNN	T1,-1		;IMPLIMENTED FUNCTION?
	JRST	LOKAR1		;NO, GIVE BAD ARGUMENT LIST RETURN
	AOS	(P)		;SET FOR GOOD RETURN
	HRRZS	T1		;CLEAR LEFT-HALF BITS, SO WE DON'T JRST BOONIES
	JRST	(T1)		;DISPATCH TO THE FUNCTION PROCESSOR
LOKAR1:	MOVEI	T1,LKERR5	;BAD ARGUMENT LIST ERROR CODE
	POPJ	P,		;NON-SKIP RETURN TO CALLER

LOKFCN:	LOKHPH,,0
MXLFCN==2*<.-LOKFCN>

LOKHPH:	PUSHJ	P,GETWD1##	;GET THE SECOND WORD OF THE ARGUMENT LIST
	TLZE	T1,-1		;LOCK THE HIGH SEGMENT AT A SPECIFIED ADDRESS?
	TLO	T1,LKB		;YES, INDICATE HIGH SEGMENT TO BE LOCKED
	TRZE	T1,-1		;LOCK THE LOW SEGMENT AT A SPECIFIED ADDRESS?
	TRO	T1,LKB		;YES, INDICATE LOW SEGMENT TO BE LOCKED
	POPJ	P,		;AND RETURN
;SUBROUTINE TO LOCK A SEGMENT CONTIGUOUSLY IN EXEC VIRTUAL MEMORY
;CALLING SEQUENCE:
;	MOVE	J,SEGMENT NUMBER OF SEGMENT TO BE LOCKED IN EVM
;	PUSHJ	P,LOKEVM
;RETURN HERE IF NOT ENOUGH EVM TO LOCK THE SEGMENT
;RETURN HERE, SEGMENT IS LOCKED IN EVM - T1 = EV PAGE NUMBER OF SEGMENT

LOKEVM:	LDB	T1,IMGIN##	;SIZE OF THE SEGMENT
	PUSH	P,T1		;SAVE THAT
	CAIG	J,JOBMAX##	;A LOW SEGMENT?
	ADDI	T1,UPMPSZ##	;YES, UPMP MUST BE MAPPED TOO
	MOVEI	T2,EVMPTR##	;POINT TO BIT MAP OF SLOTS IN THE EXEC MAP
				; USED FOR LOCKING IN EVM
	MOVE	T3,T1		;AMOUNT OF EVM NEEDED
	ADD	T3,.C0EVU##	;AMOUNT ALREADY IN USE
	CAMG	T3,.C0EVM##	;GREATER THAN TOTAL AVAILABLE?
	PUSHJ	P,GETBIT##	;GET, SET BITS IN THE EVL TABLE
	  PJRST	TPOPJ##		;NOT ENOUGH SLOTS AVAILABLE
	MOVEI	T1,400(T1)	;MAKE RELATIVE LOCATION IN THE MAP INTO PAGE NUMBER
	MOVE	T2,(P)		;NUMBER OF PAGES IN THIS SEGMENT
	CAIG	J,JOBMAX##
	ADDI	T2,UPMPSZ##
	ADDM	T2,.C0EVU##	;COUNT EVM IN USE FOR LOCKING
	CAILE	J,JOBMAX##	;LOW SEG?
	JRST	LOKEV1		;NO
	POP	P,T2
	PUSHJ	P,SAVE4##
	DMOVE	P1,T1
	ADDI	T1,UPMPSZ##
	PUSH	P,T1
	PUSH	P,M
	LSH	T1,P2WLSH##
	HRRM	T1,JBTADR##(J)
	MOVEI	P4,-PAGSIZ##(T1)
	MOVE	P3,.CPMAP##
IFE FTKLP,<
	ROT	P1,-1
	TLZN	P1,400000
	TLOA	P1,(POINT 18,(P3),17)
	TLO	P1,(POINT 18,(P3),35)
	HLRZ	T3,.UPMP+.MUPMP
>
IFN FTKLP,<
	HRLI	P1,(POINT 36,(P3),35)
	MOVE	T3,.UPMP+.UPMP/PAGSIZ##
>
	DPB	T3,P1
IFN FTMP,<
	PUSHJ	P,MAPUC##
>
	PUSHJ	P,NXTWSB##
	CAIA
LOKEV0:	PUSHJ	P,NXTWS2##
	PUSHJ	P,FPNSHS
	PUSH	P,T3
	LDB	T3,T4
IFN FTKL10!FTKS10,<
	TDZ	T3,[PM.CSH]
	DPB	T3,T4
>
	TDZ	T3,[PM.PUB]	;MAKE SURE CONCEALED
	IDPB	T3,P1
IFN FTMP,<
	PUSHJ	P,MAPUC##
>
	POP	P,T3
	SOJG	P2,LOKEV0
	POP	P,M
	JRST	LOKEV2
LOKEV1:	MOVE	T3,T1		;SAVE STARTING PAGE IN THE EXEC MAP
	PUSH	P,J		;SAVE HIGH SEGMENT NUMBER
	MOVE	J,.CPJOB##	;JOB NUMBER
	PUSHJ	P,HSVAD##	;COMPUTE STARTING VIRTUAL ADDRESS OF THE HIGH SEGMENT
	POP	P,J
	MOVE	T1,T3		;RESTORE T1
	MOVE	T3,T2		;T3=VIRTUAL ADDRESS OF HIGH SEGMENT
	MOVE	T2,(P)		;NUMBER OF PAGES TO MAP IN THE EXEC MAP
IFN FTMP,<
	PUSH	P,T3		;SAVE UVA
>
	S0PSHJ	MAPUEV##	;COPY THE USER'S MAP INTO THE EXEC MAP
	HRRM	T3,JBTADR##(J)	;STORE THE EVA OF THIS SEGMENT
IFN FTMP,<
	POP	P,T3		;RESTORE UVA
>
	MOVE	T2,T1		;T2=EXEC VIRTUAL PAGE NUMBER OF THE SEGMENT
	EXCH	T2,(P)		;SAVE THAT, RESTORE NUMBER OF PAGES TO BE MAPPED
IFN FTMP,<
	S0PSHJ	MAPUEC##	;COPY USER'S MAP TO CPU1'S MAP
>
LOKEV2:	MOVEI	T3,LOKEVB	;BIT INDICATING PAGE IS LOCKED IN EVM
	PUSHJ	P,LOKBTS	;TURN IT ON FOR EACH PAGE IN THE SEGMENT
	PUSHJ	P,CONEVA	;COMPLETE LARGEST HOLE IN EVM
IFN FTKL10!FTKS10,<
	PUSHJ	P,CSDMP##
	MOVE	T1,.CPJOB##
	MOVSI	T2,(JS.NCS)
	IORM	T2,JBTST2##(T1)
>
	PJRST	TPOPJ1##	;RESTORE EV PAGE NUMBER AND GIVE SUCCESS RETURN

LOKEXT:	HRRI	M,(T1)		;POINT M AT THE USER'S ARGUMENT LIST
IFE FTKL10!FTKS10,<
	PUSHJ	P,GETWD1##	;GET THE SECOND WORD OF THE ARGUMENT LIST
>
IFN FTKL10!FTKS10,<
	PUSHJ	P,LOKHPH	;GET THE USER'S FIRST ARGUMENT
	PUSHJ	P,CHKCSH	;SEE IF CACHE SHOULD BE OFF OR ON
	PUSHJ	P,GETWDU##
>
;HERE WITH T1= WHERE HIGH SEGMENT IS TO BE LOCKED,,WHERE LOW SEGMENT
; IS TO BE LOCKED, P1= LOW SEGMENT NUMBER,,HIGH SEGMENT NUMBER
	MOVE	P2,T1		;SAVE WHERE,,WHERE
	SETZM	LOKREL##	;INITIALIZE FOR IORM
	TLNN	P1,-1		;LOCKING BOTH SEGMENTS?
	JRST	LKSPH2		;NO
	HLRZ	T2,T1		;WHERE THE HIGH SEGMENT IS TO BE LOCKED
	HRRZ	T3,T1		;WHERE THE LOW SEGMENT IS TO BE LOCKED
	LDB	T4,PCORSZ##	;HIGHEST PAGE IN THE LOW SEGMENT
	ADDI	T4,1+UPMPSZ##(T3)
	CAIL	T2,(T3)		;IF LOCKED AS REQUESTED,
	CAIL	T2,(T4)		; WILL THE HIGH AND LOW SEGMENTS OVERLAP?
	CAIA			;NO
	JRST	ERROR6		;YES, ERROR RETURN
	LDB	T4,[POINT 9,JBTADR##(P1),8]
	ADDI	T4,1(T2)	;TOP PAGE IN HIGH SEGMENT AFTER LOCKING
	CAIL	T3,(T2)		;IF LOCKED AS REQUESTED,
	CAIL	T3,(T4)		; WILL THE HIGH AND LOW SEGMENTS OVERLAP?
	JRST	LKSPH2		;NO, ALL IS WELL SO FAR
	JRST	ERROR6
LKSPH2:	HLRZ	J,P1		;LOW SEGMENT NUMBER IF LOCKING BOTH SEGMENTS
	CAIG	P1,JOBMAX##	;LOCKING BOTH SEGMENTS OR JUST THE HIGH SEGMENT?
	JRST	[HRRZ J,P1	;NO, ONLY LOCKING THE LOW SEGMENT
		 JRST LKSPH3]
	HLRZS	T1		;WHERE THE HIGH SEGMENT IS TO BE LOCKED
	HRRZ	J,P1		;HIGH SEGMENT NUMBER
	PUSHJ	P,PHYPF		;ARE THE PAGES AVAILABLE FOR LOCKING?
	  JRST	ERROR6		;NO, ERROR RETURN
	HRRZM	T1,LOKREL##	;STORE WHERE THE HIGH SEGMENT IS TO BE LOCKED
	HLRZ	J,P1		;LOW SEGMENT NUMBER IF LOCKING THE LOW SEGMENT
	JUMPE	J,LKSPH4	;ALL DONE IF NOT LOCKING THE LOW SEGMENT
LKSPH3:	HRRZ	T1,P2		;WHERE THE LOW SEGMENT IS TO BE LOCKED
	PUSHJ	P,PHYPF		;SEE IF THOSE PAGES ARE AVAILABLE FOR LOCKING
	  JRST	ERROR6		;NOT, LOSE
	SKIPE	LOKREL##	;HIGH SEGMENT TO BE LOCKED?
	HRLZS	T1		;YES, PAGE NUMBER TO THE LEFT HALF WORD
	IORM	T1,LOKREL##	;WHERE LOW,,WHERE HIGH
LKSPH4:	MOVE	J,.CPJOB##	;CURRENT JOB NUMBER
	PUSHJ	P,LOCKIT	;LOCK THE SEGMENTS REQUESTED WHERE REQUESTED
	  JFCL			;CAN'T HAPPEN
	JRST	LOKJ17		;GIVE JOB LOCKED RETURN
;SUBROUTINE TO DETERMINE IF A SEGMENT CAN BE LOCKED IN A SPECIFIC
; PLACE IN PHYSICAL MEMORY. I.E., DETERMINE THAT THE PAGES REQUIRED ARE
; EXISTANT, NOT LOCKED, AND NOT PART OF THE MONITOR.
;CALLING SEQUENCE:
;	MOVE	T1,STARTING PHYSICAL PAGE #
;	MOVE	J,SEGMENT #
;	PUSHJ	P,PHYPF
;RETURN CPOPJ, T1=LKERR6 IF THE PAGES ARE NOT AVAILABLE
; CPOPJ1 IF THEY ARE, T1 PRESERVED

PHYPF:	LDB	T2,[POINT 9,SYSSIZ##,26]
	LDB	T3,[POINT 14,MEMSIZ##,26]
	CAIL	T1,(T2)		;ABOVE THE MONITOR?
	CAIL	T1,(T3)		;AND BELOW THE TOP OF MEMORY?
	POPJ	P,		;NO, LOSE
	LDB	T2,PCORSZ##	;HIGHEST PAGE IN THE SEGMENT
	ADDI	T2,1		;NUMBER OF PAGES IN THE SEGMENT
	CAIG	J,JOBMAX##	;IF A LOW SEGMENT,
	ADDI	T2,UPMPSZ##	;ACCOUNT FOR THE LOW SEGMENT SIZE
	MOVE	T3,T1		;STARTING PAGE FOR LOCKING THE SEGMENT
IFN FTMP,<
	PUSHJ	P,GGVMM##	;MUST HAVE THE MM RESOURCE WHILE LOOKING AT PAGTAB
>
PHYPF1:	MOVE	T4,@[IW MDSEC2,PAGTAB(T3)] ;PAGTAB ENTRY REPRESENTING
				; THIS PHYSICAL PAGE
	TLNE	T4,LKBITS	;LOCKED OR NON-EXISTANT PAGE?
	POPJ	P,		;YES, LOSE
	SOSE	T2		;LOOKED AT ALL THE PAGES REQUIRED TO LOCK THE SEGMENT?
	AOJA	T3,PHYPF1	;NO, CHECK THE NEXT PHYSICAL PAGE
	JRST	CPOPJ1##	;YES, ALL PAGES ARE FREEABLE SO SKIP RETURN
;SUBROUTINE TO LOCK A JOB (ONE OR BOTH SEGMENTS) IN CONTIGUOUS
; PHYSICAL MEMORY
;CALLING SEQUENCE:
;	MOVE	P1,0,,LOW SEGMENT NUMBER IF LOCKING ONLY LOW SEGMENT, OR
;	MOVE	P1,0,,HIGH SEGMENT NUMBER IF LOCKING ONLY HIGH SEGMENT, OR
;	MOVE	P1,LOW SEGMENT NUMBER,,HIGH SEGMENT NUMBER IF LOCKING BOTH
;	PUSHJ	P,LOKPHY
;RETURN HERE IF NO HOLE IN PHYSICAL MEMORY IS BIG ENOUGH
;RETURN HERE, REQUESTED SEGMENTS ARE LOCKED IN CONTIGUOUS PHYSICAL MEMORY

LOKPHY:	HRRZ	T2,P1		;MAKE A USABLE INDEX
	MOVE	T2,JBTSTS##(T2)	;HIGH SEGMENT STATUS IF LOCKING THE HIGH SEGMENT
	CAILE	P1,JOBMAX##	;LOCKING THE HIGH SEGMENT?
	TLNE	T2,SHRSEG	;YES, IS IT SHARABLE?
	CAIA			;YES
	HLRZS	P1		;NO, LOCK LOW AND HIGH SEGMENT ALL AT ONCE
	HLRZ	J,P1		;LOW SEGMENT NUMBER (OR ZERO)
	LDB	T1,IMGIN##	;SIZE OF THE LOW SEGMENT (OR ZERO)
	LDB	T2,NFYPGS##	;NUMBER OF FUNNY PAGES (OR ZERO)
	ADD	T1,T2		;TOTAL
	HRRZ	J,P1		;HISEG NUMBER (OR MAYBE LOWSEG)
	LDB	T2,IMGIN##	;SIZE OF IT
	ADD	T1,T2		;TOTAL
	LDB	T2,NFYPGS##	;NUMBER OF FUNNY PAGES (IF IT'S A LOWSEG)
	CAIG	J,JOBMAX##	;IS IT A LOWSEG?
	ADD	T1,T2		;YES, COUNT THAT TOO
	MOVE	T2,SYSSIZ##	;LOOK FOR A PLACE TO LOCK IT STARTING AT
				; THE TOP OF THE MONITOR
	LSH	T2,W2PLSH##	;CONVERT SYSSIZ TO PAGES
	MOVE	T3,MEMSIZ##	;LOOK THROUGH ALL OF USER CORE
	LSH	T3,W2PLSH##	; A PAGE AT A TIME
IFN FTMP,<
	PUSHJ	P,UPMM##	;MUST HAVE THE MM RESOURCE WHEN SCANNING PAGTAB
>
LOKPH1:	TDZA	T4,T4		;LARGEST HOLE SEEN SO FAR
LOKPH2:	ADDI	T4,1		;INCREMENT SIZE OF LARGEST HOLE
	CAIN	T3,(T2)		;LOOKED AT ALL OR CORE?
	JRST	LOKPH4		;YES, SEE IF A BIG ENOUGH HOLE WAS FOUND
	MOVE	S,@[IW MDSEC2,PAGTAB(T2)] ;STATUS OF THIS PAGE
	TLNN	S,LKBITS	;IS IT LOCKED OR NON-EXISTANT?
	AOJA	T2,LOKPH2	;NO, COUNT IT IN THIS HOLE
	CAMG	T4,T1		;IS THIS HOLE BIG ENOUGH?
	AOJA	T2,LOKPH1	;NO, LOOK HIGHER UP
LOKPH4:
IFN FTMP,<
	PUSHJ	P,DWNMM##	;NOW, SAFELY GIVE UP MM RESOURCE
>
	CAMG	T4,T1		;IS THE HOLE FOUND BIG ENOUGH?
	POPJ	P,		;NO, ERROR RETURN
	SUBI	T2,(T4)		;STARTING PAGE NUMBER OF THE HOLE
	HRRZM	T2,LOKREL##	;SAVE THAT FOR LOCK
	HRRZ	J,P1		;SIZE OF THE FIRST SEGMENT TO BE LOCKED
	LDB	T1,IMGIN##
	CAIG	P1,JOBMAX##	;LOCKING HIGH SEGMENT?
	ADDI	T1,UPMPSZ##	;NO, ACCOUNT FOR THE UPMP
	ADD	T1,LOKREL##	;STORE THAT FOR LOCK
	TLNE	P1,-1		;LOCKING BOTH SEGMENTS?
	HRLM	T1,LOKREL##	;WHERE TO LOCK THE OTHER SEGMENT
LOCKIT:	MOVEM	P1,LOCK##	;STORE SEGMENT NUMBERS FOR LOCK
	MOVE	J,.CPJOB##
	MOVEI	T1,LOK		;MAKE THE JOB UNRUNNABLE UNTIL LOCKING
	IORM	T1,JBTSTS##(J)	; IS COMPLETE
	PUSHJ	P,WSCHED##	;RESCHEDULE, RETURN WHEN JOB IS LOCKED
RASBAD:	LDB	T1,JBYLSA##	;STARTING PAGE NUMBER OF THE LOW SEGMENT
	SKIPG	J,JBTSGN##(J)	;JOB HAVE A REAL HIGH SEGMENT?
	 PJRST	CPOPJ1##	;NO HISEG, GIVE LOCKED RETURN (T1 = LOSEG ADDR)
	TLO	J,(1B0)		;MAKE J A REASONABLE INDEX
	LDB	T2,JBYHSA##	;STARTING PAGE NUMBER OF THE HIGH SEGMENT
	HRL	T1,T2		;HIGH SEGMENT ADDRESS,,LOW SEGMENT ADDRESS
	PJRST	CPOPJ1##	;AND GIVE LOCKED RETURN
;
;ROUTINE TO FREE CORE GIVEN UP BY A LOCKED JOB
;CALLED FROM UUOCON ON RESET UUO FROM USER OR
;ON A CALL TO RESET FROM COMCON
;ALSO CALLED FROM KILHGH IN SEGCON
;

UNLOKH::SE1ENT			;LOKCON ALWAYS RUNS EXTENDED
	MOVE	J,-2(P)		;GET JOB NUMBER
	MOVSI	T1,LKB		;UNLOCK THE HIGH SEGMENT
	JRST	UNLO00		;UNLOCK IT IF NOT LOCKED FOR SOME OTHER JOB
UNLOK.::SE1ENT			;RUN THIS EXTENDED.
	TDCN	T1,[LKB,,LKB]	;NOT UNLOCKING ANYTHING?
	JRST	CPOPJ1##	;YES, ALWAYS LEGAL
	TDCE	T1,[LKB,,LKB]	;YES, UNLOCKING BOTH SEGMENTS?
	SKIPG	T2,JBTSGN##(J)	;REAL HIGH SEG?
	JRST	UNLOK1		;NO HIGH SEGMENT OR UNLOCKING BOTH
	TLNE	T2,SHRSEG	;HIGH SEGMENT SHARABLE?
	JRST	UNLOK1		;YES, PROCEED TO UNLOCK
	TLNN	T2,LOKSEG+IFN FTKL10!FTKS10,<NCSH> ;NO, IS IT ACTUALLY LOCKED?
	JRST	CPOPJ1##	;NO, NOT REALLY LOCKED
				;(WE CAN RETURN SUCCESSFULLY BECAUSE TH
				;LOW SEGMENT CANNOT BE LOCKED IN THIS CASE.)
	POPJ	P,		;YES, CANNOT UNLOCK ONLY ONE SEGMENT
UNLOK1:	AOSA	(P)		;GIVE SKIP RETURN
UNLOCK::MOVE	T1,[XWD LKB,LKB];UNLOCK BOTH LOW AND HIGH SEGMENTS
UNLO00:	SE1ENT			;CALL COROUTINE PUSHING ACS ON STACK
	PUSHJ	P,SAVE4##	;PRESERVE ACCUMULATORS
	PUSH	P,T1		;SAVE ARGUMENT WHILE UNLOCKING
ZZ==.				;PLACE ON STACK FOR ARGUMENT (T1)
	PUSH	P,J		;SAVE JOB NUMBER
ZZ==.-ZZ			;DEPTH ON STACK FOR ARGUMENT (T1)
	MOVSI	P4,NSHF!NSWP
	MOVEI	J,(J)		;CLEAR POSSIBLE LEFT HALF BITS
	CAILE	J,JOBMAX##	;IS THIS A HIGH SEGMENT?
	JRST	UNLO04		;YES IF CALLED FROM SEGCON OR LOKINI
	TRNE	T1,LKB		;UNLOCK THE LOW SEGMENT?
	TDNN	P4,JBTSTS##(J)	;IS IT LOCKED?
	JRST	UNLO01		;NO
IFN FTRTTRP,<
	S0PSHJ	RTREL##		;RESET REAL TIME
>
	PUSHJ	P,FRELOK	;UNLOCK THE LOW SEGMENT
IFN FTKL10!FTKS10,<
	MOVSI	P2,(JS.NCS)	;DON'T CACHE BIT
	TDNE	P2,JBTST2##(J)
	PUSHJ	P,CSHLSG
	ANDCAM	P2,JBTST2##(J)	;TURN THE CACHE ON AGAIN
>
	MOVE	T1,-ZZ(P)	;RESTORE ARGUMENT
	HRROS	-ZZ(P)		;FLAG THAT CORE HAS CHANGED (SO CALL LRGHOL)
UNLO01:	TLNN	T1,LKB		;UNLOCK THE HIGH SEGMENT?
	JRST	UNLO05		;NO
	MOVSI	P2,LOKSEG+IFN FTKL10!FTKS10,<NCSH>
	SKIPLE	P3,JBTSGN##(J)	;DOES THE JOB HAVE A REAL HIGH SEGMENT
	TDNN	P2,JBTSGN##(J)	;AND IS IT LOCKED
	JRST	UNLO05		;NO
	ANDCAM	P2,JBTSGN##(J)	;TURN OFF HIGH SEGMENT LOCKED FOR THIS JOB
IFN FTKL10!FTKS10,<
	S0PSHJ	MAPHGH##	;TURN ON CACHE BITS IN THE MAP
>
	MOVE	T1,HIGHJB##	;IS ANOTHER JOB SHARING THE HIGH SEGMENT?
UNLO02:	SKIPG	JBTSGN##(T1)	;A REAL HIGH SEGMENT?
	JRST	UNLO03		;NO
	HRRZ	P1,JBTSGN##(T1)
	CAME	T1,(P)		;CURRENT JOB?
	CAIE	P1,(P3)		;SAME HIGH SEGMENT?
	JRST	UNLO03		;THIS SEGENT DOESN'T STOP UNLOCKING
	TDNE	P2,JBTSGN##(T1)	;IS THE LOW SEGMENT SHARING LOCKED?
	JRST	UNLO05		;YES, CAN'T UNLOCK THE HIGH SEGMENT
UNLO03:	SOJG	T1,UNLO02
	HRRZ	J,P3
UNLO04:	TDNN	P4,JBTSTS##(J)	;IS HIGH SEGMENT LOCKED?
	JRST	UNLO05		;NO, DO NOT UNLOCK HIGH SEGMENT
	HRROS	-ZZ(P)		;YES, FLAG FACT THAT A SEGMENT HAS
				; BEEN UNLOCKED
	PUSHJ	P,FRELOK	;NO OTHER LOCKED JOB SHARING, UNLOCK IT
UNLO05:	HRRZ	J,(P)		;GET INDEX INTO JOB TABLES
	MOVE	R,JBTADR##(J)	;RESTORE R
	POP	P,J		;RESTORE JOB NUMBER
	POP	P,T1		;HAS CORE CHANGED?
	JUMPGE	T1,CPOPJ##	;NO, REMOVE ARGUMENT AND RETURN
;FALL INTO COMLIM
;SUBROUTINE TO RECOMPUTE CORMAX AND MAXMAX
COMLIM:	PUSHJ	P,LRGHOL	;SET EXTENT OF THE LARGEST HOLE
	MOVEM	T2,MAXMAX##	;LARGEST LEGAL CORMAX
	SUBI	T2,NWMCP+IFN FTKLP,<PAGSIZ##>	;ACCOUNT FOR FUNNY SPACE
	HRRZ	P1,CORLIM##	;AND ADJUST CORMAX
	ASH	P1,P2WLSH##
	CAMLE	P1,T2		;TO CORLIM OR SIZE OF HOLE
	MOVE	P1,T2		;WHICH EVER IS SMALLER
	MOVEM	P1,CORMAX##
	POPJ	P,		;RETURN
FRELOK:
IFN FTMETR,<			;RELEASE ANY METER POINTS EFFECTED
	S0PSHJ	METREL##
>
	ANDCAM	P4,JBTSTS##(J)	;TURN OFF NSHF AND NSWP
	LDB	T1,JBYLSA##	;PAGE NUMBER OF FIRST PAGE OF THE LOW SEGMENT
	CAILE	J,JOBMAX##	;IS IT A HIGH SEGMENT?
	LDB	T1,JBYHSA##	;PAGE NUMBER OF FIRST PAGE OF THE HIGH SEGMENT
	MOVSI	T2,LOKEVB	;BIT INDICATING LOCKED IN EVM
	TDNN	T2,@[IW MDSEC2,PAGTAB(T1)] ;IS IT?
	JRST	FRELK2		;NO, PROCEED
	HRRZ	T3,JBTADR##(J)	;EVA OF THIS SEGMENT
	LSH	T3,W2PLSH##	;CONVERT TO PAGE NUMBER
	PUSHJ	P,LKEVA		;IS THIS SEGMENT LOCKED IN EVM BY VIRTUE
				; OF BEING BELOW 112K?
	  CAIA			;NO
	JRST	FRELK2		;YES, DON'T NEED TO RETURN EVM
	PUSH	P,T1		;SAVE STARTING PAGE NUMBER
	LDB	T1,IMGIN##
	SUBI	T3,400		;CONVERT TO RELATIVE PAGE WITHIN EXEC MAP
	CAILE	J,JOBMAX##	;A LOW SEGMENT?
	JRST	[PUSHJ P,SEGSIZ##
		 MOVE T1,T2
		 JRST FRELK1]	;NO, SKIP ON
	ADDI	T1,UPMPSZ##	;YES ACCOUNT FOR THE MAP
	SUBI	T3,UPMPSZ##	; WHICH IS ALSO MAPPED
FRELK1:	MOVN	T4,T1		;GET THE NUMBER OF PAGES IN SEGMENT
	ADDM	T4,.C0EVU##	;AND INDICATE THAT EVM IS NO LONGER USED
	MOVE	T2,EVMPTR##	;AOBJN POINTER FOR RETURNING SLOTS
	S0PSHJ	ZERBTS##	;RETURN EVM
	PUSHJ	P,CONEVA
	POP	P,T1		;RESTORE STARTING PAGE NUMBER
FRELK2:	MOVE	R,JBTADR##(J)	;EVA OF SEGMENT
	HRRI	R,.VJDT		;ASSUME ITS A HIGH SEGMENT
	CAILE	J,JOBMAX##	;IS IT?
	JRST	FRELK3		;YES
	HRRI	R,.JDAT		;ITS A LOW SEGMENT - EVA OF THE JOB DATA AREA
	MOVEM	R,.CPADR##	;RESET SOFTWARE RELOCATION INFO
	HRRZ	T3,P		;DIDDLE THE PUSH DOWN LIST POINTER
	MOVEI	T2,PDLPNO##	;PAGE NUMBER (EVA) OF THE PUSH DOWN LIST
	CAMLE	T3,SYSSIZ##	;IS THE PUSH DOWN LIST IN THE MONITOR?
	DPB	T2,[POINT 9,P,26];NO, AJUST RELOCATION
FRELK3:	MOVEM	R,JBTADR##(J)	;UPDATE JBTADR
FRELK4:	MOVSI	T2,LKBITS	;BITS INDICATING A PAGE IS LOCKED
	ANDCAB	T2,@[IW MDSEC2,PAGTAB(T1)] ;CLEAR THEM
	HRRZ	T1,T2		;NEXT PAGE IN THE SEGMENT
	JUMPN	T1,FRELK4	;LOOP IF MORE PAGES IN THE SEGMENT
	CAILE	J,JOBMAX##	;IS THIS A LOW SEGMENT?
	POPJ	P,		;NO, RETURN
	HRRZ	T1,JBTUPM##(J)	;YES, UNLOCK THE UPMP
	MOVSI	T2,LKBITS	;BITS INDICATING PAGES IS LOCKED
	ANDCAM	T2,@[IW MDSEC2,PAGTAB(T1)] ;CLEAR THEM FOR THE UPMP
IFN FTKLP,<
	HRRZ	T1,@[IW MDSEC2,PAGTAB(T1)] ;GET THE MAP PAGE TOO.
	ANDCAM	T2,@[IW MDSEC2,PAGTAB(T1)] 
>
	POPJ	P,		;AND RETURN
IFN FTMOFFL,<
;SUBROUTINE TO DETERMINE IF A RANGE OF MEMORY OVERLAPS LOCKED JOBS
; AND IF SO, RETURN ALL THE JOBS WHICH OVERLAP THE RANGE
CKLJB::	SE1ENT			;NEED TO BE EXTENDED TO LOOK AT PAGTAB
	ADDI	J,1		;NEXT JOB
	CAMLE	J,HIGHJB##	;UP TO THE HIGHEST JOB IN THE SYSTEM?
	POPJ	P,		;YES, ALL DONE
	MOVE	T3,JBTSTS##(J)	;JOB STATUS FOR THE CURRENT JOB
	TLNN	T3,NSHF!NSWP	;IS IT LOCKED?
	JRST	CKLJB1		;NO, CHECK ITS HIGH SEGMENT
	HRRZ	T3,JBTUPM##(J)	;ADDRESS OF THE JOBS PAGE MAP
	PUSHJ	P,CKRNG		;SEE IF THATS WITHIN THE RANGE
	  JRST	CPOPJ1##	;YES, INDICATE OVERLAP
	PUSHJ	P,FSTPG		;GET THE PAGE NUMBER OF THE FIRST PAGE OF THE JOB
	PUSHJ	P,CKPGS		;SEE IF ANY OF THE JOBS PAGES OVERLAP THE RANGE
	  JRST	CPOPJ1##	;YES, INDICATE THAT TO THE CALLER
CKLJB1:	SKIPLE	T3,JBTSGN##(J)	;DOES THE JOB HAVE A REAL HIGH SEGMENT?
	TLNN	T3,LOKSEG	;AND IS IT LOCKED?
	JRST	CKLJB		;NO, LOOK AT THE NEXT JOB
	HRRZS	T3		;CLEAR LH BITS, SO WE CAN USE AS INDEX
	LDB	T3,[POINT 13,JBTHSA##(T3),35]
	PUSHJ	P,CKPGS		;SEE IF THE HIGH SEGMENT PAGES OVERLAP THE RANGE
	  JRST	CPOPJ1##	;THEY DO, TELL THE CALLER
	JRST	CKLJB		;THEY DON'T SO LOOK AT THE NEXT JOB

;SUBROUTINE TO DETERMINE IF ATTEMPTING TO SET MONITOR PAGES OFF-LINE
CKMOL::	SE1ENT			;TO INDICATE THE ENTIRE MODULE RUNS EXTENDED
	LDB	T3,[POINT 9,SYSSIZ##,26]
	CAIL	T1,(T3)		;LOWER BOUND BELOW SYSSIZ?
	AOS	(P)		;NO, INDICATE GOODNESS
	POPJ	P,		;RETURN

;SUBROUTINE TO COMPUTE THE VALUE CORMAX WOULD HAVE IF A RANGE OF PAGES
; WERE TO BE SET OFF LINE
NEWCMX::SE1ENT			;MUST BE EXTENDED TO LOOK AT PAGTAB
	MOVEI	T3,0		;NUMBER OF ON LINE PAGES IN THE RANGE
	MOVSI	T4,NXMBIT	;BIT INDICATING PAGE IS NON-EXISTANT
NEWCM1:	TDNN	T4,@[IW MDSEC2,PAGTAB(T1)] ;IS THIS PAGE NOW ON LINE
	ADDI	T3,PAGSIZ##	;YES, COUNT IT
	CAIE	T1,-1(T2)	;LOOKED AT ALL THE PAGES IN THE RANGE?
	AOJA	T1,NEWCM1	;NO, LOOK AT THE NEXT PAGE
	MOVE	T1,MAXMAX##	;CURRENT MAXIMUM VALUE FOR CORMAX
	SUB	T1,T3		;NEW MAXIMUM VALUE FOR CORMAX IF PAGES
				; IN THE RANGE WERE SET OFF
	POPJ	P,		;RETURN THE NUMBER TO THE CALLER
;HERE TO SET MEMORY OFF LINE (T1 = FIRST PAGE TO SET OFF, T2 = HIGHEST
; PAGE TO SET OFF)
MEMOFL::HRRZ	S,T1		;LOWER BOUND
	HRL	S,T2		;UPPER BOUND
	JSP	T2,SAVCTD##	;GET TO UUO LEVEL
	HRRZ	T1,S		;RESTORE LOWER BOUND
	HLRZ	T2,S		;AND UPPER BOUND
	SKIPE	LOCK##		;LOCKING IN PROGRESS?
	PUSHJ	P,DELAY1	;YES, WAIT A WHILE AND TRY AGAIN
	LDB	T3,[POINT 14,MEMSIZ##,26]
	CAIL	T1,(T3)		;TRYING TO SET MEMORY OFF ABOVE THE TOP OF MEMORY?
	POPJ	P,		;YES, IT'S ALREADY OFF
	CAIL	T2,(T3)		;HIGH PAGE ABOVE THE TOP OF MEMORY?
	MOVE	T2,T3		;YES, SET HIGH PAGE TO LAST PAGE OF MEMORY
	MOVEM	T1,LOKREL##	;FIRST PAGE TO SET OFF
	SUB	T2,T1		;COMPUTE THE NUMBER OF PAGES IN THE RANGE
	HRLM	T2,LOKREL##	;STORE THAT FOR LOCK
	MOVEI	T3,0		;ASSUME NO MONITOR PAGES TO MOVE AND NO 
				; ON LINE PAGES TO SET OFF
	SE1ENT			;GO INTO SECTION 1 NOW, TO LOOK AT PAGTAB..
MEMOF1:	MOVE	T4,@[IW MDSEC2,PAGTAB(T1)] ;PAGE DESCRIPTOR BITS
	TLNE	T4,MONTRB	;DOES THIS PAGE CONTAIN MONITOR CODE?
	AOSA	T3		;YES, COUNT UP THE NUMBER OF MONITOR PAGES
	TLNN	T4,NXMBIT	;DOES THIS PAGE EXIST (IS IT ON LINE)?
	TLO	T3,-1		;YES, INDICATE AT LEAST ONE ON LINE PAGE SEEN
	ADDI	T1,1		;NEXT PAGE IN THE RANGE
	SOJG	T2,MEMOF1	;LOOK AT EVERY PAGE IN THE RANGE
	JUMPGE	T3,CPOPJ##	;EXIT IF NO ONLINE PAGES SEEN
	PUSHJ	P,CAWAIT##	;GET THE CA RESOURCE
	HRROM	J,LASLOK##	;INDICATE SETTING MEMORY OFF-LINE AND SAVE JOB NUMBER
IFE FTMP,<
	HRRZM T3,MOFLPG##	;NUMBER OF MONITOR PAGES
>
IFN FTMP,<
	TRNN	T3,-1		;IF NOT MOVING MONITOR PAGES, DON'T NEED CPU1 TO STOP
	JRST	MEMOF2		;GO SET THE PAGES OFF
	PUSHJ	P,ONCPU0##	;MAKE SURE ON THE BOOT CPU
	PUSH	P,T3		;SAVE THE NUMBER OF MONITOR PAGES BEING SET OFF
	MOVEI	T1,1		;SLEEP A SECOND TO LET I/O ON OTHER CPUS STOP
	S0PSHJ	SLEEPF##	;ZZZZZZ
	POP	P,T3		;RESTORE NUMBER OF MONITOR PAGES
	HRRZM	T3,MOFLPG##	;STORE THE NUMBER OF MONITOR PAGES WHICH MUST BE MOVED
	PUSHJ	P,CP1STP##	;ASK CPU1 TO JUMP INTO ITS ACS
	  PUSHJ	P,DELAY1	;AND WAIT UNTIL IT DOES
MEMOF2:>
	SETOM	LOCK##		;INDICATE SETTING PAGES OFF LINE IS IN PROGRESS
	MOVEI	T1,LOK		;PREVENT THE JOB FROM RUNNING UNTIL DONE
	IORM	T1,JBTSTS##(J)	; ..
	PUSHJ	P,USCHED##	;COME BACK WHEN THE MEMORY HAS BEEN SET OFF
	PUSHJ	P,CAFREE##	;MAKE THE LOCK RESOURCE AVAILABLE
IFN FTMP,<
	HRROI	T1,[MOVEM T2,.CPOK##-.CPCDB##(P1)
		    POPJ  P,]
	MOVN	T2,TICSEC##	;ONE SECOND TO GET THEIR OWN OK WORDS GOING AGAIN
	PUSHJ	P,CPUAPP##	;GIVE THE OTHER CPUS THIS MUCH TIME
	SETZM	MOFLPG##	;NOT SETTING MONITOR PAGES OFF LINE
>
IFN FTDAEM,<
	MOVE	T1,[.CSCMF,,.ERCSC]	;MEMORY OFF-LINE INDICATOR
	PUSH	P,J		;SAVE J FOR COMRET
	PUSHJ	P,DAEEIM##	;TELL DAEMON ABOUT THE MEMORY CONFIGURATION CHANGE
	POP	P,J		;RESTORE J 
>
	PJRST	SETEDV##	;RESET EDV POINTERS AND RETURN

;SUBROUTINE TO SLEEP A TICK AND THEN RETRY AN OPERATION. ALWAYS RETURNS TO
; CALL MINUS ONE

DELAY1:	PUSHJ	P,SAVT##	;DON'T CLOBBER CALLERS ACS
	MOVEI	T1,0		;SLEEP 1 TIC
	S0PSHJ	SLEEPF##	;SLEEP BUT DON'T CLOBBER F
	SOS	-5(P)		;BACK UP PC TO THE TEST
	SOS	-5(P)		; ..
	POPJ	P,		;RETURN TO CHECK AGAIN

;SUBROUTINE TO CHECK IF A PAGE LIES WITHIN THE RANGE SPECIFIED BY T1 AND T2

CKRNG:	CAIL	T3,(T1)		;LESS THAN THE LOWER BOUND?
	CAIL	T3,(T2)		;OR GREATER THAN THE UPPER BOUND?
	AOS	(P)		;YES, NOT IN THE RANGE
	POPJ	P,		;RETURN

;SUBROUTINE TO CHECK IF ANY OF THE PAGES BELONGING TO A SEGMENT LIE
; WITHIN THE RANGE SPECIFIED BY T1 AND T2

CKPGS:	PUSHJ	P,CKRNG		;CHECK THIS PAGE
	  POPJ	P,		;ITS WITHIN THE RANGE
	HRRZ	T3,@[IW MDSEC2,PAGTAB(T3)] ;GET THE NEXT PAGE OF THE SEGMENT
	JUMPE	T3,CPOPJ1##	;GOOD RETURN IF THIS IS THE LAST PAGE OF THE SEGMNET
	JRST	CKPGS		;CHECK THE NEXT PAGE

;SUBROUTINE TO RETURN THE FIRST PAGE OF A LOW SEGMENT

FSTPG:	LDB	T3,JBYLSA##	;PAGE ZERO OF THE JOB
	POPJ	P,		;RETURN THE FIRST PAGE OF THE JOB

> ;END FTMEMOFL
;SUBROUTINE TO DETERMINE THE NUMBER OF UNLOCKED PAGES IN USER CORE

LRGHOL:	PUSHJ	P,SAVE3##
	MOVEI	T2,0
	MOVE	P1,MEMSIZ##
	SUB	P1,SYSSIZ##
	LSH	P1,W2PLSH##
	MOVE	P2,SYSSIZ##
	LSH	P2,W2PLSH##
LRGHL1:	MOVE	P3,@[IW MDSEC2,PAGTAB(P2)]
	TLNN	P3,LKBITS
	ADDI	T2,PAGSIZ##
	ADDI	P2,1
	SOJG	P1,LRGHL1
	POPJ	P,

;SUBROUTINE TO TURN ON BITS INDICATING A PAGE IS LOCKED IN A SPECIFIED WAY

LOKBTS:	MOVSI	T1,NSHF!NSWP
	IORM	T1,JBTSTS##(J)
	LDB	T1,JBYHSA##
	CAILE	J,JOBMAX##
	JRST	LOKBT1
	HRRZ	T1,JBTUPM##(J)
	MOVSI	T2,(T3)
	IORM	T2,@[IW MDSEC2,PAGTAB(T1)]
	LDB	T1,JBYLSA##
LOKBT1:	MOVSI	T2,(T3)
	IORB	T2,@[IW MDSEC2,PAGTAB(T1)]
	HRRZ	T1,T2
	JUMPN	T1,LOKBT1
	POPJ	P,

;SUBROUTINE TO DETERMINE IF A SEGMENT IS LOCKED IN EVM BY VIRTURE OF BEING
; BELOW 112K. (PRESERVES T3)

LKEVA:	LDB	T2,IMGIN##
	ADDI	T2,(T3)
	CAIG	T2,^D224
	AOS	(P)
	POPJ	P,

;SUBROUTINE TO LOCK A SEGMENT IN EVM IF IT IS BELOW 112K. (PRESERVES T1)
LKEVC:	PUSHJ	P,LKEVA
	  POPJ	P,
	LSH	T3,P2WLSH##
	HRRM	T3,JBTADR##(J)
	PUSH	P,T1
	MOVEI	T3,LOKEVB
	PUSHJ	P,LOKBTS
	PJRST	TPOPJ1##
ERROR0:	LDB	P1,JBYLSA##	;LOW SEGMENT PHYSICAL ADDRESS
	TRNN	T1,LKB		;LOCKING LOW SEGMENT?
	JRST	LOWADR		;NO, GET ADDRESS ANYWAY
	MOVE	T4,@[IW MDSEC2,PAGTAB(P1)] ;LOCK STATUS
	MOVSS	T1		;SET UP FOR CHECKING USER ARGUMENT
	PUSHJ	P,ARGCK1	;IS LOCK POSSIBLE?
	  JRST	ERROR7		;NO. USER ARGUMENT IS INVALID
LOWADR:	TLNN	T1,LKEB		;LOCKED IN EVM?
	LDB	P1,[POINT 9,JBTADR##(J),26] ;YES. LOAD EVA FOR USER.
	MOVE	T1,P1		;LOW ADDRESS
	HRL	T1,T3		;HIGH ADDRESS
	PJRST	STOTC1##	;RETURN TO USER WITH ADDRESSES

ERROR1:	MOVEI	T1,LKERR1
	PJRST	STOTAC##

ERROR2:	MOVEI	T1,LKERR2
	PJRST	ERRRET

ERROR3:	MOVEI	T1,LKERR3
	PJRST	ERRRET

ERROR4:	POP	P,T1
ERROR5:	PUSHJ	P,UNLOCK
	PUSHJ	P,COMLIM	;RECOMPUTE CORMAX/MAXMAX
	MOVEI	T1,LKERR4
	PJRST	ERRRET
ERROR6:	MOVEI	T1,LKERR6
ERRRET:	PUSHJ	P,STOTAC##
	PJRST	CAFREE##


;SUBROUTINE TO FIND THE LARGEST CONTIGUOUS CHECK

ERROR7:	MOVEI	T1,7		;ATTEMPTED TO CHANGE LOCK STATUS
	PJRST	STOTAC##	;WITH A LOCK UUO
;SUBROUTINE TO CHECK USER'S ARGUMENT WHEN SEGMENT IS ALREADY LOCKED
ARGCK1:	TLNN	T4,LOKPHB	;PHYSICALLY CONTIGUOUS?
	TLNE	T1,LKPB		;ASKING FOR IT?
	SKIPA			;NO. SO FAR SO GOOD
	POPJ	P,		;CAN'T MAKE IT CONTIGUOUS
	TLNN	T4,LOKEVB	;LOCKED IN EVM?
	TLNE	T1,LKEB		;ASKING FOR IT?
	JRST	CPOPJ1##	;NO. ALL IS WELL
	POPJ	P,		;NOT IN EVM, SO USER CAN'T LOCK IT
;SUBROUTINE TO FIND THE LARGEST CONTIGUOUS CHUNK
; OF EVM AVAILABLE FOR MAPPING BUFFERS
CONEVA:	PUSHJ	P,SAVE4##
	MOVE	P1,EVMPTR##
	MOVEI	P2,0
	MOVEI	P3,-1
	PUSHJ	P,GETZ##
	  MOVEM	P2,EVBMAX##
	POPJ	P,
;SUBROUTINE TO CHECK WHETHER THE CACHE SHOULD BE ON OR OFF
IFN FTKL10!FTKS10,<
CHKCSH:	MOVE	J,.CPJOB##
	TRNE	T1,LKB
	TRNE	T1,LKCB
	JRST	CHKCS3
	MOVSI	T2,(JS.NCS)
	IORM	T2,JBTST2##(J)
CHKCS2:	MOVE	J,.CPJOB##
CHKCS3:	SKIPG	JBTSGN##(J)
	POPJ	P,
	TLNE	T1,LKB
	TLNE	T1,LKCB
	POPJ	P,
	MOVSI	T2,NCSH
	IORM	T2,JBTSGN##(J)
	POPJ	P,
>

;SUBROUTINE TO SEE IF THIS IS THE FIRST PAGE OF
; A SHARABLE HIGH SEGMENT
FPNSHS:	SKIPN	P4
	POPJ	P,
	ADDI	P4,PAGSIZ##
	PUSHJ	P,SAVT##
	HRRZ	T1,M
	PUSHJ	P,TPAHS##
	  SKIPA	T4,T1
	POPJ	P,
	PUSH	P,J
	HRRZ	J,JBTSGN##(J)
	SKIPL	P4
	HRRM	P4,JBTADR##(J)
	S0PSHJ	MAPHI##
	DPB	T4,JBYHSA##
	MOVSI	T1,NSHF!NSWP
	IORM	T1,JBTSTS##(J)
	MOVEI	P4,0
	JRST	JPOPJ##
IFN FTKL10!FTKS10,<
;SUBROUTINE TO CACHE THE LOW SEGMENT
CSHLSG:	PUSHJ	P,SAVE2##
	PUSH	P,M
	LDB	P1,IMGIN##
	PUSHJ	P,NXTWSB##
	CAIA
CSHLS1:	PUSHJ	P,NXTWS2##
	LDB	P2,T4
	TDO	P2,[PM.CSH]
	DPB	P2,T4
	SOJG	P1,CSHLS1
	JRST	MPOPJ##
>

SUBTTL	SEGCON - ROUTINES TO HANDLE HIGH SEGMENTS

;
;ROUTINE TO DETERMINE WHETHER THE IDLE HIGH SEGMENT FOR THE JOB CURRENTLY
;  BEING SWAPPED CAN BE SWAPPED
;
;  CALLING SEQUENCE
;
;	MOVE	J,HIGH SEGMENT NUMBER
;	PUSHJ	P,SWPHGH
;	...	;RETURN HERE TO SWAP ONLY THE LOW SEGMENT SINCE
;		;  THE HIGH SEGMENT IS LOCKED OR BEING LOCKED
;		;  T1 CONTAINS THE LOW SEGMENT NUMBER
;	...	;RETURN HERE IF HIGH SEGMENT CAN BE SWAPPED
;


LOKHGH::PUSH	P,SWPOUT##	;JOB NUMBER OF JOB BEING SWAPPED - MUST
				;  BE SETUP FOR INCREMENTING IN CORE COUNT
				;  IF HIGH SEGMENT CANNOT BE SWAPPED
	MOVE	T1,LOCK##	;GET HIGH SEGMENT NUMBER IF LOCKING ONLY
				;  A HIGH SEGMENT
	MOVSI	T2,NSHF!NSWP	;CANNOT SWAP THE HIGH SEGMENT IF ITS LOCKED
	CAIE	T1,(J)		;IS THIS A HIGH SEGMENT WHICH IS CURRENTLY
				;  BEING LOCKED?
	TDNE	T2,JBTSTS##(J)	;IS IT LOCKED
	JRST	TPOPJ##		;YES, GIVE DON'T SWAP RETURN (T1=JOB #)
	HLRZ	T1,LOCK##	;JOB NUMBER OF JOB BEING LOCKED
	CAME	T1,SWPOUT##	;SAME AS JOB BEING SWAPPED?
	AOS	-1(P)		;NO, OK TO SWAP THE HIGH SEGMENT
	JRST	T2POPJ##	;POP OFF JUNK AND GIVE SKIP OR NON-SKIP RETURN


LOKEND:	END
