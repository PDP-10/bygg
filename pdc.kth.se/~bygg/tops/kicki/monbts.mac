TITLE	MONBTS - FAST INCORE BOOTS  V050
SUBTTL	G.M. UHLER/GMU	12 JULY 83


	SEARCH	F,S
IFN FTKL10,<
	SEARCH	DTEPRM
	>

	$RELOC
	$LOW

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>
;
; DATE		LOAD	EDIT #
; ----		----	------
;
;28-OCT-80	70124	027
;9446
;04-NOV-80	70125	030
;9455
;16-DEC-80	70131	031
;9457-
;20-JAN-81	70135	032
;10-FEB-81	70140	033
;24-MAR-81	70146	034
;9650-9649
;07-APR-81	70150	035
;28-APR-81	70153	036
;02-NOV-81	70114	037
;22-DEC-81	70123	040
;10016
;12-JAN-82	70126	041
;9-MAR-82	70136	042
;10034
;04-MAY-82	70145	043
;10242
;24-AUG-82	70165	044
;10365
;31-AUG-82	70166	045
;10382
;09-MAR-83	70130	046
;10633
;15-mar-83	70131	047
;12-JUL-83	70151	050
;10836
;
XP VMNBTS,050	;VERSION NUMBER FOR LOADER STORAGE MAP



MONBTS::ENTRY	MONBTS		;LOAD IF SPECIFIED BY COMMON

;THE FOLLOWING DEFINITION OF MBTRLC CAUSES LINK TO
;GIVE MULTIPLY DEFINED GLOBAL ERRORS IF MONBTS IS NOT
;LOADED IMMEDIATELY AFTER COMMON
MBTRLC::


IFE	FTMBTS,<
	PRINTX	?MUST HAVE FTMBTS ON FOR MONBTS
	PASS2
	END
>
IFE	FTEXE,<
	PRINTX	?MUST HAVE FTEXE ON FOR MONBTS
	PASS2
	END
>
	SUBTTL	CODING CONVENTIONS/CONSIDERATIONS


;AC CONVENTIONS IN THIS MODULE:
;
; S	- FLAGS (SEE FL.XXX, FR.XXX)
; J	- INDEX INTO DEVICE CODE TABLE
; U	- PHYSICAL UNIT NUMBER
; W	- OFFSET INTO TYPE TABLE (RH10, RH20, RH11, ETC.)
; R	- PHYSICAL OR VIRTUAL CORE ADDRESS OF START OF TRANSFER
; F	- LOGICAL BLOCK ON UNIT OF FIRST BLOCK TO TRANSFER
; M	- NUMBER OF BLOCKS TO TRANSFER
; T1-T4	- TEMPORARIES.  NOT GUARENTEED ACROSS SUBROUTINE CALLS EXCEPT
;	  WHERE EXPLICITLY NOTED.
; P1,P2	- PRESERVED REGISTERS (ACROSS SUBROUTINE CALLS)
; P3,P4 - FILENAME, EXTENSION OF FILE BEING SEARCHED FOR. MAY
;	  NOT BE PRESERVED ACROSS ALL SUBROUTINE CALLS
;
;
;THIS MODULE IS CONSTRUCTED IN THREE PARTS.  THE FIRST RUNS IN THE
;MONITOR HIGH SEGMENT ADDRESS SPACE AND CONTAINS THE MONITOR
;INTERFACE CODE TO CHANGE THE SYSTEM DUMP LIST DATA BASE AND IS
;NEVER USED BY MONBTS ITSELF.  THE SECOND RUNS IN THE MONITOR LOW
;SEGMENT ADDRESS SPACE AND CONTAINS THE ENTRY POINTS CALLED BY THE
;MONITOR TO REPLACE A PAGE, DUMP, OR RELOAD THE MONITOR.  THE FINAL
;(AND MOST SUBSTANTIAL) PART RUNS IN THE MONBTS ADDRESS SPACE STARTING
;AT THE VIRTUAL ADDRESS SPECIFIED BY THE VALUE OF THE SYMBOL .VBOOT.
;THE .VBOOT ADDRESS SPACE IS NOT ADDRESSABLE UNTIL THE CALL TO
;SETUP.  AS A RESULT, THE CODE THAT INTERFACES TO THE REST OF THE
;MONITOR MUST RELOCATE ALL REFERENCES TO THE MONBTS DATA BASE
;AND/OR SUBROUTINES WITH A "-.RDATA" UNTIL SETUP IS CALLED.  GREAT
;CARE SHOULD BE TAKEN TO DETERMINE IN WHAT ADDRESS SPACE A ROUTINE
;IS TO RUN AND PLACE IT CORRECTLY TO RUN IN THAT ADDRESS SPACE.
;FAILURE TO DO THIS WILL CAUSE TOTALLY UNPREDICTABLE RESULTS.
;IN PARTICULAR,  CARE SHOULD BE TAKEN WHEN USING LITERALS
;IN CODE THAT IS NOT PHASED AT .VBOOT SINCE MACRO WILL GENERATE
;THE LITERALS IN THE .VBOOT SPACE.  IF LITERALS ARE TO BE USED,
;THEY SHOULD EITHER BE RELOCATED WITH A "-.RBOOT" OR DUMPED
;WITH A LIT BEFORE PHASED ASSEMBLY STARTS.
	SUBTTL	PARAMETER DEFINITIONS


;SYMBOLIC CHARACTER DEFINITIONS

.CHBEL==007	;BELL
.CHCNH==010	;BACKSPACE
.CHTAB==011	;TAB
.CHLFD==012	;LINE-FEED
.CHVTB==013	;VERTICAL TAB
.CHFFD==014	;FORM FEED
.CHCRT==015	;CARRIAGE RETURN
.CHCNU==025	;CONTROL U
.CHCNZ==032	;CONTROL Z
.CHESC==033	;ESCAPE
.CHDEL==177	;DELETE


;FLAGS IN S.  NOTE THAT THE FR.XXX FLAGS MUST BE IN THE SAME ORDER
;AS SWTTAB SINCE THE OFFSET INTO SWTTAB IS USED TO SET THE BIT IN S.

FL.RUB==1B0	;CURRENTLY PROCESSING RUBOUT
FL.OVW==1B1	;IGNORE UNPROCESSED DUMPS
FL.WLD==1B2	;DEVICE IS WILD
FL.RIB==1B3	;SKIP 1 BLOCK IN SELBLK SO THAT WE SKIP THE RIB
FL.NOP==1B4	;SCHED 400 IN EFFECT
FL.EXR==1B5	;READING IN AN EXTENDED RIB
FL.MOV==1B6	;ALREADY MOVED MONBTS TO HIGH CORE
FL.IO==1B7	;1 IF DOING OUTPUT, 0 IF DOING INPUT
FL.DEF==1B8	;DON'T DEFAULT ANY ANSWERS IN REDLIN
FL.CMD==1B9	;PARSE COMMANDS FROM COMMAND BUFFER
FL.1CM==1B10	;PARSE JUST NEXT COMMAND FROM COMMAND BUFFER
FL.LDE==1B11	;ERROR BEING PROCESSED WAS FROM LOAD, NOT DUMP
FL.SDT==1B12	;SUCCESSFUL DUMP TAKEN
FL.SSD==1B13	;THIS DUMP IS FOR A SYSTEM SLEEP
FL.UCC==1B14	;ALREADY COPIED THE DX20 MICROCODE

FR.DEV==1B18	;DEVICE SEEN
FR.FIL==1B19	;FILENAME SEEN
FR.EXT==1B20	;EXTENSION SEEN
FR.PTH==1B21	;PATH SEEN

FR.FRC==1B31	;/FORCE SEEN
FR.DMP==1B32	;/DUMP SEEN
FR.LOD==1B33	;/LOAD SEEN
FR.DDT==1B34	;/EDDT SEEN
FR.STA==1B35	;/START SEEN
FR.1ST==1B35	;RIGHT-MOST BIT OF SWITCH BITS. SHIFT THIS BIT BY THE
		;OFFSET INTO SWTTAB TO SET THE APPROPRIATE SWITCH BIT
FR.ALL==FR.DEV!FR.FIL!FR.EXT!FR.PTH!FR.FRC!FR.DMP!FR.STA!FR.LOD!FR.DDT
		;ALL PARSE BITS
FX.CLR==FL.RUB!FL.OVW!FL.WLD!FL.SDT!FR.ALL ;BITS TO CLEAR ON ENTRY TO PARSE
;KI10 CONI CTY, BITS

IT.DON==1B30	;INPUT DONE
IT.BSY==1B31	;OUTPUT BUSY


;MISCELANEOUS PARAMETERS

PDLLEN==^D36		;SIZE OF PDL
LINBFL==^D16		;SIZE OF COMMAND LINE BUFFER IN WORDS
BLKSIZ==200		;SIZE OF A DISK BLOCK
PAGSIZ==1000		;SIZE OF A PAGE
DTE==200		;DTE DEVICE CODE
MAXUNI==^D8		;MAX NUMBER OF UNITS ON A CONTROLLER
P2BLSH==2		;AMOUNT TO LSH A PAGE COUNT TO GET BLOCKS
B2WLSH==^D7		;AMOUNT TO LSH A BLOCK COUNT TO GET WORDS
W2BLSH==-B2WLSH		;AMOUNT TO LSH A WORD COUNT TO GET BLOCKS
WATTIM==<FTKL10&50>+<FTKI10&25>+<FTKS10&10>
			;TIME TO WAIT FOR OPERATOR RESPONSE IN REDLIN
IFN FTKL10,<MAXUCD==^D8> ;MAX NUMBER OF PAGES IN DX20 MICROCODE
IFE FTKL10,<MAXUCD==0>   ;  BUT NONE IF NOT A KL10
;DEFINITIONS FOR THE .VBOOT VIRTUAL ADDRESS SPACE.  WITH KL PAGING,
;THE MAP SLOT ASSIGNMENTS ARE ALL DIFFERENT AND WE PUT THE ADDRESS
;SPACE INTO THE LOW SEGMENT TO AVOID CONFLICTS WITH THE RH20 IOWDS.

IFE FTKLP,<
.VBOOT==750000		;VIRTUAL ADDRESS AT WHICH MOST OF BOOT
			;  RUNS (AFTER CALL TO SETUP)
.VPAG0==730000		;PAGE 0 MAPPED THROUGH THIS VIRUAL ADDRESS
			;PAGE 1 MAPPED THROUGH .VPAG0+PAGSIZ
.VMOVE==734000		;FIRST VIRTUAL ADDRESS USED TO MOVE BOOT TO
			;  HIGH CORE
.VZERO==732000		;VIRTUAL ADDRESS USED TO ZERO CORE
> ;END IFE FTKLP



IFN FTKLP,<
.VBOOT==320000		;VIRTUAL ADDRESS AT WHICH MOST OF BOOT
			;  RUNS (AFTER CALL TO SETUP)
.VPAG0==302000		;PAGE 0 MAPPED THROUGH THIS VIRUAL ADDRESS
			;PAGE 1 MAPPED THROUGH .VPAG0+PAGSIZ
.VMOVE==304000		;FIRST VIRTUAL ADDRESS USED TO MOVE BOOT TO
			;  HIGH CORE
.VZERO==300000		;VIRTUAL ADDRESS USED TO ZERO CORE
> ;END IFN FTKLP


;MACRO TO COMPUTE THE MAP SLOT OFFSET FOR A GIVEN VIRTUAL ADDRESS

DEFINE VMAP(SYMBOL,ADDR),<
  IFN FTKLP,<SYMBOL==<ADDR/PAGSIZ>>
  IFE FTKLP,<
    SYMBOL==<<ADDR/PAGSIZ>/2>
    IFL <SYMBOL-200>,<SYMBOL==SYMBOL+600>
    IFGE <SYMBOL-760>,<SYMBOL==SYMBOL-360>
  >
>
    

VMAP(.MBOOT,.VBOOT)	;LEFT HALF WORD IN EPT MAPPING .VBOOT
VMAP(.MPAG0,.VPAG0)	;LEFT HALF WORD IN EPT MAPPING .VPAG0
			;RIGHT HALF WORD MAPS .VPAG0+PAGSIZ
VMAP(.MMOVE,.VMOVE)	;LEFT HALF WORD IN EPT MAPPING .VMOVE
VMAP(.MZERO,.VZERO)	;LEFT HALF WORD IN EPT MAPPING .VZERO
IFN FTKL10!FTKI10,<

;RH10/RH20 DEVICE DEPENDENT PARAMETERS

;CONI BITS
CI.XDN==10		;TRANSFER DONE (RH10/RH20)
CI.122==4000,,0		;22 BIT CHANNEL (RH10/DF10C)
CI.1ER==736320		;DBPE, FXCEP, CHNER, OVR, DRE, ILC, PSFAIL,
			;CBOV, RAE, BUSY (RH10)
CI.1RA==100		;RAE (RH10)
CI.2ER==515000		;DPE, LWCE, DR, RAE, DOE (RH20)
CI.2RA==4000		;RAE (RH20)

;CONO BITS
CO.XDN==10		;CLEAR DONE (RH10/RH20)
CO.XSX==20		;STOP TRANSFER (RH10/RH20)
CO.XMI==2000		;MASSBUS INIT (RH10/RH20)
CO.1RB==47		;CONI BITS TO RESTORE - AIE, PIA (RH10)
CO.1AE==40		;AIE (RH10)
CO.2RB==447		;CONI BITS TO RESTORE - MBE, AIE, PIA (RH20)
CO.2ME==400		;MASSBUS ENABLE (RH20)

;DATAI/DATAO BITS

DO.XCR==004400,,0	;DRIVE CONTROL REGISTER (RH10/RH20)
DO.XSR==010400,,0	;STATUS REGISTER (RH10/RH20)
  DI.XCE==40000		;COMPOSITE ERROR (RH10/RH20)
  DI.XSM==172777	;BIT MASK OF BITS TO CHECK FOR IN INITIALIZATION
  DI.XSB==10700		;LEGAL VALUE IN SR (MOL, DP, DR, VV)
DO.XDS==054000,,0	;BLOCK ADDRESS REGISTER, LR (RH10/RH20)
DO.XDT==060000,,0	;DRIVE TYPE REGISTER (RH10/RH20)
DO.XDC==124000,,0	;DESIRED CYLINDER REGISTER, LR (RH10/RH20)
DO.1CR==404000,,0	;CONTROL REGISTER (RH10)
DO.2ST==716200,,0	;STCR, LR, RCLP, STORE (RH20)
  DO.XCL==11		;FUNCTION CODE FOR DRIVE CLEAR (RH10/RH20)
  DO.XRP==21		;FUNCTION CODE FOR READIN PRESET (RH10/RH20)
  DO.XRD==71		;FUNCTION CODE FOR READ (RH10/RH20)
  DO.XWT==61		;FUNCTION CODE FOR WRITE (RH10/RH20)
DI.2IV==740000,,0	;ARGUMENT TO READ IVI (RH20)
DO.2IV==744000,,0	;ARGUMENT TO RESTORE IVI (RH20)

;MISCELANEOUS

R2IOWL==^D66		;NUMBER OF IOWDS TO ALLOCATE FOR THE LARGEST
			;POSSIBLE TRANSFER
R2BCNT==^D15		;MAX NUMBER OF BLOCKS WHICH MAY BE SPECIFIED
			;IN ONE IOWD FOR AN RH20
R2WCNT==R2BCNT*BLKSIZ	;CORRESPONDING WORDCOUNT
R1BCNT==^D127		;MAX NUMBER OF BLOCKS WHICH MAY BE SPECIFIED
			;IN ONE IOWD FOR AN RH10
R1WCNT==R1BCNT*BLKSIZ	;CORRESPONDING WORDCOUNT

>;END IFN FTKL10!FTKI10
IFN FTKS10,<

;RH11 DEVICE DEPENDENT PARAMETERS

;UBA ADDRESSES/BITS

SO.UPR==763000		;UBA PAGING RAM ADDRESS
  SO.VFT==140000	;VALID+FAST XFER
  SO.RBT==100,,277	;BITS TO RESTORE IN CS1 AND UBA SR
SO.USR==763100		;UBA STATUS REGISTER
  SO.UBI==100		;UNIBUS INIT
  SI.UER==740000	;TIME OUT, BMD, BUS PAR, NXD

;DRIVE ADDRESSES/BITS

SO.CS1==776700		;CONTROL STATUS REGISTER 1
  SI.RDY==200		;READY AT END OF XFER
  SI.S1E==140000	;SC, TRE
SO.WC==776702		;WORD COUNT REGISTER
SO.BA==776704		;BUS ADDRESS REGISTER
SO.DA==776706		;DESIRED ADDRESS REGISTER
SO.CS2==776710		;CONTROL STATUS REGISTER 2
SO.DS==776712		;DRIVE STATUS REGISTER
  SO.DSM==172700	;MASK FOR BITS RETURNED
  SO.DSB==10700		;LEGAL VALUE (MOL, DP, DR, VV)
SO.ASR==776716		;ATTENTION SUMMARY REGISTER
SI.DT==776726		;DRIVE TYPE REGISTER
  SI.DSK==20000		;DEVICE IS A DISK
SO.DC==776734		;DESIRED CYLINDER REGISTER

;MISCELLANEOUS

SO.DCL==11		;FUNCTION CODE FOR DRIVE CLEAR
SO.RIP==21		;FUNCTION CODE FOR READIN PRESET
SO.WRT==61		;FUNCTION CODE FOR WRITE
SO.RED==71		;FUNCTION CODE FOR READ

RSBCNT==^D252		;MAX NUMBER OF BLOCKS WHICH MAY BE TRANSFERED
			;AT ONE TIME BY THE RH11

>;END IFN FTKS10
	SUBTTL	MACRO DEFINITIONS


;MACRO DEFINITIONS TO ALLOW ASSEMBLY TO BE PHASED STARTING AT
;.VBOOT

DEFINE	$PHASE,<
	  OFFSET==.-MONBTS
	  OFFSET==.VBOOT+OFFSET
	  PHASE	OFFSET
	>


DEFINE	$DEPHASE,<
	  XLIST
	  LIT
	  LIST
	  DEPHASE
	>


DEFINE	BLK(LABEL,SIZE),<
	  LABEL==BTSLOC
	  BTSLOC==BTSLOC+SIZE
	  BLOCK	SIZE
	>


;MACRO TO CAUSE A PAUSE BETWEEN THE DATAO WHICH LOADS THE PREPARATION
;REGISTER AND THE DATAI WHICH READS THE VALUE FROM THE SPECIFIED
;REGISTER.

	DEFINE	STALL,<
	  IMULI	P,1
	 IFN FTKL10,<
	  XLIST
	  IMULI P,1
	  LIST
	  >
	>
	SUBTTL	SYSTEM DUMP LIST DATA STRUCTURES


;EACH STRUCTURE IN THE SYSTEM DUMP LIST HAS AN ENTRY IN SDLTAB.
;EACH SDLTAB ENTRY CONTAINS A POINTER TO A BLOCK DESCRIBING THE
;INFORMATION NECESSARY TO READ/WRITE THAT STRUCTURE.  EACH SUCH
;BLOCK HAS THE FOLLOWING FORMAT:
;
;	!=======================================================!
;	!               SIXBIT name of structure                ! .SDBNM
;	!-------------------------------------------------------!
;	! U !     Block number on unit of RIB for CRASH.EXE     ! .SDBCR
;	!-------------------------------------------------------!
;	! U !        Block number on unit of RIB for MFD        ! .SDBMF
;	!-------------------------------------------------------!
;	\First of 8 words describing each unit in this structure\ .SDBUN
;	\             See example below for details             \
;	!-------------------------------------------------------!
;	!Phy unit!Dv Cd Of!  CPU #  !Phy unit!Dv Cd Of!  CPU #  !
;	!-------------------------------------------------------!
;	\                                                       \
;	\                                                       \
;	!=======================================================!


	PHASE	0

.SDBNM:! BLOCK	1	;OFFSET TO SIXBIT STR NAME
.SDBCR:! BLOCK	1	;OFFSET TO POINTER TO RIB FOR CRASH.EXE
.SDBMF:! BLOCK	1	;OFFSET TO POINTER TO RIB FOR MFD
.SDBUN:! BLOCK	MAXUNI	;OFFSET TO START OF POINTERS TO EACH UNIT IN STR
.SDBLN==.-.SDBNM	;LENGTH OF EACH SDL DATA BLOCK

	DEPHASE
	RELOC	MONBTS
	SUBTTL	DATA AREAS


;THE DATA AREA MUST BE THE FIRST THING IN THIS MODULE THAT GENERATES
;CODE TO INSURE THAT IT STARTS ON A PAGE BOUNDARY.  IN ADDITION,
;THE EPT MUST BE THE FIRST THING IN THE DATA AREA FOLLOWED IMMEDIATELY
;BY THE BLOCKS FOR HOM, RIB, AND BUF, FOR THE SAME REASON.  NOTE
;THAT IF ANY OF THE LAST THREE BLOCKS ARE SPLIT ACROSS A PAGE BOUNDARY
;THE I/O SUBROUTINES WILL NOT (NECESSARILY) WORK.  IN ADDITION, THE
;SDL DATA BASE MUST NOT CROSS A PAGE BOUNDARY.

.RDATA==.VBOOT-.	;RELOCATABLE ADDRESS OF START OF DATA
BTSLOC==.VBOOT		;INITIALIZE MACROS

BLK(EPT,PAGSIZ)		;PUT THIS HERE SO IT STARTS ON A PAGE BOUNDARY
IFN FTKL10,<
R2IOWD==EPT+PAGSIZ-R2IOWL ;WHERE TO PUT RH20 IOWDS
>
BLK(HOM,BLKSIZ)		;HOM BLOCK FOR CURRENT UNIT
BLK(RIB,BLKSIZ)		;RIB BLOCK FOR CURRENT FILE
BLK(BUF,BLKSIZ)		;WORK BUFFER

SDLTBV::		;FOR EXTERNAL REFERENCES NOT MAPPED VIA .VBOOT
BLK(SDLTAB,0)
SDLCNT==0
REPEAT .SDMAX,<
	EXP	SDLBLK+<SDLCNT*.SDBLN>
	BTSLOC==BTSLOC+1
SDLCNT==SDLCNT+1
>
BLK(SDLBLK,<.SDMAX*.SDBLN>) ;DATA BLOCKS GO HERE
SDLTBE==.-1
IFN <<SDLTBE/PAGSIZ>-<SDLTBV/PAGSIZ>>,<
PRINTX ?SDLTAB CROSSES A PAGE BOUNDARY
>


				;CONTINUED ON NEXT PAGE
;THE FOLLOWING LOCATIONS MUST REMAIN IN THIS ORDER.  (SEE BOOTFX IN
;ONCE)

BLK(FILSPC,0)		;FIRST WORD CLEARED EACH TIME THROUGH PARSE
BLK(DEV,1)		;DEVICE NAME
BLK(FILNAM,1)		;FILENAME
BLK(EXT,1)		;EXTENSION
BLK(PTHBLK,7)		;PATH BLOCK

;END OF ORDER DEPENDENT LOCATIONS

SWTVLV:
BLK(SWTVAL,0)		;START OF BLOCK OF SWITCH VALUES
BLK(STSA,1)		;START ADDRESS GIVEN IN /START
SWTVLL==.-SWTVLV
FILSPE==BTSLOC-1	;END OF AREA TO CLEAR EACH TIME THROUGH PARSE

BLK(EPTADR,1)		;PHYSICAL ADDRESS OF OUR EPT
BLK(CPEBR,1)		;ARGUMENT TO RESTORE THE EPT AS IT WAS ON ENTRY
BLK(CPUBR,1)		;ARGUMENT TO RESTORE THE UPT AS IT WAS ON ENTRY
BLK(CPEBB,1)		;ARGUMENT TO CHANGE THE EPT TO OUR EPT
BLK(CPCPN,1)		;COPY OF CPU NUMBER ON WHICH WE'RE RUNNING
BLK(MEMPSZ,1)		;NUMBER OF PAGES IN MEMORY
BLK(TRPADR,1)		;ADDRESS OF WHERE TO GO ON A TRAP
BLK(LUNPOS,1)		;LOGICAL UNIT NUMBER WITHIN STR
BLK(DRVBPC,1)		;BLOCKS/CYLINDER ON THIS UNIT \*** KEEP
BLK(DRVBPT,1)		;BLOCKS/TRACK ON THIS UNIT    /*** TOGETHER
BLK(SDLPOS,1)		;POSITION IN SYSTEM DUMP LIST
BLK(BLKCNT,1)		;NUMBER BLOCKS LEFT IN THIS GROUP
BLK(BLKADR,1)		;CURRENT BLOCK ADDRESS
BLK(BLKNUM,1)		;CURRENT RELATIVE BLOCK NUMBER IN FILE
BLK(NEGPGS,1)		;-VE NUMBER OF PAGES IN MONBTS
IFN FTKL10,<
BLK(SVUCSZ,1)		;COPY OF UCDSIZ FROM CRASHED MONITOR
BLK(SVUCAD,1)		;COPY OF UCDADR FROM CRASHED MONITOR
>
BLK(SAVFIR,1)		;COPY OF RIBFIR FROM CURRENT RIB
BLK(SAVSIZ,1)		;COPY OF RIBSIZ FROM CURRENT RIB
BLK(SAVEAC,20)		;SAVE AC'S HERE IN BUGDMP
IFN FTKS10,<
BLK(MAPBLK,40)		;SAVE UBA MAP REGISTERS
>
BLK(BTSPDL,PDLLEN)	;PUSH DOWN LIST
BLK(CMDPTR,1)		;BYTE POINTER TO COMMAND BUFFER
BLK(BTXPTR,1)		;BYTE POINTER TO BOOTXT
BLK(CMDBUF,LINBFL)	;COMMAND LINE BUFFER
BLK(NXMTB,<^D4096*2/^D36>+1) ;OUR COPY OF NXMTAB
	SUBTTL	DISK. UUO ERROR CODES


;ERROR CODES RETURNED BY DISK. UUO FUNCTIONS 12 AND 13

DUDND%==1		;NO SUCH STRUCTURE
DUDNC%==2		;NO CRASH SPACE ON STRUCTURE
DUDAD%==3		;STRUCTURE ALREADY IN SYSTEM DUMP LIST
DUDDF%==4		;SYSTEM DUMP LIST FULL
DUDNS%==1		;STRUCTURE NOT IN SYSTEM DUMP LIST


ERCODE	DSUNSS,DUDND%
ERCODE	DSUNKC,DUDNC%
ERCODE	DSUADL,DUDAD%
ERCODE	DSUDLF,DUDDF%
ERCODE	DSUNDL,DUDNS%
	SUBTTL	INTERFACE WITH THE REST OF THE MONITOR


	$HIGH

;ROUTINE TO SEARCH THE SYSTEM DUMP LIST DATA BASE AND REMOVE
;A SPECIFIED STRUCTURE.
;CALL:	PUSHJ	P,REMSDL
;RETURN+1 IF NOT IN SYSTEM DUMP LIST
;RETURN+2 IF THERE
;ENTER AT SDLREM WITH STR NAME IN T1.  ALWAYS RETURNS+1
;DESTROYS T2,T3

REMSDL::PUSHJ	P,GETWDU##	;GET SIXBIT STRUCTURE NAME
	PUSHJ	P,SDLREM	;DO THE WORK
	JUMPGE	T2,DSUNDL	;GIVE ERROR RETURN IF NOT THERE
	JRST	CPOPJ1-.RDATA	;GIVE SKIP RETURN
SDLREM::MOVSI	T2,-.SDMAX	;BUILD AOBJN POINTER TO SDLTAB
SDLRM1:	SKIPGE	T3,SDLTAB-.RDATA(T2) ;NEXT ENTRY IN SDLTAB USED?
	CAME	T1,.SDBNM-.RDATA(T3) ;YES, MATCH THIS STR NAME?
	AOBJN	T2,SDLRM1	;NO, LOOP
	SKIPGE	T2		;FIND MATCH?
	HRRZS	SDLTAB-.RDATA(T2) ;YES, CLEAR FLAG
	POPJ	P,		;RETURN


;ROUTINE TO ATTEMPT TO ADD A STRUCTURE TO THE SYSTEM DUMP LIST.
;FAILS IF IT IS ALREADY THERE, THE STRUCTURE CONTAINS NO CRASH
;SPACE, OR SDLTAB IS FULL.
;CALL:	PUSHJ	P,ADDSDL
;RETURN+1 IF FAILED WITH ERROR CODE STORED IN USERS'S AC
;RETURN+2 IF SUCCESSFUL

ADDSDL::PUSHJ	P,GETWDU##	;GET THE SIXBIT STR NAME
	PUSHJ	P,SRSTR##	;FIND STR DATA BLOCK
	  JRST	DSUNSS		;NO SUCH STRUCTURE
	HRRZ	T1,STRK4C##(T3)	;GET K FOR CRASH
	JUMPE	T1,DSUNKC	;NO CRASH SPACE
	MOVSI	T1,-.SDMAX	;GET AOBJN POINTER TO SDLTAB
ADDSD1:	SKIPL	T4,SDLTAB-.RDATA(T1) ;NEXT SLOT IN SDLTAB FULL?
	JRST	ADDSD2		;NO, TRY NEXT
	MOVE	T4,.SDBNM-.RDATA(T4) ;GET STRUCTURE NAME
	CAMN	T4,STRNAM##(T3)	;ALREADY THERE?
	JRST	DSUADL		;YES
ADDSD2:	AOBJN	T1,ADDSD1	;LOOP FOR ALL
	MOVSI	T1,-.SDMAX	;BUILD ANOTHER AOBJN POINTER
	SKIPGE	SDLTAB-.RDATA(T1) ;THIS SLOT FREE
	AOBJN	T1,.-1		;NO, LOOP
	JUMPGE	T1,DSUDLF	;ERROR IF TABLE FULL
	PUSHJ	P,SDLADD	;ADD IT TO THE TABLE
	PUSHJ	P,FRCCPY##	;COPY ANY UNPROCESSED DUMP ON THIS STR
	JRST	CPOPJ1-.RDATA	;GIVE SKIP RETURN
;ROUTINE TO ADD A STRUCTURE TO THE SYSTEM DUMP LIST DATA BASE AND
;SETUP ALL PARAMETERS IN THE SDL DATA BLOCK.
;CALL:
;	T1/POSITION IN SYSTEM DUMP LIST
;	T3/STR DATA BLOCK ADDRESS
;	PUSHJ	P,SDLADD
;RETURN+1 ALWAYS

SDLADD::HRROS	T4,SDLTAB-.RDATA(T1) ;FLAG THIS SLOT AS USED
	SUBI	T4,.RDATA	;RELOCATE ADDRESS
	MOVE	T1,STRNAM##(T3)	;GET STRUCTURE NAME
	MOVEM	T1,.SDBNM(T4)	;STORE IN BLOCK
	MOVE	T1,STRCRS##(T3)	;GET BLOCK IN STR OF RIB FOR CRASH.EXE
	IDIV	T1,STRBPU##(T3)	;T1=UNIT, T2=BLOCK ON UNIT
	DPB	T1,SDYCRU-.RDATA ;STORE UNIT NUMBER
	DPB	T2,SDYCRB-.RDATA ;AND BLOCK IN UNIT
	HLRZ	U,STRUNI##(T3)	;POINT TO FIRST UNIT IN STR
	MOVE	T2,STRPT1##(T3)	;GET RETRIEVAL POINTER FOR MFD
	LDB	T1,STYCLP##(T3)	;GET CLUSTER ADDRESS OF MFD
	LDB	T2,UNYBPC##	;  AND BLOCKS/CLUSTER
	IMUL	T1,T2		;COMPUTE BLOCK ADDRESS OF MFD
	DPB	T1,SDYMFB-.RDATA ;STORE BLOCK NUMBER
	MOVE	T2,T3		;MOVE STR DATA BLOCK ADDRESS TO T2
	LDB	T1,STYUN1##	;GET UNIT NUMBER CONTAINING MFD
	DPB	T1,SDYMFU-.RDATA ;STORE UNIT NUMBER
	PUSHJ	P,SAVE1##	;SAVE P1
	MOVEI	P1,.SDBUN(T4)	;POINT TO FIRST SLOT FOR UNIT POINTERS
SDLAD1:	PUSHJ	P,SDLSTO	;SETUP POINTERS FOR THIS UNIT
	AOS	P1		;INCREMENT TABLE POINTER
	HLRZ	U,UNISTR##(U)	;STEP TO NEXT UNIT
	JUMPN	U,SDLAD1	;AND LOOP FOR ALL
	POPJ	P,		;RETURN
;ROUTINE TO ADJUST THE SDL DATA BASE FOR A UNIT AS THE RESULT OF
;AN ATTACH, DETATCH, OR XCHANGE COMMAND.
;CALL:
;	U/UDB ADDRESS
;	PUSHJ	P,SDLUNI
;RETURN+1 ALWAYS

SDLUNI::PUSHJ	P,SAVE1##	;SAVE P1
	HRRZ	P1,UNISTR##(U)	;GET STR DB ADDRESS
	JUMPE	P1,CPOPJ-.RDATA	;RETURN IF NOT IN A STR
	PUSHJ	P,FNDSDL	;SEE IF STR IS IN THE SDL
	JUMPL	T1,CPOPJ-.RDATA	;RETURN IF NOT
	HRRZ	P1,SDLTAB-.RDATA(T3) ;GET POINTER TO SDL DATA BLOCK
	LDB	T1,UNYLUN##	;GET LOGICAL UNIT IN STR
	ADDI	P1,.SDBUN-.RDATA(T1) ;OFFSET TO UNIT WORD IN BLOCK
	PJRST	SDLSTO		;STORE DATA FOR UNIT IN BLOCK AND RETURN


;ROUTINE TO FIND FIND THE POSITION OF A STRUCTURE IN THE SYSTEM DUMP
;LIST AND RETURN IT AND ITS OFFSET IN SDLTAB.
;CALL:
;	P1/STR DATA BLOCK ADDRESS
;	PUSHJ	P,FNDSDL
;RETURN+1 ALWAYS WITH:
;	T1/POSITION IN SLD, -1 IF NOT FOUND
;	T3/OFFSET IN SDLTAB OF POINTER TO BLOCK
;PRESERVES T2

FNDSDL::MOVEI	T1,0		;SET INITIAL POSITION TO ZERO
	MOVSI	T3,-.SDMAX	;GET AOBJN POINTER TO SDLTAB
FNDSD1:	SKIPL	T4,SDLTAB-.RDATA(T3) ;THIS SLOT IN USE?
	JRST	FNDSD2		;NO
	MOVE	T4,.SDBNM-.RDATA(T4) ;GET STR NAME FROM BLOCK
	CAMN	T4,STRNAM##(P1)	;MATCH?
	POPJ	P,		;YES, RETURN WITH POSITION IN T1
	AOS	T1		;INCREMENT POSITION POINTER
FNDSD2:	AOBJN	T3,FNDSD1	;LOOP FOR ALL
	JRST	M1POPJ##	;NOT FOUND, RETURN -1
;ROUTINE TO STORE THE .SDBUN WORD FOR BOTH PORTS OF A UNIT IN THE
;APPROPRIATE WORD IN THE SDL DATA BLOCK FOR A STRUCTURE.
;CALL:
;	U/UDB ADDRESS
;	P1/ADDRESS OF DATA BLOCK SLOT FOR THIS UNIT
;	PUSHJ	P,SDLSTO
;RETURN+1 ALWAYS

SDLSTO:	SETOM	T4		;DISALLOW ALL MATCHES
IFN FTDUAL,<
	PUSH	P,P2		;SAVE P2
	PUSHJ	P,SDLST1	;SETUP POINTERS FOR THIS UNIT
	SKIPN	P2,UNI2ND##(U)	;2ND PORT?
	JRST	SDLST2		;NO, STORE AND RETURN
	EXCH	U,P2		;YES, POINT U AT 2ND PORT
	MOVSS	T4		;PUT POINTERS IN RH FOR THIS PORT
	PUSHJ	P,SDLST1	;STORE POINTERS
	EXCH	U,P2		;RESTORE U
	MOVSS	T4		;AND T4
SDLST2:	POP	P,P2		;RESTORE P2
	MOVEM	T4,(P1)		;STORE IN DATA BLOCK
	POPJ	P,		;RETURN
SDLST1:
>;END IFN FTDUAL
	PUSH	P,J		;SAVE J
	PUSH	P,T3		;SAVE T3
IFE FTKS10,<
	MOVE	J,UNIKON##(U)	;GET KDB ADDRESS FROM UDB
	MOVE	T1,KONREG##(J)	;GET NUMBER OF REGISTERS STORED IN KDB
	ADDI	T1,KONEBK##(J)	;COMPUTE ADDRESS OF FIRST I/O INSTN.
	LDB	T1,[POINT 7,(T1),9] ;GET DEVICE CODE FOR THIS CONTROLLER
	MOVSI	T2,-DVCTBL	;BUILD AOBJN POINTER TO DEVICE CODE TABLE
SDLST3:	HRRZ	T3,DVCTAB-.RDATA(T2) ;GET NEXT DEVICE CODE FROM TABLE
	CAIE	T3,(T1)		;MATCH?
	AOBJN	T2,SDLST3	;NO, LOOP
>;END IFE FTKS10
IFN FTKS10,<
	HRROI	T2,R11OFS	;GET OFFSET FOR KS10
>
	DPB	T2,SDYDCO-.RDATA ;STORE OFFSET INTO TABLE
	LDB	T1,UNYPUN##	;GET PHYSICAL UNIT NUMBER
	DPB	T1,SDYPUN-.RDATA ;STORE IT
	LDB	T1,KOYCPU##	;GET CPU NUMBER
	SKIPGE	T2		;FIND A DEVICE CODE MATCH?
	DPB	T1,SDYCPU-.RDATA ;STORE CPU NUMBER
IFE FTDUAL,<
	MOVEM	T4,(P1)		;STORE IN DATA BLOCK
>
	POP	P,T3		;RESTORE T3
	JRST	JPOPJ##		;RESTORE J AND RETURN


	XLIST			;LITERALS UNDER XLIST
	LIT
	LIST
	$LOW
;ROUTINE TO REPLACE A MONITOR HIGH SEGMENT PAGE FROM THE DISK COPY
;OF THE MONITOR ON PARITY ERRORS, ETC.
;CALL:
;	T1/EXEC VIRTUAL PAGE NUMBER
;	T2/PHYSICAL ADDRESS OF START OF THAT PAGE
;	PUSHJ	P,PAGRPL
;RETURN+1 IF ANY ERRORS
;RETURN+2 WITH PAGE REPLACED

PAGRPL::MOVEM	17,SAVEAC+17-.RDATA ;SAVE AC 17
	MOVEI	17,SAVEAC-.RDATA ;SETUP TO BLT THE REST
	BLT	17,SAVEAC+16-.RDATA ;SAVE THE REST
	MOVEI	T1,MBTXIT	;WHERE TO GO ON A TRAP
	PUSHJ	P,SETUP		;SETUP OUR EPT AND INITIALIZE
	MOVE	T1,[STRMON##,,DEV] ;SETUP TO BLT MONITOR FILESPEC
	BLT	T1,PTHBLK	;MOVE IT TO OUR AREA
	MOVE	T1,[SFDMON##,,PTHBLK+1] ;SETUP TO BLT SFD'S
	BLT	T1,PTHBLK+5	;MOVE THEM ALL
	SETZM	PTHBLK+6	;INSURE BLOCK TERMINATES WITH A ZERO
	PUSHJ	P,FNDMON	;FIND FILE CONTAINING THE MONITOR
	  JRST	MBTXIT		;FAILED
	MOVE	P2,SAVEAC+T1	;GET EXEC VIRTUAL PAGE NUMBER OF PAGE TO REPLACE
	MOVE	P3,SAVEAC+T2	;  AND CORRESPONDING PHYSICAL ADDRESS
PAGRP1:	HRRZ	P4,0(P1)	;GET FILE PAGE NUMBER OF NEXT DESCRIPTOR
	JUMPE	P4,PAGRP2	;NO GOOD IF ALLOCATED BUT ZERO PAGE
	HRRZ	T1,1(P1)	;GET CORE PAGE NUMBER OF DESCRIPTOR
	LDB	T2,[POINT 9,1(P1),8]  ;  AND REPEAT COUNT
	ADD	T2,T1		;CALCULATE LAST PAGE IN THIS DESCRIPTOR
	CAML	P2,T1		;IS DESIRED PAGE DESCRIBED BY
	CAMLE	P2,T2		;  THIS DESCRIPTOR?
	JRST	PAGRP2		;NO, CONTINUE
	SUB	P2,T1		;COMPUTE RELATIVE OFFSET OF DESIRED PAGE
	ADD	P4,P2		;AND FILE PAGE CONTAINING IT
	LSH	P4,P2BLSH	;COMPUTE FILE BLOCK NUMBER
	PUSHJ	P,POSFIL	;POSITION FILE TO THAT BLOCK
	  JRST	MBTXIT		;HIT EOF
	MOVEI	P2,PAGSIZ/BLKSIZ ;NUMBER OF BLOCKS TO TRANSFER
	PUSHJ	P,REDBLK	;READ PAGE INTO CORE
	  JRST	MBTXIT		;FAILED
	AOS	0(P)		;GIVE SKIP RETURN TO CALLER
	JRST	MBTXIT		;AND RETURN
PAGRP2:	AOBJN	P1,.+1		;LOOP FOR ALL DESCRIPTORS
	AOBJN	P1,PAGRP1	;WHICH ARE 2 WORDS LONG
	JRST	MBTXIT		;DIDN'T FIND IT, RETURN FAILURE
;ROUTINE TO TAKE A CONTINUABLE STOPCD DUMP. CALLED FROM DIE
;IN ERRCON WHEN THE STOPCD BEING PROCESSED IN CONTINUABLE.
;ENTER AT SLPDMP FOR A SYSTEM SLEEP DUMP.
;CALL:	PUSHJ	P,BUGDMP
;RETURN+1 IF DUMP WASN'T COMPLETED SUCCESFULLY FOR SOME REASON
;RETURN+2 IF SUCCESSFUL
;DESTROYS T1,T4

SLPDMP::TDZA	T1,T1		;CLEAR T1 FOR ENTRY AT SLPDMP
BUGDMP::SETOM	T1		;  AND SET IT TO -1 FOR ENTRY AT BUGDMP
	MOVEM	17,SAVEAC+17-.RDATA ;SAVE AC 17 IN AC SAVE AREA
	MOVEI	17,SAVEAC-.RDATA ;SETUP FOR BLT
	BLT	17,SAVEAC+16-.RDATA ;SAVE THE REST
	MOVEI	T1,BUGDU1	;WHERE TO GO ON A TRAP
	PUSHJ	P,SETUP		;SETUP MAPPING AND INITIALIZE
	SKIPN	SAVEAC+T1	;ENTRY AT SLPDMP?
	TLO	S,(FL.SSD)	;YES, SET FLAG
	MOVEI	P,BTSPDL	;SET UP A PDL
IFN FTKS10,<
	PUSHJ	P,SAVMAP	;SAVE UBA MAP REGISTERS
>
	MOVE	T1,[POINT 7,BOOTXT##] ;GET BYTE POINTER TO BOOTXT
	MOVEM	T1,BTXPTR	;STORE FOR PARSE
	PUSHJ	P,PARSE		;PARSE FIRST COMMAND
BUGDU1:	  JRST	[MOVEI	P,BTSPDL ;SETUP P IN CASE GOT HERE VIA TRAP
		 PUSHJ	P,ASKSTR ;SYNTAX ERROR, ASK THE OPERATOR
		 JRST	BUGDU2]	 ;AND EXIT
	TRNE	S,FR.DMP	;/DUMP SEEN?
	PUSHJ	P,DODUMP	;YES, TAKE A DUMP
BUGDU2:	HRRZ	T1,SAVEAC+P	;GET STACK POINTER OF CALLER
	TLNE	S,(FL.SDT)	;WAS THE DUMP SUCCESSFUL?
	AOS	0(T1)		;YES, GIVE SKIP RETURN TO CALLER
IFN FTKS10,<
	PUSHJ	P,RESMAP	;RESTORE UBA MAP REGISTERS
>


;HERE TO RESTORE THE AC'S, THE MONITOR'S EPT AND UPT AND RETURN TO
;THE CALLER

MBTXIT:	MOVSI	17,SAVEAC	;SETUP FOR BLT TO RESTORE AC'S
	BLT	17,17		;RESTORE THEM ALL
	MOVE	T4,CPUBR	;CHANGE THE UBT BACK TO WHAT
	XCT	CHGUBR		;  IT WAS ON ENTRY
	MOVE	T1,CPEBR	;CHANGE THE EPT BACK TO WHAT
	XCT	CHGEBR		;  IT WAS ON ENTRY
IFN FTKS10,<
	WRAPR	@.CPAPI##	;RESTORE APR PI ASSIGNMENT
>
	POPJ	P,		;AND RETURN


	XLIST			;LITERALS UNDER XLIST
	LIT
	LIST
;ROUTINE TO OPTIONALLY TAKE A DUMP AND RELOAD THE MONITOR. CALLED
;FROM COMMON WHEN THE SYSTEM CRASHES WITH A STOP STOPCD.
;CALL:
;	T1/BYTE POINTER TO BOOTXT OR ZERO
;	PUSHJ	P,RLDMON
;RETURNS TO THE START ADDRESS OF THE NEW MONITOR

RLDMON::MOVEM	T1,BTXPTR-.RDATA ;SAVE BYTE POINTER TO BOOTXT
	MOVEI	T1,RLDMO2	;WHERE TO GO ON A TRAP
	PUSHJ	P,SETUP		;SETUP EPT, VARIABLES
	JRST	RLDMO1		;CONTINUE EXECUTION IN .VBOOT SPACE

	$PHASE

RLDMO1:	SKIPN	BTXPTR		;WANT TO AUTO RELOAD?
RLDMO2:	TLO	S,(FL.DEF!FL.CMD) ;NO, NO DEFAULTS AND READ FROM COMMAND BUFFER
	MOVEI	P,BTSPDL	;SETUP PDL POINTER
				;<MATCH ANGLE BRACKET ON NEXT LINE
RLDMO3:	MOVEI	T1,[ASCIZ/MONBTS>/] ;OUR PROMPT
	MOVEI	T2,[0]		;DEFAULT ANSWER IS CR
	TLNE	S,(FL.CMD)	;READING FROM BOOTXT
	PUSHJ	P,REDLIN	;NO, TYPE PROMPT
	PUSHJ	P,PARSE		;PARSE THE COMMAND
	  JRST	RLDMO3		;SYNTAX ERROR
	TRNE	S,FR.DMP	;/DUMP SEEN?
	JRST	[PUSHJ P,DODUMP ;YES, TAKE A DUMP
		 JRST  RLDMO3]	;AND GO BACK AROUND
	TRNE	S,FR.STA	;/START SEEN?
	TRNE	S,FR.ALL-FR.STA	;AND NOTHING ELSE?
	TLOA	S,(FL.CMD)	;NO, READ NO MORE COMMANDS FROM BOOTXT
	JRST	RLDMO4		;YES, JUST START UP MONITOR
IFN FTKL10,<
	TLON	S,(FL.UCC)	;ALREADY COPIED THE MICROCODE?
	PUSHJ	P,UCDCPY	;NO, COPY IT NOW
>
	PUSHJ	P,DOLOAD	;LOAD NEW MONITOR
	  JRST	RLDMO3		;ERROR DETECTED
	TRNE	S,FR.LOD	;/LOAD SPECIFIED?
	JRST	RLDMO3		;YES, DON'T START
RLDMO4:
IFN FTKL10,<
	MOVE	T1,SVUCSZ	;GET SIZE OF THE DX20 MICROCODE
	MOVEM	T1,.VPAG0+UCDSIZ## ;SAVE FOR THE NEW MONITOR
	MOVE	T1,SVUCAD	;GET DX20 UCODE ADDRESS
	MOVEM	T1,.VPAG0+UCDADR## ;SAVE FOR THE NEW MONITOR
>
	MOVE	T1,EPTADR	;GET PHYSICAL ADDRESS OF EPT
	ADDI	T1,FILSPC-EPT-140 ;COMPUTE BOOTSA POINTER
	TLO	T1,(1B0)	;SET SIGN BIT SO MONITOR CAN TELL IT'S MONBTS
	MOVEM	T1,.VPAG0+BOOTSA## ;SO THAT BOOTFX CAN FIND THE MONITOR NAME
IFN FTKL10!FTKS10,<
	APRID	.VPAG0+BOOTWD##	;STORE SERIAL NUMBER FOR SYSTRT
>
IFN FTKI10,<
	CONI	PAG,.VPAG0+BOOTWD## ;DITTO FOR KI
>
	MOVE	17,[CONO APR,200000] ;STORE CONO APR,200000 SO THAT
	MOVE	T2,[MOVEM 17,FILSPC-140+1000] ;CONSISTENCY CHECKS WORK
	SKIPN	T4,STSA		;START ADDRESS SPECIFIED ON /START?
	HRRZ	T4,.VPAG0+JOBSA## ;NO, USE ADDRESS FROM FILE
	HRLI	T4,(JRST)	;MAKE IT A JRST
	MOVE	T3,CHGEBR	;GET INSTRUCTION TO CHANGE THE EBR
IFN FTKI10,<
	MOVEI	T1,PG.LEB	;TURN OFF PAGING KI STYLE
>
IFN FTKL10!FTKS10,<
	MOVEI	T1,0		;TURN OFF PAGING KL/KS STYLE
>
	JRST	T2		;TURN OFF PAGING AND START NEW MONITOR

	$DEPHASE
;ROUTINE TO COPY THE EXEC MAP FOR THE CURRENT CPU TO OUR MAP,
;SAVE THE CURRENT EPT AND UPT ADDRESSES AND CHANGE THE EPT AND UPT
;TO OUR PAGE TO AVOID CHANGING THE MONITOR DURING THE DUMP PROCESSES
;AND TO ALLOW US TO FIELD TRAPS.  ALSO SETS UP SOME INITIALIZATION
;VARIABLES.
;CALL:
;	MOVEI	T1,ADDRESS OF WHERE TO GO ON A TRAP
;	PUSHJ	P,SETUP
;RETURN+1 ALWAYS

SETUP:	MOVEM	T1,TRPADR-.RDATA ;STORE TRAP ADDRESS
IFN FTKI10,<
	DATAI	PAG,T1		;GET CURRENT EPT MAPPING
	MOVE	T4,T1		;COPY TO T4 FOR UPT MAPPING
	TRO	T1,PG.LEB	;SET BITS FOR DATAO
	MOVEM	T1,CPEBR-.RDATA	;SAVE FOR RESTORE
	TRZ	T1,PG.EPT	;CLEAR EPT PAGE
	TLO	T4,(PG.LUB)	;SET LOAD UBR BIT
	MOVEM	T4,CPUBR-.RDATA	;SAVE FOR RESTORE
	TLZ	T4,(PG.UPT)	;CLEAR UPT PAGE
>
IFN FTKL10,<
	SWPUA			;DUMP CACHE
	CONSO	APR,LP.CSD	;WAIT FOR IT
	JRST	.-1		;  TO COMPLETE
	CONI	PAG,T1		;GET CURRENT EPT MAPPING
	MOVEM	T1,CPEBR-.RDATA	;SAVE FOR RESTORE
	TRZ	T1,LG.EPT	;CLEAR EPT PAGE NUMBER
	DATAI	PAG,T4		;GET CURRENT UPT MAPPING
	MOVEM	T4,CPUBR-.RDATA	;SAVE FOR RESTORE
	TRZ	T4,LG.UPT	;CLEAR UPT PAGE NUMBER
>
IFN FTKS10,<
	RDEBR	T1		;GET CURRENT EPT MAPPING
	MOVEM	T1,CPEBR-.RDATA	;SAVE FOR RESTORE
	TRZ	T1,SG.EPT	;CLEAR EPT PAGE NUMBER
	RDUBR	T4		;GET CURRENT UPT MAPPING
	MOVEM	T4,CPUBR-.RDATA	;SAVE FOR RESTORE
	TRZ	T4,SG.UPT	;CLEAR UPT PAGE NUMBER
>
	HRLZ	T2,.CPMAP##	;GET VIRTUAL PAGE CONTAINING EPT
	HRRI	T2,EPT-.RDATA	;MOVE TO OUR EPT PAGE
	BLT	T2,EPT+PAGSIZ-1-.RDATA ;MOVE IT ALL
IFE FTKLP,<
	MOVEI	T2,PM.ACC+PM.WRT+0 ;MAKE PAGE 0 AND 1 ADDRESSABLE
	HRLI	T2,1(T2)		;AS VIRTUAL ADDRESSES .VPAG0
	MOVSM	T2,EPT+.MPAG0-.RDATA ;AND .VPAG0+PAGSIZ IN OUR MAP
>
IFN FTKLP,<
	MOVSI	T2,(<PM.DCD>B2+PM.WRT) ;ACCESSIBLE AND WRITABLE
	MOVEM	T2,EPT+.MPAG0-.RDATA ;MAP PAGE 0
	MOVEM	T2,EPT+.MPAG0-.RDATA+1
	AOS	EPT+.MPAG0-.RDATA+1 ;AND PAGE 1
	HLLZ	T2,CPUBR-.RDATA	;GET CURRENT AC SET
	TLZ	T2,770777
	TLO	T2,(1B0+6B11)	;PREVIOUS EQUALS 6
	JRSTF	@[IC.UOU+.+1]	;MAKE SURE PREVIOUS IS ADDRESSABLE
	DATAO	PAG,T2		;PREVIOUS CONTEXT ACS
	EXCTUX	<SETZM 2>	;CLEAR CST BASE
>


				;CONTINUED ON THE NEXT PAGE
;HERE TO SETUP THE MAP THAT WE JUST COPIED SO THAT THE .VBOOT ADDRESS
;SPACE IS MAPPED THROUGH THE APPROPRIATE MAP SLOTS.

	MAP	T2,EPT-.RDATA	;GET PHYSICAL ADDRESS OF OUR EPT
IFN FTKI10,<
	ANDI	T2,PG.EPT	;ISOLATE THE PAGE NUMBER
	LSH	T2,P2WLSH##	;CONVERT TO AN ADDRESS
>
IFN FTKL10,<
	TLZ	T2,(^-<LG.EPT*PAGSIZ+PAGSIZ-1>) ;ISOLATE ADDRESS
>
IFN FTKS10,<
	TLZ	T2,(^-<SG.EPT*PAGSIZ+PAGSIZ-1>) ;ISOLATE ADDRESS
>
	MOVEM	T2,EPTADR-.RDATA ;STORE PHYSICAL ADDRESS OF EPT
	LSH	T2,W2PLSH##	;CONVERT TO PAGE NUMBER
	IORI	T1,(T2)		;INSERT PAGE NUMBER
IFN FTKI10,<
	TLO	T4,(T2)		;FOR UPT ALSO
>
IFN FTKL10!FTKS10,<
	IORI	T4,(T2)		;FOR UPT ALSO
>
	MOVEM	T1,CPEBB-.RDATA	;SAVE MAPPING HERE
IFE FTKLP,<
	HRLI	T2,-<MBTPGS+MAXUCD> ;MAKE AOBJN POINTER FOR MONBTS+UCODE
	TRO	T2,PM.ACC+PM.WRT ;SET FLAG BITS
	MOVSI	T3,(POINT 18,0)	;BUILD BYTE POINTER TO EPT (NO LITERAL
	HRRI	T3,EPT+.MBOOT-.RDATA  ; TO GET AROUND A LINK BUG)
	IDPB	T2,T3		;MAP MONBTS IN .VBOOT ADDRESS SPACE
	AOBJN	T2,.-1		;  ADDRESS SPACE
>
IFN FTKLP,<
	HRLI	T2,(<PM.DCD>B2+PM.WRT) ;ACCESSIBLE + WRITABLE
	MOVEM	T2,EPT+540-.RDATA ;SETUP SECTION TABLE TO POINT AT SECTION 0 PT
	SETZM	EPT-.RDATA+DTEEPW ;CLEAR EXAMINE/PROTECTION WORD SINCE MIGHT BE JUNK
	SETZM	EPT-.RDATA+DTEMTI ;ALSO INPUT READY FLAG
	MOVSI	T3,-<MBTPGS+MAXUCD> ;AOBJN POINTER FOR MONBTS+UCODE
	MOVEM	T2,EPT+.MBOOT-.RDATA(T3) ;STORE MAPPING
	AOS	T2		;NEXT PHYSICAL PAGE
	AOBJN	T3,.-2		;MAP ALL OF MONBTS
>
	XCT	CHGEBR-.RDATA 	;SETUP NEW MAPPING


				;CONTINUED ON THE NEXT PAGE
;HERE TO SETUP THE TRAP VECTORS IN THE MAP TO POINT TO OUR TRAP
;ROUTINES AND POINT THE UBR AT THE SAME PAGE AS THE EBR.

	MOVE	T1,[JRST TRAP]	;GET INSTRUCTION TO XCT ON TRAPS
	MOVEM	T1,EPT+.UPPDT	;STORE FOR PDL OVERFLOWS
	MOVEM	T1,EPT+.UP03T	;  AND TRAP 3'S
	HRRZM	T1,EPT+.UPMTS	;STORE ADDRESS IN FIRST OF MUUO TRAP LOCATIONS
	MOVE	T1,[EPT+.UPMTS,,EPT+.UPMTS+1] ;SETUP BLT POINTER
	BLT	T1,EPT+.UPMTE	;SETUP TRAP ADDRESS IN ALL WORDS
IFN FTKI10,<
	MOVE	T1,[JSR PFTRAP]	;GET PAGE FAIL TRAP INSTRUCTION
	MOVEM	T1,EPT+.UPPFT	;STORE
>
IFN FTKL10!FTKS10,<
	MOVEI	T1,PFTRAP	;GET PAGE FAIL TRAP NEW PC
	MOVEM	T1,EPT+.LMPFN+IFN FTKLP,<1>	;STORE
>
	XCT	CHGUBR		;CHANGE UBR

;HERE TO SETUP MISCELLANEOUS FLAGS AND VARIABLES BEFORE WE RETURN
;TO THE CALLER.

	MOVEI	S,0		;CLEAR FLAGS
	MOVEI	T1,ST.NOP	;GET NO OPERATOR BIT
	TDNE	T1,STATES##	;IS IT SET?
	TLO	S,(FL.NOP)	;YES, SET IN FLAGS WORD
	MOVNI	T1,MBTPGS	;GET -VE NUMBER OF PAGES IN MONBTS ALONE
	MOVEM	T1,NEGPGS	;STORE AS INITIAL VALUE OF NEGPGS
	MOVE	T1,.CPCPN##	;GET NUMBER OF THIS CPU
	MOVEM	T1,CPCPN	;STORE IN OUR DATA AREA
	MOVE	T1,[NXMTAB##,,NXMTB] ;SETUP TO COPY NXMTAB
	BLT	T1,NXMTB+NXMTBL##-1  ;DO SO
	HLRE	T1,NXMPTR##	;GET MONITOR'S AOBJN POINTER TO NXMTAB
	MOVNS	T1		;MAKE LENGTH POSITIVE
	SKIPLE	T1		;IF NOT SETUP
	CAILE	T1,NXMTBL##	;  OR UNREASONABLE
	MOVEI	T1,NXMTBL##	;USE LENGTH OF TABLE
	IMULI	T1,^D36		;COMPUTE NUMBER OF PAGES
	MOVEM	T1,MEMPSZ	;STORE FOR LATER
	POPJ	P,		;RETURN
	XLIST			;LITERALS UNDER XLIST
	LIT
	LIST

	$PHASE

CHGEBR:
IFN FTKI10,<
	DATAO	PAG,T1		;CHANGE THE EBR
>
IFN FTKL10,<
	CONO	PAG,(T1)	;CHANGE THE EBR
>
IFN FTKS10,<
	WREBR	(T1)		;CHANGE THE EBR
>

CHGUBR:
IFN FTKI10!FTKL10,<
	DATAO	PAG,T4		;CHANGE THE UBR
>
IFN FTKS10,<
	WRUBR	T4		;CHANGE THE UBR
>
	SUBTTL	DUMP MONITOR


;ROUTINE TO DUMP THE SYSTEM. CALL WITH INITIAL FILESPEC ON
;WHICH TO DUMP IN THE FILESPEC AREA.  ASKS THE USER FOR A NEW
;FILESPEC IF ERRORS ARE DETECTED.
;CALL:	PUSHJ	P,DODUMP
;RETURN+1 ALWAYS WITH FL.SDT SET IN S IF DUMP WAS SUCCESSFUL

ILLSPC:	MOVEI	T1,[ASCIZ/?Only device may be specified for dump
/]
	PUSHJ	P,PRMSG		;PRINT MESSAGE
ASKSTR:	TLO	S,(FL.1CM)	;FORCE PARSE FROM COMMAND BUFFER
	MOVEI	T1,[ASCIZ/Structure on which to dump: /]
	MOVEI	T2,[ASCIZ/DSK:/]
	PUSHJ	P,REDLIN	;ASK WHERE HE WANTS THE DUMP
	PUSHJ	P,PARSE		;PARSE THE COMMAND
	  JRST	ASKSTR		;TRY AGAIN
	TLZ	S,(FL.1CM)	;CLEAR COMMAND FLAG
	TRNN	S,FR.ALL	;SEE ANYTHING AT ALL?
	POPJ	P,		;NO, LONE CR MEANS NO DUMP

DODUMP:	TRNE	S,FR.FIL!FR.EXT!FR.PTH	;ANYTHING BUT DEVICE SPECIFIED?
	JRST	ILLSPC		;YES, THIS IS A RESTRICTION TO MAKE IT FAST
	MOVE	T1,[SIXBIT/CRASH/] ;FILENAME IS CRASH
	MOVEM	T1,FILNAM	;STORE IT BACK
	TLNN	S,(FL.WLD)	;WILD STR?
	JRST	DODUM3		;NO, USE THE ONE HE SAID
	MOVSI	P1,-.SDMAX	;BUILD AOBJN POINTER TO SDLTAB
DODUM2:	SKIPL	T1,SDLTAB(P1)	;GET ADDRESS OF NEXT TABLE
	JRST	DODUM5		;NONE THERE, TRY NEXT
	MOVE	T1,.SDBNM(T1)	;GET NAME OF STR
	MOVEM	T1,DEV		;STORE STR NAME TO TRY THIS TIME
	HRRZM	P1,SDLPOS	;STORE POSITION IN SYSTEM DUMP LIST
DODUM3:	TLZA	S,(FL.OVW)	;DON'T ALLOW OVERWRITING
DODUM4:	TLO	S,(FL.OVW)	;OVERWRITE IF HE SAYS TO
	TLNE	S,(FL.SSD)
	SKIPA	T1,[[ASCIZ/[Suspending system on /]]
	MOVEI	T1,[ASCIZ/[Dumping on /]
	PUSHJ	P,PRMSG		;TELL WHAT'S HAPPENING
	PUSHJ	P,PRFILE	;AND WHAT THE FILE IS
	PUSHJ	P,PRRBCR	;END THE LINE
	PUSHJ	P,DUMP		;TRY TO DUMP THE MONITOR
	  JRST	DMPERR		;FAILED, ANALYZE ERROR AND TRY TO RECOVER
	TLO	S,(FL.SDT)	;FLAG IT AS SUCCESSFUL
	POPJ	P,		;COMPLETED SUCCESSFULLY, RETURN
DODUM5:	AOBJN	P1,DODUM2	;LOOP FOR ALL STRS IN THE SDL
	MOVEI	T1,[ASCIZ/?Unable to dump on any structure in the system dump list
/]
	PUSHJ	P,PRMSG		;PRINT MESSAGE
	MOVEI	T1,[ASCIZ/Do you want to keep this dump? /]
	MOVEI	T2,[ASCIZ/No/]
	PUSHJ	P,ASKYN		;ASK HIM WITH DEFAULT ANSWER
	  POPJ	P,		;HE SAYS NO
	JRST	ASKSTR		;ASK ON WHAT STR TO DUMP
;HERE IF AN ERROR IS DETECTED IN THE DUMP OR LOAD.  USE THE ERROR
;CODE RETURNED IN T1 TO INDEX INTO EMSTAB AND PRINT A MESSAGE.
;FOR DUMP, INDEX INTO DMPDSP AND DISPATCH TO THE ROUTINE TO
;HANDLE THE ERROR.

LODERR:	TLOA	S,(FL.CMD!FL.LDE) ;INSURE NEXT READ IS FROM TTY
DMPERR:	TLZ	S,(FL.LDE)	;CLEAR BIT FOR DUMP ERRORS
	PUSH	P,T1		;SAVE CODE FOR LATER
	HRRZ	T1,EMSTAB(T1)	;GET MESSAGE ADDRESS
	PUSHJ	P,PRMSG		;PRINT IT
	PUSHJ	P,PRFILE	;PRINT FILENAME
	PUSHJ	P,PRCRLF	;END THE LINE
	POP	P,T1		;RESTORE ERROR CODE
IFN FTKI10,<
	CONSZ	APR,IP.PAR!IP.NXM ;NXM OR PARITY ERROR?
>
IFN FTKL10,<
	CONSZ	APR,LP.SBE!LP.NXM!LP.PAR ;NXM OR PARITY ERROR?
>
IFN FTKS10,<
	CONSZ	APR,SP.NXM!SP.HMP ;NXM OR PARITY ERROR?
>
	JRST	DMPER1		;YES
	TLNN	S,(FL.LDE)	;SKIP IF LOAD ERROR
	SKIPA	T1,DMPDSP(T1)	;GET DISPATCH ADDRESSES FOR DUMP
	MOVE	T1,LODDSP(T1)	;DITTO FOR LOAD
	TLNN	S,(FL.WLD)	;DOING WILD STR?
	MOVSS	T1		;YES, USE LH DISPATCH ADDRESSES
	JRST	(T1)		;GO RECOVER

;HERE ON A NXM OR PARITY ERROR DETECTED IN THE CONI APR TO PRINT THE
;APR STATUS AND GIVE UP.

DMPER1:	MOVEI	T1,[ASCIZ/?NXM or memory parity error detected/]
	PUSHJ	P,PRMSG		;TELL WHAT HAPPENED
	PUSHJ	P,PRTAPR	;PRINT APR STATUS
	CONO	APR,AP0NUL##	;RESET THE BITS
	TLO	S,(FL.DEF!FL.CMD) ;NO DEFAULTS, READ FROM CTY
	POPJ	P,		;AND GIVE UP
;TABLE OF ERROR MESSAGES INDEXED BY THE ERROR CODE RETURNED IN T1.

EMSTAB:	[ASCIZ/%Structure not found for /]
	[ASCIZ/%File not found /]
	[ASCIZ/%Unprocessed dump on /]
	[ASCIZ/%Unexpected end-of-file on /]
	[ASCIZ\%I/O error on \]
	[ASCIZ/%Bad directory format for /]
	[ASCIZ/%Memory configuration too complicated for /]
EMSTBL==.-EMSTAB


;DISPATCH TABLES INDEXED BY ERROR CODE.  LH GIVES THE DISPATCH ADDRESS
;IF AN EXPLICIT STRUCTURE WAS GIVEN, RH GIVES THE DISPATCH ADDRESS IF
;THE STRUCTURE WAS WILD (USE SYSTEM DUMP LIST)

DMPDSP:	XWD	ASKSTR,DODUM5	;STRUCTURE NOT FOUND
	XWD	ASKSTR,DODUM5	;FILE NOT FOUND
	XWD	STRFUL,DODUM5	;UNPROCESSED DUMP
	XWD	ASKSTR,DODUM5	;UNEXPECTED EOF
	XWD	ASKSTR,DODUM5	;I/O ERROR
	XWD	ASKSTR,DODUM5	;BAD DIRECTORY FORMAT
	XWD	ASKSTR,DODUM5	;MEMORY CONFIGURATION TOO COMPLICATED
DMPDSL==.-DMPDSP

LODDSP:	XWD	CPOPJ,DOLOA4	;STRUCTURE NOT FOUND
	XWD	CPOPJ,DOLOA4	;FILE NOT FOUND
	XWD	CPOPJ,DOLOA4	;UNPROCESSED DUMP
	XWD	CPOPJ,DOLOA4	;UNEXPECTED EOF
	XWD	CPOPJ,DOLOA4	;I/O ERROR
	XWD	CPOPJ,DOLOA4	;BAD DIRECTORY FORMAT
	XWD	CPOPJ,DOLOA4	;MEMORY CONFIGURATION TO COMPLICATED
LODDSL==.-LODDSP


IF2 <IFN EMSTBL-DMPDSL+LODDSL-ERRTBL,<
PRINTX ?Discrepency in lengths of EMSTAB, DMPDSP, LODDSP, ERRTAB
>>


;HERE IF AN EXPLICIT STR WAS GIVEN AND AN UNPROCESSED DUMP WAS FOUND
;ON THAT STR.

STRFUL:	MOVEI	T1,[ASCIZ/Do you want to overwrite it? /]
	MOVEI	T2,[ASCIZ/No/]
	PUSHJ	P,ASKYN
	  JRST	ASKSTR
	JRST	DODUM4
;ROUTINE TO DUMP THE SYSTEM ONTO STR:CRASH.EXE[1,4].  DOES 5
;1 BLOCK TRANSFERS TO WRITE THE 4 BLOCKS OF THE DIRECTORY PLUS WORDS
;0-177 OF PAGE 0 (SINCE THE RH20 CAN'T READ/WRITE ADDRESS 0) AND THEN DOES
;AS FEW TRANSFERS AS NECESSARY FOR EACH GROUP POINTER IN RIB
;GENERALLY ONLY 1).  CALL WITH STRUCTURE NAME IN DEV.
;CALL:	PUSHJ	P,DUMP
;RETURN+1 IF ERROR DETECTED WITH ERROR CODE IN T1
;RETURN+2 IF SUCCESSFUL

DUMP:	PUSHJ	P,SAVE2		;SAVE P1-P2
	PUSHJ	P,FNDCRS	;FIND CRASH.EXE FOR THIS STR
	  POPJ	P,		;NOT FOUND
	MOVEI	T1,RIPDMP##	;GET "UNPROCESSED DUMP BIT"
	TLNN	S,(FL.OVW)	;DOES CALLER CARE?
	TDNN	T1,RIB+RIBSTS##	;YES, IS BIT SET IN RIB?
	CAIA			;NO, OR DOESN'T CARE
	JRST	UPDERR		;YES, GIVE ERROR RETURN
	TLNN	S,(FL.SSD)	;DON'T SET BIT IF SYSTEM SLEEP DUMP
	IORM	T1,RIB+RIBSTS##	;SET BIT IN RIB
	PUSHJ	P,WRTRIB	;REWRITE RIB
	  POPJ	P,		;FAILED
	PUSHJ	P,CLRBUF	;CLEAR BUFFER AREA
	MOVSI	P3,-BLKSIZ	;MAKE AOBJP POINTER TO BUF
	MOVEI	P4,1		;FIRST FILE PAGE IS 1
	MOVEI	P2,0		;FIRST CORE PAGE IS 0
DUMP1:	PUSHJ	P,FNDPGS	;FIND NEXT GROUP OF CONTIGUOUS PAGES
	JUMPLE	P1,DUMP3	;DONE IF NONE FOUND
	MOVE	T1,P1		;COPY NUMBER OF PAGES TO T1
	SUBI	T1,1		;REPEAT COUNT FOR LAST HUNK
	ROT	T1,-^D9		;NUMBER OF 256K HUNKS+REPEAT COUNT IN LH
	MOVEI	T2,1(T1)	;T2:=NUMBER OF DESCRIPTORS
DUMP2:	AOBJP	P3,MCCERR	;GO IF TOO MANY DESCRIPTORS
	HRRZM	P4,BUF(P3)	;STORE FILE PAGE NUMBER IN BUF
	MOVEI	T3,(P2)		;COPY CORE PAGE NUMBER TO T3
	HRLI	T3,777000	;512 PAGES IN THIS HUNK
	AOBJP	P3,MCCERR	;GO IF TOO MANY DESCRIPTORS
	MOVEM	T3,BUF(P3)	;STORE IN BUFFER
	ADDI	P2,<^D256*^D1024>/PAGSIZ ;INCR CORE PAGE
	ADDI	P4,<^D256*^D1024>/PAGSIZ ;DITTO FOR FILE PAGE
	SOJG	T2,DUMP2	;LOOP FOR ALL DESCRIPTORS
	HLLM	T1,BUF(P3)	;CORRECT REPEAT COUNT IN LAST DESCRIPTOR
	LSH	T1,-<^D9+^D18>	;RIGHT JUSTIFY REPEAT COUNT
	MOVNI	T1,-777(T1)	;HAVE TO BACK OFF ON CORE AND FILE PAGE
	SUBI	P2,(T1)		;  NUMBERS TO REFLECT THE (POSSIBLY)
	SUBI	P4,(T1)		;  PARTIAL ALLOCATION IN THE LAST DESCRIPTOR
	JRST	DUMP1		;LOOP FOR MORE
DUMP3:	MOVE	T1,[SV.END,,1]	;GET END OF DESCRIPTOR MARKER
	AOBJP	P3,MCCERR	;GO IF TOO MANY DESCRIPTORS
	MOVEM	T1,BUF(P3)	;STORE IN BUFFER
	HRLI	P3,SV.DIR	;MAKE P3 BE 1ST WORD OF DIRECTORY
	MOVEM	P3,BUF		;AND STORE IT THERE
	PUSHJ	P,WRTBUF	;WRITE BUFFER TO FILE
	  POPJ	P,		;NO POINTERS OR WRITE FAILURE
	PUSHJ	P,CLRBUF	;CLEAR BUFFER AGAIN
	MOVEI	P1,3		;NEED TO WRITE 3 BLOCKS OF ZEROS
DUMP4:	PUSHJ	P,WRTBUF	;  TO COMPLETE DIRECTORY
	  POPJ	P,		;NO POINTERS OR WRITE FAILURE
	SOJG	P1,DUMP4	;LOOP FOR ALL
	MOVE	T1,[.VPAG0,,BUF] ;SETUP TO BLT WORD 0-177 TO BUF
	BLT	T1,BUF+BLKSIZ-1 ;DO SO
	PUSHJ	P,WRTBUF	;WRITE IT
	  POPJ	P,		;NO POINTERS OR WRITE FAILURE
	MOVEI	P2,0		;START WITH ADDRESS 0
DUMP5:	LSH	P2,W2PLSH##	;CONVERT TO PAGE NUMBER
	PUSHJ	P,FNDPGS	;FIND NEXT GROUP OF CONTIGUOUS PAGES
	JUMPLE	P1,CPOPJ1	;DONE IF NO MORE
	LSH	P2,P2WLSH##	;CONVERT BACK TO ADDRESS
	LSH	P1,P2BLSH	;CONVERT PAGES TO BLOCKS
	JUMPN	P2,DUMP6	;GO IF NOT DOING PAGE ZERO
	ADDI	P2,BLKSIZ	;COMPENSATE FOR WORDS 0-177
	SUBI	P1,1		;  WHICH WERE WRITTEN ABOVE
DUMP6:	JUMPLE	P1,DUMP5	;LOOP IF NO MORE BLOCKS IN THIS CHUNK
	MOVE	T1,P1		;COPY NUMBER OF BLOCKS WE WANT TO XFER
	PUSHJ	P,SELBLK	;SETUP TO DO THAT MANY
	  JRST	EOFERR		;RAN OUT OF POINTERS
	MOVE	R,P2		;START AT THIS ADDRESS
	MOVE	P1,T1		;COPY NUMBER LEFT INTO P1 FOR LOOP TEST
	MOVE	T1,M		;GET NUMBER OF BLOCKS WE CAN DO
	LSH	T1,B2WLSH	;CONVERT TO WORDS
	ADD	P2,T1		;INCREMENT ADDRESS FOR NEXT TIME
	PUSHJ	P,@WRTTAB(W)	;DO THE WRITE
	  JRST	IOFERR		;WRITE ERROR
	JRST	DUMP6		;LOOP FOR ALL OF CORE
	SUBTTL	RELOAD MONITOR


;ROUTINE TO RELOAD THE MONITOR FROM A FILE ON DISK.  CALL WITH
;THE FILESPEC FROM WHICH TO LOAD SETUP IN THE FILESPEC AREA.
;CALL:	PUSHJ	P,DOLOAD
;RETURN+1 IF ERRORS DETECTED WITH MESSAGE ALREADY ISSUED
;RETURN+2 IF LOAD WAS SUCCESSFUL

DOLOAD:	MOVE	T1,[SIXBIT/SYSTEM/] ;DEFAULT FILENAME IS SYSTEM
	TRNN	S,FR.FIL	;SEE A FILENAME?
	MOVEM	T1,FILNAM	;NO, USE DEFAULT
	TLNN	S,(FL.WLD)	;WILD STR?
	JRST	DOLOA3		;NO, USE THE ONE HE GAVE
	MOVSI	P1,-.SDMAX	;BUILD AOBJN POINTER TO SDLTAB
DOLOA2:	SKIPL	T1,SDLTAB(P1)	;GET ADDRESS OF NEXT TABLE
	JRST	DOLOA4		;NONE THERE, TRY NEXT
	MOVE	T1,.SDBNM(T1)	;GET NAME OF STR
	MOVEM	T1,DEV		;STORE STR NAME
	HRRZM	P1,SDLPOS	;STORE POSITION IN SYSTEM DUMP LIST
DOLOA3:	MOVEI	T1,[ASCIZ/[Loading from /]
	PUSHJ	P,PRMSG		;TELL WHAT'S HAPPENING
	PUSHJ	P,PRFILE	;PRINT FILENAME
	PUSHJ	P,PRRBCR	;END THE LINE
	PUSHJ	P,LOAD		;LOAD IT
	  JRST	LODERR		;GIVE ERROR MESSAGE AND RETURN
	JRST	CPOPJ1		;GIVE SKIP RETURN
DOLOA4:	AOBJN	P1,DOLOA2	;TRY NEXT
	TLO	S,(FL.DEF)	;PREVENT LOOP ASKING FUTILE QUESTIONS
	MOVEI	T1,[ASCIZ/?No file found on system dump list
/]
	PJRST	PRMSG		;GIVE ERROR MESSAGE AND RETURN
;ROUTINE TO LOAD A NEW MONITOR INTO CORE. CALL WITH THE FILESPEC AREA
;CONTAINING THE FILE TO BE LOADED.
;CALL:	PUSHJ	P,LOAD
;RETURN+1 IF ERROR DETECTED WITH ERROR CODE IN T1
;RETURN+2 IF SUCCESSFUL

LOAD:	PUSHJ	P,SAVE2		;SAVE P1-P2
	PUSHJ	P,FNDMON	;FIND THE MONITOR, READ EXE DIRECTORY
	  POPJ	P,		;FAILED, RETURN CODE IN T1
	TLON	S,(FL.MOV)	;ALREADY MOVED MONBTS?
	PUSHJ	P,MOVBTS	;NO, DO SO NOW
	MOVEI	P3,0		;START WITH CORE ADDRESS OF ZERO
LOAD1:	LDB	P2,[POINT 9,1(P1),8] ;GET REPEAT COUNT FOR THIS ENTRY
	ADDI	P2,1		;MAKE IT TOTAL PAGE COUNT
	LSH	P2,P2BLSH	;COMPUTE BLOCK COUNT
	HRRZ	P4,0(P1)	;GET FILE PAGE NUMBER
	LSH	P4,P2BLSH	;COMPUTE FILE BLOCK NUMBER
	JUMPE	P4,[LSH  P2,B2WLSH ;IF ALLOCATED BUT ZERO PAGE, COMPUTE
		    ADD  P3,P2	;  NUMBER OF WORDS IN THIS DESCRIPTOR
		    JRST LOAD6]	;  UPDATE CORE ADDRESS AND DO NEXT ONE
	CAMGE	P4,BLKNUM	;PAGE NUMBERS IN THE EXE DIRECTORY MUST
	JRST	BDFERR		;  BE MONOTONICALLY INCREASING
	PUSHJ	P,POSFIL	;POSITION FILE TO THAT BLOCK
	  POPJ	P,		;HIT EOF
	SKIPGE	0(P1)		;THIS A HIGH SEG PAGE?
	JRST	LOAD5		;YES, READ IN JUST AFTER LOW SEG
	HRRZ	P3,1(P1)	;GET CORE PAGE NUMBER
	LSH	P3,P2WLSH##	;COMPUTE CORE ADDRESS
	JUMPN	P3,LOAD5	;GO IF NOT ZERO
	HRL	P4,P2		;REMEMBER NUMBER OF BLOCKS
	MOVEI	P2,1		;  AND READ ONE BLOCK
LOAD4:	MOVEI	P3,BLKSIZ	;  STARTING AT 200
LOAD5:	PUSHJ	P,REDBLK	;READ THE SPECIFIED BLOCKS
	  POPJ	P,		;FAILED
	HLRZ	P2,P4		;WERE WE READING 0-177
	JUMPE	P2,LOAD6	;  INTO 200-377?
	MOVE	T1,[.VPAG0+BLKSIZ+40,,.VPAG0+40] ;YES, SETUP TO MOVE
	BLT	T1,.VPAG0+BLKSIZ-1 ;THEM TO WHERE THEY BELONG
	HRRZS	P4		;CLEAR FLAG
	SOJG	P2,LOAD4	;DO THE REST IF MORE
LOAD6:	AOBJN	P1,.+1		;SKIP PAST FIRST OF 2 WORDS
	AOBJN	P1,LOAD1	;AND DO NEXT DESCRIPTOR
	JRST	CPOPJ1		;GIVE SKIP RETURN
	SUBTTL	FILE SEARCH SUBROUTINES


;ROUTINE TO FIND CRASH.EXE ON A STRUCTURE AND RETURN THE RIB IN
;RIB.  USES THE SDL IN-CORE DATA BASE IF AT ALL POSSIBLE TO AVOID
;DISK ACCESSES.  CALL WITH DEV CONTAINING THE STRUCTURE NAME.
;CALL:	PUSHJ	P,FNDCRS
;RETURN+1 IF FILE NOT FOUND WITH ERROR CODE IN T1
;RETURN+2 IF FILE FOUND AND RIB SETUP IN RIB
;DESTROYS P3-P4

FNDCRS:	TRNN	S,FR.FRC	;/FORCE SPECIFIED?
	PUSHJ	P,SDLLUK	;NO, TRY TO FIND STR IN SDL
	  PJRST	FNDFIL		;FAILED, DO IT THE HARD WAY
	LDB	T1,SDYCRU	;GET UNIT IN STR ON WHICH RIB OF CRASH.EXE EXISTS
	MOVEM	T1,LUNPOS	;STORE
	PUSH	P,T4		;NEED POINTER TO TABLE LATER
	PUSHJ	P,SDLRED	;FIND UNIT, READ HOM BLOCK
	  JRST	[POP	P,(P)	;FLUSH THE STACK
		 JRST	SNTERR]	;GIVE ERROR AND RETURN
	POP	P,T4		;RESTORE POINTER TO TABLE
	LDB	F,SDYCRB	;GET BLOCK CONTAINING RIB OF CRASH.EXE
	PUSHJ	P,REDRIB	;READ IT AND RETURN
	  JRST	FNTERR		;FILE NOT FOUND
	JRST	CPOPJ1		;GIVE SKIP RETURN


;ROUTINE TO FIND THE FILE CONTAINING THE MONITOR SPECIFIED IN THE
;FILESPEC AREA, READ THE EXE DIRECTORY INTO BUF AND SETUP TO READ
;THE FILE.
;CALL:	PUSHJ	P,FNDMON
;RETURN+1 IF FAILED WITH ERROR CODE IN T1
;RETURN+2 IF SUCCESSFUL WITH
;	  P1/AOBJN POINTER TO EXE DIRECTORY DESCRIPTORS
;DESTROYS P3-P4

FNDMON:	PUSHJ	P,FNDFIL	;FIND THE FILE
	  POPJ	P,		;FILE NOT FOUND
	PUSHJ	P,REDBUF	;READ 1ST BLOCK OF EXE DIRECTORY
	  POPJ	P,		;FAILED
	HLRZ	T1,BUF		;GET CODE
	HRRZ	P1,BUF		;AND LENGTH OF DIRECTORY
	CAIN	T1,SV.DIR	;THIS AN EXE FILE?
	CAILE	P1,BLKSIZ-1	;AND NOT TOO LONG?
	JRST	BDFERR		;NO, BAD DIRECTORY FORMAT
	MOVNI	P1,-1(P1)	;BUILD -VE COUNT FOR AOBJN POINTER
	HRLI	P1,BUF+1	;AND FIRST WORD
	MOVSS	P1		;MAKE IT AN AOBJN POINTER TO BUF
	JRST	CPOPJ1		;GIVE SKIP RETURN
;ROUTINE TO FIND A FILE AND SETUP ITS RIB IN RIB.  CALL WITH
;FILESPEC AREA SETUP.
;CALL:	PUSHJ	P,FNDFIL
;RETURN+1 IF NOT FOUND OR READ ERROR ON DIRECTORY WITH CODE IN T1
;RETURN+2 IF FILE FOUND
;DESTROYS P3-P4

FNDFIL:	PUSHJ	P,SAVE2		;SAVE P1-P2
	PUSHJ	P,FNDMFD	;FIND THE MFD
	  JRST	SNTERR		;FAILED
	MOVEI	P1,0		;SETUP LOOP POINTER TO PTHBLK
FNDFI1:	SKIPN	P3,PTHBLK(P1)	;GET NEXT UFD/SFD FROM PATH BLOCK
	MOVE	P3,FILNAM	;FOUND END, USE FILENAME
	MOVEI	P4,'UFD'	;ASSUME EXTENSION IS UFD
	JUMPE	P1,FNDFI2	;GO IF CORRECT
	MOVEI	P4,'SFD'	;ASSUME SFD
	SKIPN	PTHBLK(P1)	;DONE WITH PATH BLOCK?
	HLRZ	P4,EXT		;YES, USE REAL EXTENSION
FNDFI2:	PUSHJ	P,SRCHFD	;SEARCH THE DIRECTORY
	  JRST	FNTERR		;FILE NOT FOUND
	PUSH	P,T2		;SAVE BLOCK IN UNIT OF RIB
	PUSHJ	P,FNDLUN	;FIND SPECIFIED UNIT
	  JRST	[POP	P,(P)	;FLUSH STACK
		 JRST	SNTERR]	;GIVE ERROR CODE AND RETURN
	POP	P,F		;RESTORE BLOCK OF RIB
	PUSHJ	P,REDRBP	;READ THE RIB OF THE FILE
	  JRST	FNTERR		;FAILED
	SKIPE	PTHBLK(P1)	;FOUND UFD, ALL SFD'S AND FILE?
	AOJA	P1,FNDFI1	;NO, TRY NEXT LEVEL
	JRST	CPOPJ1		;GIVE SKIP RETURN, RIB SETUP
;ROUTINE TO FIND THE MFD FOR A STRUCTURE.  CALL WITH DEV CONTAINING
;THE STRUCTURE NAME.
;CALL:	PUSHJ	P,FNDMFD
;RETURN+1 IF FAILED
;RETURN+2 IF FOUND WITH MFD RIB IN RIB
;DESTOYS P3-P4

FNDMFD:	TRNN	S,FR.FRC	;/FORCE SPECIFIED?
	PUSHJ	P,SDLLUK	;FIND STR IN IN-CORE TABLES
	  JRST	FNDMF1		;FAILED, DO IT THE HARD WAY
	LDB	T1,SDYMFU	;GET UNIT CONTAINING MFD RIB
	MOVEM	T1,LUNPOS	;STORE IT
	PUSH	P,T4		;NEED POINTER LATER
	PUSHJ	P,SDLRED	;FIND UNIT, READ HOM BLOCK
	  JRST	TPOPJ		;FAILED
	POP	P,T4		;RESTORE POINTER TO SDL BLOCK
	LDB	F,SDYMFB	;GET BLOCK IN UNIT CONTAINING RIB
	JRST	FNDMF3		;JOIN COMMON CODE TO READ RIB

FNDMF1:	SETZM	LUNPOS		;FIND UNIT ZERO OF STRUCTURE
	PUSHJ	P,FNDUNI	;FIND IT
	  POPJ	P,		;FAILED, GIVE UP
	MOVE	T1,HOM+HOMMFD##	;GET BLOCK IN STR CONTAINING MFD RIB
	MOVE	T2,HOM+HOMBSC##	;GET BLOCKS/SUPERCLUSTER
	IMUL	T2,HOM+HOMSCU##	;TIME SUPERCLUSTERS/UNIT
	IDIV	T1,T2		;T1=UNIT, T2=BLOCK IN UNIT OF RIB
	PUSH	P,T2		;SAVE BLOCK NUMBER
	JUMPE	T1,FNDMF2	;GO IF ON UNIT ZERO
	MOVEM	T1,LUNPOS	;STORE UNIT
	PUSHJ	P,FNDUNI	;FIND UNIT
	  JRST	TPOPJ		;FAILED
FNDMF2:	POP	P,F		;RESTORE BLOCK IN UNIT
FNDMF3:	MOVE	P3,[1,,1]	;FILENAME IS [1,,1]
	MOVEI	P4,'UFD'	;EXTENSION IS UFD
	PJRST	REDRBP		;READ RIB OF MFD AND RETURN
;ROUTINE TO SEARCH A UFD OR SFD FOR A FILE.  CALL WITH RIB SETUP
;IN RIB.
;CALL:
;	P3/FILENAME,	P4/0,,EXTENSION
;	PUSHJ	P,SRCHFD
;RETURN+1 IF FILE NOT FOUND
;RETURN+2 IF FOUND
;RETURNS T1=UNIT IN STR, T2=BLOCK IN UNIT OF RIB FOR FILE.

SRCHFD:	PUSHJ	P,REDBUF	;READ THE NEXT BLOCK OF THE DIRECTORY
	  POPJ	P,		;EOF OR READ ERROR
	MOVSI	T1,-BLKSIZ	;BUILD AOBJN POINTER TO BLOCK
SRCHF1:	HLRZ	T2,BUF+1(T1)	;GET EXTENSION
	CAMN	P3,BUF(T1)	;FILENAMES MATCH?
	CAME	P4,T2		;YES, EXTENSIONS MATCH?
	AOBJN	T1,.+2		;NO, INCREMENT PAST FILENAME
	JRST	SRCHF2		;YES
	AOBJN	T1,SRCHF1	;LOOP FOR ALL OF THIS BLOCK
	JRST	SRCHFD		;TRY NEXT BLOCK
SRCHF2:	HRRZ	T1,BUF+1(T1)	;GET CFP FROM DIRECTORY
	IDIV	T1,HOM+HOMSCU##	;T1=UNIT, T2=SUPERCLUSTER IN UNIT
	IMUL	T2,HOM+HOMBSC##	;T2=BLOCK IN UNIT
	JRST	CPOPJ1		;GIVE SKIP RETURN
	SUBTTL	BLOCK READ/WRITE SUBROUTINES


;ROUTINE TO WRITE BUF/RIB TO THE OUTPUT FILE.  CALL WITH RIB OF FILE
;SETUP.
;CALL:	PUSHJ	P,WRTBUF  -OR-  PUSHJ P,WRTRIB
;RETURN+1 IF ERROR DETECTED WITH ERROR CODE IN T1
;RETURN+2 IF SUCCESSFUL

WRTRIB:	MOVEI	R,RIB		;POINT TO RIB
	AOS	SAVSIZ		;COMPENSATE FOR SELBLK DECREMENTING SAVSIZ
	TLZA	S,(FL.RIB)	;FORCE SELBLK TO WRITE THE RIB
WRTBUF:	MOVEI	R,BUF		;POINT TO BUF
	MOVEI	T1,1		;NUMBER OF BLOCKS IS 1
	PUSHJ	P,SELBLK	;SETUP TO DO THAT MANY
	  JRST	EOFERR		;FILE MUST BE REALLY SCREWED UP
	JUMPN	T1,EOFERR	;DITTO
	PUSHJ	P,VRTWRT	;WRITE THE BLOCK
	  JRST	IOFERR		;WRITE ERROR
	JRST	CPOPJ1		;GIVE SKIP RETURN


;ROUTINE TO READ ONE BLOCK FROM THE INPUT FILE INTO BUF.  CALL WITH
;RIB OF FILE SETUP.
;CALL:	PUSHJ	P,REDBUF
;RETURN+1 IF ERROR DETECTED WITH ERROR CODE IN T1
;RETURN+2 IF SUCCESSFUL

REDBUF:	MOVEI	R,BUF		;POINT TO BUF
	MOVEI	T1,1		;NUMBER OF BLOCKS IS 1
	PUSHJ	P,SELBLK	;SETUP TO READ
	  JRST	EOFERR		;HIT EOF
	JUMPN	T1,EOFERR	;DITTO
	PUSHJ	P,VRTRED	;READ THE BLOCK
	  JRST	IOFERR		;READ ERROR
	JRST	CPOPJ1		;GIVE SKIP RETURN
;ROUTINE TO POSITION AN EXE FILE SO THAT THE NEXT READ WILL READ
;THE BLOCKS THAT WE WANT.
;CALL:
;	P4/DESIRED BLOCK IN FILE
;	PUSHJ	P,POSFIL
;RETURN+1 IF EOF ENCOUNTERED WITH ERROR CODE IN T1
;RETURN+2 WITH FILE POSITIONED CORRECTLY

POSFIL:	CAMN	P4,BLKNUM	;AT THE RIGHT BLOCK IN THE FILE NOW?
	JRST	CPOPJ1		;YES, GIVE SKIP RETURN
	MOVEI	T1,1		;DO ONE BLOCK
	PUSHJ	P,SELBLK	;USETI .+1
	  JRST	EOFERR		;CANNOT HAVE EOF HERE
	JRST	POSFIL		;TRY AGAIN


;ROUTINE TO READ ONE OR MORE BLOCKS FROM AN EXE FILE.
;CALL:	P2/NUMBER OF BLOCKS TO READ
;	P3/CORE ADDRESS OF WHERE TO READ FIRST BLOCK
;	P4/FILE BLOCK NUMBER OF FIRST BLOCK
;	PUSHJ	P,REDBLK
;RETURN+1 IF ERROR WITH ERROR CODE IN T1
;RETURN+2 IF SUCCESSFUL WITH P3 AND P4 UPDATED TO REFLECT THE TRANSFER

REDBLK:	JUMPLE	P2,CPOPJ1	;READ ALL BLOCKS YET?
	MOVE	T1,P2		;NO, GET NUMBER OF BLOCKS TO TRANSFER
	PUSHJ	P,SELBLK	;SETUP TO DO THAT MANY
	  JRST	EOFERR		;CAN'T HAVE EOF
	MOVE	R,P3		;PUT CORE ADDRESS IN R
	MOVE	P2,T1		;COPY BLOCKS WE COULDN'T DO FOR NEXT TIME
	ADD	P4,M		;INCREMENT FILE BLOCK NUMBER
	MOVE	T1,M		;GET NUMBER OF BLOCKS TO DO
	LSH	T1,B2WLSH	;CONVERT TO WORDS
	ADD	P3,T1		;UPDATE CORE ADDRESS
	PUSHJ	P,@REDTAB(W)	;READ THE SPECIFIED BLOCKS
	  JRST	IOFERR		;I/O ERROR
	JRST	REDBLK		;CONTINUE FOR ALL
;ROUTINE TO FIND A UNIT AND READ IT'S HOM BLOCK. CALL WITH LUNPOS
;CONTAINING THE LOGICAL UNIT NUMBER AND DEV CONTAINING THE DEVICE
;NAME.
;CALL:
;	T1/LOGICAL UNIT IN STRUCTURE
;	PUSHJ	P,FNDLUN
;RETURN+1 IF NOT FOUND
;RETURN+2 IF FOUND WITH HOM BLOCK IN HOM

FNDLUN:	EXCH	T1,LUNPOS	;STORE UNIT, GET CURRENT
	CAMN	T1,LUNPOS	;SAME AS CURRENT ONE?
	JRST	CPOPJ1		;YES, ALREADY THERE
	TRNN	S,FR.FRC	;DO IT THE HARD WAY IF /FORCE SPECIFIED
	PUSHJ	P,SDLLUK	;TRY TO FIND STR IN SDL
	  PJRST	FNDUNI		;FAILED, DO IT THE HARD WAY
	PJRST	SDLRED		;READ HOME BLOCK AND RETURN


;ROUTINE TO FIND A UNIT BY EXHAUSTIVE SEARCH.  CALL WITH LUNPOS
;CONTAINING THE LOGICAL UNIT NUMBER IN THE STRUCTURE, DEV CONTAINING
;THE STRUCTURE NAME AND SDLPOS CONTAINING THE POSITION IN THE SYSTEM
;DUMP LIST.
;CALL:	PUSHJ	P,FNDUNI
;RETURN+1 IF NOT FOUND
;RETURN+2 IF FOUND WITH HOM BLOCK IN HOM

FNDUNI:	MOVSI	J,-DVCTBL	;AOBJN POINTER TO DEVICE CODE TABLE
FNDUN1:	MOVSI	U,-MAXUNI	;AOBJN POINTER FOR EACH UNIT
FNDUN2:	HLRZ	W,DVCTAB(J)	;SETUP TYPE OFFSET
	PUSHJ	P,SETIOT	;SETUP I/O INSTRUCTIONS
	PUSHJ	P,REDHOM	;READ HOM BLOCK FOR UNIT
	  JRST	FNDUN3		;FAILED OR BAD
	MOVE	T1,HOM+HOMLUN## ;GET LOGICAL UNIT NUMBER OF THIS STR
	MOVE	T2,HOM+HOMSNM##	;GET STR NAME
	CAMN	T1,LUNPOS	;UNIT NUMBER MATCH?
	CAME	T2,DEV		;YES, DOES IT?
	JRST	FNDUN3		;NO
	SKIPL	T1,HOM+HOMSDL##	;GET POSITION IN SYSTEM DUMP LIST
	SUBI	T1,1		;CONVERT FROM 1...N TO 0...N-1
	TLNE	S,(FL.WLD)	;NEED TO MATCH THIS?
	CAMN	T1,SDLPOS	;YES, DOES IT?
	JRST	[MOVEM T1,SDLPOS ;STORE POSTION
		 JRST  CPOPJ1]	;AND GIVE SKIP RETURN
FNDUN3:	AOBJN	U,FNDUN2	;LOOP FOR NEXT UNIT
	AOBJN	J,FNDUN1	;LOOP FOR NEXT CONTROLLER
	POPJ	P,		;ERROR RETURN
;ROUTINE TO READ A HOM BLOCK.
;CALL:
;	U/PHYSICAL UNIT NUMBER
;	J/OFFSET INTO DEVICE CODE TABLE
;	W/OFFSET INTO TYPE TABLES
;	PUSHJ	P,REDHOM
;RETURN+1 IF ERROR
;RETURN+2 IF SUCCESSFUL WITH HOM BLOCK IN HOM

REDHOM:	MOVEI	F,LBNHOM##	;ADDRESS OF FIRST HOM BLOCK ON UNIT
REDHO1:	MOVEI	R,HOM		;ADDRESS OF WHERE TO PUT IT
	MOVEI	M,1		;READ 1 BLOCK
	PUSHJ	P,VRTRED	;READ THE BLOCK
	  JRST	REDHO2		;FAILED, TRY SECOND
	MOVS	T1,HOM+HOMNAM##	;GET FIRST WORD OF BLOCK
	MOVE	T2,HOM+HOMCOD##	;GET WORD CONTAINING UNLIKELY CODE
	CAIN	T1,'HOM'	;NAME MUST BE HOM
	CAIE	T2,CODHOM##	;AND MUST MATCH UNLIKELY CODE
	JRST	REDHO2		;ONE FAILED
	CAMN	F,HOM+HOMSLF##	;SELF POINTER MUST MATCH
	SKIPE	HOM+HOMREF##	;AND MUST NOT NEED REFRESHING
	JRST	REDHO2		;FAILED
	MOVEI	T1,T4		;SETUP HOMCLP AND
	HRRM	T1,HOM+HOMCLP##	;  HOMCNP TO POINT
	HRRM	T1,HOM+HOMCNP##	;  TO T4
	JRST	CPOPJ1		;GIVE SKIP RETURN
REDHO2:	CAIE	F,LBNHOM##	;DOING FIRST HOM BLOCK?
	POPJ	P,		;NO, GIVE FAIL RETURN
	MOVEI	F,LB2HOM##	;GET ADDRESS OF 2ND
	JRST	REDHO1		;AND TRY THAT ONE
;ROUTINE TO READ A RIB.
;CALL:
;	U/PHYSICAL UNIT NUMBER
;	J/OFFSET INTO DEVICE CODE TABLE
;	W/OFFSET INTO TYPE TABLES
;	F/BLOCK IN UNIT
;	PUSHJ	P,REDRIB
;RETURN+1 IF READ OR RIB ERROR
;RETURN+2 IF SUCCESSFUL WITH RIB IN RIB
;CALL REDRBP IF FILENAME AND EXTENSION ALREADY IN P3,P4
;DESTROYS P3-P4

REDRIB:	MOVE	P3,FILNAM	;GET FILENAME
	HLRZ	P4,EXT		;AND EXT
REDRBP:	MOVEI	R,RIB		;ADDRESS OF WHERE TO READ IT
	MOVEI	M,1		;READ 1 BLOCK
	PUSHJ	P,VRTRED	;READ THE BLOCK
	  POPJ	P,		;FAILED
	MOVE	T1,RIB+RIBCOD##	;GET WORD CONTAINING UNLIKELY CODE
	CAIN	T1,CODRIB##	;MUST MATCH
	SKIPL	T1,RIB+RIBFIR##	;POINTER MUST BE NEGATIVE
	POPJ	P,		;FAILED
	MOVEM	T1,SAVFIR	;SAVE FOR SELBLK
	MOVE	T1,RIB+RIBNAM##	;GET FILENAME FROM RIB
	CAMN	T1,P3		;MATCH WITH WHAT WE WANT?
	CAME	F,RIB+RIBSLF##	;SELF POINTER MUST MATCH
	POPJ	P,		;ELSE ERROR
	HLRZ	T1,RIB+RIBEXT##	;GET EXTENSION FROM RIB
	MOVE	T2,PTHBLK	;GET PPN FROM PATH BLOCK
	CAIN	P4,'UFD'	;READING A UFD?
	MOVE	T2,[1,,1]	;YES, PPN IS 1,1
	CAMN	T1,P4		;EXTENSION MATCH?
	CAME	T2,RIB+RIBPPN##	;  ALONG WITH PPN?
	POPJ	P,		;NO, ERROR
	TLO	S,(FL.RIB)	;TELL SELBLK THAT FIRST BLOCK IS A RIB
	SETOM	BLKCNT		;AND NO BLOCKS LEFT IN GROUP
	MOVE	T1,RIB+RIBSIZ##	;GET RIBSIZ FROM RIB
	ADDI	T1,BLKSIZ-1	;ROUND UP TO A BLOCK
	LSH	T1,W2BLSH	;CONVERT TO BLOCKS
	TLZE	S,(FL.EXR)	;READING EXTENDED RIB?
	JRST	CPOPJ1		;YES, GIVE SKIP RETURN
	MOVEM	T1,SAVSIZ	;NO, SAVE SIZE FOR SELBLK
	SETZM	BLKNUM		;AND ZERO RELATIVE BLOCK IN FILE
	JRST	CPOPJ1		;AND GIVE SKIP RETURN
;ROUTINE TO SETUP A TRANSFER TO/FROM DISK.
;CALL:
;	T1/NUMBER OF BLOCKS DESIRED TO TRANSFER
;	PUSHJ	P,SELBLK
;RETURN+1 IF EOF DETECTED
;RETURN+2 IF SOME TRANSFER IS POSSIBLE
;RETURNS M/NUMBER OF BLOCKS POSSIBLE, T1/NUMBER OF BLOCKS IN REQUEST
;	 THAT COULDN'T BE TRANSFERED, F/BLOCK ON UNIT OF FIRST BLOCK.
;PRESERVES P3-P4

SELBLK:	TLNN	S,(FL.RIB)	;WANT TO SKIP FIRST RIB BLOCK?
	JRST	SELBL1		;NO
	PUSHJ	P,SAVE2		;SAVE P1-P2
	MOVE	P1,T1		;SAVE REQUESTED TRANSFER IN P1
	MOVEI	T1,1		;AND MAKE IT LOOK LIKE 1 BLOCK
SELBL1:	SKIPLE	BLKCNT		;AND MORE BLOCKS LEFT IN GROUP?
	JRST	SELBL4		;YES, USE THEM
SELBL2:	SKIPL	T2,SAVFIR	;RUN OUT OF POINTERS?
	JRST	SELBL5		;YES, CHECK FOR EXTENDED RIBS
	MOVE	T4,RIB(T2)	;GET NEXT POINTER
	AOBJN	T2,.+1		;INCREMENT POINTER TO POINTERS
	MOVEM	T2,SAVFIR	;STORE POINTER BACK
	LDB	T2,HOM+HOMCNP##	;GET CLUSTER COUNT FROM THIS POINTER
	JUMPN	T2,SELBL3	;GO IF NON-ZERO
	TRZN	T4,RIPNUB##	;UNIT CHANGE POINTER?
	POPJ	P,		;NO, THAT'S AN EOF POINTER
	PUSH	P,T1		;SAVE ARGUMENT
	MOVE	T1,T4		;COPY NEW UNIT NUMBER
	PUSHJ	P,FNDLUN	;FIND IT AND SETUP HOM BLOCK
	  JRST	TPOPJ		;NOT THERE, SIMULATE EOF
	POP	P,T1		;RESTORE ARGUMENT
	JRST	SELBL2		;TRY WITH NEXT POINTER
SELBL3:	IMUL	T2,HOM+HOMBPC##	;COMPUTE NUMBER OF BLOCKS IN GROUP
	SKIPL	SAVFIR		;DOING LAST POINTER IN THIS RIB?
	SUBI	T2,1		;YES, DON'T OVERWRITE SPARE RIB
	TLNE	S,(FL.RIB)	;SKIPPING A RIB?
	AOS	SAVSIZ		;YES, FILE IS 1 MORE BLOCK LONG
	CAMLE	T2,SAVSIZ	;MORE THAN AMOUNT REMAINING IN FILE?
	MOVE	T2,SAVSIZ	;YES, USE THAT
	MOVEM	T2,BLKCNT	;STORE IT
	LDB	T2,HOM+HOMCLP##	;GET CLUSTER ADDRESS OF 1ST CLUSTER IN GROUP
	IMUL	T2,HOM+HOMBPC##	;COMPUTE BLOCK ADDRESS
	MOVEM	T2,BLKADR	;STORE ADDRESS OF BLOCK


				;CONTINUED ON THE NEXT PAGE
SELBL4:	MOVN	M,T1		;GET -VE NUMBER OF BLOCKS IN REQUEST
	SUB	T1,BLKCNT	;SUBTRACT AMOUNT LEFT IN GROUP
	SKIPLE	T1		;REQUEST LARGER THAN AMOUNT WE HAVE?
	MOVN	M,BLKCNT	;YES, USE WHAT WE HAVE
	ADDM	M,BLKCNT	;DECREASE BLKCNT BY APPROPRIATE AMOUNT
	ADDM	M,SAVSIZ	; AND SIZE OF FILE
	MOVNS	M		;SET M TO AMOUNT TO TRANSFER
	MOVE	F,BLKADR	;START AT THIS BLOCK
	ADDM	M,BLKADR	;INCREMENT BLOCK ADDRESS FOR NEXT CALL
	TLNN	S,(FL.RIB)	;SKIPING A RIB?
	ADDM	M,BLKNUM	;NO, UPDATE RELATIVE FILE BLOCK
	SKIPGE	T1		;CAN WE DO THE WHOLE REQUEST?
	MOVEI	T1,0		;YES, RETURN ZERO AS REMAINDER
	TLZN	S,(FL.RIB)	;SKIPPING 1 BLOCK FOR RIB?
	JRST	CPOPJ1		;NO, RETURN TO CALLER
	MOVE	T1,P1		;RESTORE ORIGINAL REQUEST
	JRST	SELBL1		;AND DO THE REAL REQUEST
SELBL5:	SKIPN	RIB+RIBXRA##	;EXTENDED RIB POINTER?
	POPJ	P,		;NO, GIVE EOF RETURN
	PUSH	P,T1		;SAVE ARGUMENT
	PUSH	P,P3		;AND QUASI-PRESERVED REGISTERS
	PUSH	P,P4		;SMASHED BY REDRIB
	LDB	T1,DEYRBU	;GET UNIT ON WHICH NEXT RIB EXISTS
	PUSHJ	P,FNDLUN	;FIND UNIT, SETUP HOM BLOCK
	  JRST	SELBL6		;FAILED GIVE EOF RETURN
	LDB	F,DEYRBA	;GET CLUSTER ADDRESS ON THAT UNIT
	IMUL	F,HOM+HOMBPC##	;CONVERT TO BLOCK ADDRESS
	TLO	S,(FL.EXR)	;DON'T CHANGE SAVSIZ FOR EXTENDED RIBS
	PUSHJ	P,REDRIB	;READ NEW RIB
	  JRST	SELBL6		;FAILED, GIVE EOF RETURN
	POP	P,P4		;RESTORE P4 AND
	POP	P,P3		;  P3
	POP	P,T1		;RESTORE ARGUMENT
	JRST	SELBLK		;AND TRY NEW POINTER FROM THIS RIB
SELBL6:	TLZ	S,(FL.EXR)	;MAKE SURE THIS FLAG IS OFF
IFN FTKL10!FTKS10,<
	ADJSP	P,-3		;BRING STACK INTO SYNC
>
IFN FTKI10,<
	SUB	P,[3,,3]	;HARDER FOR THE KI10
>
	POPJ	P,		;AND GIVE NON-SKIP RETURN
	SUBTTL	SUPPORT SUBROUTINES


;ROUTINE TO CLEAR BUF.
;CALL:	PUSHJ	P,CLRBUF	
;RETURN+1 ALWAYS

CLRBUF:	SETZM	BUF		;CLEAR FIRST WORD
	MOVE	T1,[BUF,,BUF+1]	;SETUP FOR BLT
	BLT	T1,BUF+BLKSIZ-1 ;CLEAR IT ALL
	POPJ	P,		;RETURN


;ROUTINE TO STORE A DEVICE CODE IN ALL I/O INSTRUCTIONS.
;CALL:
;	J/OFFSET INTO DEVICE CODE TABLE
;	PUSHJ	P,SETIOT
;RETURN+1 ALWAYS

SETIOT:
IFN FTKL10!FTKI10,<
	HRRZ	T1,DVCTAB(J)	;GET DEVICE CODE
	MOVSI	T2,-IOTTBL	;BUILD AOBJN POINTER TO IOTTAB
	DPB	T1,[POINT 7,IOTTAB(T2),9] ;STORE DEVICE CODE IN INSTN.
	AOBJN	T2,.-1		;DO THEM ALL
>
	POPJ	P,		;RETURN


;RETURN POINTS TO SET T1 TO AN ERROR CODE AND NON-SKIP RETURN

ERRTAB:
SNTERR:	PJSP	T1,ALLERR	;STRUCTURE NOT FOUND
FNTERR:	PJSP	T1,ALLERR	;FILE NOT FOUND
UPDERR:	PJSP	T1,ALLERR	;UNPROCESSED DUMP
EOFERR:	PJSP	T1,ALLERR	;UNEXPECTED EOF
IOFERR:	PJSP	T1,ALLERR	;I/O ERROR
BDFERR:	PJSP	T1,ALLERR	;BAD DIRECTORY FORMAT
MCCERR:	PJSP	T1,ALLERR	;MEM CONFIG TOO COMPLICATED
ERRTBL==.-ERRTAB
ALLERR:	SUBI	T1,ERRTAB+1	;COMPUTE ERROR CODE
	POPJ	P,		;RETURN
;ROUTINE TO READ DATA INTO A VIRTUAL ADDRESS.
;CALL:
;	R/VIRTUAL ADDRESS
;	M/NUMBER OF BLOCKS TO TRANSFER
;	F/BLOCK ON UNIT
;	U/PHYSICAL UNIT
;	W/OFFSET INTO TYPE TABLE
;	J/OFFSET INTO DEVICE CODE TABLE
;	PUSHJ	P,VRTRED
;RETURN+1 IF ERROR
;RETURN+2 IF SUCCESSFUL

VRTRED:	PUSHJ	P,MAPADR	;CONVERT VIRTUAL TO PHYSICAL ADDRESS
	PJRST	@REDTAB(W)	;DO THE TRANSFER


;ROUTINE TO WRITE DATA FROM A VIRTUAL ADDRESS.  CALL WITH SAME ARGUMENTS
;AS VRTRED.
;CALL:	PUSHJ	P,VRTWRT
;RETURN+1 IF ERROR
;RETURN+2 IF SUCCESSFUL

VRTWRT:	PUSHJ	P,MAPADR	;CONVERT VIRTUAL TO PHYSICAL ADDRESS
	PJRST	@WRTTAB(W)	;DO THE TRANSFER


;ROUTINE TO CONVERT A VIRTUAL ADDRESS TO A PHYSICAL ADDRESS.
;CALL:
;	R/VIRTUAL ADDRESS
;	PUSHJ	P,MAPADR
;RETURN+1 ALWAYS WITH PHYSICAL ADDRESS IN R

MAPADR:
IFN FTKI10,<
	PUSH	P,R		;SAVE VIRTUAL ADDRESS
	ANDI	R,PAGSIZ-1	;KEEP ONLY OFFSET IN PAGE
	EXCH	R,0(P)		;STORE THAT, GET FULL ADDRESS
>
	MAP	R,(R)		;CONVERT TO PHYSICAL ADDRESS
IFN FTKI10,<
	LSH	R,P2WLSH	;CONVERT PAGE NUMBER TO ADDRESS
	IOR	R,0(P)		;INCLUDE OFFSET IN PAGE
	POP	P,(P)		;FLUSH STACK
	TLZ	R,(^-<PG.EPT*PAGSIZ+PAGSIZ-1>) ;KEEP ONLY ADDRESS
>
IFN FTKL10,<
	TLZ	R,(^-<LG.EPT*PAGSIZ+PAGSIZ-1>) ;KEEP ONLY ADDRESS
>
IFN FTKS10,<
	TLZ	R,(^-<SG.EPT*PAGSIZ+PAGSIZ-1>) ;KEEP ONLY ADDRESS
>
	POPJ	P,		;AND RETURN
;ROUTINE TO FIND A STRUCTURE IN THE SYSTEM DUMP LIST IN-CORE
;DATA BASE.  CALL WITH STR NAME IN DEV.
;CALL:	PUSHJ	P,SDLLUK
;RETURN+1 IF STR NOT FOUND
;RETURN+2 IF MATCH FOUND
;RETURNS RH(T3)/POSITION IN SDL, T4/POINTER TO BLOCK FOR THIS STR

SDLLUK:	MOVSI	T3,-.SDMAX	;GET AOBJN POINTER TO SDLTAB
	MOVE	T1,DEV		;GET DEVICE TO LOOK FOR
SDLLU1:	SKIPGE	T4,SDLTAB(T3)	;THIS ENTRY EMPTY?
	CAME	T1,.SDBNM(T4)	;NO, MATCH WITH STR NAME?
	AOBJN	T3,SDLLU1	;NO, LOOP
	JUMPL	T3,CPOPJ1	;GIVE SKIP RETURN IF FOUND
	POPJ	P,		;AND RETURN SKIP/NON-SKIP


;ROUTINE TO SETUP PARAMETERS FROM THE SDL IN-CORE DATA BLOCK.
;CALL WITH LUNPOS CONTAINING THE LOGICAL UNIT NUMBER IN THE STR TO
;SETUP FOR.
;CALL:
;	T4/ADDRESS OF SDL DATA BLOCK
;	PUSHJ	P,SDLRED
;RETURN+1 IF UNIT NOT FOUND ON THIS CPU
;RETURN+2 WITH PARAMETERS SETUP
;RETURNS U=PHYSICAL UNIT NUMBER, J=OFFSET INTO DEVICE CODE TABLE,
;	 W=OFFSET INTO TYPE TABLE, HOM BLOCK FOR UNIT IN HOM

SDLRED:	ADD	T4,LUNPOS	;OFFSET BY UNIT NUMBER
	MOVE	T4,.SDBUN(T4)	;GET UNIT SLOT
	LDB	T3,SDYCPU	;GET CPU NUMBER FOR THIS PORT
	CAMN	T3,CPCPN	;ARE WE ON THAT ONE?
	JRST	SDLRE1		;YES
	MOVSS	T4		;PUT OTHER PORT IN RH
	LDB	T3,SDYCPU	;GET THE OTHER CPU NUMBER
	CAME	T3,CPCPN	;MATCH WITH THAT ONE?
	POPJ	P,		;NO
SDLRE1:	LDB	J,SDYDCO	;GET OFFSET INTO DEVICE CODE TABLE
	HLRZ	W,DVCTAB(J)	;GET OFFSET INTO TYPE TABLES
	LDB	U,SDYPUN	;GET PHYSICAL UNIT NUMBER
	PUSHJ	P,SETIOT	;SETUP I/O INSTRUCTIONS
	PJRST	REDHOM		;READ HOM BLOCK AND RETURN
;ROUTINE TO SAVE P1 AND P2 AND CALL THE CALLER AS A COROUTINE
;WHICH RESTORES P1 AND P2 WHEN THE CALLER RETURNS.
;CALL:	PUSHJ	P,SAVE2
;RETURN+1 ALWAYS

SAVE2:	EXCH	P1,(P)		;GET RETURN, SAVE P1
	PUSH	P,P2		;SAVE P2
	MOVEM	P1,1(P)		;SAVE RETURN
	MOVE	P1,-1(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;CALL CALLER
	  CAIA			;NON SKIP
	AOS	-2(P)		;SKIP RET
	POP	P,P2		;RESTORE P2
	POP	P,P1		;RESTORE P1
	POPJ	P,		;RETURN


;ROUTINE TO SAVE F AND R AND CALL THE CALLER AS A COROUTINE
;WHICH RESTORES F AND R WHEN THE CALLER RETURNS.
;CALL:	PUSHJ	P,SAVFR
;RETURN+1 ALWAYS
SAVFR:	EXCH	F,(P)		;GET RETURN, SAVE F
	PUSH	P,R		;SAVE R
	MOVEM	F,1(P)		;SAVE RETURN
	MOVE	F,-1(P)		;RESTORE F
	PUSHJ	P,@1(P)		;CALL CALLER
	  CAIA			;NON SKIP
	AOS	-2(P)		;SKIP RET
	POP	P,R		;RESTORE R
	POP	P,F		;RESTORE F
	POPJ	P,		;RETURN
IFN FTKL10,<
;ROUTINE TO COPY THE DX20/RP20 MICROCODE POINTED TO BY UCDADR TO THE
;END OF MONBTS SO THAT IT IS PRESERVED ACROSS THIS RELOAD.  AFTER THE
;MOVE, SVUCAD IS SET TO POINT TO THE NEW ADDRESS.
;CALL:	PUSHJ	P,UCDCPY
;RETURN+1 ALWAYS

UCDCPY:	MOVE	T3,.VPAG0+UCDSIZ## ;GET NUMBER PAGES,,NUMBER BYTES
	SKIPN	T2,.VPAG0+UCDADR## ;GET ADDRESS OF UCODE FROM MONITOR
	MOVEI	T3,0		;NO ADDRESS, SO NO SIZE
	HLRZ	T1,T3		;GET NUMBER OF PAGES IN UCODE
	JUMPE	T1,UCDCP1	;DON'T COPY IF BAD ADDRESS OR SIZE
	CAILE	T1,MAXUCD	;DO SANITY CHECK ON SIZE
	JRST	UCDCP1		;TOO LARGE
	MOVEM	T3,SVUCSZ	;SAVE SIZE FOR LATER
	LSH	T2,W2PLSH##	;CONVERT ADDRESS TO PAGE NUMBER
	MOVNS	T1		;MAKE IT NEGATIVE
	ADDM	T1,NEGPGS	;UPDATE NEGPGS FOR SIZE OF UCODE
	HRLZS	T1		;PUT IT IN THE LH FOR AN AOBJN POINTER
IFE FTKLP,<
	HRRI	T1,PM.ACC+PM.WRT(T2) ;GET FIRST MAP SLOT ENTRY
	MOVE	T2,[POINT 18,EPT+.MMOVE] ;USE .VMOVE TO COPY
	IDPB	T1,T2		;MAKE ENOUGH MAP SLOTS ADDRESSABLE
	AOBJN	T1,.-1		;  TO COPY ALL THE UCODE
>
IFN FTKLP,<
	HRLI	T2,(<PM.DCD>B2+PM.WRT) ;GET IMMEDIATE POINTER BITS
	MOVEM	T2,EPT+.MMOVE(T1) ;STORE IN MAP SLOT
	AOS	T2		;INCREMENT PHYSICAL ADDRESS
	AOBJN	T1,.-2		;MAP THEM ALL
>
	MOVE	T1,CPEBB	;GET CURRENT MAPPING
	XCT	CHGEBR		;CAUSE THE PAGE TABLE TO BE FLUSHED
	MOVE	T1,[.VMOVE,,.VBOOT+<MBTPGS*PAGSIZ>] ;GET BLT POINTER
	HLRZ	T2,SVUCSZ	;GET NUMBER OF PAGES IN THE UCODE
	LSH	T2,P2WLSH##	;CONVERT TO NUMBER OF WORDS
	ADDI	T2,.VBOOT+<MBTPGS*PAGSIZ> ;COMPUTE LAST ADDRESS+1
	BLT	T1,-1(T2)	;BLT ALL THE UCODE TO AFTER MONBTS
	MOVE	T1,EPTADR	;GET EPT ADDRESS (FIRST LOC IN MONBTS)
	ADDI	T1,<MBTPGS*PAGSIZ> ;COMPUTE FIRST PHYSICAL ADDR IN UCODE
UCDCP1:	MOVEM	T1,SVUCAD	;STORE NEW PHYSICAL ADDRESS
	POPJ	P,		;RETURN
> ;END IFN FTKL10
	SUBTTL	MOVE MONBTS TO THE TOP OF MEMORY AND ZERO CORE


;ROUTINE TO MOVE MONBTS TO THE TOP OF CORE SO THAT A NEW MONITOR
;MAY BE READ IN.  ZEROES THE REST OF CORE AFTER THE MOVE.
;CALL:	PUSHJ	P,MOVBTS
;RETURN+1 ALWAYS

MOVBTS:	PUSHJ	P,FINDHI	;FIND WHERE TO MOVE MONBTS TO
	LSH	T2,P2WLSH##	;CONVERT TO WORDS
	MOVEM	T2,EPTADR	;STORE PHYSICAL ADDRESS OF NEW EPT
IFN FTKL10,<
	MOVE	T1,T2		;COPY ADDRESS OF EPT (FIRST LOC IN MONBTS)
	ADDI	T1,<MBTPGS*PAGSIZ> ;COMPUTE FIRST ADDRESS IN UCODE
	MOVEM	T1,SVUCAD	;STORE NEW ADDRESS OF UCODE
>
	LSH	T2,W2PLSH##	;CONVERT BACK TO PAGE NUMBER
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT(T2) ;GET MAP SLOT ENTRY FOR THIS PAGE
	HRL	T1,NEGPGS	;MAKE IT AN AOBJN POINTER
	MOVE	T3,[POINT 18,EPT+.MMOVE] ;GET BYTE POINTER TO MAP SLOT
	IDPB	T1,T3		;MAKE ENOUGH PAGE ADDRESSABLE TO MOVE MONBTS
	AOBJN	T1,.-1		;DO THEM ALL
>
IFN FTKLP,<
	HRLZ	T1,NEGPGS	;AOBJN POINTER TO THE MAP
	MOVE	T3,T2		;FIRST PHYSICAL PAGE
	HRLI	T3,(<PM.DCD>B2+PM.WRT) ;BITS
	MOVEM	T3,EPT+.MMOVE(T1) ;STORE NEXT POINTER
	AOS	T3		;NEXT PHYSICAL PAGE
	AOBJN	T1,.-2		;SETUP POINTERS FOR ALL PAGES
>
	MOVE	T1,CPEBB	;GET CURRENT MAPPING
	XCT	CHGEBR		;CAUSE THE PAGE TABLE TO BE FLUSHED
	MOVE	T4,[.VBOOT,,.VMOVE] ;SETUP BLT WORD TO MOVE IT ALL
	MOVN	T3,NEGPGS	;GET NUMBER OF PAGES TO MOVE
	LSH	T3,P2WLSH##	;CONVERT TO NUMBER OF WORDS
	ADDI	T3,.VMOVE	;ADD IN THE FIRST DESTINATION ADDRESS
	BLT	T4,-1(T3)	;BLT ALL OF MONBTS
IFE FTKLP,<
	MOVEI	T3,PM.ACC+PM.WRT(T2) ;GET MAP SLOT ENTRY
	HRL	T3,NEGPGS	;MAKE ANOTHER AOBJN POINTER
	MOVE	T4,[POINT 18,.VMOVE+.MBOOT] ;POINT TO MAP
	IDPB	T3,T4		;SLOTS IN NEW MAP TO MAKE US
	AOBJN	T3,.-1		;ADDRESSABLE
>
IFN FTKLP,<
	MOVE	T3,T2		;FIRST PHYSICAL PAGE + BITS
	HRLI	T3,(<PM.DCD>B2+PM.WRT)
	MOVEM	T3,.VMOVE+540	;POINTER TO SECTION 0 MAP
	HRLZ	T4,NEGPGS	;AOBJN POINTER TO MAP
	MOVEM	T3,.VMOVE+.MBOOT(T4) ;STORE NEXT POINTER
	AOS	T3		;NEXT PHYSICAL PAGE
	AOBJN	T4,.-2		;SETUP POINTERS FOR ALL PAGES
>
	MOVE	T4,CPUBR	;GET UPT ARGUMENT
IFN FTKI10,<
	TRZ	T1,PG.EPT	;CLEAR OLD PAGE NUMBER
	TLZ	T4,(PG.UPT)	;  DITTO FOR UPT
>
IFN FTKL10,<
	TRZ	T1,LG.EPT	;CLEAR OLD PAGE NUMBER
	TRZ	T4,LG.UPT	;  DITTO FOR UPT
>
IFN FTKS10,<
	TRZ	T1,SG.EPT	;CLEAR OLD PAGE NUMBER
	TRZ	T4,SG.UPT	;  DITTO FOR UPT
>
	IORI	T1,(T2)		;INSERT NEW EPT PAGE NUMBER
IFN FTKI10,<
	TLO	T4,(T2)		;  ALSO UPT
>
IFN FTKL10!FTKS10,<
	IORI	T4,(T2)		;  ALSO UPT
>
	MOVEM	T1,.VMOVE+CPEBB-.VBOOT ;STORE NEW MAPPING
	XCT	CHGEBR		;CONTINUE EXECUTION AT TOP OF CORE
	XCT	CHGUBR		;CHANGE UPT ALSO


				;CONTINUED ON THE NEXT PAGE
;HERE AFTER HAVING MOVED MONBTS TO THE TOP OF CORE TO ZERO ALL OTHER
;PAGES IN MEMORY.

	MOVE	T4,T2		;PUT EPT PAGE NUMBER IN T4
	MOVEI	T3,-1(T4)	;COPY EPT PAGE NUMBER-1
	SUB	T3,NEGPGS	;COMPUTE LAST PAGE IN MONBTS+UCODE
	MOVE	T2,MEMPSZ	;GET NUMBER OF PAGES DESCRIBED BY NXMTB
	SUBI	T2,1		;CALCULATE THE HIGHEST PAGE # IN CORE
MOVBT1:	CAIL	T2,(T4)		;IS THIS PAGE
	CAILE	T2,(T3)		;  OCCUPIED BY MONBTS?
	PUSHJ	P,CHKNXM	;NO, DOES IT EXIST?
	  JRST	MOVBT2		;NO, TRY NEXT
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT(T2) ;GET NEXT PAGE TO ZERO
	HRLM	T1,EPT+.MZERO	;STORE IN MAP SLOT TO USE
>
IFN FTKLP,<
	HRLI	T1,(<PM.DCD>B2+PM.WRT) ;ACCESS BITS
	HRR	T1,T2		;PAGE NUMBER
	MOVEM	T1,EPT+.MZERO	;SETUP MAPPING TO ZERO THE PAGE
>
IFN FTKL10!FTKS10,<
	CLRPT	.VZERO		;FLUSH PAGE TABLE FOR THAT PAGE
>
IFN FTKI10,<
	MOVE	T1,CPEBB	;GET EPT MAPPING
	XCT	CHGEBR		;CAUSE PAGE TABLE TO BE FLUSHED
>
	MOVE	T1,[.VZERO,,.VZERO+1] ;SETUP BLT POINTER
	SKIPN	T2		;ABOUT TO DO PAGE 0?
IFN FTKI10,<
	ADD	T1,[40,,40]	;YES, DON'T CLEAR 0-37
>
IFN FTKL10!FTKS10,<
	ADJSP	T1,40		;YES, DON'T CLEAR 0-37
>
	SETZM	-1(T1)		;CLEAR FIRST WORD OF PAGE
	BLT	T1,.VZERO+PAGSIZ-1 ;DO IT ALL
MOVBT2:	SOJGE	T2,MOVBT1	;LOOP IF MORE TO DO
	POPJ	P,		;RETURN
	SUBTTL	NXMTAB HANDLING ROUTINES


;ROUTINE TO FIND -NEGPGS CONTIGUOUS PAGES STARTING AT THE TOP OF
;CORE SO THAT WE CAN MOVE MONBTS THERE.
;CALL:	PUSHJ	P,FINDHI
;RETURN+1 ALWAYS WITH STARTING PAGE NUMBER IN T2

FINDHI:	MOVE	T2,MEMPSZ	;GET NUMBER OF PAGES IN CORE
FINDH1:	MOVN	T1,NEGPGS	;NUMBER OF CONTIGUOUS PAGES WE NEED
FINDH2:	SOS	T2		;DECREMENT PAGE NUMBER
	PUSHJ	P,CHKNXM	;DOES THIS PAGE EXIST?
	  JRST	FINDH1		;NO, RESET COUNT AND TRY AGAIN
	SOJG	T1,FINDH2	;YES, DECREMENT PAGE AND CHECK IT
	POPJ	P,		;FOUND THEM, RETURN PAGE # IN T2


;ROUTINE TO FIND A CONTIGUOUS GROUP OF PAGES WHICH EXIST BY LOOKING
;THROUGH NXMTB.  I KNOW THAT THIS ISN'T PARTICULARLY FAST BUT I WAS
;IN A HURRY.
;CALL:
;	P2/PAGE NUMBER OF WHERE TO START
;	PUSHJ	P,FNDPGS
;RETURN+1 ALWAYS
;RETURNS P1=COUNT OF PAGES
;	 P2=STARTING PAGE NUMBER

FNDPGS:	MOVEI	P1,0		;START WITH NO PAGES FOUND
	SOS	P2		;TAKE A RUNNING START AT THE LOOP
FNDPG1:	AOS	T2,P2		;INCREMENT PAGE NUMBER, COPY TO T2
	CAML	T2,MEMPSZ	;OFF THE END OF MEMORY?
	POPJ	P,		;YES, RETURN WITH P1=0
	PUSHJ	P,CHKNXM	;DOES THAT PAGE EXIST?
	  JRST	FNDPG1		;NO, LOOP FOR NEXT
FNDPG2:	CAMGE	T2,MEMPSZ	;OFF THE END OF MEMORY?
	PUSHJ	P,CHKNXM	;NO, DOES THIS PAGE EXIST?
	  POPJ	P,		;NO, RETURN
	AOS	P1		;INCREMENT COUNT OF PAGES
	AOJA	T2,FNDPG2	;INCREMENT PAGE NUMBER AND LOOP
;ROUTINE TO CHECK NXMTB TO SEE IF A PAGE EXISTS.
;CALL:
;	T2/PHYSICAL PAGE NUMBER
;	PUSHJ	P,CHKNXM
;RETURN+1 IF MARKED AS NXM
;RETURN+2 IF NOT
;PRESERVES ALL

CHKNXM:	PUSH	P,T2		;SAVE PAGE NUMBER
	PUSH	P,T3		;SAVE TEMP WE USE
	IDIVI	T2,^D36		;DIVIDE BY THE NUMBER OF BITS PER WORD
	MOVE	T2,NXMTB(T2)	;GET THE WORD CONTAINING THE BIT
	LSH	T2,(T3)		;SHIFT NXM BIT TO 1B0
	SKIPL	T2		;MARKED AS A NXM?
	AOS	-2(P)		;NO, GIVE SKIP RETURN
	POP	P,T3		;RESTORE T3
	POP	P,T2		;RESTORE T2
	POPJ	P,		;RETURN
	SUBTTL	TRAP HANDLING


;HERE ON A TRAP OTHER THAN A PAGE FAIL.

TRAP:
IFE FTKLP,<
	MOVEI	T1,[ASCIZ/?Trap other than page fail
MUUO = /]
>
IFN FTKLP,<
	MOVEI	T1,[ASCIZ/?Trap other than page fail
MUUO Flags, Opcode, AC = /]
>
	PUSHJ	P,PRMSG
	MOVE	T4,EPT+.UPMUO	;GET MUUO
	PUSHJ	P,PRHWD		;PRINT AS HALF WORDS
	MOVEI	T1,[ASCIZ/
MUUO PC = /]
	PUSHJ	P,PRMSG
	MOVE	T4,EPT+.UPMUP	;GET OLD PC WORD
	PUSHJ	P,PRHWD		;PRINT AS HALF WORDS
IFN FTKLP,<
	MOVEI	T1,[ASCIZ/
MUUO EA = /]
	PUSHJ	P,PRMSG
	MOVE	T4,EPT+.UPMUE	;GET MUUO EFFECTIVE ADDRESS
	PUSHJ	P,PRHWD		;PRINT AS HALF WORDS
>
	JRST	PFTRA1		;JOIN COMMON EXIT CODE
;HERE ON A PAGE FAIL TRAP

PFTRAP:
IFN FTKI10,<
	EXP	0		;JSR HERE ON A KI
>
	MOVEI	T1,[ASCIZ/?Page fail trap
PFW = /]
	PUSHJ	P,PRMSG		;PRINT ERROR MESSAGE
IFN FTKI10,<
	MOVE	T4,EPT+.UPEPF	;GET PAGE FAIL WORD
>
IFN FTKL10!FTKS10,<
	MOVE	T4,EPT+.LMPFW	;GET PAGE FAIL WORD
>
	PUSHJ	P,PRHWD		;PRINT AS HALF-WORDS
IFN FTKLP,<
	MOVEI	T1,[ASCIZ/
PF Flags = /]
	PUSHJ	P,PRMSG
	MOVE	T4,EPT+.LMPFP	;GET PC FLAGS (DEFINITION WRONG IF FTKLP ON)
	PUSHJ	P,PRHWD		;PRINT AS HALF-WORDS
>
	MOVEI	T1,[ASCIZ/
PF PC = /]
	PUSHJ	P,PRMSG	
IFN FTKI10,<
	MOVE	T4,PFTRAP	;GET PC OF FAILURE
>
IFN FTKL10!FTKS10,<
	MOVE	T4,EPT+.LMPFP+IFN FTKLP,<1> ;GET PC OF FAILURE
>
	PUSHJ	P,PRHWD		;PRINT IT AS HALF WORDS
PFTRA1:	PUSHJ	P,PRTAPR	;PRINT APR STATUS
	JRST	@TRPADR		;RESTART AT POINT APPROPRIATE TO ENTRY POINT
;ROUTINE TO PRINT THE CONI APR AND RDERA (IF A KL10).
;CALL:	PUSHJ	P,PRTAPR
;RETURN+1 ALWAYS

PRTAPR:	MOVEI	T1,[ASCIZ/
CONI APR, = /]
	PUSHJ	P,PRMSG
	CONI	APR,T4		;GET CONI APR
	PUSHJ	P,PRHWD		;PRINT AS HALF WORDS
IFN FTKL10,<
	MOVEI	T1,[ASCIZ/
RDERA = /]
	PUSHJ	P,PRMSG
	RDERA	T4		;GET ERA
	PUSHJ	P,PRHWD		;PRINT AS HALF WORDS
>
	PJRST	PRCRLF		;END LINE AND RETURN
	SUBTTL	COMMAND PARSING


;ROUTINE TO PARSE A COMMAND LINE. CALL WITH FL.CMD OR FL.1CM SET
;TO PARSE THE COMMAND BUFFER, CALL WITH BOTH OFF TO PARSE BOOTXT.
;RETURNS WITH THE FILESPEC VARIABLE AND BITS IN S SETUP.
;CALL:	PUSHJ	P,PARSE
;RETURN+1 IF ERROR DETECTED AND MESSAGE ISSUED
;RETURN+2 IF NO ERRORS DETECTED

PARSE:	SETZM	FILSPC		;CLEAR FIRST WORD OF FILESPEC
	MOVE	T1,[FILSPC,,FILSPC+1] ;SETUP FOR BLT
	BLT	T1,FILSPE	;CLEAR IT ALL
	TDZA	S,[FX.CLR]	;CLEAR FLAG BITS AND GET FIRST ATOM
PARSE1:	TDZA	T1,T1		;CLEAR ATOM, SKIP CALL TO GETSIX
PARSE2:	PUSHJ	P,GETSIX	;GET SIXBIT ATOM IN T1
	MOVSI	T2,-TRMTBL	;-VE LENGTH OF TERMINATING CHAR TABLE
PARSE3:	HLRZ	T4,TRMTAB(T2)	;GET NEXT POSSIBLE CHARACTER FROM TABLE
	CAIE	T4,(T3)		;MATCH WITH THE ONE WE SAW?
	AOBJN	T2,PARSE3	;NO, LOOP
	HRRZ	T4,TRMTAB(T2)	;GET DISPATCH ADDRESS FOR ATOM
	JUMPL	T2,(T4)		;GO TO ROUTINE IF MATCH FOUND
CMDERR:	MOVEI	T1,[ASCIZ/%Syntax error
/]
	PJRST	PRMSG		;TELL OF ERROR AND RETURN


;TABLE OF LEGAL CHARACTERS TERMINATING COMMAND STRING ATOMS AND
;THE CORRESPONDING DISPATCH ADDRESSES.  FORMAT IS:
;	XWD	CHAR,ADDRESS

TRMTAB:	XWD	":",CMDDEV	;DEVICE SEEN
	XWD	".",CMDFIL	;FILENAME SEEN
	XWD	"[",CMDPTH	;START OF PATCH SEEN
	XWD	"/",CMDSWT	;SWITCH SEEN
	XWD	.CHCRT,CMDEOL	;END OF LINE SEEN
	XWD	0,BTXEOL	;END OF BOOTXT (ASCIZ)
TRMTBL==.-TRMTAB		;LENGTH OF TABLE
;HERE TO PROCESS DEVICE IN COMMAND STRING

CMDDEV:	TRON	S,FR.DEV	;ALREADY HAVE A DEVICE?
	SKIPN	T1		;NO, DEVICE NULL?
	JRST	CMDERR		;YES, ERROR
	MOVEM	T1,DEV		;STORE DEVICE
	JRST	PARSE2		;AND GET NEXT ATOM


;HERE TO PROCESS FILENAME IN COMMAND STRING

CMDFIL:	JSP	T2,STOFIL	;STORE FILENAME AS NECESSARY
	TROE	S,FR.EXT	;FLAG AN EXTENSION SEEN
	JRST	CMDERR		;ERROR IF MORE THAN ONE
	PUSHJ	P,GETSIX	;GET EXTENSION
	HLLZM	T1,EXT		;STORE IT
	JRST	PARSE1		;GET NEXT ATOM


;HERE TO PROCESS PATH SPEC IN COMMAND STRING

CMDPTH:	JSP	T2,STOFIL	;STORE FILENAME AS NECESSARY
	PUSHJ	P,GETOCT	;GET OCTAL PROJECT NUMBER
	JUMPE	T1,CMDERR	;NONE IS ILLEGAL
	TRON	S,FR.PTH	;ALREADY SEEN A PATH?
	CAIE	T3,","		;MUST HAVE BROKEN ON A COMMA
	JRST	CMDERR		;ELSE ERROR
	HRLZM	T1,PTHBLK	;STORE IN PATH BLOCK
	PUSHJ	P,GETOCT	;GET PROGRAM NUMBER
	JUMPE	T1,CMDERR	;NONE IS ILLEGAL
	HRRM	T1,PTHBLK	;STORE IN PATH BLOCK
	MOVSI	W,-LIMLVL##	;SETUP AOBJN POINTER TO SFD'S
CMDPT1:	CAIE	T3,","		;SFD COMMING?
	JRST	CMDPT2		;NO, OR NONE ALLOWED
	PUSHJ	P,GETSIX	;GET SFD NAME
	JUMPE	T1,CMDERR	;MUST NOT BE NULL
	MOVEM	T1,PTHBLK+1(W)	;STORE IN NEXT SLOT IN PATH BLOCK
	AOBJN	W,CMDPT1	;LOOP FOR NEXT
CMDPT2:	CAIN	T3,"]"		;TERMINATE WITH RIGHT BRACKET?
	JRST	PARSE2		;YES, GET NEXT ATOM
	JRST	PARSE1		;NO, WORRY ABOUT THE CHARACTER
;HERE TO PROCESS THE END OF THE COMMAND LINE

BTXEOL:	TLO	S,(FL.CMD)	;FORCE NEXT READ FROM TERMINAL
CMDEOL:	JSP	T2,STOFIL	;STORE FILENAME AS NECESSARY
	MOVSI	T1,'DSK'	;GET GENERIC DISK
	TRNE	S,FR.DEV	;DEVICE SEEN?
	CAMN	T1,DEV		;OR GENERIC DISK?
	TLO	S,(FL.WLD)	;YES, FLAG IT
	MOVSI	T1,'EXE'	;DEFAULT EXTENSION IS EXE
	TRNN	S,FR.EXT	;EXTENSION SEEN?
	MOVEM	T1,EXT		;NO, USE DEFAULT
	MOVE	T1,[1,,4]	;DEFAULT DIRECTORY IS [1,4]
	TRNN	S,FR.PTH	;PATH SEEN?
	MOVEM	T1,PTHBLK	;NO, STORE DEFAULT
	MOVEI	T1,SYSDDT##	;GET ADDRESS OF EDDT START
	TRNE	S,FR.DDT	;USER SPECIFY /EDDT?
	SKIPE	STSA		;  AND NO ADDRESS ON /START?
	JRST	CPOPJ1		;NO TO FIRST OR YES TO SECOND
	MOVEM	T1,STSA		;FORCE A STARTING ADDRESS
	JRST	CPOPJ1		;GIVE SKIP RETURN
;HERE TO PROCESS A SWITCH IN THE COMMAND STRING

CMDSWT:	JSP	T2,STOFIL	;STORE FILENAME AS NECESSARY
	PUSHJ	P,GETSIX	;GET THE SWITCH
	MOVE	T2,T1		;COPY IT TO T2
	SETOM	W		;SET FULL WORD MASK
CMDSW1:	LSH	W,-6		;SHIFT MASK 6
	LSH	T2,6		;AND WORD BY SAME AMOUNT
	JUMPN	T2,CMDSW1	;UNTIL IT'S NULL
	MOVSI	T4,-SWTTBL	;GET -VE LENGTH OF SWITCH TABLE
CMDSW2:	MOVE	T2,SWTTAB(T4)	;GET NEXT ENTRY IN SWITCH TABLE
	TDZ	T2,W		;MASK TO SAME SIZE AS WHAT USER TYPED
	CAME	T1,T2		;MATCH?
	AOBJN	T4,CMDSW2	;NO, LOOP FOR NEXT
	TLZN	T4,-1		;CLEAR LH.  FIND MATCH?
	JRST	CMDERR		;NO
	MOVEI	T1,FR.1ST	;GET FIRST SWITCH BIT IN S
	LSH	T1,(T4)		;SHIFT BY OFFSET INTO SWITCH TABLE
	IORI	S,(T1)		;SET SWITCH BIT IN S
	CAIE	T3,":"		;SWITCH HAVE A VALUE?
	JRST	PARSE1		;NO, GET NEXT ATOM
	CAIL	T4,SWTVLL	;CAN THIS SWITCH LEGALLY HAVE A VALUE?
	JRST	CMDERR		;NO
	PUSHJ	P,GETOCT	;GET OCTAL VALUE FOR SWITCH
	MOVEM	T1,SWTVAL(T4)	;STORE VALUE IN TABLE
	JRST	PARSE1		;AND GET NEXT ATOM


;TABLE OF LEGAL SWITCHES.  NOTE THAT ALL SWITCHES THAT MAY HAVE
;AN OCTAL VALUE MUST OCCUR POSITIONALLY BEFORE THE SWTVLL'TH
;LOCATION IN THE TABLE.

SWTTAB:	SIXBIT/START/		;/START:N
	SIXBIT/EDDT/		;/EDDT
	SIXBIT/LOAD/		;/LOAD
	SIXBIT/DUMP/		;/DUMP
	SIXBIT/FORCE/		;/FORCE
SWTTBL==.-SWTTAB
	SUBTTL	COMMAND	INPUT


;ROUTINE TO STORE A FILENAME IF REQUIRED.
;CALL:
;	T1/FILENAME OR 0
;	JSP	T2,STOFIL
;RETURN+1 IF NO ERRORS

STOFIL:	JUMPE	T1,(T2)		;DON'T DO ANYTHING IF NOTHING TO STORE
	TROE	S,FR.FIL	;ALREADY SEEN A FILENAME?
	JRST	CMDERR		;YES, ERROR
	MOVEM	T1,FILNAM	;STORE FILENAME
	JRST	(T2)		;AND RETURN


;ROUTINE TO READ A SIXBIT NAME FROM THE COMMAND STRING.
;CALL:	PUSHJ	P,GETSIX
;RETURN+1 ALWAYS
;RETURNS NAME IN T1, BREAK CHARACTER IN T3
;DESTROYS T2

GETSIX:	MOVEI	T1,0		;START WITH NULL NAME
	MOVE	T2,[POINT 6,T1]	;GET BYTE POINTER FOR ATOM
GETSI1:	PUSHJ	P,GETCHR	;GET NEXT CHARACTER FROM COMMAND
	CAIL	T3,"A"		;LETTER?
	CAILE	T3,"Z"		; ??
	CAIA			;NO, CHECK DIGITS
	JRST	GETSI2		;YES
	CAIL	T3,"0"		;NUMBER?
	CAILE	T3,"9"		; ??
	POPJ	P,		;NO, RETURN
GETSI2:	TRC	T3,"A"-'A'	;CONVERT ASCII TO SIXBIT
	TLNE	T2,770000	;TOO MANY?
	IDPB	T3,T2		;NO, STORE IN T1
	JRST	GETSI1		;AND LOOP FOR NEXT


;ROUTINE TO RETURN AN OCTAL NUMBER FROM THE COMMAND STRING.
;CALL:	PUSHJ	P,GETOCT
;RETURN+1 ALWAYS
;RETURNS NUMBER IN T1, BREAK CHARACTER IN T3

GETOCT:	MOVEI	T1,0		;START WITH NO NUMBER
GETOC1:	PUSHJ	P,GETCHR	;GET NEXT CHARACTER FROM COMMAND
	CAIL	T3,"0"		;NUMBER?
	CAILE	T3,"7"		;  OCTAL THAT IS?
	POPJ	P,		;NO, RETURN
	LSH	T1,3		;MAKE ROOM FOR IT
	IORI	T1,-"0"(T3)	;INCLUDE IN TOTAL
	JRST	GETOC1		;LOOP FOR NEXT
;ROUTINE TO RETURN THE NEXT CHARACTER FROM THE COMMAND STREAM.
;CONVERTS LOWER TO UPPER CASE.
;CALL:	PUSHJ	P,GETCHR
;RETURN+1 ALWAYS WITH CHARACTER IN T3

GETCHR:	TLNN	S,(FL.1CM!FL.CMD) ;WANT TO READ FROM COMMAND BUFFER?
	ILDB	T3,BTXPTR	;NO, READ FROM BOOTXT
	TLNE	S,(FL.1CM!FL.CMD) ;SAME QUESTION
	ILDB	T3,CMDPTR	;ONLY THIS TIME READ FROM COMMAND BUFFER
	CAIE	T3," "		;SPACE?
	CAIN	T3,.CHTAB	;  OR TAB?
	MOVEI	T3,.CHCRT	;YES, RETURN CR
	CAIL	T3,"a"		;LOWER CASE?
	CAILE	T3,"z"		;??
	POPJ	P,		;NO
	SUBI	T3,"a"-"A"	;YES, CONVERT TO UPPER
	POPJ	P,		;AND RETURN


;ROUTINE TO ASK A QUESTION WITH DEFAULT ANSWER AND GIVE SKIP
;RETURN IF ANSWER WAS YES.
;CALL:
;	T1/ADDRESS OF QUESTION STRING
;	T2/ADDRESS OF DEFAULT ANSWER STRING
;	PUSHJ	P,ASKYN
;RETURN+1 IF ANSWER WAS NO (REALLY NOT YES)
;RETURN+2 IF ANSWER WAS YES

ASKYN:	PUSHJ	P,REDLIN	;ASK QUESTION, READ ANSWER
	TLO	S,(FL.1CM)	;FORCE READ FROM COMMAND BUFFER
	PUSHJ	P,GETCHR	;GET FIRST CHARACTER
	TLZ	S,(FL.1CM)	;CLEAR FLAG
	CAIN	T3,"Y"		;YES?
CPOPJ1:	AOS	0(P)		;YES, GIVE SKIP RETURN
CPOPJ:	POPJ	P,		;RETURN
;ROUTINE TO PRINT A PROMPT STRING, AND READ A COMMAND LINE INTO
;CMDBUF.  DOES LOCAL EDITING OF RUBOUT AND ^U AND DEFAULT STRING IF
;THE OPERATOR DOESN'T ANSWER OR SCHED IS 400.
;CALL:
;	T1/ADDRESS OF PROMPT STRING
;	T2/ADDRESS OF DEFAULT ANSWER STRING
;	PUSHJ	P,REDLIN
;RETURN+1 ALWAYS WITH LINE IN CMDBUF


REDLIN:	PUSHJ	P,SAVE2		;SAVE P1-P2
	PUSH	P,T1		;SAVE ADDRESS OF PROMPT STRING
	HRLI	T2,(POINT 7,0)	;MAKE BYTE POINTER TO DEFAULT STRING
	PUSH	P,T2		; AND SAVE IT
REDLI1:	MOVE	T1,-1(P)	;RESTORE ADDRESS FOR SUBSEQUENT TIMES
	PUSHJ	P,PRMSG		;TYPE PROMPT STRING
	MOVE	P1,[POINT 7,CMDBUF] ;GET POINTER TO BUFFER
	MOVEM	P1,CMDPTR	;SAVE FOR CALLER
	SETZM	CMDBUF		;SET TO CLEAR BUFFER
	MOVE	T1,[CMDBUF,,CMDBUF+1] ;SETUP FOR BLT
	BLT	T1,CMDBUF+LINBFL-1 ;ZERO IT ALL
	TLZ	S,(FL.RUB)	;CLEAR RUBOUT FLAG
	MOVEI	P2,<LINBFL*5>-5 ;MAX CHARACTERS
REDLI2:	PUSHJ	P,TYI		;READ A CHARACTER
	  ILDB	T3,0(P)		;TIMED OUT, GET ONE FROM DEFAULT STRING
	CAIE	T3,.CHCNH	;BACKSPACE?
	CAIN	T3,.CHDEL	; OR RUBOUT?
	JRST	REDRUB		;YES
	CAIN	T3,.CHCNU	;^U?
	JRST	REDCNU		;YES
	JUMPN	T3,REDLI3	;READ LAST CHARACTER OF DEFAULT STRING?
	MOVEI	T1,[ASCIZ/	;Default answer/] ;TELL HIM WHAT HAPPENED
	PUSHJ	P,PRMSG		;FOR POST MORTUM
	MOVEI	T3,.CHCRT	;AND TURN IT INTO A CR
REDLI3:	CAIE	T3,.CHCRT	;END OF LINE?
	SOSL	P2		;IGNORE IF TOO MANY
	IDPB	T3,P1		;STASH CHAR
	TLZE	S,(FL.RUB)	;POST PROCESS RUBOUT
	PUSHJ	P,PRBSL		;BY PRINTING BACKSLASH
	LDB	T3,P1		;GET CHAR BACK
	PUSHJ	P,ECHO		;AND ECHO CHARACTER
	LDB	T3,P1		;ONCE MORE
	CAIE	T3,.CHCRT	;END-OF LINE?
	JRST	REDLI2		;NO, LOOP
	POP	P,(P)		;FLUSH STACK
TPOPJ:	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
;HERE TO PROCESS RUBOUTS

REDRUB:	CAIN	P2,<LINBFL*5>-5	;CHECK FOR BEGINNING OF LINE
	JRST	REDRU1		;YES
	TLON	S,(FL.RUB)	;CHECK HERE BEFORE?
	PUSHJ	P,PRBSL		;NO, TYPE BACKSLASH
	LDB	T3,P1		;GET CHAR
	PUSHJ	P,ECHO		;PRINT IT
IFN FTKI10,<
	ADD	P1,[POINT 0,0,28] ;BACK UP BYTE PNTR
	TLNE	P1,(1B0)
	SUB	P1,[POINT 0,1,0]
>
IFN FTKL10!FTKS10,<
	MOVNI	T3,1		;WANT TO BACKUP POINTER BY
	EXCH	T3,P1		;BY 1 BYTE POSITION
	ADJBP	P1,T3		;DO IT THE EASY WAY
>
	AOJA	P2,REDLI2	;GET NEXT CHAR

;HERE TO PROCESS BEGINNING OF LINE ON RUBOUT

REDRU1:	TLZE	S,(FL.RUB)	;NEED TO TYPE A BACKSLASH?
	PUSHJ	P,PRBSL		;YES, DO SO
	JRST	REDCU1		;JOIN COMMON CODE

;HERE TO PROCESS ^U

REDCNU:	PUSHJ	P,ECHO		;ECHO AS UPARROW U
REDCU1:	PUSHJ	P,PRCRLF	;TYPE CRLF
	JRST	REDLI1		;RETYPE PROMPT AND TRY AGAIN
	SUBTTL	COMMAND OUTPUT


;ROUTINES TO PRINT SELECTED CHARACTERS.
;
;	PRCRLF	- PRINT CRLF
;	PRBSL	- PRINT BACKSLASH
;	PRCOMA	- PRINT COMMA
;	PRLBKT	- PRINT LEFT BRACKET
;	PRRBKT	- PRINT RIGHT BRACKET
;	PRRBCR	- PRINT RIGHT BRACKET AND CRLF

PRRBCR:	PUSHJ	P,PRRBKT	;PRINT RIGHT BRACKET AND FALL INTO PRCRLF
PRCRLF:	MOVEI	T3,.CHCRT	;GET A CR
	PUSHJ	P,TYO
	MOVEI	T3,.CHLFD	;GET A LF
	PJRST	TYO		;TYPE IT AND RETURN

PRBSL:	SKIPA	T3,["\"]	;GET A BACKSLASH
PRCOMA:	MOVEI	T3,","		;GET A COMMA
	PJRST	TYO		;TYPE IT AND RETURN
PRLBKT:	SKIPA	T3,["["]	;GET A LEFT BRACKET
PRRBKT:	MOVEI	T3,"]"		;GET A RIGHT BRACKET
	PJRST	TYO		;TYPE IT AND RETURN


;ROUTINE TO PRINT AN ASCIZ MESSAGE ON THE CTY.
;CALL:
;	T1/ADDRESS OF ASCIZ STRING
;	PUSHJ	P,PRMSG
;RETURN+1 ALWAYS
;DESTROYS T1,T3

PRMSG:	HRLI	T1,(POINT 7,)	;FORM 7 BIT BYTE POINTER
PRMSG1:	ILDB	T3,T1		;GET NEXT CHARACTER
	JUMPE	T3,CPOPJ	;RETURN ON NULL
	PUSHJ	P,TYO		;TYPE CHARACTER
	JRST	PRMSG1		;LOOP FOR NEXT


;ROUTINE TO PRINT A SIXBIT WORD ON THE CTY.
;CALL:
;	T1/SIXBIT WORD
;	PUSHJ	P,PRSIX
;RETURN+1 ALWAYS
;DESTROYS T1,T2,T3

PRSIX:	LSHC	T1,-^D36	;MOVE WORD TO T2, CLEAR T1
	LSHC	T1,6		;MOVE NEXT BYTE TO T1
	MOVEI	T3,"A"-'A'(T1)	;CONVERT TO ASCII AND COPY TO T3
	PUSHJ	P,TYO		;PUT IT OUT
	SKIPE	T1,T2		;MOVE REMAINDER BACK TO T1, SKIP IF DONE
	JRST	PRSIX		;LOOP FOR REST
	POPJ	P,		;RETURN
;ROUTINE TO PRINT AN OCTAL NUMBER ON THE CTY.
;CALL:
;	T1/NUMBER TO PRINT
;	PUSHJ	P,PROCT
;RETURN+1 ALWAYS
;DESTROYS T1,T2,T3

PROCT:	IDIVI	T1,^D8		;DIVIDE BY RADIX, REMAINDER IN T2
	HRLM	T2,0(P)		;STORE ON STACK
	SKIPE	T1		;DONE?
	PUSHJ	P,PROCT		;NO, LOOP
	HLRZ	T3,0(P)		;GET DIGIT FROM STACK
	ADDI	T3,"0"		;CONVERT TO ASCII
	PJRST	TYO		;OUTPUT IT AND RETURN TO CALLER


;ROUTINE TO PRINT A WORD AS TWO 6 DIGIT OCTAL NUMBERS SEPARATED
;BY TWO COMMAS.
;CALL:
;	T4/WORD
;	PUSHJ	P,PRHWD
;RETURN+1 ALWAYS

PRHWD:	PUSHJ	P,PRHWD1	;PRINT LEFT HALF
	MOVEI	T1,[ASCIZ/,,/]	;FOLLOWED BY
	PUSHJ	P,PRMSG		;  TWO COMMAS
PRHWD1:	MOVEI	T1,6		;LOOP COUNT IS 6
PRHWD2:	MOVE	T3,T4		;MOVE WORD TO T3
	LSHC	T3,-^D33	;KEEP 1 DIGIT, CLEAR REST OF T3
	ADDI	T3,"0"		;CONVERT TO ASCII
	PUSHJ	P,TYO		;PUT IT OUT
	SOJG	T1,PRHWD2	;LOOP FOR ALL
	POPJ	P,		;RETURN


;ROUTINE TO PRINT ONE CHARACTER IN (POSSIBLY) UP-ARRROW FORMAT.
;CALL:
;	T3/CHARACTER TO ECHO
;	PUSHJ	P,ECHO
;RETURN+1 ALWAYS
;DESTROYS T3

ECHO:	CAIE	T3,.CHTAB	;TAB?
	CAIL	T3," "		;NO, CONTROL CHARACTER?
	PJRST	TYO		;NO, JUST PRINT IT
	CAIN	T3,.CHCRT	;END-OF-LINE?
	PJRST	PRCRLF		;YES, ECHO CRLF
	PUSH	P,T3		;SAVE CHAR
	MOVEI	T3,"^"		;PRINT CTRL CHAR
	PUSHJ	P,TYO		;...
	POP	P,T3		;RESTORE CHARACTER
	ADDI	T3,"A"-1	;CONVERT TO PRINTING CHARACTER
	PJRST	TYO		;PRINT IT AND RETURN
;ROUTINE TO PRINT THE CURRENT FILESPEC FROM THE DATA BASE.
;CALL:	PUSHJ	P,PRFILE
;RETURN+1 ALWAYS
;DESTROYS T1-T4

PRFILE:	MOVE	T1,DEV		;GET DEVICE NAME
	PUSHJ	P,PRSIX		;PRINT IT
	MOVEI	T3,":"		;GET A COLON
	PUSHJ	P,TYO		;PRINT IT
	MOVE	T1,FILNAM	;GET THE FILENAME
	PUSHJ	P,PRSIX		;PRINT IT
	MOVEI	T3,"."		;GET A DOT
	PUSHJ	P,TYO		;PRINT IT
	HLLZ	T1,EXT		;GET EXTENSION
	PUSHJ	P,PRSIX		;PRINT IT
	PUSHJ	P,PRLBKT	;PRINT LEFT BRACKET
	HLRZ	T1,PTHBLK	;GET PROJECT NUMBER
	PUSHJ	P,PROCT		;PRINT IT
	PUSHJ	P,PRCOMA	;PRINT COMMA
	HRRZ	T1,PTHBLK	;GET PROGRAMMER NUMBER
	PUSHJ	P,PROCT		;PRINT IT
	MOVEI	T4,1		;OFFSET INTO PTHBLK OF FIRST SFD
PRFIL1:	SKIPN	T1,PTHBLK(T4)	;NEXT SFD NON-NULL?
	PJRST	PRRBKT		;NO, PRINT RIGHT BRACKET AND RETURN
	PUSHJ	P,PRCOMA	;PRINT COMMA
	PUSHJ	P,PRSIX		;PRINT SFD NAME
	AOJA	T4,PRFIL1	;LOOP FOR NEXT SFD
	SUBTTL	LOWEST LEVEL CTY INPUT/OUTPUT ROUTINES


;ROUTINE TO TYPE ONE CHARACTER ON THE CTY.
;CALL:
;	T3/CHARACTER TO TYPE
;	PUSHJ	P,TYO
;RETURN+1 ALWAYS
;DESTROYS T3.

TYO:
IFN FTKL10,<
	MOVEI	T3,DT.MTO(T3)	;GET CHAR IN LOW ORDER 8 BITS, COMMAND IN NEXT FOUR
	SETZM	EPT+DTEMTD	;CLEAR DONE FLAG
	MOVEM	T3,EPT+DTECMD	;PUT INTO COMMAND LOCATION
	CONO	DTE,TO11DB	;RING DOORBELL
	SKIPN	EPT+DTEMTD	;WAIT TILL MONITOR OUTPUT DONE
	JRST	.-1		;LOOP
	POPJ	P,0		;DONE.
>;END IFN FTKL10

IFN FTKI10,<
	DATAO	TTY,T3		;SEND OUT CHAR
	CONSZ	TTY,IT.BSY	;WAIT FOR IDLE
	JRST	.-1		; ..
	POPJ	P,0		;DONE.
>;END IFN FTKI10

IFN FTKS10,<
	SKIPE	.VPAG0+CTYOWD	;CAN WE SEND NEXT CHAR?
	JRST	.-1		;NOT YET
	IORI	T3,CTYOVL	;SIGNAL VALID
	MOVEM	T3,.VPAG0+CTYOWD ;PUT IT UP FOR THE 8080 TO FIND IT
	WRAPR	SP.SSF!SP.IFE	;WAKE THE 8080
	POPJ	P,0		;DONE
>;END IFN FTKS10
;ROUTINE TO READ ONE CHARACTER FROM THE CTY.
;CALL:	PUSHJ	P,TYI
;RETURN+1 IF THE OPERATOR DID NOT ANSWER OR SCHED WAS 400
;RETURN+2 WITH CHARACTER IN T3
;DESTROYS T1

TYI:	TLNE	S,(FL.NOP)	;NO OPERATOR IN ATTENDANCE?
	TDZA	T1,T1		;YES, USE SHORT TIMEOUT COUNT
	MOVSI	T1,WATTIM	;ELSE USE 30 SECONDS OR SO
IFN FTKL10,<
	SKIPN	EPT+DTEMTI	;INPUT READY?
>
IFN FTKI10,<
	CONSO	TTY,IT.DON	;INPUT READY?
>
IFN FTKS10,<
	SKIPN	.VPAG0+CTYIWD	;INPUT READY?
>
	SOJGE	T1,.-1		;NO, LOOP BUT NOT TOO LONG
	JUMPGE	T1,TYI1		;GO IF DIDN'T TIME OUT
	TLNE	S,(FL.DEF)	;WANT TO DO DEFAULTING?
	JRST	TYI		;NO, WAIT FOR TYPEIN
	TLO	S,(FL.NOP)	;SET NO OPERATOR FLAG
	POPJ	P,		;AND GIVE NON-SKIP RETURN
TYI1:
IFN FTKL10,<
	MOVE	T3,EPT+DTEF11	;GET CHARACTER
	SETZM	EPT+DTEMTI	;FLAG WE GOT IT
>;END IFN FTKL10

IFN FTKI10,<
	DATAI	TTY,T3		;GET THE CHARACTER
>;END IFN FTKI10

IFN FTKS10,<
	MOVEI	T3,0		;SET TO GET CHAR AND CLEAR WORD
	EXCH	T3,.VPAG0+CTYIWD ;GET CHARACTER AND CLEAR
>;END IFN FTKS10

	ANDI	T3,177		;KEEP ONLY 7 BITS
	JUMPE	T3,TYI		;IGNORE NULLS
	MOVEI	T1,1		;GET A BIT TO SHIFT
	LSH	T1,(T3)		;SHIFT BY VALUE OF CHARACTER
	TDNE	T1,BRKTAB	;BREAK CHARACTER?
	MOVEI	T3,.CHCRT	;YES, CONVERT TO CR
	JRST	CPOPJ1		;GIVE SKIP RETURN

BRKTAB:	1_.CHBEL!1_.CHTAB!1_.CHLFD!1_.CHVTB!1_.CHFFD!1_.CHCNZ!1_.CHESC!1_" "
	SUBTTL	DISK SUPPORT SUBROUTINES


IFE FTKS10,<
;ROUTINE TO READ A MASSBUS REGISTER AND RETURN THE VALUE.
;CALL WITH:
;	T1/DATAO WORD
;	PUSHJ	P,REDREG
;RETURN+1 ALWAYS WITH FULL 36 BIT DATA IN T1

REDREG:	XCT	DODATO		;TELL THE DEVICE WHICH REGISTER
	STALL			;WAIT AWHILE
	XCT	DODATI		;READ THE DATA
	POPJ	P,		;RETURN
>;END IFE FTKS10


;ROUTINE TO READ AND CHECK THE DRIVE TYPE REGISTER FOR A DEVICE AGAINST
;THOSE DRIVE TYPES THAT WE KNOW ABOUT.
;CALL:
;	T1/DATAO WORD TO READ DRIVE TYPE REGISTER
;	PUSHJ	P,DRVTYP
;RETURN+1 IF NO MATCH
;RETURN+2 IF MATCH WITH DRVBPC, DRVBPT SETUP

DRVTYP:
IFE FTKS10,<
	PUSHJ	P,REDREG	;READ THE REGISTER
>
IFN FTKS10,<
	TRNN	T1,SI.DSK	;THIS A DISK UNIT?
	POPJ	P,		;NO
>
	ANDI	T1,777		;KEEP ONLY 9 BITS
	MOVSI	T2,-DRTTBL	;GET AOBJN POINTER TO DRIVE TYPE TABLE
DRVTY1:	CAME	T1,DRTTAB(T2)	;MATCH WITH THIS ONE?
	AOBJN	T2,DRVTY1	;NO, LOOP
	JUMPGE	T2,CPOPJ	;FAIL IF NO MATCH
	MOVE	T1,BPCTAB(T2)	;GET BLOCKS/CYLINDER
	MOVE	T2,BPTTAB(T2)	;  AND BLOCKS/TRACK
	DMOVEM	T1,DRVBPC	;STORE VALUES
	JRST	CPOPJ1		;GIVE SKIP RETURN
;TABLES DEFINING THE DRIVE TYPES OF THE DRIVES WE KNOW ABOUT AND
;THE CORRESPONDING VALUES OF BLOCKS/CYLINDER AND BLOCKS/TRACK FOR
;EACH DRIVE.  THESE ARE PARALLEL TABLES AND THUS ARE ORDER SENSITIVE.
;
;TABLE GIVING THE DRIVE TYPES THAT WE KNOW ABOUT.

DRTTAB:	EXP	20		;RP04
	EXP	22		;RP06
	dec	25		;rm02
	EXP	24		;RM03
	exp	27		;rm05
	EXP	42		;RP07
DRTTBL==.-DRTTAB


;TABLE GIVING THE NUMBER OF BLOCKS/CYLINDER FOR EACH DRIVE.

BPCTAB:	DEC	380		;RP04
	DEC	380		;RP06
	DEC	150		;RM02
	DEC	150		;RM03
	dec	570		;rm05
	DEC	1376		;RP07
;6

;TABLE GIVING THE NUMBER OF BLOCKS/TRACK FOR EACH DRIVE.

BPTTAB:	DEC	20		;RP04
	DEC	20		;RP06
	dec	30		;rm02
	DEC	30		;RM03
	dec	30		;rm05
	DEC	43		;RP07
	SUBTTL	BYTE POINTERS INTO DATA STRUCTURES


DESRBU==^D4	;SIZE OF UNIT NUMBER FIELD IN RIBXRA
DENRBU==^D12	;BIT POSITION OF UNIT NUMBER FIELD IN RIBXRA
DESRBA==^D23	;SIZE OF CLUSTER ADDRESS FIELD IN RIBXRA
DENRBA==^D35	;BIT POSITION OF CLUSTER ADDRESS FIELD IN RIBXRA
SDSCRU==^D3	;SIZE OF UNIT NUMBER FIELD IN .SDBCR
SDNCRU==^D2	;BIT POSITION OF UNIT NUMBER FIELD IN .SDBCR
SDSCRB==^D33	;SIZE OF BLOCK ADDRESS FIELD IN .SDBCR
SDNCRB==^D35	;BIT POSITION OF BLOCK ADDRESS FIELD IN .SDBCR
SDSMFU==^D3	;SIZE OF UNIT NUMBER FIELD IN .SDBMF
SDNMFU==^D2	;BIT POSITION OF UNIT NUMBER FIELD IN .SDBMF
SDSMFB==^D33	;SIZE OF BLOCK ADDRESS FIELD IN .SDBMF
SDNMFB==^D35	;BIT POSITION OF BLOCK ADDRESS FIELD IN .SDBMF
SDSPUN==^D6	;SIZE OF PHYSICAL UNIT NUMBER FIELD IN .SDBUN
SDNPUN==^D5	;BIT POSITION OF PHYSICAL UNIT NUMBER FIELD IN .SDBUN
SDSDCO==^D6	;SIZE OF DEVICE CODE OFFSET FIELD IN .SDBUN
SDNDCO==^D11	;BIT POSITION OF DEVICE CODE OFFSET FIELD IN .SDBUN
SDSCPU==^D6	;SIZE OF CPU NUMBER FIELD IN .SDBUN
SDNCPU==^D17	;BIT POSITION OF CPU NUMBER FIELD IN .SDBUN

SDYCRU:	POINT	SDSCRU,.SDBCR(T4),SDNCRU
		;LOGICAL UNIT NUMBER IN STR ON WHICH
		;RIB FOR CRASH.EXE RESIDES
SDYCRB:	POINT	SDSCRB,.SDBCR(T4),SDNCRB
		;BLOCK ADDRESS ON UNIT OF RIB FOR
		;CRASH.EXE
SDYMFU:	POINT	SDSMFU,.SDBMF(T4),SDNMFU
		;LOGICAL UNIT NUMBER IN STR ON WHICH
		;RIB FOR MFD RESIDES
SDYMFB:	POINT	SDSMFB,.SDBMF(T4),SDNMFB
		;BLOCK ADDRESS ON UNIT OF RIB FOR
		;MFD
SDYPUN:	POINT	SDSPUN,T4,SDNPUN
		;PHYSICAL UNIT NUMBER ON CONTROLLER
		;FOR THIS PACK
SDYDCO:	POINT	SDSDCO,T4,SDNDCO
		;OFFSET IN DVCTAB OF DEVICE CODE FOR
		;THIS DEVICE
SDYCPU:	POINT	SDSCPU,T4,SDNCPU
		;CPU NUMBER ON WHICH THIS DEVICE LIVES
DEYRBU:	POINT	DESRBU,RIB+RIBXRA##,DENRBU
		;UNIT ON WHICH NEXT EXTENDED RIB EXISTS
DEYRBA:	POINT	DESRBA,RIB+RIBXRA##,DENRBA
		;CLUSTER ADDRESS ON UNIT ON WHICH NEXT EXTENDED
		;RIB EXISTS
	SUBTTL	TABLES DRIVING DEVICE DEPENDENT I/O


;TABLE GIVING DEVICE CODES OF CONTROLLERS THAT WE CAN TALK TO.
;TABLE IS ORDERED (HOPEFULLY) SO THAT WE WILL FIND THE FILE IN THE
;LEAST DISK ACCESSES.
;FORMAT IS:
;	XWD	<OFFSET INTO TYPE TABLES>,<DEVICE CODE>_-2

DEFINE	DCODE(CODE,OFS,FTS),<
IFN	FTS,<
	XWD	OFS,CODE_-2
	>
>

DVCTAB:	DCODE	(540,R20OFS,FTKL10)	;RH20 0 ON KL
	DCODE	(544,R20OFS,FTKL10)	;RH20 1 ON KL
	DCODE	(550,R20OFS,FTKL10)	;RH20 2 ON KL
	DCODE	(554,R20OFS,FTKL10)	;RH20 3 ON KL
	DCODE	(270,R10OFS,FTKI10!FTKL10) ;RH10 0 ON KI OR KL
	DCODE	(274,R10OFS,FTKI10!FTKL10) ;RH10 1 ON KI OR KL
	DCODE	(560,R20OFS,FTKL10)	;RH20 4 ON KL
	DCODE	(564,R20OFS,FTKL10)	;RH20 5 ON KL
	DCODE	(570,R20OFS,FTKL10)	;RH20 6 ON KL
	DCODE	(574,R20OFS,FTKL10)	;RH20 7 ON KL
	DCODE	(360,R10OFS,FTKI10!FTKL10) ;RH10 2 ON KI OR KL
	DCODE	(364,R10OFS,FTKI10!FTKL10) ;RH10 3 ON KI OR KL
	DCODE	(<1_2>,R11OFS,FTKS10)	;RH11 UBA 1 ON KS
DVCTBL==.-DVCTAB


;TABLE OF I/O INSTRUCTIONS.  DEVICE CODES FILLED IN BEFORE USE.

IOTTAB:
IFN FTKI10!FTKL10,<
DODATO:	DATAO	0,T1
DODATI:	DATAI	0,T1
DOCONI:	CONI	0,T1
DOCONO:	CONO	0,(T1)
DOCNSO:	CONSO	0,(T1)
>;END IFN FTKI10!FTKL10
IOTTBL==.-IOTTAB
;THE FOLLOWING TABLES GIVE THE DISPATCH ADDRESSES FOR THE CONTROLLER
;DEPENDENT READ AND WRITE ROUTINES.  ALL ARE CALLED WITH THE FOLLOWING
;AC'S SETUP:
;
; J = INDEX INTO DEVICE CODE TABLE
; U = PHYSICAL UNIT NUMBER
; W = OFFSET INTO TABLES BELOW
; R = PHYSICAL MEMORY ADDRESS OF START OF TRANSFER
; F = BLOCK ON UNIT OF FIRST BLOCK TO TRANSFER
; M = NUMBER OF CONTIGUOUS BLOCKS TO TRANSFER
;
;ALL CONTROLLER DEPENDENT ROUTINES MUST PRESERVE F AND R WITH
;A CALL TO SAVFR.
;
;**** THE RH10 AND RH20 ENTRIES IN THE FOLLOWING TABLES MUST BE
;**** THE FIRST AND SECOND ENTRIES IN THE TABLES AND MUST REMAIN
;**** IN THE SAME RELATIVE ORDER.


DEFINE	DADDR(ADDR,OFS,FTS),<
IFN	FTS,<
	OFS==.-REDTAB
	EXP	ADDR
	>
>


;TABLE OF ADDRESSES OF CONTROLLER READ ROUTINES INDEXED BY CONTROLLER
;TYPE.

REDTAB:	DADDR	(R12RED,R10OFS,FTKI10!FTKL10)
	DADDR	(R12RED,R20OFS,FTKL10)
	DADDR	(R11RED,R11OFS,FTKS10)


DEFINE	DADDR	(ADDR,FTS),<
IFN	FTS,<
	EXP	ADDR
	>
>


;TABLE OF ADDRESSES OF CONTROLLER WRITE ROUTINES INDEXED BY CONTROLLER
;TYPE.

WRTTAB:	DADDR	(R12WRT,FTKI10!FTKL10)
	DADDR	(R12WRT,FTKL10)
	DADDR	(R11WRT,FTKS10)
IFN FTKL10!FTKI10,<
	SUBTTL	RH10/RH20 DEVICE DEPENDENT ROUTINES


;ROUTINES TO READ FROM/WRITE TO A DRIVE ON AN RH10/RH20. CALL WITH THE
;STANDARD AC'S SETUP.  TRANSLATES THE DEVICE INDEPENDENT TRANSFER
;REQUEST INTO AS MANY TRANSFERS AS NECESSARY TO MAKE THE RH10/RH20 HAPPY.
;CALL:	PUSHJ	P,R12RED -OR- PUSHJ   P,R12WRT
;RETURN+1 IF I/O ERRORS
;RETURN+2 IF TRANSFER WAS SUCCESSFUL

R12WRT:	TLOA	S,(FL.IO)	;SET FLAG FOR OUTPUT
R12RED:	TLZ	S,(FL.IO)	;CLEAR FLAG FOR INPUT
	PUSHJ	P,SAVFR		;SAVE F AND R
	PUSHJ	P,R12INI	;INITIALIZE THE RH10/RH20
	  POPJ	P,		;FAILED
R12XFR:	JUMPLE	M,CPOPJ1	;DONE WHEN TRANSFERED ALL BLOCKS
	TLNE	S,(FL.IO)	;WRITING?
	CAILE	F,LB2HOM##+LBOBAT## ;YES, ON HOM OR BAT BLOCKS?
	CAIA			;NO
	HALT	.		;YES,  DON'T MAKE THINGS WORSE
	PUSHJ	P,R12CLR	;MAKE SURE THE RH10/RH20 IS CLEARED
	PUSHJ	P,R12SET	;MAKE IOWDS, TELL DRIVE WHERE TO START
IFN FTKL10,<
	JUMPE	W,R10XFR	;DIFFERENT IF RH10
	MOVSI	T1,<(DO.2ST)>(U) ;TALK TO STCR AND SPECIFIED DRIVE
	DPB	T4,[POINT 10,T1,29] ;STORE -VE BLOCKCOUNT
	JRST	R12XF1		;JOIN COMMON CODE
>
R10XFR:	MOVSI	T1,<(DO.1CR)>(U) ;TALK TO COMMAND REGISTER AND SPECIFIED DRIVE
	HRRI	T1,<BOOTWD##_6>	;SET INITIAL CONTROL WORD ADDRESS
R12XF1:	TLNN	S,(FL.IO)	;DOING OUTPUT?
	TROA	T1,DO.XRD	;NO, SET READ FUNCTION CODE
	TRO	T1,DO.XWT	;YES, SET WRITE FUNCTION CODE
	XCT	DODATO		;START THE TRANSFER
	PUSHJ	P,R12WAT	;WAIT FOR IT TO COMPLETE
	PUSHJ	P,R12CHK	;CHECK FOR ERRORS
	  POPJ	P,		;GIVE NON-SKIP RETURN IF ERRORS OR TIMED OUT
	JRST	R12XFR		;DO MORE IF ANY BLOCKS LEFT
;ROUTINE TO SETUP THE CHANNEL COMMAND LIST FOR THIS TRANSFER AND
;TELL THE DRIVE WHERE TO START THE TRANSFER.  CALL WITH THE STANDARD
;AC'S SETUP.
;CALL:	PUSHJ	P,R12SET
;RETURN+1 ALWAYS
;RETURNS WITH M, R, AND F UPDATED TO REFLECT THIS TRANSFER AND
;	 T4/NEGATIVE BLOCKCOUNT FOR THIS TRANSFER

R12SET:	MOVEI	T4,0		;INITIALIZE BLOCK COUNT TO 0
IFN FTKL10,<
	JUMPE	W,R12SE2	;NO LOGOUT AREA FOR RH10'S
	HRRZ	T1,DVCTAB(J)	;GET DEVICE CODE FOR THIS DEVICE
	LSH	T1,2		;TIMES 2
	SUBI	T1,540		;COMPUTE OFFSET IN EPT OF LOGOUT AREA
	MOVE	T2,EPTADR	;GET PHYSICAL ADDRESS OF THE EPT
	ADDI	T2,R2IOWD-EPT	;ADD OFFSET TO FIRST IOWD
	TLO	T2,RH2JMP##	;MAKE IT A JUMP WORD
	MOVEM	T2,EPT(T1)	;STORE JUMP WORD IN LOGOUT AREA
	MOVSI	T1,-<R2IOWL-1>	;MAKE AOBJN POINTER TO IOWD LIST
R12SE1:	JUMPLE	M,R12SE5	;STOP WHEN DONE ENTIRE TRANSFER
>
R12SE2:	MOVEI	T2,(M)		;ASSUME LESS THAN MAX
	CAMLE	M,[R1BCNT
		   R2BCNT](W)	;ARE WE CORRECT?
	MOVE	T2,[R1BCNT
		    R2BCNT](W)	;NO, MAKE IT THE MAX POSSIBLE IN 1 IOWD
	SUBI	M,(T2)		;DECREMENT BLOCKS REMAINING
	SUBI	T4,(T2)		;AND BLOCKS DONE
	LSH	T2,B2WLSH	;CONVERT TO WORDS
IFN FTKL10,<
	JUMPE	W,R12SE3	;GO IF RH10
	LSH	T2,^D18+4	;POSITION IN IOWD
	TLO	T2,RH2TRA##	;MAKE THE OPCODE A TRANSFER
	IOR	T2,R		;STORE PHYSICAL ADDRESS
	MOVEM	T2,R2IOWD(T1)	;STORE IN CHANNEL COMMAND LIST
	ADDI	R,R2WCNT	;INCREMENT CORE ADDRESS FOR NEXT TIME
	JRST	R12SE4		;JOIN COMMON CODE
>
R12SE3:	MOVNS	T2		;RH10'S WANT A NEGATIVE WORDCOUNT
	LSH	T2,^D18		;MOVE TO LH
	XCT	DOCONI		;GET CONI FOR DRIVE
	TLNE	T1,(CI.122)	;SKIP IF 18 BIT DF10
	LSH	T2,4		;DF10C'S ONLY HAVE 14 BITS OF WORDCOUNT
	IOR	T2,R		;STORE PHYSICAL ADDRESS
	SUBI	T2,1		;AND ADDRESS-1
	MOVEM	T2,.VPAG0+BOOTWD## ;STORE IOWD IN LOW CORE
	SETZM	.VPAG0+BOOTWD##+1 ;INSURE IOWD TERMINATION
	ADDI	R,R1WCNT	;INCREMENT CORE ADDRESS FOR NEXT TIME
IFN FTKL10,<
	JRST	R12SE6		;DO ONLY ONE IOWD FOR AN RH10
R12SE4:	AOBJN	T1,R12SE1	;DO AS MANY AS POSSIBLE
R12SE5:	SETZM	R2IOWD(T1)	;STORE HALT IOWD TO TERMINATE LIST
>
R12SE6:	MOVE	T1,F		;COPY BLOCK ADDRESS
	SUB	F,T4		;UPDATE FOR AMOUNT OF THIS TRANSFER
	IDIV	T1,DRVBPC	;T1=CYLINDER, T2=REMAINDER
	HRLI	T1,<(DO.XDC)>(U) ;STORE IN DESIRED CYLINDER REGISTER
	XCT	DODATO		;TELL THE DRIVE
	IDIV	T2,DRVBPT	;T2=TRACK, T3=SECTOR
	DPB	T2,[POINT 8,T3,27] ;POSITION CORRECTLY
	MOVSI	T1,<(DO.XDS)>(U) ;TALK TO THE BLOCK ADDRESS REGISTER
	HRRI	T1,(T3)		;STORE ADDRESS
	XCT	DODATO		;TELL THE DRIVE
	POPJ	P,		;RETURN
;ROUTINE TO INITIALIZE THE RH10/RH20 FOR A TRANSFER.  ACTS AS A COROUTINE
;IF NO ERRORS ARE DETECTED SO THAT THE CONI STATE MAY BE RESTORED
;WHEN THE CALLER RETURNS
;CALL:	PUSHJ	P,R12INI
;RETURN+1 IF INITIALIZATION FAILED
;RETURN+2 IF SUCCESSFUL

R12INI:	XCT	DOCONI		;GET CONI IN T1
	PUSH	P,T1		;SAVE IT FOR LATER
	MOVEI	T1,1		;WRITE THE PIA
	XCT	DOCONO
	XCT	DOCONI		;AND READ IT BACK
	JUMPE	T1,TPOPJ	;IF NON-0, KONTROLLER EXISTS
	PUSHJ	P,R12CLR	;BLAST THE RH10/RH20 INTO A KNOWN STATE
	MOVSI	T1,<(DO.XDT)>(U) ;NEED DRIVE TYPE REGISTER FOR THIS DRIVE
	PUSHJ	P,DRVTYP	;READ AND CHECK IT
	  JRST	R12IN1		;NO MATCH
	MOVSI	T1,<(DO.XCR)>(U) ;POINT TO DRIVE CONTROL REGISTER
	HRRI	T1,DO.XCL	;FUNCTION IS DRIVE CLEAR
	XCT	DODATO		;CLEAR THE DRIVE
	HRRI	T1,DO.XRP	;FOLLOWED BY A READIN
	XCT	DODATO		;  PRESET
	MOVSI	T1,<(DO.XSR)>(U) ;SETUP TO READ STATUS REGISTER
	PUSHJ	P,REDREG	;DO SO
	ANDI	T1,DI.XSM	;MASK, IGNORING WRITE LOCK, PGM
	CAIE	T1,DI.XSB	;IS IT OK?
	JRST	R12IN1		;NO
	MOVE	T1,-1(P)	;GET CALLERS RETURN ADDRESS
	POP	P,-1(P)		;MOVE CONI BITS DOWN ONE ON THE STACK
	PUSHJ	P,1(T1)		;CALL THE CALLER
	  CAIA			;PROPAGATE NON-SKIP
	AOS	-1(P)		;SET FOR SKIP RETURN
R12IN1:	PUSHJ	P,R12CLR	;BLAST THE RH10/RH20 AGAIN
	POP	P,T1		;RESTORE THE CONI BITS
	IOR	T1,[CO.1AE
		    CO.2ME](W)	;FORCE CORRECT BITS FOR CONTROLLER TYPE
	AND	T1,[CO.1RB
		    CO.2RB](W)	;BUT KEEP ONLY THE IMPORTANT ONES
	XCT	DOCONO		;RESTORE THE PIA, AIE, ETC.
	POPJ	P,		;RETURN


;ROUTINE TO CHECK THE RH10/RH20 FOR ERRORS IN THE LAST TRANSFER.
;CALL:	PUSHJ	P,R12CHK
;RETURN+1 IF ERRORS DETECTED
;RETURN+2 IF NO ERRORS

R12CHK:	MOVSI	T1,<(DO.XSR)>(U) ;SET TO READ STATUS REGISTER
	PUSHJ	P,REDREG	;DO SO
	TRNE	T1,DI.XCE	;COMPOSITE ERROR?
	POPJ	P,		;YES, GIVE ERROR RETURN
	MOVE	T1,[CI.1ER
		    CI.2ER](W)	;GET CONI ERROR BITS FOR CONTROLLER
	XCT	DOCNSO		;ANY SET?
	JRST	CPOPJ1		;NO, GIVE SKIP RETURN
	POPJ	P,		;YES
;ROUTINE TO WAIT FOR THE RH10/RH20 TO FINISH A TRANSFER.
;CALL:	PUSHJ	P,R12WAT
;RETURN+1 IF SUCCESSFUL
;RETURN+2 IF TIMED OUT

R12WAT:	MOVSI	T2,10		;LOOP COUNT = ABOUT 7 SECONDS
	MOVE	T1,[CI.1RA!CI.XDN
		    CI.2RA!CI.XDN](W) ;WAIT FOR DONE OR RAE TO COME UP
	XCT	DOCNSO		;IN THE CONI
	SOJG	T2,.-1		;HASN'T YET, WAIT FOR IT
	JUMPLE	T2,CPOPJ1	;GIVE SKIP RETURN IF TIMED OUT
	POPJ	P,		;RETURN


;ROUTINE TO FORCE THE RH10/RH20 INTO A KNOWN STATE FOR A TRANSFER.
;CALL:	PUSHJ	P,R12CLR
;RETURN+1 ALWAYS

R12CLR:
IFN FTKL10,<
	JUMPE	W,R12CL1	;GO IF RH10
	MOVEI	T1,CO.2ME	;DO A MASSBUS ENABLE
	XCT	DOCONO		;  SO THAT WE CAN READ THE IVI
	MOVSI	T1,(DI.2IV)	;GET ARG TO READ IVI REGISTER
	PUSHJ	P,REDREG	;DO SO
	PUSH	P,T1		;SAVE TO RESTORE IT LATER
R12CL1:
>;END IFN FTKL10
	MOVEI	T1,CO.XMI	;DO A
	XCT	DOCONO		;  MASSBUS INIT
IFN FTKL10,<
	MOVEI	T1,CO.XSX	;THEN A
	XCT	DOCONO		;  STOP TRANSFER
	MOVEI	T1,CO.XDN	;THEN A
	XCT	DOCONO		;  CLEAR DONE
	MOVEI	T1,CO.2ME	;AND FINALLY A
	XCT	DOCONO		;  MASSBUS ENABLE
	JUMPE	W,CPOPJ		;RETURN IF RH10
	POP	P,T1		;RESTORE PREVIOUS IVI
	HRLI	T1,(DO.2IV)	;SET TO RESTORE IT
	XCT	DODATO		;RESTORE THE IVI
>
	POPJ	P,


>;END IFN FTKL10!FTKI10
IFN FTKS10,<
	SUBTTL	RH11 DEVICE DEPENDENT ROUTINES


;ROUTINES TO READ FROM/WRITE TO A DRIVE ON AN RH11.  CALL WITH THE
;STANDARD AC'S SETUP.  TRANSLATES DEVICE INDEPENDENT TRANSFER REQUEST
;TO AS MANY TRANSFERS AS NECESSARY TO MAKE THE RH11 HAPPY.
;CALL:	PUSHJ	P,R11RED -OR- PUSHJ	P,R11WRT
;RETURN+1 IF I/O ERRORS
;RETURN+2 IF TRANSFER WAS SUCCESSFUL

R11WRT:	TLOA	S,(FL.IO)	;SET FLAG FOR OUTPUT
R11RED:	TLZ	S,(FL.IO)	;CLEAR FLAG FOR INPUT
	PUSHJ	P,SAVFR		;SAVE F AND R
	HRLZ	T4,DVCTAB(J)	;SET T4=UBA,,0
	PUSHJ	P,R11INI	;INITIALIZE THE RH11
	  POPJ	P,		;FAILED
R11XFR:	JUMPLE	M,CPOPJ1	;DONE WHEN TRANSFERED ALL BLOCKS
	TLNE	S,(FL.IO)	;WRITING?
	CAILE	F,LB2HOM##+LBOBAT## ;YES, ON HOM OR BAT BLOCKS?
	CAIA			;NO
	HALT	.		;YES, DON'T MAKE THINGS WORSE
	PUSHJ	P,R11CLR	;CLEAR THE RH11
	WRIO	U,SO.CS2(T4)	;SELECT DRIVE
	PUSH	P,T4		;SAVE T4
	PUSHJ	P,R11SET	;SET UBA MAP SLOTS, DRIVE LBN
	POP	P,T4		;RESTORE T4
	MOVEI	T1,SO.WRT	;ASSUME WRITING
	TLNN	S,(FL.IO)	;ARE WE CORRECT?
	MOVEI	T1,SO.RED	;NO, SET READING
	WRIO	T1,SO.CS1(T4)	;START THE TRANSFER
	MOVSI	T2,2		;LOOP COUNT
R11XF1:	RDIO	T1,SO.CS1(T4)	;READ STATUS REGISTER
	TRNN	T1,SI.RDY	;READY COME UP?
	SOJG	T2,R11XF1	;NO, LOOP
	JUMPLE	T2,CPOPJ	;ERROR RETURN IF TIMED OUT
	TRNE	T1,SI.S1E	;ERRORS?
	POPJ	P,		;YES
	JRST	R11XFR		;DO MORE IF ANY BLOCKS LEFT
;ROUTINE TO SETUP THE UBA MAPPING REGISTERS, AND THE DRIVE REGISTERS
;FOR THIS TRANSFER.  CALL WITH THE STANDARD AC'S SETUP.
;CALL:
;	T4/UBA,,0
;	PUSHJ	P,R11SET
;RETURN+1 ALWAYS
;RETURNS WITH M, R, AND F UPDATED TO REFLECT THIS TRANSFER.
;DESTROYS T4

R11SET:	MOVEI	T1,(R)		;GET ADDRESS OF FIRST WORD TO TRANSFER
	ANDI	T1,PAGSIZ-1	;ISOLATE OFFSET OF FIRST WORD IN PAGE
	LSH	T1,2		;MAKE IT A BYTE OFFSET
	WRIO	T1,SO.BA(T4)	;SET THE BUS ADDRESS REGISTER
	MOVE	T1,F		;COPY LBN OF FIRST BLOCK TO TRANSFER
	IDIV	T1,DRVBPC	;T1=CYLINDER, T2=BLOCK IN CYLINDER
	WRIO	T1,SO.DC(T4)	;SET DESIRED CYLINDER REGISTER
	IDIV	T2,DRVBPT	;T2=TRACK, T3=BLOCK IN TRACK
	DPB	T2,[POINT 8,T3,27] ;POSITION TRACK NUMBER
	WRIO	T3,SO.DA(T4)	;TELL DRIVE
	MOVEI	T1,(M)		;ASSUME WE CAN DO ALL OF TRANSFER
	CAILE	T1,RSBCNT	;LARGER THAN MAX?
	MOVEI	T1,RSBCNT	;YES, USE MAX
	SUBI	M,(T1)		;ADJUST M FOR NEXT TIME
	ADDI	F,(T1)		;ADVANCE TO FIRST BLOCK OF NEXT TRANSFER
	MOVE	T2,R		;COPY CORE ADDRESS OF FIRST WORD
	LSH	T1,B2WLSH	;COMPUTE WORD COUNT
	ADD	R,T1		;ADVANCE CORE ADDRESS FOR NEXT TIME
	LSH	T1,1		;COMPUTE PDP11 WORD COUNT
	MOVNS	T1		;MAKE IT NEGATIVE
	WRIO	T1,SO.WC(T4)	;SET WORD COUNT REGISTER
	LSH	T2,W2PLSH	;COMPUTE PAGE NUMBER OF 1ST PAGE
	MOVE	T1,R		;GET ADDRESS OF FIRST WORD OF NEXT TRANSFER
	SUBI	T1,1		;MAKE IT LAST ADDRESS OF THIS TRANSFER
	LSH	T1,W2PLSH	;COMPUTE PAGE NUMBER
	SUBI	T1,-1(T2)	;COMPUTE NUMBER OF PAGES TO MAP
	MOVNS	T1		;MAKE IT NEGATIVE
	HRL	T2,T1		;AND MAKE AN AOBJN POINTER
	TRO	T2,SO.VFT	;SET VALID AND FAST TRANSFER
R11SE1:	WRIO	T2,SO.UPR(T4)	;MAP ONE PAGE
	ADDI	T4,1		;INCREMENT UBA MAP ADDRESS
	AOBJN	T2,R11SE1	;LOOP FOR ALL
	POPJ	P,		;RETURN
IFN <DVCTBL-1>,<PRINTX ?MAPBLK MUST BE EXPANDED>

;ROUTINE TO SAVE UBA MAP REGISTERS
SAVMAP:	HRLZ	T1,DVCTAB	;UBA
	MOVE	T2,[POINT 18,MAPBLK]
SVMAP1:	TRNE	T1,100		;DONE?
	POPJ	P,		;YES
	RDIO	T3,SO.UPR(T1)	;READ MAP REGISTER
	LSHC	T3,-^D20	;CONVERT READ FORMAT TO WRITE
	LSH	T3,-4
	LSHC	T3,^D11
	IDPB	T3,T2		;STORE IT
	AOJA	T1,SVMAP1	;LOOP

;ROUTINE TO RESTORE UBA MAP REGISTERS
RESMAP:	HRLZ	T1,DVCTAB	;UBA
	MOVE	T2,[POINT 18,MAPBLK]
RSMAP1:	TRNE	T1,100		;DONE?
	POPJ	P,		;YES
	ILDB	T3,T2		;GET ORIGINAL VALUE
	WRIO	T3,SO.UPR(T1)	;PUT IT BACK
	AOJA	T1,RSMAP1	;LOOP
;ROUTINE TO INITIALIZE THE RH11 FOR A TRANSFER.  ACTS AS A COROUTINE
;IF NO ERRORS ARE DETECTED SO THAT THE UBA STATUS REGISTER AND
;CONTROL STATUS REGISTER 1 MAY BE RESTORED WHEN THE CALLER RETURNS.
;CALL:
;	T4/UBA,,0
;	PUSHJ	P,R11INI
;RETURN+1 IF INITIALIZATION FAILED
;RETURN+2 IF SUCCESSFUL

R11INI:	RDIO	T1,SO.USR(T4)	;READ UBA STATUS REGISTER
	TRNE	T1,SI.UER	;ANY ERRORS?
	POPJ	P,		;YES, ERROR
	RDIO	T2,SO.CS1(T4)	;READ CS REGISTER 1
	HRL	T1,T2		;T1=CSR 1,,UBA SR
	PUSH	P,T1		;SAVE FOR RESTORE
	PUSHJ	P,R11CLR	;CLEAR THE RH11
	WRIO	U,SO.CS2(T4)	;SELECT DRIVE
	RDIO	T1,SI.DT(T4)	;READ DRIVE TYPE REGISTER
	PUSHJ	P,DRVTYP	;CHECK IT
	  JRST	R11IN1		;FAILED
	MOVEI	T1,SO.DCL	;GET DRIVE CLEAR FUNCTION
	WRIO	T1,SO.CS1(T4)	;DO IT
	MOVEI	T1,SO.RIP	;GET READIN PRESET FUNCTION
	WRIO	T1,SO.CS1(T4)	;DO IT
	RDIO	T1,SO.DS(T4)	;READ DRIVE STATUS REGISTER
	ANDI	T1,SO.DSM	;MASK, IGNORING WRITE LOCK, PGM
	CAIE	T1,SO.DSB	;IS IT OK?
	JRST	R11IN1		;NO
	MOVE	T1,-1(P)	;GET CALLERS RETURN ADDRESS
	POP	P,-1(P)		;MOVE STATE BITS DOWN ONE ON THE STACK
	PUSHJ	P,1(T1)		;CALL THE CALLER
	  CAIA			;PROPAGATE NON-SKIP
	AOS	-1(P)		;GIVE SKIP RETURN
R11IN1:	PUSHJ	P,R11CLR	;CLEAR THE RH11 AGAIN
	POP	P,T1		;GET BACK CS1,,UBA SR
	AND	T1,[SO.RBT]	;KEEP ONLY IMPORTANT BITS
	WRIO	T1,SO.USR(T4)	;RESTORE UBA STATUS REGISTER
	MOVSS	T1		;PUT CS1 BITS IN RH
	WRIO	T1,SO.CS1(T4)	;RESTORE CS1 BITS
	POPJ	P,		;RETURN


;ROUTINE TO FORCE THE RH11 INTO A KNOWN STATE.
;CALL:
;	T4/UBA,,0
;	PUSHJ	P,R11CLR
;RETURN+1 ALWAYS

R11CLR:	MOVEI	T1,SO.UBI	;UBA INIT
	WRIO	T1,SO.USR(T4)	;CLEAR THE UBA/DRIVES
	RDIO	T1,SO.ASR(T4)	;READ ATTENTION SUMMARY
	WRIO	T1,SO.ASR(T4)	;CLEAR ANYBODY WHO'S STILL ON
				;CAN HAPPEN IF DUAL PORTED
	POPJ	P,		;RETURN


>;END IFN FTKS10
	$DEPHASE

MBTPAT:	BLOCK	10		;PATCH SPACE
	MBTLEN==.-MONBTS	;LENGTH OF MONBTS
	MBTPGS==<MBTLEN+PAGSIZ-1>/PAGSIZ ;LENGTH IN PAGES



MBTEND:	END
