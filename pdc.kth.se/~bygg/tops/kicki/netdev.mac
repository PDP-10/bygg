TITLE	NETLPT - NETWORK LINE PRINTER ROUTINES - V132
SUBTTL	NETLPT -- WEM/	18 OCT 83
	SEARCH	F,S,NETPRM

	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1978,1979,1980,1982,1984  BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>

;EDIT HISTORY
;
;  DATE		LOAD	EDIT#
;  ----		----	-----
;
;16-SEP-80	70116	057
;23-SEP-80	70117	060
;04-NOV-80	70125	061
;25-NOV-80	70126	062
;9471-
;24-FEB-81	70142	063
;9592
;10-MAR-81	70144	064
;9617
;17-MAR-81	70145	065
;9627
;21-APR-81	70152	066
;9694
;19-MAY-81	70156	067
;07-JUL-81	70165	070
;9802-
;22NOV-81	70117	071
;9991
;15-DEC-81	70122	072
;MCO 10013
;12-JAN-82	70126	073
;26-JAN-82	70130	074
;10065
;16-FEB-82	70133	075
;10101
;23-FEB-82	70134	076
;09-MAR-82	70136	077
;10144,10148
;16-MAR-82	70137	100
;23-MAR-82	70140	101
;10163
;25-MAY-82	70150	102
;8-JUNE-82	70152	103
;15-JUN-82	70153	104
;22-JUN-82	70154	105
;17-AUG-82	70164	106
;31-AUG-82	70166	107
;10384
;21-SEP-82	70171	110
;28-SEP-82	70172	111
;26-OCT-82	70176	112
;16-NOV-82	70112	113
;23-NOV-82	70113	114
;21-DEC-82	70116	115
;10541
;08-FEB-83	70124	116
;10599
;18-APR-83	70136	117
;10703
;26-APR-83	70137	120
;10-MAY-83	70141	121
;28-JUN-83	70150	122
;12-JUL-83	70151	123
;26-JULY-83	70153	124
;10872
;9-AUG-83	70155	125
;10897
;16-AUG-83	70156	126
;10908
;20-SEP-83	70163	127
;4-OCT-83	70165	130
;11-OCT-83	70166	131
;10999
;18-OCT-83	70167	132
;11003
;
XP VNETDV,132		;PUT VERSION NUMBER IN GLOB AND LOADER MAP

NETLPT::ENTRY	NETLPT
SUBTTL 1.0      LPT SPECIFIC SYMBOL DEFINITIONS

;BITS IN LPT IOS STATUS REGISTER

LPTNFF==100			;SUPPRESSS FORM FEED AT START/END


SUBTTL 2.0      INTERFACE TO UUOCON.  (DEVSER DISPATCH VECTOR)

	JRST	NTDONL##	;(-5) CHECK IF DEVICE IS ON LINE
	JRST	CPOPJ##		;(-4) SPECIAL ERROR STATUS
	JRST	REGSIZ##	;(-3) BUFFER SIZE
	JRST	CPOPJ##		;(-2) INITIALIZATION
	JRST	CPOPJ1##	;(-1) HUNG DEVICE (IGNORE. REMOTE WORRYS)
NDEVLP::JRST	NTDREL##	;RELEASE
	JRST	NTDCLO##	;CLOSE OUTPUT
	JRST	L.OUT		;OUTPUT
	JRST	NTDILI##	;ILLEGAL INPUT (RETURN INTERLOCK)
SUBTTL 2.1        OUT UUO.

L.OUT:				;HERE FROM UUOCON TO OUTPUT A BUFFER
	PUSHJ	P,SAVE3##	;WE USE P1, NETSER USES P2, P3 FOR PCB'S
	MOVSI	S,IOSUSO	;CLEAR THE "UUOCON STOPED OUTPUT"
	ANDCAB	S,DEVIOS(F)	;  SINCE IT JUST TRIED TO START IT AGAIN

L.LOOP:	PUSHJ	P,NTDSET##	;SET UP W, S AND CHECK IOSCON
	MOVSI	S,IO		;GET AND SET 'OUTPUT"
	IORB	S,DEVIOS(F)	; JUST TO KEEP WSYNC HAPPY.
	PUSHJ	P,NTDONL##	;CHECK IOSERR TO SEE IF STILL ONLINE
	  JRST	L.HUNG		;IF LPT IS OFFLINE, GO PLAY DEAD.
	TLNE	S,IOBEG		;IS THIS THE FIRST OUT??
	JRST	L.FRST		; IF SO, GO DO SPECIAL CODE.

	MOVEI	T1,7		;LINE PRINTER DATA IS 7 BIT BYTES
	PUSHJ	P,NTDSOB##	;SET UP THE OUTPUT BUFFER
	  JRST	L.DONE		;NO MORE DATA. RETURN TO UUOCON.
	SKIPN	DEVAXO+1(F)	;FOR LPT'S MAKE SURE THAT WE DON'T
	JRST	L.LOO1		; SEND ZERO LENGTH BUFFERS
	PUSHJ	P,NTDCDQ##	;SEE IF ANY DATA REQUESTS PENDING
	  JRST	L.WAIT		;NONE AVAILABLE.  WE MUST WAIT.
	MOVEI	T1,PCV.LC	;WE WANT LINE-PRINTER COMPRESSION
	MOVEI	T2,DC.DAR	; NOT-INTERRUPT, DATA WITH E-O-R
	PUSHJ	P,NTDXMT##	;SEND ANOTHER PCB'S WORTH OF DATA
	  PUSHJ	P,[JUMPN T1,NTDSTP## ;WE SHOULD NEVER GET AN IO-ERROR
		   POP P,(P)	;CLEAN OFF THE RETURN ADDRESS (UGLY)
		   PUSHJ P,NETSLP## ;PAUSE FOR FREECORE
		   JRST L.LOOP]	; AND TRY AGAIN
	PUSHJ	P,NTDDDQ##	;UPDATE THE DATA REQUEST COUNT
	SKIPN	DEVAXO+1(F)	;ARE THERE ZERO BYTES LEFT??
L.LOO1:	PUSHJ	P,NTDAOB##	;IF SO, THEN GIVE USER BACK THE BUFFER
	JRST	L.LOOP		;LOOP UNTIL ALL DATA IS OUT
SUBTTL 2.2        FIRST TIME ONLY CODE (OUTPUT <CR><FF>)

L.FRST:				;HERE ON FIRST OUT FROM UUOCON
	SETZM	DEVAXO(F)	;CLEAR ANY DATA NOT OUTPUT LAST TIME
	TRNE	S,LPTNFF	;SHOULD WE OUTPUT THE FIRST <CR><FF>
	JRST	L.FRS3		; IF NOT, THEN SKIP MOST OF THIS
	PUSHJ	P,NTDCDQ##	;DO WE HAVE A DATA REQUEST FOR THIS?
	  JRST	L.WAIT		; IF NOT, WE MUST WAIT FOR ONE
	MOVEI	T1,^D16		;WE WANT A 16 WORD DATA MESSAGE
	PUSHJ	P,NTDHDR##	; SET UP P2 := POINTER, P3 := COUNT
	  JRST	[PUSHJ P,NETSLP##	;IF WE CAN'T GET THE MEMORY, SLEEP
		 JRST L.LOOP]	;NOW GO TRY AGAIN
	MOVE	T3,[POINT 8,[BYTE (8)3,DC.DAR,215,214]]
				;LENGTH & MESSAGE TO SEND (REMEMBER
				; COMPRESSION)
	MOVEI	T4,4		;WE WILL SEND 4 BYTES (INCLUDING LENGTH)

L.FRS2:	ILDB	T1,T3		;GET THE NEXT BYTE
	PUSHJ	P,DPBBIN##	; AND PUT IT IN THE MESSAGE
	SOJG	T4,L.FRS2	;LOOP TILL ALL BYTES IN MESSAGE.

	ADDB	P3,PCBOCT(U)	;UPDATE THE COUNT IN FIRST SEGMENT.
	SETZB	P3,PCBOC1(U)	;INDICATE THAT THERE IS NO SECOND SEG.
	MOVEI	T1,PCV.NC	;NO LPT COMPRESSION
	PUSHJ	P,NTDWRT##	;SEND THE MESSAGE.
	PUSHJ	P,NTDDDQ##	;DECREMENT THE DATA REQUEST COUNT

L.FRS3:				;HERE WHEN ALL "FIRST TIME" STUFF DONE.
	MOVSI	S,IOBEG!IOSREL	;GET AND CLEAR "RELEASED"
	ANDCAB	S,DEVIOS(F)	; AND "FIRST TIME" BIT
	JRST	L.LOOP		;GO BACK AND TRY TO SEND USER DATA.
SUBTTL 2.3        EXCEPTION HANDLING.

L.DONE:				;HERE IF ALL USERS BUFFERS SENT
	POPJ	P,		;I THINK UUOCON WILL DO THE REST

L.WAIT:				;HERE WHEN NO DATA REQUESTS.
	PUSHJ	P,NTDWTO##	;WAIT FOR DRQ.
	  POPJ	P,		;RETURN TO UUOCON IF NON-BLOCKING.
	JRST	L.LOOP		;TRY FOR MORE DATA-OUT.
				;L.LOOP WILL RELOAD "S" AND "W"

L.HUNG:				;HERE WHEN IOSERR IS SET.
	TLNN	S,IOSCON	;ARE WE STILL CONNECTED
	JRST	L.GONE		; NO. TELL USER DEVICE IS GONE
	TLNE	S,IOSERR	;IS THE LPT ON LINE YET??
	PUSHJ	P,NTDHNG##	;SET OFF-LINE AND TELL THE OPERATOR
	JRST	L.LOOP		;TRY TO SEND SOME MORE DATA.

L.GONE:				;HERE WHEN LPT IS DISCONNECTED.
	MOVEI	S,IODERR!IODTER	;TWO BITS FOR UUOCON TO CONTEMPLATE
	IORB	S,DEVIOS(F)	;SET THEM IN DEVIOS
	MOVEI	T1,IONND%	;??????
	DPB	T1,PDVESE##	;??????
	POPJ	P,		;BACK TO UUOCON
SUBTTL 3.0      INTERFACE TO NETSER (NETWORK DISPATCH VECTOR)

	JRST	NTDNWD##	;USE DEFAULT "NODE WENT DOWN" HANDLER
	JRST	NTDDSC##	;USE DEFAULT DISCONNECT HANDLER
	JRST	L.CNC		;CONNECT CONFIRM HANDLER
	JRST	NTDSTP##	;++ SHOULD NEVER GET CONNECT INITIATE ENTRY
	JRST	NTDRDQ##	;USE STANDARD DATA-REQUEST HANDLER
LPTNDP::JRST	NTDILD##	;USE CANNED INTERRUPT LEVEL DISPATCH
	JRST	CPOPJ##		;WE DON'T GET ANY DATA
	JRST	CPOPJ##		; ESPECIALY DATA WITH E-O-R...
	JRST	L.STAT		;WE DO GET STATUS MESSAGES
	JRST	CPOPJ##		;WE DONT GET CONTROL
	JRST	CPOPJ##		;OR UID
	JRST	CPOPJ##		;OR FILE-SPEC'S



;DUMMY CONNECT INIT PROCESSOR

NLPTCI==:NJNKCI##		;A JUNK CI
SUBTTL	CONNECT CONFIRM HANDLER

L.CNC:	PUSHJ	P,NTDCNC##	;STANDARD CONNECT CONFIRM PROCESSING
	  POPJ	P,		;ERROR, PROPAGATE BACK TO NETSER
	LDB	T1,NETDVT##	;RETRIEVE "DVT" ATTRIBUTES FIELD
	SETZ	T2,		;INITIAL "HCW" HARDWARE CHARACTERISTICS
	TRNE	T1,DLP.LL	;LOWERCASE?
	TLO	T2,(HC.LCP)	;YES
	LDB	T1,NETDVU##	;RETRIEVE "UNIT" TYPE
	DPB	T1,[POINT 3,T2,14]  ;AND STUFF INTO HCW WORD
	LDB	T1,NETDVV##	;RETRIEVE "CONTROLLER" TYPE
	DPB	T1,[POINT 3,T2,11]  ;AND STUFF INTO HCW WORD
	MOVEM	T2,DEVHCW(F)	;SET LINEPRINTER HARDWARE CHARACTERISTICS
	JRST	CPOPJ1##	;SUCCESSFUL RETURN BACK TO NETSER
SUBTTL 3.1        INPUT STATUS MESSAGE PROCESSING

L.STAT:				;HERE FROM NETSER WITH A STATUS MESSAGE.
				;STC
	PUSHJ	P,EBI2BI##	;GET TYPE OF STATUS MESSAGE
	JUMPN	T1,CPOPJ##	; (WE ONLY RESPECT TYPE 0)
				;STD
	PUSHJ	P,EBI2BI##	;GET THE DEVICE BITS.
	HRRM	T1,DEVSTS(F)	;STORE THE STATUS FOR UUOLEVEL TO WATCH
	AOS	(P)		;WE ARE NOW SATISFIED THAT MSG IS GOOD.
	MOVE	T2,[IORB S,DEVIOS(F)]	;ASSUME THAT WE ARE OFFLINE.
	TRNN	T1,SLP.OL	; BUT CHANGE OUR MINDS IF WE
	MOVE	T2,[ANDCAB S,DEVIOS(F)]	; WE ARE ONLINE
	MOVE	T3,DEVIOS(F)	;COPY OLD STATUS
	MOVSI	S,IOSERR	;AND SET/CLEAR
	XCT	T2		; THE ERROR BIT "IOSERR" IN DEVIOS

	CAME	S,T3		;DID THE STATUS CHANGE??
	PUSHJ	P,NTDOAV##	; IF IT DID, THEN WAKE UP UUOLEVEL
	POPJ	P,		;GIVE GOOD RETURN TO NETSER



	XLIST			;DON'T LIST LITERALS
	$LIT
	LIST
	PRGEND
TITLE	NETCDR - NETWORK CARD READER ROUTINES - V001
SUBTTL	NETCDR -- WEM/	4-JUN-78
	SEARCH	F,S,NETPRM
	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; COPYRIGHT (C) 1978 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
XP VNETCD,001		;PUT VERSION NUMBER IN GLOB AND LOADER MAP
	ENTRY	NETCDR
NETCDR::
SUBTTL 1.0      CDR SPECIFIC SYMBOL DEFINITIONS

;SPECIAL CHARACTERS

	C%EOF==7417		;END OF FILE CHARACTER
	C%026==4242		;CHANGE MODE TO 026 CHARACTER
	C%029==5252		;CHANGE MODE TO 029 CHARACTER


;BITS IN LH OF DEVIOS(F)

	IOS029==IOSFFB		;IF SET THEN DO TRANSLATION IN 029 MODE


;BIT INDICATING SUPER-IMAGE-MODE INPUT

	IO.SIM==1B29		;BIT THAT SAYS SUPER-IMAGE-INPUT
SUBTTL 2.0      INTERFACE TO UUOCON (DEVSER DISPATCH VECTOR)

	JRST	NTDONL##	;(-5) CHECK IF DEVICE IS ON LINE
	JRST	CPOPJ##		;(-4) SPECIAL ERROR STATUS
	JRST	C.BFSZ		;(-3) BUFFER SIZE
	JRST	CPOPJ##		;(-2) INITIALIZATION
	JRST	CPOPJ1##	;(-1) HUNG DEVICE
NDEVCD::JRST	NTDREL##	;RELEASE
	JRST	CPOPJ##		;CLOSE OUTPUT
 	JRST	NTDILO##	;ILLEGAL OUTPUT (RETURN INTERLOCK)
	JRST	C.IN		;INPUT
SUBTTL 2.1        INPUT UUO PROCESSING

C.IN:				;HERE FROM UUOCON ON IN UUO
	PUSHJ	P,SAVE4##	;WE CLOBBER ALL THE P'S
	MOVSI	S,IOSUSI	;CLEAR THE "UUOCON STOPED INPUT" BIT SINCE
	ANDCAB	S,DEVIOS(F)	;  IT HAS JUST TRIED TO START IT AGAIN.

C.LOOP:	PUSHJ	P,NTDSET##	;SET UP W, S ETC.
	MOVE	S,DEVIOS(F)	;FAMOUS STYLE OF LOOP DRIVEN CODE.
	TLNN	S,IOSCON	;STILL THERE?
	JRST	C.GONE		;NODE WENT AWAY
	TLNE	S,IOBEG		;IS THIS THE FIRST TIME THROUGH?
	JRST	C.FRST		; IF IT IS, DO SOME SPECIAL CHECKING
	MOVSI	S,IO		;WE ARE AN INPUT DEVICE
	ANDCAB	S,DEVIOS(F)	;MAKE SURE THAT UUOCON NOTICES
	PUSHJ	P,NTDIBA##	;CHECK TO MAKE SURE THAT NTDSIB WON'T FAIL
	  POPJ	P,		;IF NO INPUT BUFFER, RETURN TO UUOCON
	HRRZ	T1,DEVPCB(F)	;IS THERE ANY INPUT TO PROCESS??
	JUMPE	T1,C.WAIT	;IF NO DATA, GO WAIT FOR SOME
	PUSHJ	P,NTDDID##	;PROCESS THE NEXT NCL SUB-MESSAGE
	JRST	C.LOOP		;MAKE SURE EVERYTHING'S STILL OK.



C.WAIT:	PUSHJ	P,NTDONL##	;SEE IF THERE'S ANY BAD REASON FOR NO DATA
	  JRST	C.HUNG		; IF ERROR BIT IS SET. GO FIND OUT WHY.
	PUSHJ	P,NTDXDQ##	;SEE IF WE ARE BEHIND ON OUR DRQ'S
	PUSHJ	P,C.CLRS	;MAKE SURE THE CDR IS RUNNING
	PUSHJ	P,NTDWTI##	;WAIT FOR INPUT (EW STATE)
	  POPJ	P,		;IF NONBLOCKING, RETURN TO UUOCON NOW.
	JRST	C.LOOP		;SOMETHING WOKE US UP.  GO SEE WHAT
SUBTTL 2.2        INPUT UUO EXCEPTION PROCESSING

C.FRST:				;HERE ON THE FIRST IN
	MOVSI	S,IO!IOBEG!IOSREL ;CLEAR THESE BITS
	ANDCAB	S,DEVIOS(F)	;SINCE WE ARE APPARENTLY RUNNING NOW
	MOVSI	S,IOS029	;INITIALIZE THE TRANSLATION MODE
	IORB	S,DEVIOS(F)	;MODEL 029.
	SETZM	DEVAXI(F)	;CLEAR ANY PARTIAL BUFFER THAT MAY BE LEFT
	PUSHJ	P,C.CLRS	;CLEAR THE "STOP" BITS
	JRST	C.LOOP


C.HUNG:				;HERE FROM C.LOOP WHEN IOSERR IS SET.
	TLNN	S,IOSCON	;ARE WE STILL CONNECTED
	JRST	C.GONE		; NO. TELL USER THE DEVICE IS GONE
	PUSHJ	P,C.CLRS	;CLEAR THE STOP BITS
	TLNE	S,IOSERR	;IS THE CDR ONLINE YET??
	PUSHJ	P,NTDHNG##	;SET OFF-LINE AND TELL THE OPERATOR
	JRST	C.LOOP		;BACK TO LOOP TO TRY AGAIN.

C.GONE:				;HERE WHER DEVICE IS NO LONGER CONNECTED
	MOVEI	S,IODERR!IODTER	;TWO LIKELY LOOKING BITS
	IORB	S,DEVIOS(F)	;SET THEM SO THE USER WILL KNOW SOMETHINGS BAD
	MOVEI	T1,IONND%	;??????
	DPB	T1,PDVESE##	;??????
	POPJ	P,		;BACK TO UUOCON.



C.CLRS:				;HERE TO CLEAR THE "EOF" AND "STOP" BITS
	MOVEI	T1,SCD.SR!SCD.HZ!SCD.CZ ;"STOP READ", "HARD EOF", "EOF CARD"
	PUSHJ	P,NTDCST##	;SEND THE "CLEAR BITS" MESSAGE
	  JRST	C.CLR1		;COULDN'T SEND MSG. SLEEP AND TRY AGAIN LATER.
	POPJ	P,		;ALL DONE.  RETURN

C.CLR1:	PUSHJ	P,NETSLP##	;SLEEP FOR 2 SECONDS
	PUSHJ	P,NTDSET##	;SET UP "W" AND "S" AGAIN
	TLNE	S,IOSCON	;MAKE SURE NODE DIDN'T GO AWAY
	JRST	C.CLRS		;IF STILL THERE, TRY SENDING STATUS AGAIN
	POPJ	P,		;IF NODE GONE, JUST PRETEND MSG WENT OUT.


;ROUTINE TO RETURN BUFFER SIZE
C.BFSZ:	MOVEI	T1,^D81		;ASSUME THAT WE ARE IN SUPER IMAGE MODE
	TRNE	M,IO.SIM	;IF WE ARE IN SUPER IMAGE MODE
	POPJ	P,		; THEN THE BUFFER SIZE IS 80. WORDS
	JRST	REGSIZ##	;IF NOT IN SUPERIMAGE MODE, LOOK IN THE DDB
SUBTTL 3.0      INTERFACE TO NETSER (NETWORK DISPATCH VECTOR)

	JRST	NTDNWD##	;USE DEFAULT "NODE WENT DOWN" HANDLER
	JRST	NTDDSC##	;USE DEFAULT DISCONNECT HANDLER
	JRST	NTDCNC##	;USE STANDARD CONNECT CONFIRM CODE
	JRST	NTDSTP##	;++ SHOULD NEVER GET HERE
	JRST	CPOPJ##		;WE SHOULDN'T GET DATA REQUESTS
CDRNDP::JRST	NTDQIP##	;QUEUE INCOMING MESSAGE TO UUO LEVEL
	JRST	C.DATA		;DATA
	JRST	C.DATA		;DATA WITH E-O-R
	JRST	C.STAT		;STATUS
	JRST	CPOPJ##		;WE DONT GET CONTROL
	JRST	CPOPJ##		;OR UID
	JRST	CPOPJ##		;OR FILE-SPEC'S



;DUMMY CONNECT INIT PROCESSOR

NCDRCI==:NJNKCI##		;A JUNK CI
SUBTTL 3.1        INPUT DATA MESSAGE PROCESSING

;REGISTER USAGE IS AS FOLLOWS.
;  P1	SET UP AT ENTRY BY NTDISP.  POINTS TO FIRST DATA BYTE IN MESSAGE
;  P4	SET UP AT ENTRY BY NTDISP.  CONTAINS NUMBER OF DATA BYTES LEFT.
;  P2	USED AS A COLUMN COUNTER. (STARTS AT 80. COUNTS DOWN)
;  P3	USED BY C.NEXT WHEN DE-COMPRESSING CDR DATA.

C.DATA:				;HERE TO PROCESS CDR DATA
	SETZ	P3,		;CLEAR REPEAT COUNT FOR C.NEXT
	MOVEI	P2,^D80		;INITIALIZE THE COLUMN COUNTER.
	TRNE	S,IO.SIM	;IS IT SUPER IMAGE MODE?
	JRST	C.SIMG		; YES. GO TO SUPER IMAGE MODE PROCESSOR.
	LDB	T1,PIOMOD##	;GET THE MODE.
	CAIG	T1,AL		;IS IT ONE OF THE ASCII MODES
	JRST	C.ASCI		; YES. GO TO SPECIAL PROCESSOR
	CAIN	T1,I		;IMAGE?
	JRST	C.IMAG		; YES.
	CAIL	T1,IB		;IS IT ONE OF THE SCREWY
	CAILE	T1,B		; BINARY MODES?
	JRST	C.IMPM		;NO. BAD MODE. GIVE ERROR
	JRST	C.BIN		;BINARY MODE. GO READ SCREWY CARDS.
SUBTTL 3.1.1        IMAGE MODE INPUT PROCESSING

C.SIMG:				;CDR SUPER-IMAGE MODE.
	SKIPA	T4,[EXP ^D36]	;SUPER-IMAGE MODE USES 36 BIT BYTES
C.IMAG:				;IMAGE MODE
	MOVEI	T4,^D12		;IMAGE MODE USES 12 BIT BYTES.
	PUSHJ	P,NTDSIB##	;SET UP THE INPUT BUFFER
	  PUSHJ	P,NTDSTP##	;STOP!  THIS WAS CHECKED AT C.LOOP!

C.IMG1:	PUSHJ	P,C.NEXT	;GET THE NEXT 12 BIT CHARACTER
	  JRST	C.DERR		;IF NONE, THEN REMOTE SENT BAD MESSAGE.
	SOSGE	DEVAXI+1(F)	;COUNT DOWN THE BYTE COUNT
	JRST	C.BKTL		; IF EMPTY, THEN USER'S BUFFER IS TOO SMALL
	EXCTUU	<IDPB T1,DEVAXI(F)> ;STORE THE BYTE
	SOJG	P2,C.IMG1	;LOOP OVER ALL COLUMNS
	PJRST	NTDA1B##	;ADVANCE THE INPUT BUFFER AND SKIP RETURN
SUBTTL 3.1.2        ASCII MODE INPUT PROCESSING

C.ASCI:				;ASCII MODE CARDS (UGH)
	MOVEI	T4,^D7		;SEVEN BIT BYTES FOR ASCII MODES
	PUSHJ	P,NTDSIB##	;SET UP THE INPUT BUFFER
	  PUSHJ	P,NTDSTP##	;STOP. CAN'T HAPPEN. WE CHECKED AT C.LOOP

	PUSHJ	P,C.NEXT	;GET COLUMN 1
	  JRST	C.DERR		;?? NO FIRST COLUMN ??
	CAIN	T1,C%EOF	;IS IT AN E-O-F CARD
	JRST	C.DEND		; IF SO, GO TELL THE USER
	CAIN	T1,C%029	;IS IT A CHANGE TO 029 STYLE TRANSLATION
	JRST	[MOVSI S,IOS029	;IF SO, FIRST SET THE "029 MODE"
		 IORB S,DEVIOS(F) ; BIT FOR C.CONV TO SEE, AND
		 PJRST CPOPJ1##]  ; GIVE GOOD RETURN (BUT DON'T ADVANCE BUFFER)
	CAIN	T1,C%026	;IS IT A CHANGE TO 026 STYLE TRANSLATION
	JRST	[MOVSI S,IOS029	;IF SO, FIRST CLEAR THE "029 MODE"
		 ANDCAB S,DEVIOS(F) ; FOR C.COMV
		 PJRST CPOPJ1##]    ;GIVE GOOD RETURN.

	JRST	C.ASC2		;NORMAL CARD. SKIP INTO COPY LOOP.
C.ASC1:	PUSHJ	P,C.NEXT	;GET THE NEXT BYTE
	  JRST	C.DERR		;REMOTE SENT BAD DATA
C.ASC2:	PUSHJ	P,C.CONV	;DO THE DATA CONVERSION
	SOSGE	DEVAXI+1(F)	;COUNT DOWN THE BYTE COUNT
	JRST	C.BKTL		;USER DIDN'T GIVE BIG ENOUGH BUFFER.
	EXCTUU	<IDPB T1,DEVAXI(F)> ;STORE THE BYTE IN THE USERS BUFFER.
	SOJG	P2,C.ASC1	;LOOP FOR ALL 80 CHARACTERS.

	SOSGE	DEVAXI+1(F)	;COUNT OFF THE <CR>
	JRST	C.BKTL		;BUFFER TOO SMALL
	MOVEI	T1,15		;<CR>
	EXCTUU	<IDPB T1,DEVAXI(F)> ;STORE THE <CR>

	SOSGE	DEVAXI+1(F)	;COUNT OFF THE <LF>
	JRST	C.BKTL		;BUFFER TOO SMALL
	MOVEI	T1,12		;<LF>
	EXCTUU	<IDPB T1,DEVAXI(F)> ;STORE THE <LF>

	PJRST	NTDA1B##	;ADVANCE BUFFER AND NCL MESSAGE
SUBTTL 3.1.3        BINARY MODE INPUT PROCESSING

C.BIN:				;BINARY MODE
	MOVEI	T4,^D12		;12 BIT BYTES IN BINARY MODE
	PUSHJ	P,NTDSIB##	;SET UP THE INPUT BUFFER
	  PUSHJ	P,NTDSTP##	;STOP. THIS WAS CHECKED EARLIER.
	PUSHJ	P,C.NEXT	;GET THE FIRST COLUMN
	  JRST	C.DERR		;?? NO FIRST BYTE ??
	CAIN	T1,C%EOF	;WAS THIS AN EOF CARD
	JRST	C.DEND		;IF SO, GO SET E-O-F AND RETURN
	MOVEI	T2,-5(T1)	;TAKE OUT THE 7-9 BITS
	TRNE	T2,17		;MAKE SURE THAT'S ALL THAT WAS THERE
	JRST	C.IMPB		;IMPROPER BINARY CARD. ABORT.
	LSH	T1,-6		;SHIFT TO GET JUST WORD COUNT.
	JUMPE	T1,CPOPJ1##	;IF NO WORDS. JUST RETURN
	HRLM	T1,DEVAXO(F)	;STORE WORD COUNT IN OUTPUT WORD FOR A BIT
	IMUL	T1,3		;CONVERT WORD COUNT INTO A COLUMN COUNT
	MOVEI	T2,(T1)		;INITIALIZE "GLOBAL" COLUMN COUNT.

	PUSHJ	P,C.NEXT	;GET THE CHECKSUM BYTE
	  JRST	C.DERR		;?? STRANGE MESSAGE ??
	HRRM	T1,DEVAXO(F)	;SAVE THE CHECKSUM TILL LATER TOO!

C.BIN1:				;COPY LOOP.
	PUSHJ	P,C.NEXT	;GET THE NEXT BYTE
	  JRST	C.DERR		;CARD ENDED TOO SOON!
	SOSGE	DEVAXI+1(F)	;COUNT DOWN THE BYTE
	JRST	C.BKTL		;USER DIDN'T MAKE BUFFER BIG ENOUGH.
	EXCTUU	<IDPB T1,DEVAXI(F)> ;STORE THE BYTE IN THE USERS BUFFER.
	SOJG	P2,C.BIN1	;COMPLETE THE REST OF THE CARD.

;NOW WE MUST COMPUTE THE "FOLDED 12 BIT" CHECKSUM

	HRRZ	T1,DEVIAD(F)	;GET A POINTER TO THE BUFFER HEADER
	ADDI	T2,2		;NOW IT POINTS TO FIRST USER DATA WORD
	HLRZ	T3,DEVAXO(F)	;RECOVER THE WORD COUNT
	SETZ	T1,		;INITIALIZE THE CHECKSUM

	EXCTUX	<ADD T1,(T2)>	;ADD THE NEXT WORD
	SOJG	T3,.-1		;LOOP UNTIL ALL WORDS ARE COLLECTED

	LSHC	T1,-^D24	;SHIFT SO AS TO GET TOP AND
	LSH	T2,-^D12	; BOTTOM THIRD ADDED
	ADD	T1,T2		; TOGETHER IN T1
	LSHC	T1,-^D12	;SHIFT SO AS TO GET MIDDLE
	LSH	T2,-^D24	; THIRD ADDED IN
	ADD	T1,T2		; THERE TOO
	TRZE	T1,770000	;CLEAR EXTRA BITS, BUT CHECK
	ADDI	T1,1		; AND CORRECT FOR CARRY (CIRCULAR CHECKSUM)
	HRRZ	T2,DEVAXO(F)	;GET THE ORIGIONAL CHECKSUM
	CAIE	T1,(T2)		;SEE IF THEY AGREE.
	JRST	C.DTER		;IF NOT, GIVE IODTER
	PJRST	NTDA1B##	;IF THEY DO, THEN ADVANCE BUFFERS
SUBTTL 3.2        INPUT STATUS MESSAGE PROCESSING

C.STAT:				;HERE UPON RECEIPT OF A STATUS MESSAGE
;STC
	PUSHJ	P,EBI2BI##	;READ THE CODE (STATUS, SET, OR CLEAR)
	JUMPN	T1,CPOPJ##	;WE ONLY ACCEPT THE ZERO KIND.
;STD
	PUSHJ	P,EBI2BI##	;READ THE STATUS BITS
	XOR	T1,DEVSTS(F)	;GET A MASK OF THE BITS THAT CHANGED
	TRNN	T1,-1		;DID ANY CHANGE?
	JRST	CPOPJ1##	;IF NOT, DON'T GO ANY FARTHER
	XORB	T1,DEVSTS(F)	;REMEMBER THE NEW STATUS
	MOVSI	S,IOSERR	;GET ERROR BIT TO SET/CLEAR
	MOVE	T2,[0 S,DEVIOS(F)] ;GET SKELETON INSTRUCTION TO SET/CLEAR BITS
	TRNE	T1,SCD.ME	;IS THE ERROR BIT LIT?
	TLOA	T2,(IORB)	;YES. SET ERROR BITS
	TLO	T2,(ANDCAB)	;NO. CLEAR ERROR BITS
	XCT	T2		;SET/CLEAR THE BITS
	PUSHJ	P,NTDIAV##	;TELL LOWLEVEL THAT SOMETHING HAPPENED
	JRST	CPOPJ1##	;NO NEED TO DO MORE.  C.LOOP & C.HUNG WILL
				; NOTICE THESE BITS SOON ENOUGH.
SUBTTL 4.0      UTILITY ROUTINES

SUBTTL 4.1        ERROR HANDLING ROUTINES

COMMENT \

Possible CDR error codes and their causes are as follows.

    IOEND
	Ascii and binary modes.  Indicates an "EOF" card
    IOBKTL
	All modes.  A user specified buffer was too small to hold an
	entire card.
    IODTER
	Binary mode only.  Indicates that the checksum was wrong.
    IODERR
	Device error (usually a bad message from the remote)
    IOIMPM
	Improper mode. Cdr was not opened in a legal mode, or while in
	binary mode a non-binary card was read.

\


C.SER0==.+1			;KONSTANT TO NORMALIZE "T1"
C.DEND:	JSP	T1,C.SERR	;END-OF-FILE
C.BKTL:	JSP	T1,C.SERR	;BLOCK TO LARGE
C.DTER:	JSP	T1,C.SERR	;CHECKSUM ERROR
C.DERR:	JSP	T1,C.SERR	;DEVICE ERROR (OR REMOTE ERROR)
C.IMPM:	JSP	T1,C.SERR	;IMPROPER MODE (OPEN)
C.IMPB:	JSP	T1,C.SERR	;IMPROPER MODE (BINARY MODE AND NOT BINARY CARD)

;THE FORMAT OF ENTRIES IN THIS NEXT TABLE ARE "XWD FLAGS,BIT"
; WHERE BIT IS THE "DEVIOS" ERROR BIT TO SET, AND
; WHERE FLAGS ARE BITS THAT SAY:
;  1 - ADVANCE THE USERS BUFFER
;  2 - SKIP RETURN (ADVANCE THE NCL MESSAGE)

C.SERR:	MOVE	T1,[XWD 7,IOEND		;E-O-F
		    XWD 3,IOBKTL	;BLOCK-TOO-LARGE
		    XWD 3,IODTER	;DATA-ERROR
		    XWD 3,IODERR	;DEVICE ERROR
		    XWD 1,IOIMPM	;IMPROPER MODE (OPEN)
		    XWD 3,IOIMPM	;IMPROPER MODE (BINARY CARD)
		   ]-C.SER0(T1)	;GET XWD FLAGS,BIT
	MOVEI	S,(T1)		;GET OUR BIT TO SET
	TLNE	T1,4		;IF THIS BIT IS SET,
	HRLZ	S,S		;THEN PUT THE BIT IN THE LH
	IORB	S,DEVIOS(F)	;AND SET IT
	TLNE	T1,2		;SKIP RETURN?
	AOS	(P)		;YES. MAKE SURE IT HAPPENS
	TLNE	T1,1		;ADVANCE INPUT BUFFER?
	PUSHJ	P,NTDAIB##	;YES. GO DO IT.
	POPJ	P,		;ALL DONE
SUBTTL 4.2        DATA DECOMPRESSION ROUTINE

COMMENT \
DATA SENT TO DECSYSTEM-10 IS ESSENTIALY IMAGE MODE
	REPRESENTATION	MEANING
	1CCCCCCC	CCCCCCC = SEVEN BIT ENCODED CHARACTER
			PUNCH 12=B6; PUNCH 11=B5; PUNCH 0=B4
			CODE	PUNCHES IN ROWS 1-9
			0	NONE
			1	1
			2	2
			3	3
			4	4
			5	5
			6	6
			7	7
			10	8
			11	9
			12	8-2
			13	8-3
			14	8-4
			15	8-5
			16	8-6
			17	8-7
	01XXXXXX	XXXXXX =COUNT OF BLANKS
	001XXXXX	XXXXX = COUNT OF REPETITIONS, 0-31
	0000CCCC
	CCCCCCCC	CCCCCCCCCCCC = TWELVE BIT ENCODED CHARACTER

DB.DCS - DEVICE CONTROL STATUS BITS

	CS.ERR=0001	;CARD READER ERROR(MASTER ERROR)
	CS.HEM=0002	;HOPPER EMPTY
	CS.RER=0004	;REGISTRATION ERROR
	       0010	;INVALID PUNCH
	CS.FUL=0020	;STACKER FULL
	CS.JAM=0040	;JAM WHILE FEEDING
	CS.PCK=0100	;PICK FAILURE
	CS.EOF=0200	;END OF FILE CARD
	       0400	;HDW EOF
	       1000	;CDR OVERRAN THE PROCESSOR
	CS.OFL=2000	;CDR HAS GONE OFF LINE
	CS.STP=4000	;CDR STOPPED (CLEARED BY 10 WITH CLEAR STATUS MSG)

\
;SUBROUTINE C.NEXT RETURN THE NEXT CHAR FROM THE DAP MESSAGE POINTED
; TO BY P1 (WITH SUB-MESSAGE LENGTH IN P4)
;
;CALL	MOVE P1,BYTE POINTER TO FIRST CHAR OF DATA IN MESSAGE (AFTER TYP)
;	MOVE P4,COUNT OF DAP DATA BYTES
;	SETZ P3,		;CLEAR THE REPEAT COUNT
;	PUSHJ P,C.NEXT
;RETURN	CPOPJ			;NO CHAR AVAILABLE (MESSAGE COUNTED OUT, OR
;				; SOMETHING WAS WRONG WITH THE MESSAGE)
;	CPOPJ1			;T1 := THE NEXT 12 BIT CHAR FROM THE STREAM
;
;NOTE.	WHEN THIS ROUTINE IS DECOMPRESSING CHARACTERS IT USES P3 AS
;	A REPEAT COUNT.  IF YOU CLOBBER P3 BETWEEN CALLS TO C.NEXT, YOU
;	WILL GET GARBAGE.

C.NEXT:				;MAIN ENTRY TO GET NEXT 12 BYTE CHAR.
	JUMPN	P3,C.RPT	;IF WE ARE IN A REPEAT, GO USE LH OF P3
C.NXT0:				;RECURSIVE ENTRY POINT WHEN PICKING
				; A REPEATED CHARACTER
	SOJL	P4,C.IERR	;COUNT OFF NEXT BYTE (ERROR IF MESSAGE IS DONE)
	ILDB	T1,P1		;FETCH THE NEXT CHARACTER

	TRZE	T1,1_7		;IS THIS A "COMPRESSED" CHAR
	JRST	C.NXT1		; IF SO, EXPAND IT AND RETURN

	TRZE	T1,1_6		;IS THIS A REPEATED BLANK?
	JRST	C.NXT2		; IF SO, SET COUNT AND LET C.RPT LOOSE ON IT.

	TRZE	T1,1_5		;IS THIS A REPEAT COUNT?
	JRST	C.NXT3		; IF SO, THEN GET NEXT CHAR AND REPEAT IT.

	TRZE	T1,1_4		;IS IT AN "UNUSED" FORM...
	JRST	C.IERR		; IF SO, THEN SOMETHING IS WRONG.

	MOVEI	T2,(T1)		;IT MUST BE THE FIRST 4 BITS OF A TWO BYTE CHAR
	LSH	T2,^D8		;SHIFT UP THE MOST SIGNIFICANT 4 BITS
	SOJL	P4,C.IERR	;COUNT DOWN THE NEXT BYTE
	ILDB	T1,P1		;GET THE NEXT CHAR
	IORI	T1,(T2)		;OR IN THE HIGH FOUR BITS
	JRST	CPOPJ1##	;GIVE A GOOD RETURN
C.NXT1:				;HERE IF THIS IS A "COMPRESSED" CHAR
	IDIVI	T1,20		;SEPARATE THE ZONES (CLEVER DON'T YOU THINK...)
	LSHC	T2,-2		;NOW T2 := WORD INDEX, T3(B0, B1) HAS BYTE INDEX
	MOVE	T2,[BYTE (9)000,400,200,100 ;NOW LOAD T2 WITH A WORD THAT
		    BYTE (9)040,020,010,004 ; HAS FOUR DIFFERENT LOW ORDER
		    BYTE (9)002,001,202,102 ; BYTES.  WE WILL THEN CLEVERLY
		    BYTE (9)042,022,012,006](T2) ; POSITION IT AT THE TOP OF T2
	TLZE	T3,(1B0)	;SKIP IF TOP HALF-WORD IS RIGHT.
	HRLZI	T2,(T2)		;MAKE UPPER HALF CONTAIN THE DESIRED BYTE
	TLZE	T3,(1B1)	;SKIP IF THE TOP BYTE IS RIGHT.
	LSH	T2,^D9		;MOVE THE SECOND BYTE UP TO WHERE IT BELONGS
	LSHC	T1,^D9		;(REMEMBER THAT T1 HAS TOP 4 BITS ALREADY)
	JRST	CPOPJ1##	;ALL DONE. THE CHAR IS THE LOW 12 BITS IN T1!

C.NXT2:				;HERE IF WE HAVE REPEATED BLANKS
	JUMPN	P3,C.IERR	;NESTED REPEATS ARE ILLEGAL!
	MOVEI	P3,(T1)		;COPY THE REPEAT COUNT
	JUMPE	P3,C.NEXT	;IGNORE ZERO LENGTH REPEATS
	PJRST	C.RPT		;PASS THE BUCK TO C.RPT.

C.NXT3:				;HERE TO REPEAT AN ARBITRARY CHAR.
	JUMPN	P3,C.IERR	;NEXTED REPEATS ARE NOT ALLOWED.
	MOVEI	P3,(T1)		;COPY THE REPEAT COUNT
	PUSHJ	P,C.NXT0	;CALL OURSELF RECURSIVLY FOR THE REPEATED CHAR.
	  PJRST	C.IERR		;?? THIS IS WRONG. WE SHOULD HAVE ANOTHER CHAR.
	JUMPE	P3,C.NEXT	;LET ZERO LENTGH REPEATS WORK. (WONT HAPPEN)
	HRLI	P3,(T1)		;COPY THE CHAR TO REPEAT SO C.RPT WILL SEE IT.
;	PJRST	C.RPT		;LET C.RPT DO THE REST.

C.RPT:	HLRZ	T1,P3		;GET THE CHAR THAT'S BEING REPEATED
	SUBI	P3,1		;DECREMENT THE COUNT
	TRNN	P3,77		;SEE IF WE HAVE COUNTED DOWN ALL CHARS.
	SETZ	P3,		; IF WE HAVE, CLEAR THE REPEAT CHAR
	JRST	CPOPJ1##	;GIVE A GOOD RETURN

C.IERR:	POPJ	P,		;GIVE ERROR RETURN (WHAT ELSE CAN I DO??)
SUBTTL 4.3        CARD CODE TO ASCII CONVERSION ROUTINE

;C.CONV	THIS ROUTINE TRANSLATES A 12 BIT CARD CODE INTO A 7 BIT
;	ASCII CHAR (GOD KNOWS HOW...)
;CALL	MOVEI	T1,"THE 12 BIT CHAR"
;	PUSHJ	P,C.CONV
	;RETURN	CPOPJ		;CONVERTED CHAR IN T1
C.CONV:
	MOVEI	T3,(T1)		;PUT THE CHAR IN T3 FOR EXAMINATION
	SETZB	T1,T2		;CLEAR T1 AND T2
	JUMPE	T3,C.CNV1	;BLANKS ARE VERY SIMPLE
	CAIN	T3,5000		;12-0?
	MOVEI	T3,4242		;YES, TREAT AS 12-8-2 ([)
	CAIN	T3,3000		;NO, 11-0?
	MOVEI	T3,2202		;YES, TREAT AS 11-8-2 (!)
	LDB	T2,[POINT 3,T3,26]
	TRNE	T3,3		;DIDDLE T1 AND T2 TO FORM
	TRC	T2,7		;INDEXES INTO CHAR TABLE
	TRNE	T3,74
	TRO	T2,10
	TRNE	T3,314
	TRO	T1,2
	TRNE	T3,525
	TRO	T1,1
	TLNE	S,IOS029	;IN 026 CHAR SET MODE?
	TRO	T2,20		;NO, USE SECOND TABLE
C.CNV1:	LDB	T1,CRCVPT##(T1)	;GET 7-BIT TRANSLATION
	POPJ	P,
	XLIST			;DON'T LIST THE LITERALS
	$LIT
	LIST

NTCDRX::PRGEND

TITLE	NETDDP - NETWORK "DDCMP" DEVICE SERVICE ROUTINES - V001
SUBTTL	NETDDP -- RDH/	21-APR-82

	SEARCH	F,S,NETPRM,D36PAR,MACSYM
	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE SUED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; COPYRIGHT (C) 1982,1984  BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

XP VNETDP,001		;PUT VERSION NUMBER IN GLOB AND LOADER MAP

NETDDP::ENTRY	NETDDP
SUBTTL	GENERAL DEFINTIONS PECULIAR TO THE DDP DEVICE/KONTROLLER

;DEVIOUS BITS

XP	IOSDDK,IOSFFB_0		;DDP IS IN USE AS A KONTROLLER
				;  IF 0 THEN USER I/O (IN, OUT UUOS) OK
				;  IF 1 THEN USER GETS IO.IMP
XP	IOSDDH,IOSFFB_1		;DDP KONTROLLER IS "HALTED" (BY DRIVER REQUEST)
				;  IF 0 THEN DDP RUNNING, PASS DATA
				;  IF 1 THEN DDP DOWN, DISCARD DATA
XP	IOSDDD,IOSFFB_2		;DDP'S DDCMP PROTOCOL IS DOWN
				;  IF 0 THEN DDCMP IS RUNNING
				;  IF 1 THEN DDCMP IS DOWN



;DDP DDB WORDS ABOVE AND BEYOND STANDARD NETWORK DEVICE

DEFINE	X(NAM,SIZ<1>),<NAM==:<%%%OFF==%%%OFF+SIZ>-SIZ>

	%%%OFF==NETLEN

X	DDPUSR			;LINE USER OF DDP KONTROLLER (E.G., DECNET)
X	DDPLBK			;DRIVER'S LINE BLOCK ADDRESS
X	DDPQOB			;POINTER TO QUEUE OF OUTPUT MESSAGES
X	DDPMBP			;POINTER TO RECEIVE MESSAGE BUFFER

X	DDPDLN,0		;LENGTH OF DDP DDB
SUBTTL	UUO INTERFACE - DEVSER UUO DISPATCH VECTOR


	JRST	NTDONL##	;(-5) CHECK IF DEVICE IS ONLINE
	JRST	CPOPJ##		;(-4) SPECIAL ERROR STATUS
	JRST	REGSIZ##	;(-3) BUFFER SIZE
	JRST	CPOPJ##		;(-2) INITIALIZATION
	JRST	CPOPJ1##	;(-1) HUNG DEVICE CHECK (REMOTE DOES IT)
NDEVDP::JRST	NTDREL##	;(00) RELEASE
	JRST	NTDCLO##	;(01) CLOSE
	JRST	DDPUOU		;(02) BUFFERED OUT
	JRST	DDPUIN		;(03) BUFFERED IN
SUBTTL	UUO INTERFACE - DDB CREATION

;TSTDDP - TEST FOR DDP DEVICE, CREATE DDB IF NEEDED
;CALL	MOVEI	P1,FLAGS	;(ONLY MATCH IF LOOKING FOR PHYSICAL DEVICE)
;	MOVE	T1,[SIXBIT /DD?NNX/] ;DEVICE NAME
;	PUSHJ	P,TSTDDP
;RETURN	CPOPJ			;NOT A DDP DEVICE
;	CPOPJ1			;IS A DDP DEVICE; F := DDP DDB.

TSTDDP::TRNE	P1,DD%LOG##	;LOOKING AT LOGICAL NAMES?
	POPJ	P,		;GIVE UP NOW IF NOT PHYSICAL SEARCH
	HLRZ	T2,T1		;GET JUST THE NAME
	CAIL	T2,'DDA'	;SEE IF WITHIN RANGE OF ALLOWABLE
	CAILE	T2,'DDH'	; "CONTROLLER"S
	POPJ	P,		;NOT A DDP-CLASS DEVICE
	PUSHJ	P,NTDPRV##	;DDP'S ARE PRIVILEGED GADGETS
	 POPJ	P,		;AND THE USER ISN'T
	PUSHJ	P,SAVJW##	;WE CLOBBER W RIGHT AWAY, AND J IF WE CONNECT.
	PUSHJ	P,SAVE4##	;NETSER CLOBBERS MOST OF THESE
	NETDBJ			;BETTER INTERLOCK FROM HERE ON OUT.
	PUSH	P,T1		;SAVE THE DEVICE NAME
	PUSHJ	P,DVSCVT##	;GET THE NODE NUMBER FROM THE NAME
	  PJRST	TPOPJ##		;NOT A NETWORK NAME.
	MOVEI	T1,(T2)		;COPY THE NODE NUMBER
	PUSHJ	P,SRCNDB##	;GET A NDB POINTER
	  PJRST	TPOPJ##		;NO NODE MEANS NO DDP
	MOVEI	P1,(W)		;COPY THE NDB POINTER FOR MAKDDB
	MOVEI	T1,'DDP'	;GET GENERIC DEVICE NAME IN RH(T1)
	PUSHJ	P,SRCNDT##	;SEE IF THE NODE SUPPORTS DDP'S
	  PJRST	TPOPJ##		;IF NOT, THEN DEVICE DOESN'T EXIST
	LDB	T1,[POINT 6,(P),17] ;POINT TO "CONTROLLER" CHARACTER
	SUBI	T1,'A'		;CONVERT TO A CONTROLLER NUMBER
	LDB	T2,[POINT 3,(P),35] ;GET THE UNIT DIGIT (NUMERIC)
	CAIL	T2,0		;MAKE SURE THAT IT'S IN THE
	CAILE	T2,7		; RANGE 0-7
	PJRST	TPOPJ##		;NOT A VALID DIGIT.
	LSH	T1,3		;CONTROLLER BECOMES TOP HALF OF "PUNIT"
	IORI	T1,(T2)		;T1 := FULL UNIT SPECIFICATION
	PUSH	P,T1		;SAVE "PUNIT" VALUE UNTIL WE SEND THE CONNECT.

	MOVE	P2,-1(P)	;GET THE FULL NAME BACK
	PUSHJ	P,MAKDDP	;MAKE A DDP DDB
	  JRST	TTPOPJ##	;NO CORE. GIVE ERROR RETURN
	POP	P,T1		;GET THE UNIT NUMBER BACK
	DPB	T1,PUNIT##	;STORE THE UNIT NUMBER IN THE DDB
	MOVEI	W,(P1)		;SET UP THE NDB POINTER AGAIN
	PUSHJ	P,NTDCNT##	;ATTEMPT TO CONNECT THE DEVICE
	  JRST	[PUSHJ P,UNLDDB## ;CONNECT FAILED. FREE THE DDB
		 JRST TPOPJ##]	;AND GIVE UUOCON THE ERROR RETURN
	PJRST	TPOPJ1##	;ALL DONE. GOOD RETURN, F := DDB POINTER.
SUBTTL	UUO INTERFACE - CONVERT LINE-ID TO DDB
;DDPSRC - CONVERT LINE-ID TO DDB
;CALL	MOVE	T2,<LINE-ID>
;	PUSHJ	P,DDPSRC
;	 <ERROR>
;	<GOOD>
;RETURN CPOPJ IF NOT A DDP LINE ID
;RETURN CPOPJ1 WITH DDB ADDRESS IN T2
DDPSRC:	PUSH	P,T1		;SAVE WORK AC'S
	LOAD	T1,LIDEV,+T2	;GET LINE ID
	CAIE	T1,LD.DDP	;IS IT ONE OF OURS?
	PJRST	TPOPJ##		;NO, DON'T TOUCH IT
	PUSH	P,T2		;SAVE THE OTHER TEMPS
	PUSH	P,T3
	LOAD	T1,LIKON,+T2	;GET KONTROLLER NUMBER(REALLY NODE)
	LOAD	T3,LIUNI,+T2	;GET THE UNIT NUMBER
	IDIVI	T1,10		;GET THE HIGH ORDER DIGIT OF NODE NUMBER
	ADDI	T1,'0'		;MAKE IT SIXBIT
	LSH	T1,6		;SHIFT FOR NEXT DIGIT
	ADDI	T1,'0'(T2)	;SIXBIT ALSO
	LSH	T1,6		;SHIFT ONE LAST TIME
	ADDI	T1,'0'(T3)	;INCLUDE THE UNIT NUMBER
	HRLI	T1,'DDA'	;FORCE KONTROLLER NUMBER
	DDBSRL			;LOCK THE DDB DATA BASE
	HLRZ	T2,NETDDB##+DEVSER ;GET ADDRESS OF FIRST DDB IN CHAIN
DDPSR1:	CAMN	T1,DEVNAM(T2)	;IS THIS THE ONE
	JRST	DDPSR2		;YES, WE FOUND IT
	HLRZ	T2,DEVSER(T2)	;NO, STEP TO NEXT DDB
	JUMPN	T2,DDPSR1	;LOOP IF ONE THERE
DDPSR2:	DDBSRU			;DONE FOOLING WITH DDBS
	SKIPN	T2		;NO SKIP IF NO DDB
	JRST	DDPSR3		;WE DIDN'T FIND ON
	AOS	-3(P)		;WE FOUND ONE, SKIP RETURN
	MOVEM	T2,-1(P)	;STORE DDB ADDRESS
DDPSR3:	POP	P,T3		;RESTORE AC'S
	POP	P,T2
	POP	P,T1
	POPJ	P,		;RETURN TO CALLER
SUBTTL	UUO INTERFACE - DDB DESTRUCTION

;ZAPDDP - SEE IF OK TO DESTROY DDP DDB
;CALL	MOVE	F,<DDB>
;	PUSHJ	P,ZAPNET
;RETURN	CPOPJ			;ALWAYS
;
;IF DDP IS IN USE AS KONTROLLER (AND THUS CANNOT BE ZAPPED) THEN THIS
;ROUTINE (CALLED BY ZAPNET) RETURNS, AND ZAPNET DOES NOTHING. IF THE
;DDP IS IDLE (I.E., IS NOT A KONTROLLER), THEN ZAPNET IS ALLOWED TO
;GO AHEAD AND DESTROY THE DDB, RELEASING THE DDP DEVICE BACK TO THE
;REMOTE NODE.

ZAPDDP::MOVE	S,DEVIOS(F)	;GET THE I/O STATUS BITS
	TLNN	S,IOSDDK	;IN USE AS A KONTROLLER?
	PJRST	ZAPNE1##	;NO, OFF TO ZAPNET TO ZAP THE DEVICE
	POPJ	P,		;YES, RETURN HAVING DONE NOTHING
SUBTTL	UUO INTERFACE - IN UUO

;HERE FROM UUOCON ON USER IN UUO

DDPUIN:	TLNE	S,IOSDDK	;IS DDP IN USE AS A KONTROLLER
	PJRST	DDPIMP		;YES, NAUGHTY BOY, HE GETS AN ERROR RETURN

;DDP IS AVAILABLE AS AN I/O DEVICE TO THE USER

	PUSHJ	P,SAVE4##	;WE NEED LOTS OF P'S
	MOVSI	S,IOSUSI	;CLEAR THE UUOCON-STOPPED-INPUT BIT
	ANDCAB	S,DEVIOS(F)	; SINCE WE ARE DOING AN IN NOW

DDPUI1:	PUSHJ	P,NTDSET##	;SETUP NETWORK CONTEXT (W, S, ETC)
	TLNE	S,IOSERR	;ANYTHING SERIOUSLY WRONG?
	JRST	DDPIER		;YES, NODE DOWN, ETC.
	TLNE	S,IOBEG		;HAVE WE BEEN HERE BEFORE?
	PUSHJ	P,DDPFIR	;NO, FIRST IN, SPECIAL
	MOVSI	S,IO		;THE IN VERSUS OUT BIT
	ANDCAB	S,DEVIOS(F)	;WE ARE DOING "IN" TYPE STUFF

;NOW TRY TO FILL A USER BUFFER FROM INCOMING DATA MESSAGE(S)

DDPUI3:	PUSHJ	P,NTDIBA##	;VERIFY BUFFERS ETC
	 POPJ	P,		;NO BUFFER, RETURN TO UUOCON
	HRRZ	T1,DEVPCB(F)	;ADDRESS OF PENDING PCB CHOCK FULL OF DATA
	JUMPE	T1,DDPUI8	;NO DATA, GO WAIT FOR INPUT
	PUSHJ	P,NTDDID##	;PROCESS THIS NCL SUBMESSAGE
	JRST	DDPUI1		;LOOP ON INPUT


;HERE WHEN NO INPUT

DDPUI8:	PUSHJ	P,NTDONL##	;CHECK THE DEVICE
	 JRST	DDPIER		;ERROR?
	PUSHJ	P,NTDXDQ##	;SEND ANY DATA REQUESTS NEEDED
	PUSHJ	P,NTDWTI##	;WAIT FOR INPUT
	 POPJ	P,		;NON-BLOCKING, BACK TO UUOCON
	JRST	DDPUI1		;LOOP BACK FOR INPUT PROCESSING


;HERE ON INPUT ERROR FROM NTDONL

DDPIER:	MOVE	S,DEVIOS(F)	;ENSURE FRESH COPY
	TLNN	S,IOSCON	;IS DEVICE STILL CONNECTED?
	PJRST	NTDGON		;NO - NETWORK CONNECTION GONE
	TLNE	S,IOSERR	;IS THE DDP "OFFLINE"
	PUSHJ	P,NTDHNG##	;YES, COMPLAIN
	JRST	DDPUI1		;BACK TO TRY INPUT PROCESSING
SUBTTL	UUO INTERFACE - OUT UUO

;HERE FROM UUOCON ON OUT UUO

DDPUOU:	TLNE	S,IOSDDK	;IS DDP IN USE AS A KONTROLLER?
	PJRST	DDPIMP		;YES, DISALLOW UUO-LEVEL DIDDLING

;DDP IS AVAILABLE AS AN I/O DEVICE

	PUSHJ	P,SAVE4##	;USE LOTS OF P'S
	MOVSI	S,IOSUSO	;CLEAR THE UUOCON-STOPPED-OUTPUT BIT
	ANDCAB	S,DEVIOS(F)	; SINCE ITS DOING ANOTHER OUT

;LOOP OUTPUTTING DATA FROM USER'S I/O BUFFER(S)

DDPUO1:	PUSHJ	P,NTDSET##	;SETUP NETWORK ACS (W, S, ETC)
	TLNE	S,IOSERR	;ANYTHING SERIOUSLY WRONG?
	JRST	DDPOER		;YES, SEE IF STILL THERE
	TLNE	S,IOBEG		;FIRST TIME HERE?
	PUSHJ	P,DDPFIR	;YEAH, DO SOME CLEANUP FIRST
	MOVSI	S,IO		;THE IN VERSUS OUT BIT
	IORB	S,DEVIOS(F)	;WE ARE DOING "OUT" TYPE STUFF

;TRY TO SEND ONE BUFFER'S WORTH OF DATA

DDPUO3:	PUSHJ	P,NTDCDQ##	;CHECK TO SEE IF ANY DATA REQUESTS AVAILABLE
	 JRST	DDPUO8		;NONE AVAILABLE, WAIT
	MOVEI	T1,^D08		;DDP DATA IS BY DEFINITION 8 BITS
	PUSHJ	P,NTDSOB##	;SET UP AN OUTPUT BUFFER
	 POPJ	P,		;TIME TO RETURN TO UUOCON (NO MORE DATA, ETC)
	MOVEI	T1,PCV.NC	;NO FUNNY BIT DIDDLING, JUST STRAIGHT IMAGE DATA
	MOVEI	T2,DC.DAR	;NCL DATA WITH EOR
	PUSHJ	P,NTDXMT##	;SEND A BUFFER
	 JRST	DDPUO7		;NO FREE CORE FOR PCB
	PUSHJ	P,NTDDDQ##	;WE JUST USED UP ONE DATA REQUEST
	SKIPE	DEVAXO+1(F)	;DID NTDXMT EMPTY THE BUFFER?
	JRST	DDPBTL		;NO - BLOCK TOO LARGE ERROR
	PUSHJ	P,NTDAOB##	;ADVANCE USER'S BUFFER
	JRST	DDPUO1		;TRY FOR ANOTHER BUFFER
;HERE WHEN NO FREE CORE FOR OUTPUT PCBS

DDPUO7:	CAIE	T1,0		;0 MEANS NO FREE CORE
	 pushj	p,ntdstp##
	PUSHJ	P,NETSLP##	;WAIT FOR FREE CORE
	JRST	DDPUO1		;LOOP BACK AND TRY AGAIN


;HERE TO WAIT FOR OUTPUTABILITY

DDPUO8:	PUSHJ	P,NTDONL##	;ENSURE NICE JUICY DEVICE
	 JRST	DDPOER		;CHECK OUT BADNESS
	PUSHJ	P,NTDWTO##	;WAIT FOR OUTPUT (DATA REQUESTS)
	 POPJ	P,		;NON-BLOCKING, BACK TO UUOCON NOW
	JRST	DDPUO1		;TRY OUTPUT AGAIN


;HERE ON OUTPUT ERROR FROM NTDONL

DDPOER:	MOVE	S,DEVIOS(F)	;ENSURE FRESH COPY
	TLNN	S,IOSCON	;IS DDP DEVICE STILL CONNECTED?
	PJRST	NTDGON		;NO, NETWORK CONNECTION GONE
	TLNE	S,IOSERR	;IS THE DDP "OFFLINE"
	PUSHJ	P,NTDHNG##	;YEAH, COMPLAIN
	JRST	DDPUO1		;LOOP BACK AND TRY OUTPUT AGAIN

NTDGON:	MOVEI	S,IODERR!IODTER	;DEVICE AND DATA ERRORS
	IORB	S,DEVIOS(F)	;ASSERT ERROR FLAGS
	POPJ	P,		;RETURN (PRESUMABLY TO UUOCON)
SUBTTL	UUO INTERFACE - DDP SERVICE INITIALIZATION

DDPFIR:	MOVSI	S,IOBEG!IOSREL	;KRUFTY BITS
	ANDCAB	S,DEVIOS(F)	;CLEAR OLD BITS IN DDB
	SETZM	DEVAXI(F)	;CLEAR DANGLING INPUT
	SETZM	DEVAXO(F)	;AND ANY DANGLING OUTPUT
	POPJ	P,		;NOW SET FOR CLEAN I/O



SUBTTL	UUO INTERFACE - DDP DEVICE ERRORS

;HERE WHEN USER TRIED TO PLAY WITH A DDP IN KONTROLLER MODE

DDPIMP:	MOVEI	S,IOIMPM	;IMPROPER MODE
	JRST	DDPERS		;SET ERROR AND RETURN


;HERE WHEN OUTPUT BUFFER OVERFLOWED NETWORK PCB

DDPBTL:	MOVEI	S,IOBKTL	;BLOCK-TOO-LARGE FOR NETWORK BUFFER
DDPERS:	IORB	S,DEVIOS(F)	;SET ERROR BITS IN DDB
	POPJ	P,		;ERROR RETURN TO UUOCON
SUBTTL	UUO INTERFACE - DDP. UUO -  CONTROL OF DDP KONTROLLER

;THE DDP. UUO ALLOWS UUO-LEVEL CONTROL OF DDP DEVICES/KONTROLLERS.
;CALL IS:
;
;	MOVE	AC,[LEN,,ADR]
;	DDP.	AC,
;	 ERROR RETURN
;	NORMAL RETURN
;
;ADR:	FUNCTION
;	DDP DEVICE ID
;	ARGUMENT (AS NEEDED)
;
;FUNCTION IS ONE OF
;
; (00)	.DPFAS	ASSIGN (CREATING IF NEEDED) DDP DEVICE
; (01)	.DPFZP	ZAP ("RELEASE") DDP DEVICE/KONTROLLER
; (02)	.DPFDV	SET DDP TO "DEVICE" MODE (IN/OUT/ETC. UUOS)
; (03)	.DPFKN	SET DDP TO "KONTROLLER" MODE
; (04)	.DPFUS	SET DDP "KONTROLLER" USER TYPE
; (10)	.DPFHL	HALT THE DDP KONTROLLER
; (11)	.DPFIN	INITIALIZE DDP KONTROLLER
; (12)	.DPFMA	SET TO MAINTENANCE MODE (FOR BOOTSTRAPING)
;
;ON ERROR, AC CONTAINS ERROR CODE:
;
; (01)	DPEIF%	ILLEGAL DDP. FUNCTION CODE
; (02)	DPESH%	ARGUMENT LIST TOO SHORT
; (03)	DPEID%	ILLEGAL DDP. DEVICE (NOT DDP, ETC.)
; (04)	DPEPR%	USER NOT PRIVILEGED
; (05)	DPEIM%	ILLEGAL OPERATION MODE (DDP NOT IN KONTROLLER MODE)
; (06)	DPEIU%	ILLEGAL USER NAME
; (07)	DPEOU%	DDP IS IN USE BY OTHER USER/JOB


;DEFINE ERROR RETURNS

	DDE%IF==ECOD1##		;ILLEGAL FUNCTION
	DDE%SH==ECOD2##		;ARG LIST TOO SHORT
	DDE%ID==ECOD3##		;ILLEGAL DEVICE
	DDE%PR==ECOD4##		;USER NOT PRIVILEGED
	DDE%IM==ECOD5##		;ILLEGAL OPERATION MODE
	DDE%IU==ECOD6##		;ILLEGAL USER NAME
	DDE%OU==ECOD7##		;OTHER USER HAS THE DDP
DDPUUO::HLRZ	P2,T1		;SAVE LENGTH OF ARG LIST
	HRR	M,T1		;POSITION ADDRESS OF ARG LIST
	SOJL	P2,DDE%SH	;ERROR IF TOO SHORT
	PUSHJ	P,GETWDU##	;GET THE FUNCTION CODE
	HRRZ	P1,T1		;POSITION JUST FUNCTION CODE (ALLOW FOR FUTURE)
	CAILE	P1,DDPCMX	;RANGE-CHECK THE FUNCTION CODE
	JRST	DDE%IF		;ILLEGAL FUNCTION CODE
	SOJL	P2,DDE%SH	;ERROR IF ARG LIST TOO SHORT
	PUSHJ	P,NTDPRV##	;IS THIS USER PRIVILEGED?
	 JRST	DDE%PR		;NO, HE LOSES
	PUSHJ	P,GETWD1##	;GET THE DEVICE NAME/ID
	PUSHJ	P,DVCNSG##	;TRY TO DECIPHER THE DEVICE NAME
	 JRST	DDE%ID		;ILLEGAL DEVICE
	LDB	T1,PDVTYP##	;GET DEVICE TYPE
	CAIE	T1,.TYDDP/.TYEST;IS IT A REAL DDP DEVICE?
	JRST	DDE%ID		;NO, ILLEGAL DEVICE
	MOVE	S,DEVIOS(F)	;PRE-LOAD S
	PJRST	@DDPCMT(P1)	;DISPATCH ON FUNCTION

DDPCMT:	IFIW	DDPCAS		;(00) ASSIGN (CREATE) DDP DEVICE
	IFIW	DDPCZP		;(01) ZAP (DESTROY/RELEASE) DDP DEVICE
	IFIW	DDPCDV		;(02) SET TO DEVICE MODE
	IFIW	DDPCKN		;(03) SET TO KONTROLLER MODE
	IFIW	DDPCUS		;(04) SET KONTROLLER USER
	IFIW	DDE%IF		;(05) RESERVED/ILLEGAL
	IFIW	DDE%IF		;(06) RESERVED/ILLEGAL
	IFIW	DDE%IF		;(07) RESERVED/ILLEGAL
	IFIW	DDPCHA		;(10) HALT KONTROLLER PROTOCOL
	IFIW	DDPCIN		;(11) INITIALIZE KONTROLLER PROTOCOL
	IFIW	DDPCMA		;(12) SET TO MAINTENANCE MODE PROTOCOL

	DDPCMX==.-DDPCMT	;MAX DDP COMMAND FUNCTION
;DDPCAS - ASSIGN (CREATE IF NEEDED) DDP DEVICE

;NOTE THAT THE DDP WILL HAVE BEEN CREATED IF NECESSARY BY THE DVCNSG
;PRIOR TO MAIN FUNCTION DISPATCH . . .

DDPCAS:	PUSHJ	P,DDPCAZ	;SEE IF WE CAN MUNCH ON THE DDP
	 JRST	DDE%OU		;OTHER USER HAS THE DDP
	MOVEI	T1,ASSCON	;THE "IN USE BY ASSIGN COMMAND" FLAG
	IORM	T1,DEVMOD(F)	;WE NOW OWN THE DDP
	DPB	J,PJOBN##	;MAKE SURE "WE" IS US
	JRST	CPOPJ1##	;SUCCESSFUL RETURN



;DDPCZP - ZAP (DESTROY) THE DDP DEVICE

DDPCZP:	PUSHJ	P,DDPCAZ	;SEE IF WE CAN MUNCH ON THE DDP
	 JRST	DDE%OU		;OTHER USER HAS THE DDP
	TLNE	S,IOSDDK	;IS THE DDP IN USE AS A KONTROLLER?
	PUSHJ	P,DDPKZP	;YES, ZAP THE KONTROLLER USER FIRST
	MOVEI	T1,ASSCON	;THE "IN USE" BY ASSIGNMENT FLAG
	ANDCAM	T1,DEVMOD(F)	;ALLOW UUOCON TO KRUMP ON THE DDB NOW
	PUSHJ	P,RELEA3##	;NOW DO UUO-LEVEL DDB ZAPPING
				; (EVENTUALLY WINDING UP IN ZAPNET/ZAPDDP)
	JRST	CPOPJ1##	;SUCCESSFUL RETURN



;HELPER FOR DDPCAS/DDPCZP
;
;RETURNS CPOPJ IF THE DDP DDB IS NOT AVAILABLE TO THIS JOB (I.E., SOME OTHER
;JOB HAS THE DDB "IN USE"); RETURNS CPOPJ1 IF THE DDB CAN BE ASSIGNED TO
;THIS JOB.

DDPCAZ:	MOVEI	T1,ASSCON!ASSPRG;THE "IN USE" FLAGS
	LDB	T2,PJOBN##	;THE JOB NUMBER (IF ANY) USING THE DDP
	TDNE	T1,DEVMOD(F)	;IS THE DDB IN USE BY A JOB?
	CAMN	T2,J		;YES, IS THAT JOB THIS JOB?
	AOS	(P)		;EITHER AVAILABLE, OR ALREADY IN USE BY US
	POPJ	P,		;RETURN AS APPROPRIATE
;DDPCDV - SET DDP TO "DEVICE" MODE

DDPCDV:	TLNN	S,IOSDDK	;IN KONTROLLER MODE?
	JRST	CPOPJ1##	;NO, ALL DONE HERE
	PUSHJ	P,DDPKZP	;YES, ZAP THE KONTROLLER'S USER FIRST
				; (ALSO FLUSHES ANY QUEUED DATA)
	MOVSI	S,IOSDDK	;THE KONTROLLER-MODE FLAG
	ANDCAB	S,DEVIOS(F)	;SWITCH THE DDP INTO DEVICE MODE
	JRST	CPOPJ1##	;SUCCESSFUL RETURN



;DDPCKN - SET DDP TO "KONTROLLER" MODE

DDPCKN:	MOVSI	S,IOSDDK	;THE KONTROLLER MODE FLAG
	IORB	S,DEVIOS(F)	;SWITCH TO KONTROLLER MODE
	JRST	CPOPJ1##	;ALL DONE HERE
;DDPCUS - SET THE KONTROLLER'S USER

DDPCUS:	SOJL	P2,DDE%SH	;ERROR IF TOO SHORT
	PUSHJ	P,GETWD1##	;GET THE USER NAME (INTO T1)
DDPCU1:	PUSHJ	P,KONUSN##	;TRANSLATE USER NAME INTO TYPE (IN T2)
	 JRST	DDE%IU		;ILLEGAL USER NAME
DDPCU2:	CAMN	T2,DDPUSR(F)	;IS USER TYPE CHANGING?
	JRST	CPOPJ1##	;NO, THIS IS A NO-OP THEN

IFE FTCIMP,<

;*** KROCK FOR NOW

	CAIE	T2,DD.NOB	;ALLOW NOBODY
	CAIN	T2,DD.DEC	;AND DECNET, THAT'S IT
	CAIA			;HAPPY
	JRST	DDE%IU		;UNHAPPY
>;IFE FTCIMP
IFN FTCIMP,<
	CAIE	T2,DD.NOB	;Nobody?
	 CAIN	T2,DD.DEC	; DECnet?
	  JRST	DDPCU3		;  Yes, ok.
	CAIE	T2,DD.IP	;IP?
	 JRST	DDE%IU		; Not that either.  bad.
DDPCU3:

>;IFN FTCIMP

;CHANGING DRIVER ("USER") TYPE, QUIESCE THE KONTROLLER FIRST

	TLNN	S,IOSDDK	;BUT IS THE DDP A KONTROLLER?
	JRST	DDPCU9		;NO, NOT TO WORRY, JUST SET NEW USER
	PUSH	P,T2		;SAVE TENTATIVE NEW USER
	PUSHJ	P,DDPKZP	;"ZAP" THE KONTROLLER
	MOVSI	S,IOSDDK	;RESET THE "KONTROLLER" STATUS
	IORB	S,DEVIOS(F)	; 'CUZ DDPKZP CLEARS THE KONTROLLER STATUS
	POP	P,T2		;RETRIEVE NEW USER
DDPCU9:	HRRZM	T2,DDPUSR(F)	;SET NEW USER TYPE
	PUSHJ	P,@DDPCUT(T2)	;DO ANY HACKERY REQUIRED BY NEW USER
	 JRST	DDE%IU		;SOMETHING IS ILLEGAL
	JRST	CPOPJ1##	;SUCCESSFUL RETURN

DEFINE	X(USR,CON,DSP),<
	IFN	.-DDPCUT-DD.'USR,<
		PRINTX	? DDPCUT "USR" initialization dispatch out of order>
	IFE	CON,<IFIW CPOPJ##>
	IFN	CON,<IFIW DSP>
> ;END X MACRO

DDPCUT:	X	(NOBODY,1,CPOPJ1##)
	X	(ANF,FTNET,NTDSTP##)
	X	(DECNET,FTDECN,DDPC2T)
	X	(PROGRA,1,CPOPJ##)
	X	(IBMCOM,FTDN60,CPOPJ##)
IFN FTCIMP,<
	X	(IP,FTCIMP,DDPC3T)
>;IFN FTCIMP

	IFN	.-DDPCUT-<DD.MAX+1>,<
		PRINTX	? DDPCUT initialization dispatch missing>
;DDPC2T - INITIALIZE FOR DECNET USER

IFN	FTDECN,<
DDPC2T:	SKIPE	DDPLBK(F)	;ALREADY HAVE LINE BLOCK?
	PJRST	CPOPJ1##	;YES, SKIP THIS
	SETZ	T3,		;START OFF WITH A CLEAN LINE ID
	MOVEI	T1,LD.DDP	;GET THE DEVICE TYPE
	STOR	T1,LIDEV,+T3	;SAVE IN LINE ID
	HRRZ	T1,DEVNET(F)	;NODE NUMBER OWNING THE DDP DEVICE
	STOR	T1,LIKON,+T3	;SAVE AS KONTROLLER NUMBER
	LDB	T1,PUNIT##	;GET THE DDP UNIT NUMBER AT SAID NODE
	STOR	T1,LIUNI,+T3	;SAVE AS THE UNIT NUMBER
>;IFN FTDECN
IFN FTCIMP,<
DDPC3T:
>;IFN FTCIMP
IFN FTDECN!FTCIMP,<
	MOVEI	T1,DI.ICB	;OPEN THIS CIRCUIT
	PUSHJ	P,DDPDVR	;TELL DLL OF NEW KONTROLLER
	POPJ	P,		;GIVE ERROR RETURN
	MOVEM	T1,DDPLBK(F)	;REMEMBER THE DLL'S DATA BLOCK ADDRESS
	JRST	CPOPJ1##	;GIVE A GOOD RETURN
> ;END IFN FTDECN!FTCIMP
;DDPCHA - HALT THE DDP KONTROLLER

DDPCHA:	TLNN	S,IOSDDK	;IS DDP IN KONTROLLER MODE?
	JRST	DDE%IM		;ILLEGAL OPERATING MODE
	JRST	DDE%IF		;*** ILLEGAL FUNCTION . . .



;DDPCIN - INITIALIZE DDP KONTROLLER

DDPCIN:	TLNN	S,IOSDDK	;IS DDP IN KONTROLLER MODE?
	JRST	DDE%IM		;NO, ERROR
	JRST	DDE%IF		;*** ILLEGAL FUNCTION . . .



;DDPCMA - SET DDP KONTROLLER TO MAINTENANCE MODE

DDPCMA:	TLNN	S,IOSDDK	;IS DDP IN KONTROLLER MODE?
	JRST	DDE%IM		;NO, ERROR
	JRST	DDE%IF		;*** ILLEGAL FUNCTION . . .
SUBTTL	NETSER INTERFACE

	IFIW	DDPNND		;(-5) NODE WENT DOWN
	IFIW	DDPNRL		;(-4) DISCONNECT ("RELEASE") INIT RECEIVED
	IFIW	NTDCNC##	;(-3) STANDARD CONNECT CONFIRM PROCESSOR
	IFIW	NTDSTP##	;(-2) ERROR - WE DON'T POST DDBS
	IFIW	DDPNIQ		;(-1) DATA REQUEST PROCESSOR
DDPNDP::IFIW	DDPNIL		;(00) INCOMING NCL TO PROCESS
	IFIW	CPOPJ##		;(01) SHOULD NEVER RECEIVE DATA SANS EOR
	IFIW	DDPNIN		;(02) RECEIVE DATA WITH EOR
	IFIW	DDPNST		;(03) DEVICE STATUS
	IFIW	DDPNCT		;(04) DEVICE CONTROL
	IFIW	CPOPJ##		;(05) UID (?)
	IFIW	CPOPJ##		;(06) FILE SPECIFICATION (?)
SUBTTL	NETSER INTERFACE - INCOMING NCL PROCESSORS

;HERE FOR CONNECT INITIATE

NDDPCI::PUSH	P,U		;PROTECT THE INPUT PCB
	PUSHJ	P,DPCIDD	;ALLOCATE US A NETWORK DDP DEVICE DDB
	 JRST	DPCIE3		;NO FREE CORE FOR EVEN A DDB??? JEEEZZ
	HRRZ	T1,F		;ADDRESS OF NEWLY-ACQUIRED DDB
	MOVEI	T2,LAT.OK	;INITIAL LAT STATE
	PUSHJ	P,GETSLA##	;GET A LAT SLOT FOR THE DDB
	 JRST	DPCIE2		;NO FREE LAT SLOTS, BOMB THE CONNECT INIT
	DPB	T1,NETSLA##	;REMEMBER THE LAT SLOT
	HLRZ	T1,P3		;GET THE REMOTE'S "LAT" SLOT
	DPB	T1,NETDLA##	;AND REMEMBER THAT TOO

;DPN(,PID)

	PUSHJ	P,XSKIP##	;SKIP THE REMOTE'S REQUEST

;SPN(OBJ,)

	PUSHJ	P,EBI2BI##	;GET REMOTE'S OBJECT TYPE
	CAIE	T1,OBJ.DP	;MAKE SURE IT IS CONSISTENT
	JRST	DPCIE4		;WHOA! WHAT NONSENSE IS THIS?

;SPN(,PID)

	PUSHJ	P,EBI2BI##	;GET REMOTE "UNIT" NUMBER
	CAIL	T1,0		;CAN'T BE NEGATIVE (TEXT???)
	CAILE	T1,77		;AND CAN'T EXCEED DDH7
	JRST	DPCIE4		;MORE NONSENSE
	DPB	T1,PUNIT##	;STORE DEVICE UNIT NUMBER
	LSHC	T1,-3		;SEPARATE "CONTROLLER" AND "UNIT"
	LSH	T1,^D18-3	;PARTIALLY POSITION
	LSHC	T1,3		;MAKE XWD CONTROLLER,UNIT
	IOR	T1,['DDA  0']	;SIXBITDEVICEIFY THE VALUE
	IORM	T1,DEVNAM(F)	;MAKE FULL-FLEDGED DEVICE NAME
				;(MAKDDC LEFT THE NODE NUMBER FIELD SETUP)

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;PROCESS THE MML AND FEA FIELDS

	PUSHJ	P,NTDCNF##	;SLURP UP MML AND RLN
	 JFCL			;NOT USED

;WE LIKE THE DEVICE, ACCEPT THE CONNECT (SEND A CONNECT CONFIRM)

	MOVE	T1,[NTDXMN##,,NTDXPN##]  ;SPN AND DPN ROUTINES
	PUSHJ	P,NCSCNC##	;SEND CONNECT CONFIRM
	 JRST	DPCIE1		;AFTER ALL THAT WORK, CAN'T BUILD A MESSAGE!

;THE DEVICE IS NOW READY AND RARING TO GO. FOR LACK OF ANYTHING BETTER
;TO DO (AND BECAUSE IT WAS THE REASON FOR CREATING DDP'S IN THE FIRST
;PLACE) MAKE THE DDP INTO A DECNET KONTROLLER

	PUSHJ	P,DDPCKN	;MAKE A KONTROLLER OUT OF IT
	 pushj	p,ntdstp##
IFN FTCIMP,<
	MOVEI	T2,DD.IP	;Set IP user,
	PUSHJ	P,DDPCU2	; and ask IP if it wants the DDP.
	 SKIPA			;No, try DECnet.
	  JRST	NDDPC1		;Yes, continue.
>;FTCIMP
	MOVEI	T2,DD.DEC	;USER: DECNET
	PUSHJ	P,DDPCU2	;ANNOUNCE NEW KONTROLLER TO DECNET
	 JRST	[PUSHJ	P,DDPCDV	;WELL! UNMAKE IT A KONTROLLER
		 pushj p,ntdstp##
		JRST	UPOPJ1##]	;AND LEAVE DEVICE LYING AROUND
IFN FTCIMP,<
NDDPC1:
>;IFN FTCIMP
;IF DDCMP ALREADY RUNNING, MAKE SURE DECNET PAYS ATTENTION

	MOVE	S,DEVIOS(F)	;FRESH COPY OF DEVIOUS BITS
	TLNN	S,IOSDDD	;DDCMP UP AND RUNNING?
	PUSHJ	P,DDPKUP	;YES, CONJURE UP AN ONLINE INTERRUPT

;ALL DONE

	JRST	UPOPJ1##	;SUCCESSFUL RETURN
;HELPER TO CREATE DDB (NETSER INTERRUPT LEVEL)

DPCIDD:	PUSHJ	P,SAVE4##	;PROTECT INPUT POINTER/ET AL
	PUSHJ	P,SAVJW##	;ALSO J AND W
	MOVE	P1,W		;POSITION NDB POINTER FOR MAKDDC
	SETZB	P2,J		;FRESH SLATE FOR THE NAME

;ENTRY FROM TSTDDP (UUO LEVEL)

MAKDDP:	SKIPN	W,NDTTAB##+OBJ.DP  ;POSITION NDT POINTER FOR MAKDDC
	 pushj	p,ntdstp##
	SETZ	P3,		;NO LOGICAL NAME (YET, ANYWAY)
	MOVEI	T2,DDPDLN	;LENGTH OF A DDP DDB
	PUSHJ	P,MAKDDC##	;MAKE GENERAL NETWORK DEVICE DDB
	 POPJ	P,		;NO CORE, ERROR RETURN
	MOVSI	T1,DEPRAS	;THE RESTRICTED-DEVICE FLAG
	IORM	T1,DEVSTA(F)	;REQUIRE PRIVILEGES TO PLAY WITH DDPS
	PUSHJ	P,LNKDDB##	;MAKE THE DDB "REAL"
	JRST	CPOPJ1##	;SUCCESS RETURN WITH NICE SHINY NEW DDB



;ERRORS FOR DDP CONNECT INIT

DPCIE1:	LDB	T1,NETSLA##	;GET LAT SLOT INDEX
	PUSHJ	P,GIVSLA##	;FREE UP THE LAT
DPCIE2:	PUSHJ	P,UNLDDB##	;FREE UP THE DDB
DPCIE3:	MOVEI	T1,RSN.XN	;REASON: NO RESOURCES
	JRST	UPOPJ##		;RESTORE U AND ERROR EXIT

DPCIE4:	LDB	T1,NETSLA##	;GET LAT SLOT INDEX
	PUSHJ	P,GIVSLA##	;FREE UP THE LAT
	PUSHJ	P,UNLDDB##	;FREE UP THE DDB
	MOVEI	T1,RSN.OT	;REASON: JUNK
	JRST	UPOPJ##		;RESTORE U AND ERROR EXIT
;HERE FOR DISCONNECT INITIATE

DDPNRL:	MOVE	S,DEVIOS(F)	;GET THE DDP I/O STATUS FLAGS
	TLNE	S,IOSDDK	;IN USE AS A KONTROLLER?
	PUSHJ	P,DDPKZP	;YES, ZAP THE KONTROLLER FIRST
	PJRST	NTDDSC##	;NOW ALLOW NETSER TO ZAP THE DEVICE/DDB



;HERE FOR NODE DOWN

DDPNND:	HRRZ	T1,DEVNET(F)	;GET OWNING NODE
	MOVE	S,DEVIOS(F)	;GET THE DDP I/O STATUS FLAGS
	TLNE	S,IOSDDK	;IN USE AS A KONTROLLER?
	PUSHJ	P,DDPKZP	;YES, ZAP THE KONTROLLER FIRST
	PJRST	NTDNWD##	;NOW ALLOW NETSER TO CLEAN UP THE DDB
;HERE FOR AN NCL DATA REQUEST RECEIVED (AT NETWORK INTERRUPT LEVEL)

DDPNIQ:	MOVE	S,DEVIOS(F)	;DEVICE STATUS FLAGS
	TLNE	S,IOSDDK	;IS DDP A DEVICE OR A KONTROLLER?
	PJRST	DDPKIQ		;A KONTROLLER, NUDGE OUTPUT, ETC.
	PJRST	NTDRDQ##	;A DEVICE, USE STANDARD NETSER ROUTINE



;HERE FOR AN NCL MESSAGE RECEIVED (AT NETWORK INTERRUPT LEVEL)

DDPNIL:	MOVE	S,DEVIOS(F)	;DEVICE STATUS FLAGS
	TLNE	S,IOSDDK	;IS DDP A DEVICE OR A KONTROLLER?
	PJRST	DDPKIL		;A KONTROLLER, IT RUNS AT INTERRUPT LEVEL
	PJRST	NTDQIP##	;A DEVICE, IT RUNS AT UUO LEVEL, SO TELL
				; NETSER TO "QUEUE" THE NCL TO BE PROCESSED
				; LATER AT USER/UUO LEVEL.
;HERE FOR INCOMING DATA (WITH EOR)

DDPNIN:	MOVE	S,DEVIOS(F)	;GET DEVIOUS BITS
	TLNE	S,IOSDDK	;IS DDP IN USE AS A KONTROLLER?
	PJRST	DDPKIN		;YES, INTERRUPT LEVEL BEHAVES DIFFERENTLY

;DDP IS NOT A KONTROLLER, THEREFORE DATA IS DESTINED FOR USER I/O BUFFER

	MOVEI	T4,^D08		;DDCMP DATA IS *ALWAYS* 8 BITS
	PUSHJ	P,NTDSIB##	;SETUP USER'S INPUT BUFFER POINTER/COUNTER
	 pushj	p,ntdstp##
	DMOVE	T3,DEVAXI(F)	;GET BYTE POINTER AND COUNTER FOR SPEED
	JRST	DDPNI5		;ENTER DATA COPY LOOP

;LOOP COPYING DATA FROM NCL INTO USER BUFFER

DDPNI3:	ILDB	T1,P1		;NEXT NCL DATA BYTE
	SOJL	T4,DDPNI9	;COUNT DOWN ROOM LEFT, IOBKTL IF OVERFLOW
	EXCTUU	<IDPB T1,T3>	;STORE BYTE INTO USER'S BUFFER
DDPNI5:	SOJGE	P4,DDPNI3	;COPY ENTIRE NCL DATA MESSAGE
	DMOVEM	T3,DEVAXI(F)	;RESTORE BYTE COUNTER/POINTER FOR USER
	PJRST	NTDA1B##	;ADVANCE USER'S BUFFER, RETURN TO DDPUIN

;HERE IF NCL DATA OVERFLOWED USER'S BUFFER

DDPNI9:	PUSHJ	P,DDPBTL	;SET IOBKTL ERROR
	PJRST	NTDAIB##	;AND RETURN USER HIS STUFFED BUFFER
;HERE FOR STATUS MESSAGE

DDPNST:				;HERE ON RECEIPT OF DEVICE STATUS MESSAGE

;STC

	PUSHJ	P,EBI2BI##	;READ THE CODE (STATUS, SET, OR CLEAR)
	JUMPN	T1,CPOPJ##	;MUST BE BASIC STATUS

;STS

	PUSHJ	P,EBI2BI##	;READ IN STATUS BITS
	XOR	T1,DEVSTS(F)	;GET CHANGE FROM PREVIOUS STATUS
	XORM	T1,DEVSTS(F)	;AND UPDATE TO NEW STATUS
	HRL	T1,DEVSTS(F)	;CARRY CURRENT STATUS IN LH, DELTA IN RH
	TRNN	T1,-1		;ANYTHING OF CONSEQUENCE CHANGE?
	JRST	CPOPJ1##	;SUCCESSFUL RETURN

;SOMETHING HAPPENED TO THE DDP, TELL SOMEONE ABOUT IT, IF ANYONE CARES

	MOVE	S,DEVIOS(F)	;S PROBABLY TRASHED BY NOW
	TLNE	S,IOSDDK	;IS DDP IN USE AS A KONTROLLER?
	PJRST	DDPKST		;YES, PROCESS KONTROLLER STATUS CHANGE
				; (WE ARE AT INTERRUPT LEVEL)

;DDP IN USE AS AN I/O DEVICE, GIVE USER PSI/ETC.

	PUSHJ	P,NTDIAV##	;NUDGE LOW LEVEL ROUTINES
	JRST	CPOPJ1##	;SUCCESSFUL RETURN
;HERE FOR DEVICE CONTROL

DDPNCT:	POPJ	P,		;HO HUM.
SUBTTL	KONTROLLER SERVICE - VECTORED DRIVER INTERFACE

;REMEMBER, KONTROLLERS RUN AT INTERRUPT LEVEL, GOTTA BE CAREFUL NOT TO
;OFFEND ANYONE!

;DDPDSP  --  ENTRY INTO KONTROLLER LAYER FROM DRIVER LAYER
;CALL IS:
;
;	MOVX	T1,<FNC>
;	MOVX	T2,<DDP>
;	MOVX	T3,<ARG>
;	MOVX	T4,<USR>
;	PUSHJ	P,DDPDSP
;	 ERROR RETURN
;	NORMAL RETURN
;
;WHERE <FNC> IS THE KONTROLLER FUNCTION (DD.???) TO BE PERFORMED, SUCH
;AS START OR STOP THE DEVICE, ETC.; <DDP> IS THE DDP DATA BLOCK ADDRESS
;(I.E., THE DDB, THE SAME AS IN UUO-LEVEL PROCESSING). <ARG> IS ANY
;ARGUMENT APPROPRIATE TO THE PARTICULAR FUNCTION REQUESTED (E.G., BUFFER
;ADDRESS FOR OUTPUT DATA) AND <USR> IS THE "LINE USER" - ANF, DECNET,
;ETC.
;
;ON ERROR RETURN SOMETHING AWFUL HAPPENED, SUCH AS ILLEGAL USER.
;
;ON NORMAL RETURN THE REQUESTED FUNCTION HAS BEEN SUCCESSFULLY PERFORMED
;(WHICH IS NOT TO SAY IT CAN'T FAIL LATER - SUCH AS THE DDP GOING DOWN
;WHILE OUTPUT DATA IS STILL QUEUED).

DDPDSP::CAIL	T1,0		;RANGE-CHECK THE FUNCTION CODE
IFE FTCIMP,CAILE	T1,DD.MAX	; TO MAKE SURE WE UNDERSTAND IT
IFN FTCIMP,CAILE	T1,DD.MAF	;[je] Avoid symbol confusion.
	 pushj	p,ntdstp##
	CAIE	T4,DD.DEC	;IS IT A LINE-ID FROM DECNET
	JRST	DDPDS1		;NO, DON'T CONVERT IT
	TLNN	T2,-1		;IS IT A LINE-ID
	JRST	DDPDS1		;NO, ITS A DDB USE IT
	PUSHJ	P,DDPSRC	;GET THE DDB
	POPJ	P,		;COULDN'T DO IT
DDPDS1:	CAME	T4,DDPUSR(T2)	;CALLED BY LEGIT USER?
	POPJ	P,		;NO, ERROR RETURN
	PUSH	P,F		;SAVE F
	PUSH	P,S		; AND S
	PUSH	P,U		;ALSO SAVE U
	PUSH	P,W		;AND DOUBLE-U
	MOVE	F,T2		;PUT DDB ADDRESS IN F
	MOVE	S,DEVIOS(F)	;LOAD S ON G.P.S
	TLNE	S,IOSDDK	;HAD BETTER BE IN KONTROLLER MODE!
	PUSHJ	P,@DDPDST(T1)	;DISPATCH BASED ON FUNCTION
	 TRNA			;HO HUM
	AOS	-4(P)		;PROPIGATE SKIP
	POP	P,W		;RANDOM ACS
	POP	P,U		;TRASHED BY NETSER
	POP	P,S		;RESTORE S
	POP	P,F		;AND F
	POPJ	P,		;RETURN TO DRIVER
DDPDST:	IFIW	DDPOPN		;0 = OPEN CIRCUIT (INITIALIZE PROTOCOL)
	IFIW	DDPCLS		;1 = CLOSE CIRCUIT (HALT PROTOCOL)
	IFIW	DDPQUE		;2 = QUEUE OUTPUT BUFFER
	IFIW	DDPPRB		;3 = POST RECEIVE BUFFER
	IFIW	CPOPJ##		;4 = CHECK FOR EXISTANCE
IFE FTCIMP,<IFN <.-DDPDST-DD.MAX-1>,<PRINTX ? Table DDPDST is incorrect>>
IFN FTCIMP,<IFN <.-DDPDST-DD.MAF-1>,<PRINTX ? Table DDPDST is incorrect>>
;KONTROLLER FUNCTION: OPEN CIRCUIT (INITIALIZE PROTOCOL)

DDPOPN:	SKIPE	DDPMBP(F)	;JUST CAUTIOUS
	 STOPCD .+1,DEBUG,JE1	; Sigh...
	SETZM	DDPMBP(F)	;CLEAR IT (OR STOPCD LATER)
	TLNN	S,IOSDDH	;WERE WE HALTED BEFORE?
	JRST	DDPOP2		;NO, SEE IF DDCMP IS RUNNING
	MOVSI	S,IOSDDH	;THE "HALTED BY REQUEST" BIT
	ANDCAB	S,DEVIOS(F)	;TURN THE DDP BACK ON
DDPOP2:	TLNE	S,IOSDDD	;WAS THE DDCMP PROTOCOL RUNNING?
	PUSHJ	P,DDPKUP	;DDCMP IS NOW RUNNING
	HRRZ	T1,F		;RETURN DDB ADDRESS TO USER
	JRST	CPOPJ1##	;SUCCESSFUL (I HOPE)



;KONTROLLER FUNCTION: CLOSE CIRCUIT (HALT PROTOCOL)

DDPCLS:	TLNE	S,IOSDDH	;ALREADY HALTED?
	JRST	DDPCL1		;YES
	MOVSI	S,IOSDDH	;THE "HALTED BY REQUEST" BIT
	IORB	S,DEVIOS(F)	;STOP FURTHER USAGE
	TLNN	S,IOSDDD	;WAS THE PROTOCOL UP BEFORE?
	PUSHJ	P,DDPKDN	;YES, TAKE IT DOWN FORCIBLY
				; IOSDDH WILL HOLD IT DOWN EVEN THOUGH
				; DDCMP IS REALLY STILL RUNNING
DDPCL1:	MOVE	T1,DDPMBP(F)	;GET ANY MESSAGE POINTER
	SETZM	DDPMBP(F)	;CLEAR KNOWLEDGE
	JRST	CPOPJ1##	;SUCCESSFUL (MORE OR LESS)


;KONTROLLER FUNCTION: QUEUE OUTPUT DATA

DDPQUE:	TLNN	S,IOSDDD	;MAKE SURE THE PROTOCOL IS "UP"
	SKIPN	DDPUSR(F)	; AND IS IN USE BY SOMEBODY
	POPJ	P,		;IT ISN'T, DON'T QUEUE IT
	SETZM	MB.NXT(T3)	;CLEAR GARBAGE IN MESSAGE BLOCK
				; (I PERSONALLY THINK THIS, AH, IS JUNK!
				;  HOWEVER, THAT'S THE WAY IT IS)
IFN FTCIMP,<			;Make sure we don't create circular buffers...
	CAMN	T3,DDPQOB(F)	;This MB already there?
	 SETZM	DDPQOB(F)	; Yes, prevent chaining.
>;IFN FTCIMP

	XMOVEI	T1,DDPQOB-MB.NXT(F)  ;PRIME THE PUMP, SO TO SPEAK
	SETZ	T4,		;*** FOR KICKS
	NETOFF			;TIME TO PLAY WITH THE OUTPUT QUEUE

DDPDM3:	MOVE	T2,T1		;SAVE CURRENT MESSAGE
	SKIPE	T1,MB.NXT(T2)	;STEP TO NEXT MESSAGE
	AOJA	T4,DDPDM3	;*** FOR KICKS
	MOVEM	T3,MB.NXT(T2)	;STASH THIS MESSAGE AT THE TAIL OF THE QUEUE
	NETON			;ALLOW INTS AGAIN
	AOS	(P)		;WHATEVER ELSE HAPPENS, THIS FUNCTION WORKED
	PJRST	DDPKOU		;NOW TRY TO OUTPUT WHAT WE CAN
;KONTROLLER FUNCTION: POST RECEIVE BUFFER

DDPPRB:	TLNN	S,IOSDDD	;MAKE SURE THE PROTOCOL IS "UP"
	SKIPN	DDPUSR(F)	; AND IS IN USE BY SOMEBODY
	POPJ	P,		;NO, REFUSE RECEIVE BUFFER
	SKIPE	DDPMBP(F)	;ALREADY HAVE RECEIVE BUFFER POINTER?
	 STOPCD	CPOPJ##,DEBUG,JE2;[je] refuse receive buffer, but don't WEM.
	MOVEM	T3,DDPMBP(F)	;SAVE RECEIVE BUFFER ADDRESS
	PJRST	CPOPJ1##	;AND RETURN
;CONTINUED FROM PREVIOUS PAGE

;TRY TO PROCESS ANY QUEUED DATA AWAITING TRANSMISSION

DDPKOU:	SKIPN	DDPQOB(F)	;ANY DATA QUEUED FOR OUTPUT?
	POPJ	P,		;NO, NOTHING TO DO

;TIS NOW TIME TO ARRANGE NETSER'S INTERLOCK. WISH ME LUCK.

	SKIPL	NTLOCK##	;IS NETSER INTERLOCK TAKEN?
	JRST	[PUSHJ	P,NTCHCK##	;YES, CHECK NETSER INTERLOCK
		  POPJ	P,		;IT'S OWNED BY SOMEONE ELSE, PUNT
		PJRST	DDPKO1]		;WE ALREADY OWN IT, ALL SET

	PUSHJ	P,INTLVL##	;ARE WE AT INTERRUPT LEVEL?
	 JRST	[NETDBL			;GET NETSER INTERLOCK AT UUO LEVEL
		PUSHJ	P,DDPKO1	;DO IT
		NETDBU			;FREE NETSER INTERLOCK
		POPJ	P,]		;ALL DONE
	NTDBLI			;GET NETSER INTERLOCK AT INTERRUPT LEVEL
	 POPJ	P,		;CAN'T DO IT NOW
	PUSHJ	P,DDPKO1	;DO IT
	NTDBUI			;FREE NETSER INTERLOCK
	POPJ	P,		;ALL DONE
;NOW SETUP NDB POINTER FOR NETSER.

DDPKO0:	SE1ENT			;HERE FROM NETSER, GET TO SECTION 1
DDPKO1:	PUSHJ	P,SAVE4##	;NETSER TRASHES THE P'S
	HRRZ	T1,DEVNET(F)	;GET THE NODE NUMBER
	PUSHJ	P,SRCNDB##	;FIND THE DDP'S NDB
	 pushj	p,ntdstp##

;LOOP BUILDING NCL OUTPUT MESSAGES FOR NETSER

DDPKO2:	NETOFF			;TIME TO DIDDLE THE QUEUE
	SKIPE	P1,DDPQOB(F)	;GET ADDRESS OF NEXT OUTPUT MESSAGE
	PUSHJ	P,NTDCDQ##	;GOT OUTPUT PENDING, ANY DATA REQUESTS FOR IT?
	 JRST	DDPKP2		;OOPS - NO MORE LEFT, PUNT
	MOVE	T1,MB.NXT(P1)	;NEXT QUEUED DATA MESSAGE
	MOVEM	T1,DDPQOB(F)	;BECOMES NEW FIRST QUEUED MESSAGE
	NETON			;SAFE AGAIN

;START UP A NETSER DATA MESSAGE

	SKIPN	T2,MB.FMS(P1)	;ADDRESS OF FIRST MESSAGE SEGMENT DESCRIPTOR
	 pushj	p,ntdstp##
	SKIPA	T1,MD.BYT(T2)	;START WITH FIRST BYTE COUNT
	ADD	T1,MD.BYT(T2)	;ACCUMULATE TOTAL MESSAGE BYTE COUNT
	SKIPE	T2,MD.NXT(T2)	;ADVANCE TO NEXT SEGMENT
	JRST	.-2		;WALK THE ENTIRE CHAIN
	PUSH	P,T1		;SAVE DATA BYTE COUNT
	ADDI	T1,17		;ALLOW FOR NCL HEADER (AND ROUND UP)
	LSH	T1,-2		;CONVERT TO WORD ALLOCATION

;THIS WOULD BE A CLEVER PLACE TO TRY TO PIGGYBACK OUTGOING DATA REQUESTS
;WITH RELATIVELY NON-HUGE OUTGOING DATA MESSAGES

	S0PSHJ	NTDHDR##	;FIRE UP NCL DATA MESSAGE
	 JRST	DDPKPU		;NO NETSER FREE CORE, PUNT FOR NOW
	MOVE	T1,0(P)		;RETRIEVE THE DATA BYTE COUNT
	ADDI	T1,1		;ALLOW FOR "TYP" NCL FIELD
	PUSHJ	P,BI2EBI##	;OUTPUT "CNT" (COUNT OF DATA) FIELD
	MOVEI	T1,DC.DAR	;DATA WITH END OF RECORD
	PUSHJ	P,DPBBIN##	;OUTPUT "TYP" FIELD
	ADDM	P3,PCBOCT(U)	;ACCOUNT FOR ADDITIONAL NCL BYTES

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;LOOP COPYING DATA FROM MESSAGE BLOCK INTO PCB

	MOVEM	P1,0(P)		;SAVE ORIGINAL MESSAGE BLOCK ADDRESS
	MOVE	P1,MB.FMS(P1)	;ADDRESS OF FIRST MESSAGE SEGMENT DESCRIPTOR
	PUSH	P,T5		;SAVE PROTECTED TEMPORARY
	PUSH	P,T6		;AND THE OTHER ONE TOO

;AT THIS POINT, P1 IS THE FIRST LINK OF A CHAIN OF "MESSAGE SEGMENT DESCRIPTOR"
;BLOCKS (ANY ONE OF WHICH CAN BE "NULL") CONTAINING THE DATA TO BE SENT. THE
;MD.AUX WORD IDENTIFIES THE FIRST BYTE WITHIN THE FIRST WORD CONTAINING VALID
;DATA, AND THE MD.ALA WORD IDENTIFIES THE FIRST WORD. WE CONSTRUCT OUR OWN
;BYTE POINTER SINCE THE DRIVER MAY HAVE INDEXED MD.AUX WITH SOME BIZARRE
;REGISTER.

DDPKO4:	SKIPG	T1,MD.BYT(P1)	;COUNT OF BYTES IN THIS SEGMENT
	 JRST	DDPKO6		; NULL SEGMENT, PITCH AND ADVANCE TO NEXT ONE
	ADDM	T1,PCBOCT(U)	;UPDATE PCB'S BYTE COUNT
	move t2,md.aux(p1)	;Fix extend instruction for KI10.
	add t2,md.ala(p1)
	tlz t2,77
	ildb cx,t2
	idpb cx,p2
	sojg t1,.-2

DDPKO6:	SKIPE	P1,MD.NXT(P1)	;GET ADDRESS OF NEXT MESSAGE SEGMENT
	JRST	DDPKO4		;COPY NEXT SEGMENT OF DATA INTO ANF PCB
	POP	P,T6		;RESTORE FUNNY T-REG
	POP	P,T5		;AND THE OTHER ONE TOO
	MOVEI	T1,PCV.NC	;"NO COMPRESSION"
	S0PSHJ	NTDWRT##	;GIVE THIS BUFFER TO NETSER TO TRANSMIT
	PUSHJ	P,NTDDDQ##	;COUNT DOWN AVAILABLE DATA REQUESTS
	POP	P,T3		;ADDRESS OF USED-UP MESSAGE BLOCK
	MOVEI	T1,DI.ODN	;"OUTPUT DONE" INTERRUPT
	PUSHJ	P,DDPDV1	;CALL OUR DRIVER
	JFCL			;HO HUM
	JRST	DDPKO2		;CHECK FOR MORE OUTPUT
;HERE WHEN NETSER IS OUT OF MEMORY - TRY TO REQUEUE THE MESSAGE BLOCK

DDPKPU:	POP	P,T1		;PITCH THE UNUSEABLE BYTE COUNT
	NETOFF			;BACK TO DIDDLING THE QUEUE
	MOVE	T1,MB.NXT(P1)	;MB THAT WE LEFT AS THE NEXT IN THE QUEUE
	CAME	T1,DDPQOB(F)	;STILL THERE?
	JUMPN	T1,DDPKP5	;QUEUE HAS CHANGED (UNLESS NEW ENTRY APPEARED)
	MOVE	T1,DDPQOB(F)	;GET PENDING HEAD OF QUEUE
	MOVEM	T1,MB.NXT(P1)	;PRE-PEND THE DE-QUEUED MESSAGE BLOCK
				; (THIS IS NEEDED FOR THE CASE WHERE
				;  THE DE-QUEUED MB WAS THE ONLY ENTRY IN
				;  THE QUEUE, THEN A NEW ENTRY WAS ADDED
				;  AFTER THIS ONE GOT DE-QUEUED)
	MOVEM	P1,DDPQOB(F)	;RE-QUEUE THE DE-QUEUED MESSAGE BLOCK
DDPKP2:	NETON			;SAFE AGAIN
	PJRST	DDPKK7		;TRY TO OUTPUT DATA REQUESTS (IF NEEDED)

;HERE WHEN WE CAN'T RE-QUEUE THE MESSAGE 'CUZ THE QUEUE CHANGED. PROBABLY
;KONTROLLER GOT HALTED OR SOMETHING LIKE THAT. PITCH THE MESSAGE AND LET
;THE DRIVER WORRY ABOUT IT. THIS SHOULD NOT HAPPEN OFTEN.

DDPKP5:	NETON			;HO HUM
	MOVE	T3,P1		;ADDRESS OF MESSAGE BLOCK
DDPKP7:	MOVEI	T1,DI.ODN	;FUNCTION: LIE AND SAY "OUTPUT DONE"
	PUSHJ	P,DDPDV1	;TELL DRIVER OUR WOES
	JFCL			;IGNORE ERROR
	POPJ	P,
;HERE WHEN RECEIVE DATA REQUESTS FROM REMOTE
;
;ENTERED WITH NETSER INTERLOCK . . .

DDPKIQ:	PUSHJ	P,NTDRDQ##	;ACCUMULATE DATA REQUESTS FOR OUTPUT
	 pushj	p,ntdstp##
	PUSHJ	P,DDPKKO	;KICK THE OUTPUT STUFF
	JRST	CPOPJ1##	;SKIP RETURN (FOR NCTDSP)



;HERE WHEN WE'VE RECEIVED AN NCL MESSAGE FOR THIS DDP, MAY BE DATA, STATUS,
;ETC. LET NETSER DO THE BRUNT OF THE PARSING AND DISPATCHING (BACK TO DDPSER
;VIA NDEVDP DISPATCH - AND NO, THIS IS NOT RECURSIVE, EVEN THOUGH WE GOT
;HERE VIA SAID NDEVDP DISPATCH).
;
;ENTERED WITH NETSER INTERLOCK . . .

;***	AT THIS POINT, WE REALLY SHOULD CHECK FOR ANY DATA LEFT OVER FROM
;***	"UUO" DAYS (READ, "DEVPCB") SINCE IT IS POSSIBLE THAT BETWEEN THE
;***	CREATION OF THE DDP AS A DEVICE (DDB) AND THE SWITCHING OF THE
;***	DDP INTO KONTROLLER MODE ONE OR MORE DATA MESSAGES IN THE PIPE
;***	ARRIVED AND GOT QUEUED FOR "IN" UUOS . . .

DDPKIL:	PUSHJ	P,NTDILD##	;GO PROCESS NCL INPUT
;	PJRST	DDPKKO		;GO KICK THE OUTPUT ROUTINES
;CHECK FOR OUTPUTTABILITY

DDPKKO:	PUSHJ	P,SAVJW		;SAVE REGISTERS J AND W
	PUSHJ	P,SAVE4##	;SAVE REGISTERS P1 - P4
	PUSH	P,U		;FINALLY SAVE THE INPUT'S PCB ADDRESS
	SETZ	U,		;TAKE NO CHANCES
	PUSHJ	P,DDPKK0	;DO IT!
	POP	P,U		;RESTORE INPUT'S PCB ADDRESS
	POPJ	P,		;AND LOTS OF REGISTERS TOO!


;SEE IF THERE IS ANY QUEUED OUTPUT WE CAN SHIP TO THE REMOTE

DDPKK0:	NTDBUG	YES, EITHER	;MUST HAVE NETSER INTERLOCK HERE!
	PUSHJ	P,DDPKO0	;TRY TO FORCE OUT ANY PENDING OUTPUT

;TRY TO OUTPUT ANY DATA REQUESTS

DDPKK7:	HRLOI	T1,6		;AIM AT 6 OUTSTANDING DATA REQUESTS
	SUB	T1,DEVDRQ(F)	;LH(T1) IS SHORT-COUNT
	HLRZ	T1,T1		;T1 IS COUNT OF DATAREQUESTS NEEDED
	CAIGE	T1,2		;WAIT FOR AT LEAST 2
	POPJ	P,		;DON'T BOTHER WITH JUST 1
	PUSH	P,T1		;SAVE DATA REQUEST INCREMENT
	S0PSHJ	NCSDRQ##	;SEND DATA REQUEST(S)
	  JRST	TPOPJ##		;NO CORE, TRY LATER
	POP	P,T1		;DATA REQUESTS SENT
	HRLZ	T1,T1		;POSITION IN LH
	ADDM	T1,DEVDRQ(F)	;AND ACCOUNT FOR OUTSTANDING DATA REQUESTS
	POPJ	P,		;ALL DONE
;HERE FOR DATA INPUT (VIA DDPKIL), PASS TO THE DRIVER (OR "TRANSPORT") LAYER

DDPKIN:	SE1ENT			;NEED TO RUN IN EXTENDED ADDRESS SPACE
	TLNN	S,IOSDDH	;IS THE PROTOCOL "RUNNING"
	SKIPN	DDPUSR(F)	;YES, AND DO WE HAVE SOMEBODY TO RECEIVE DATA?
	JRST	DDPKI9		;NO, JUST EAT INCOMING DATA

;GET A BUFFER FROM OUR DRIVER INTO WHICH TO COPY DATA

	SKIPN	T3,DDPMBP(F)	;DO WE HAVE A RECEIVE MESSAGE BUFFER
	JRST	DDPKI9		;NO, PITCH DATA, MUST BE SHUTTING DOWN
	SETZM	DDPMBP(F)	;CLEAR PREVIOUS MESSAGE BUFFER POINTER
	PUSH	P,T5		;SAVE EXTEND TEMPS
	PUSH	P,T6		;THE OTHER ONE

;COPY DATA INTO MESSAGE BLOCK

	MOVE	P2,T3		;ADDRESS OF MESSAGE BLOCK
	MOVE	P3,MB.FMS(P2)	;POINTER TO FIRST (AND ONLY) MESSAGE SEGMENT
	MOVEM	P4,T1		;SET "SOURCE" BYTE COUNT
	MOVEM	P4,MD.BYT(P3)	;ALSO TELL THE DRIVER
	HRRZ	T4,MD.ALL(P3)	;GET MAXIMUM MESSAGE SIZE
	CAMLE	P4,T4		;WILL IT FIT?
	 pushj	p,ntdstp##
	MOVEM	P4,T4		;SET "DESTINATION" BYTE COUNT
	MOVSI	T5,(POINT 8,(T6))  ;"DESTINATION" BYTE POINTER (PROTOTYPE)
	SKIPN	T6,MD.ALA(P3)	;ADDRESS OF "DESTINATION" DATA SEGMENT
	 pushj	p,ntdstp##
	ildb cx,p1
	idpb cx,t5
	sojg t1,.-2
	SETZ	P4,		;AND SUBMESSAGE BYTE COUNTER
	POP	P,T6		;DONE WITH EXTEND INSTRUCTION
	POP	P,T5		;THE OTHER ONE

;GIVE THE DATA TO OUR DRIVER

	MOVE	T3,P2		;POSITION MESSAGE BLOCK ADDRESS
	MOVEI	T1,DI.INC	;FUNCTION "INPUT COMPLETE"
	PUSHJ	P,DDPDV1	;GIVE DATA TO OUR DRIVER
	JFCL			;IGNORE ERROR
	JRST	CPOPJ1##	;SUCCESSFUL RETURN TO NETSER


;HERE TO EAT THE NCL INPUT DATA

DDPKI9:	ADJBP	P4,P1		;SKIP PAST THIS NCL SUB-MESSAGE
	MOVEM	P4,P1		;PUT INCREMENTED POINTER BACK IN P1
	SETZ	P4,		;PUT DECREMENTED COUNTER BACK IN P4
	JRST	CPOPJ1##	;AND TAKE THE SUCCESSFUL RETURN
;HERE FOR STATUS CHANGE, PASS PROTOCOL UP/DOWN/ETC TO THE DRIVER

DDPKST:	SE1ENT			;THIS NEEDS TO BE IN SECTION 1
	PUSH	P,T1		;SAVE A COPY OF THE STATUS

;BASICALLY, THE SDP.AV STATUS IS IGNORED (IF SDP.AV CLEARS, IT WILL DRAG
;SDP.RN WITH IT), ONLY SDP.RN IS CHECKED TO SEE IF THE DDP IS "VIABLE"

	TRNN	T1,SDP.RN	;DID PROTOCOL GO UP/DOWN?
	JRST	TPOPJ##		;NO, (Should check for errors)
	XMOVEI	T3,DDPKUP	;YES, ASSUME IT WENT UP
	TLNN	T1,SDP.RN	;IS DDCMP PROTOCOL NOW RUNNING?
	XMOVEI	T3,DDPKDN	;NO, THEN THE PROTOCOL WENT DOWN
	TLNN	S,IOSDDH	;IGNORE IF HALTED BY DRIVER
	PUSHJ	P,0(T3)		;HANDLE PROTOCOL STATUS CHANGE
	JRST	TPOPJ##		;RESTORE STATUS THEN RETURN
;PROCESS DDP PROTOCOL UP CONDITION

DDPKUP:	MOVSI	S,IOSDDD	;THE "PROTOCOL DOWN" FLAG
	ANDCAB	S,DEVIOS(F)	;PROTOCOL IS NOT DOWN

	MOVEI	T1,DI.LSC	;LINE STATE CHANGE
	MOVEI	T3,LS.ON	;PROTOCOL IS UP
	PUSHJ	P,DDPDV1	;TELL OUR DRIVER THE GOOD NEWS
	 TRN			;HO HUM
	POPJ	P,
;PROCESS DDP PROTOCOL DOWN CONDITION

DDPKDN:	MOVSI	S,IOSDDD	;THE "PROTOCOL DOWN" FLAG
	IORB	S,DEVIOS(F)	;FLAG THE EVENT

;CLEAN UP STALE OUTPUT AND DECLARE THE KONTROLLER "PROTOCOL DOWN"

DDPKD3:	NETOFF			;NO INTERRUPTS WHILST DIDDLING QUEUES
	SKIPN	T3,DDPQOB(F)	;GET START OF OUTPUT QUEUE
	JRST	DDPKD7		;NONE, ALL CLEAR
	MOVE	T1,MD.NXT(T3)	;GET ADDRESS OF NEXT MESSAGE IN THE QUEUE
	MOVEM	T1,DDPQOB(F)	;DELINK THE FIRST MESSAGE
	NETON			;SAFE AGAIN
	MOVEI	T1,DI.ODN	;LIE AND SAY OUTPUT DONE
	PUSHJ	P,DDPDV1	;TELL DRIVER THE BAD NEWS
	JFCL			;IGNORE ERRORS
	JRST	DDPKD3		;FREE THE REST OF THE OUTPUT QUEUE

DDPKD7:	NETON			;SAFE AGAIN

;CLEAN UP STALE INPUT BUFFER TOO

	SKIPN	T3,DDPMBP(F)	;GOT A DECNET INPUT BUFFER POSTED?
	JRST	DDPKD8		;NO
	SETZM	DDPMBP(F)	;YES, MARK IT DE-POSTED
	MOVE	T2,DDPLBK(F)	;POSITION ADDRESS OF DATA LINK BLOCK
;	MOVEI	T1,DI.INE	;FUNCTION: INPUT ERROR RETURN OF BUFFER
;	PUSHJ	P,DDPDV1	;TELL DRIVER WE ARE RETURNING HIS BUFFER
;	 JFCL			;OH WELL, WE TRIED
IFN FTCIMP,<
	HRRZ	T1,DDPUSR(F)	;Get protocol.				[JMR]
	CAIN	T1,DD.IP	;Handle IP differently.			[JMR]
	 JRST[	PUSHJ	P,IPIINE## ;Call IP protocol down routine.	[JMR]
		JRST	DDPKD8]	;Don't call the DECnet routine!		[JMR]
>;IFN FTCIMP
	PUSHJ	P,DDIINE##	;TELL DRIVER WE ARE RETURNING HIS BUFFER

DDPKD8:	MOVEI	T1,DI.LSC	;LINE STATE CHANGE
	MOVEI	T3,LS.OFF	;PROTOCOL IS DOWN
	PUSHJ	P,DDPDV1	;TELL THE DRIVER WE ARE NOW "HALTED"
	JFCL
	POPJ	P,
;ZAP (DESTROY) A DDP KONTROLLER

DDPKZP:	SE1ENT			;NEED SECTION 1 . . .
	PUSHJ	P,DDPKDN	;FIRST SHUT DOWN THE DDP PROTOCOL/DRIVER
	MOVSI	S,IOSDDK!IOSDDD	;VARIOUS KONTROLLER FLAGS
	ANDCAB	S,DEVIOS(F)	;DDP IS NO LONGER A KONTROLLER!
	SETZM	DDPUSR(F)	; . . .
	SETZM	DDPLBK(F)	; . . .
	POPJ	P,		;AND THAT IS THE END OF THAT
SUBTTL	SUBSIDIARY ROUTINES

;DDPDVR	ROUTINE TO CALL THIS LINE'S DRIVER
;CALL:
;
;	MOVX	T1,<FNC>
;	MOVX	T3,<ARG>
;	PUSHJ	P,DDPDVR
;	RETURN
;
;WHERE <FNC> IS THE DRIVER FUNCTION (DI.???) TO PERFORM; AND <ARG> IS
;ANY ARGUMENT AS NEEDED BY THE DRIVER.
;
;F MUST BE POINTING TO THE DDP DDB
;
;DDPDVR WILL DISPATCH INTO THE APPROPRIATE DRIVER BASED ON THE LINE
;USER IN DDPUSR, WITH T2 CONTAINING THE APPROPRIATE DATA BLOCK ADDRESS

DEFINE	X(TYP,CON,DAT,ADR),<
	IFN	.-DDPDX0-<2*DD.'TYP>,<
		PRINTX	? DDPDVR vector dispatch phase error for TYP user>
	IFE	CON,<
		PUSHJ	P,NTDSTP##	;;DIE IF NO DRIVER SUPPORTED
		HALT	.>		;;FILLER FOR TWO-WORD VECTOR
	IFN	CON,<
		MOVE	T2,DAT(F)	;;GET "DRIVER" DATA BLOCK ADDRESS
		PJRST	ADR>		;;AND GO TO APPROPRIATE DRIVER
> ;END DEFINE X

DDPDVR:	SE1ENT			;RUN IN EXTENDED ADDRESS SPACE
DDPDV1:
	PUSHJ	P,SAVR##	;DECnet USES R AS A TRASH AC.
	HRRZ	T2,DDPUSR(F)	;GET THE USER CODE
	CAILE	T2,DD.MAX	; AND RANGE CHECK IT
	 pushj p,ntdstp##
	LSH	T2,1		;TRANSLATE INTO TWO-WORD BLOCK OFFSET
	PJRST	.+1(T2)		;DISPATCH BASED ON "USER" TYPE

DDPDX0:	X	(NOBODY,1,0,CPOPJ1##)	;ALWAYS SAY GOODNESS FOR "NOBODY"
DDPDX1:	X	(ANF10,FTNET,0,DDPDXE)
DDPDX2:	X	(DECNET,FTDECN,DDPLBK,DDIPPI##)
DDPDX3:	X	(PROGRAM,1,0,DDPDXE)
DDPDX4:	X	(IBMCOMM,FTDN60,0,DDPDXE)
IFN FTCIMP,<
DDPDX5:	X	(IP,FTCIMP,DDPLBK,IPIPPI##) ;IP dispatch.		[JMR]
>;IFN FTCIMP
	IFN	.-DDPDX0-<2*<DD.MAX+1>>,<
		PRINTX	? DDPDVR vector dispatch entry missing>
DDPDXE:	pushj p,ntdstp##
	XLIST			;THE LITERALS
	LIT
	LIST

	
	PRGEND
TITLE	NETMCR - NETWORK MONITOR CONTROL ROUTINES  VERSION 001
SUBTTL	NETMCR -- WEM/	4-JUN-78

	SEARCH	F,S,NETPRM

ifn stupid,<ifn ftcimp,<search netdef>>

FTYORK==0			;*** Until checked out MCROKE ***

	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; COPYRIGHT (C) 1978  BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
XP VNEMCR,001		;PUT VERSION NUMBER IN GLOB AND LOADER MAP

NETMCR::ENTRY NETMCR


NDEVMC==:777740			;DUMMY DEVSER DISPATCH FOR NDT MACRO
SUBTTL 1.0      INTERFACE TO SCNSER

SUBTTL 1.1        SCNSER DISPATCH TABLE

REMDSP::JRST	D85TYP		;ILLEGAL NOW.  DON'T USE!!
	JRST	CPOPJ##		;MODEM CONTROL
	JRST	CPOPJ##		;ONCE A SECOND STUFF
	JRST	CPOPJ##		;INITIALIZE
	JRST	D85CHP		;CHANGE HARDWARE PARMS
	JRST	D85LPC		;LINE PARM CONTROL
	JRST	D85ELE		;SET TERMINAL ELEMENT
	JRST	D85REM		;STUFF FOR REMOTE TERMINALS
	JRST	D85OFL		;IS THE LINE DEFINED ON THE STATION

D85TYP:	STOPCD	.,STOP,CU0,	;++ CAN'T USE ZERO DISPATCH
	POPJ	P,

D85CHP:				;HERE TO REQUEST A CHANGE OF PARAMETERS
	PJRST	SETCHP##	;LET SCNSER DO THE WORK

D85LPC:				;HERE TO REQUEST A LINE PARM CHANGE.
	CAIE	T3,<LPCUKB>B27	;UNLOCK KEYBOARD OR TERMINAL INPUT WAIT?
	POPJ	P,		;??
	PJRST	D85CHP		;REQUEST THE CHANGE OF PARMS

D85ELE:				;HERE TO CHANGE THE ELEMENT ON A 2741
	PUSHJ	P,ELEINX##	;CONVERT TO AN INDEX
	  POPJ	P,		;ILLEGAL
	DPB	T2,LDPELE##	;STORE THE NEW ELEMENT NUMBER,
	AOS	(P)		;GIVE A GOOD SKIP RETURN
	PJRST	D85CHP		; AND SIGNAL THE CHANGE IN PARAMETERS

D85OFL:				;SEE IF THE TERMINAL IS ON-LINE
	MOVE	T1,LDBREM##(U)	;GET THE STATUS BITS
	TLNE	T1,LRLCON##	;IF THIS IS SET WE ARE PROBABLY
	AOS	(P)		; STILL CONNECTED, IF IT IS ZERO, WE
	POPJ	P,		; ARE MOST CERTAINLY NOT.
;COME HERE ON SPECIAL CALLS FROM SCNSER

;CODE IN T3:
;1 = BUFFER LOW
;2 = CHARACTER NOT STORED
;3 = CONTROL O PROCESSING.

D85REM:	CAIL	T3,1		;VALIDATE RANGE
	CAILE	T3,3
	POPJ	P,		;IGNORE IF NOT IN RANGE
	JRST	@.(T3)		;OTHERWISE DISPATCH
	EXP	MCRBFL		;BUFFER LOW
	EXP	MCRCNS		;CHARACTER NOT STORED
	EXP	MCRCTO		;CONTROL O

;THESE ARE NO-OPS FOR NOW.

MCRCNS==CPOPJ##

;COME HERE ON CONTROL O ACTION.  THE CONTROL O MAY HAVE BEEN
;  SET EITHER ON OR OFF.  CHECK THE LDB TO DETERMINE WHICH AND
;  SEND A CHARACTER GOBBLER IF IT HAS BEEN SET ON.

MCRCTO:
	MOVSI	T2,LRLSCG##	;GET AND SET THE BIT
	IORM	T2,LDBREM##(U)	; SAYING WE WANT A CHAR GOBBLER SENT
	PJRST	D85CHP		;NOW QUEUE THE LDB FOR SERVICE

;COME HERE IF INPUT BUFFER IS FULL
;THIS TELLS THE FRONT END THAT AN XOFF IS NEEDED
;	SKIP	RETURNS IF MESSAGE GETS SENT
MCRBFL:
	MOVSI	T2,LRLXOF##	;GET THE XOFF FLAG
	IORM	T2,LDBREM##(U)	;SET IT SO SCNMC7 WILL SEE IT
	AOS	(P)		;GIVE A GOOD SKIP RETURN
	PJRST	D85CHP		;AND QUEUE THE LDB
SUBTTL 1.2        SCNSER MODEM CONTROL.

IFN FTMODM,<
;HERE FOR MODEM CONTROL FROM SCNSER
D85DSC::			;ENTRY
	PUSHJ	P,MCRCHK	;SEE IF A LEGAL TERMINAL
	  JRST	ECOD4##		;NOT A TERMINAL
	MOVE	T2,LDBDCH##(U)	;GET THE STATUS BITS
	TRNN	T2,LDRDSD##	;IS THIS A DATA SET LINE
	JRST	ECOD4##		;NO
	CAIN	T3,DSTSTS##	;STATUS?
	JRST	D85STS		;YES
	CAIN	T3,DSTOFF##	;MODEM OFF
	JRST	D85OFF		;YES,
	CAIN	T3,DSTON##	;MODEM ON
	JRST	D85ON		;YES
	CAIN	T3,DSTCRQ##	;REQUEST DIAL OUT
	JRST	D85CRQ		;YES
	JRST	ECOD3##		;NONE OF ABOVE


D85STS:	MOVSI	T2,LRLDSR##	;CARRIER ON BIT
	TDNN	T2,LDBREM##(U)	;IS IT?
	TDZA	T1,T1		;NO
	MOVSI	T1,DSCHWC##	;YES
	JRST	STOTC1##	;STORE ANSWER FOR USER


D85OFF:	MOVSI	T2,LRLHUR##	;HANG-UP BIT
	IORM	T2,LDBREM##(U)	;REQUEST REMOTE TO HANG UP THE PHONE
	PUSHJ	P,D85CHP	;GO KICK THE REMOTE
	JRST	CPOPJ1##	;WE'VE DONE OUR PART


D85ON:	JRST	CPOPJ1##	;JUST PRETEND ALL IS WELL
	;STILL IN FTMODEM

D85CRQ:				;AUTO DIAL
	MOVSI	T2,LRLADL##	;GET AUTO DIAL LINE BIT
	TDNN	T2,LDBREM##(U)	;IS THIS A AUTO DIAL LINE
	PJRST	ECOD4##		;NOPE FAIL
D85CR1:	SKIPN	DIALDB##	;IS THE DIALER AVAILABLE
	JRST	D85CR2		;YES, CONTINUE
	MOVEI	T1,5		;NO
	PUSHJ	P,[NTSAVE	 ;RETURN THE 'NT RESOURCE
		   PJRST SLEEP##];AND NOW SLEEP.
	JRST	D85CR1		;TRY AGAIN
D85CR2:	HRRZM	U,DIALDB##	;STORE THE LDB OF THE REQUESTER
	MOVEM	J,DIALJB##	;STORE THE JOB NUMBER FOR NETCTC
	SETZM	DIALFL##	;INITIALIZE DIALOUT "STATE"
	PUSHJ	P,GETWRD##	;GET PART ONE OF THE NUMBER
	  PJRST	ECOD3##		;BAD ADDRESS
	MOVEM	T1,DIALNM##	;STORE PART ONE
	AOS	M		;SECOND PART
	PUSHJ	P,GETWRD##	;GET SECOND PART
	  PJRST	ECOD3##		;ADDRESS CHECK
	TRO	T1,17		;FORCE AN END CHARACTER
	MOVEM	T1,DIALNM+1	;STORE PART TWO
	MOVSI	T2,LRLADR##	;GET AUTO DIAL REQUEST BIT
	IORM	T2,LDBREM##(U)	;SET IT
	PUSHJ	P,D85CHP	;REQUEST SERVICE
D85CR3:	MOVEI	T1,^D3		;WAIT FOR THREE SECONDS
	PUSHJ	P,[NTSAVE	;SAVE THE 'NT'
		   PJRST SLEEP##] ;AND GO SLEEP
	SKIPL	T1,DIALFL##	;CHECK FOR A COMPLETED CALL
	JRST	D85CR3		;NO, WAIT AGAIN
	SETZM	DIALDB##	;YES, MAKE THE DIALER AVAILABLE
	SETZM	DIALJB##	;DON'T CONFUSE NETCTC
	TLNN	T1,LRLDSR	;DID THE DIALOUT SUCCEED?
	JRST	ECOD5##		;NO, GIVE AN ERROR RETURN
	JRST	CPOPJ1##	;YES, GOOD RETURN

>	;END IFN FTMODM
SUBTTL 2.0      INTERFACE TO NETSER FOR INCOMING DATA

SUBTTL 2.1        NETWORK DISPATCH TABLE FOR TERMINALS (NDP)

	JRST	MCRNWD		;(-5)NODE WENT DOWN
	JRST	MCRDSC		;(-4)DISCONNECT MESSAGE
	JRST	MCRCNC		;(-3)CONNECT CONFIRM
	JRST	NTDSTP##	;(-2)CONNECT INITIATE (WE DON'T POST DDB'S)
	JRST	MCRDRQ		;(-1)DATA REQUESTS
MCRNDP::JRST	NMCDSP		;(0) DISPATCH ON INCOMING MESSAGE
	JRST	MCRDAT		;(1) DATA WITHOUT END OF RECORD
	JRST	MCRDAR		;(2) DATA WITH END OF RECORD (MTA'S)
	JRST	MCRSTS		;(3) STATUS
	JRST	MCRCTL		;(4) CONTROL MESSAGE
	JRST	CPOPJ##		;(5) USER ID
	JRST	CPOPJ##		;(6) FILE SPEC
SUBTTL 2.2        NETWORK CONTROL MESSAGE PROCESSING

SUBTTL 2.2.1        NODE WENT DOWN

;MCRNWD	ROUTINE TO HANDLE THE "NODE WENT DOWN" NETWORK DISPATCH ENTRY
;CALL	MOVEI	F,LAT-ENTRY	;RH CONTAINS LDB POINTER
;	MOVEI	P1,NODE NUMBER OF THE DEAD NODE
;	PUSHJ	P,MCRNWD
;RETURN	CPOPJ			;ALWAYS
;
MCRNWD:	LDB	T1,LDPRNF##	;GET THE REMOTE NODE NUMBER
	CAIE	T1,(P1)		;IS IT THE SAME AS THE ONE WE ARE LOOKING AT?
	PUSHJ	P,NTDSTP##	;++ CLNNDB DOESN'T DO THIS ANYMORE
	PUSH	P,U		;SAVE U FOR A MOMENT
	MOVEI	U,(F)		;COPY THE LDB POINTER (WHERE MCR SUBRS LIKE IT)
	PUSHJ	P,NMCWAK	;WAKE ANYONE WHO MIGHT BE WAITING
	PUSHJ	P,CLRTTY	;THEN CLEAR THE LDB
	PUSHJ	P,RMVTTY	; AND DETACH THE TERMINAL
	PJRST	UPOPJ##		;RESTORE U AND WE ARE DONE
SUBTTL 2.2.2        DISCONNECT MESSAGES (BOTH INIT AND CONFIRM)

;MCRDSC	ROUTINE TO HANDLE INCOMING DISCONNECTS FOR MCR'S
;CALL	MOVEI	F,LDB		;(CAUSE THAT'S HOW ICMDSC DOES IT)
;	P1, P4 := POINT TO "SLA" OF THE DISCONNECT MESSAGE. (BUT WE DON'T CARE)
;	MOVEI	W,NDB
;	PUSHJ	P,MCRDSC
;RETURN	CPOPJ			;WE SHOULDN'T HAVE GOTTEN A DISCONNECT. BAD MSG.
;	CPOPJ1			;MESSAGE ACCEPTED.
;
MCRDSC:				;HERE TO PROCESS A MCR DISCONNECT MESSAGE
	PUSH	P,U		;SAVE THE INCOMING PCB
	MOVEI	U,(F)		;COPY THE LDB FOR CONVENIENCE.
	LDB	T1,LDPSLA##	;GET OUR LAT ADDRESS
	LDB	T2,LATSTA##	;GET THE STATE OF THE CONNECTION
	CAIL	T2,LAT.CC	;THE ONLY TIMES DISCONNECT IS LEGAL IS
	CAILE	T2,LAT.DC	; ARE LAT.CC, LAT.OK, AND LAT.DC
	JRST	UPOPJ##		;IF IT'S NOT ONE OF THEM, WE CAN'T PROCESS IT.
	CAIE	T2,LAT.OK	;DO WE NEED TO SEND A DISCONNECT CONFIRM?
	JRST	MCRDS1		; IF NOT. SKIP THE CODE THAT DOES
	MOVEI	T1,RSN.OK	;GET THE REASON FOR THE DISCONNECT CONFIRM
	EMRGCY			;USE "EMERGENCY" MEMORY IF NECESSARY
	PUSHJ	P,TRMXDC	;SEND THE DISCONNECT.
	  PUSHJ	P,NTDSTP##	;++ SHOULDN'T HAPPEN. EMERGENCY HACK SCREWED UP
MCRDS1:	PUSHJ	P,RMVTTY	;ATTEMPT TO "DETACH" THE USER (IF THERE IS ONE)
	PUSHJ	P,NMCWAK	;WAKE ANY JOB THAT MAY BE WAITING ON A CONNECT.
	PUSHJ	P,CLRTTY	;FREE THE LAT AND THE LDB
	PJRST	UPOPJ1##	;RETURN PCB AND GIVE A GOOD RETURN
SUBTTL 2.2.3        CONNECT CONFIRM

;MCRCNC	ROUTINE TO PROCESS A MCR CONNECT CONFIRM MESSAGE.
;CALL	MOVEI	W,NDB
;	MOVEI	F,LDB
;	P1, P4 := POINTER TO THE "SLA" SECTION OF THE CONNECT CONFIRM
;RETURN	CPOPJ1			;ALWAYS

MCRCNC:				;HERE FOR MCR CONNECT CONFIRM MESSAGE
	PUSH	P,U		;SAVE THE PCB POINTER
	MOVEI	U,(F)		;COPY THE LDB FOR CONVENIENCE

;SLA

	PUSHJ	P,EBI2BI##	;GET THE LINK ADDRESS AT THE OTHER END
	DPB	T1,LDPDLA##	;REMEMBER IT SO WE CAN SEND HIM STUFF

;DPN(OBJ)

	PUSHJ	P,XSKIP##	;IGNORE "OUR" OBJECT TYPE

;DPN(PID)

	PUSHJ	P,XSKIP##	;IGNORE "OUT" PROCESS NAME (OR UNIT #)

;SPN(OBJ,PID)

	PUSHJ	P,TTYRPN	;READ HIS LINE NUMBER AND CHECK FOR OPR.

;MML,FEA(DCM,RLN,DVT,DVU,DVV)

	PUSHJ	P,TTYRAT	;READ THE "ATTRIBUTES"
	PUSHJ	P,TRM.UP	;MARK TERMINAL ONLINE (MCRCHK WILL NOW SKIP)
	MOVSI	T1,LRLGRT##	;AS THIS IS A TERMINAL ASSIGNMENT REQUEST,
	IORM	T1,LDBREM##(U)	;LET THE OWNER "GREET" IT IF NECESSARY
	PUSHJ	P,NMCWAK	;WAKE ANY JOB THAT MAY BE WAITING FOR CONNECT
	JRST	UPOPJ1##	;RESTORE THE PCB AND SKIP RETURN
SUBTTL 2.2.4        CONNECT INITIATE

;NMCRCI	ROUTINE TO HANDLE THE CONNECT INITIATE MESSAGE FOR A MCR.
;CALLED	BY THE NDTCNI DISPATCH IN ICMCNT.
;	P1, P4 POINT TO THE "DPN" OF THE CONNECT MESSAGE
;	P3 := XWD DLA,OBJ	;AS READ FROM THE CONNECT
;	W := POINTER TO THE NDB
;RETURN	CPOPJ			;CONNECT REJECT. REASON IN "T1"
;	CPOPJ1			;CONNECT ACCEPTED. CONNECT CONFIRM SENT.

NMCRCI::			;HERE TO PROCESS A CONNECT INIT FOR A MCR.
	MOVE	T1,STATES##	;GET THE SCHEDULE BITS
	TRNE	T1,ST.NRT	;ANY REASON NOT TO CONNECT?
	JRST	[MOVEI T1,RSN.OT ;IF SO, GIVE A "NOT AVAILABLE" CODE
		 POPJ P,]	; AND GIVE AN ERROR RETURN
	PUSH	P,U		;SAVE THE INPUT PCB
	PUSHJ	P,GETLDB	;GET A FREE LDB
	  JRST	MCRXNU		;CAPACITY EXCEEDED ERROR
	PUSHJ	P,LDBCLR##	;GET SCNSER TO CLEAR NEW LDB
	MOVEI	T1,(U)		;GET A COPY OF THE LDB FOR GETSLA
	HRLI	T1,LAT.TY!LAT.OK ;SET THE "TTY" BIT AND NEW STATE
	PUSHJ	P,GETSLA##	;ALLOCATE A LAT ENTRY
	  JRST	MCRXNU		;IF NONE LEFT, THEN CAPACITY EXCEEDED.
	DPB	T1,LDPSLA##	;STORE THE LAT ADDRESS IN THE SLA FIELD
	HLRZ	T1,P3		;GET AND SAVE THE
	DPB	T1,LDPDLA##	; DLA
	PUSHJ	P,TRM.UP	;ANTICIPATE SUCCESS, AND DECLARE THE LDB ONLINE
				; (IF WE FAIL LATER, ALL WILL BE CLEARED UP)

;DPN(PID)

	PUSHJ	P,XSKIP##	;THE REMOTE CAN'T SELECT PARTICULAR MCR'S

;SPN(OBJ,PID)

	PUSHJ	P,TTYRPN	;READ THE REMOTE LINE NUMBER.

;MML,FEA(DCM,RLN,DVT,DVU,DVV)

	PUSHJ	P,TTYRAT	;READ THE REMOTE MCR'S ATTRIBUTES.
	PUSHJ	P,MCRXCN	;TRY TO SEND A CONNECT-CONFIRM.
	  JRST	[PUSHJ	P,CLRTTY	;FAILED, CLEAR THE LAT AND FREE THE LDB
		JRST	MCRXNU]		; GIVE THE "CAPACITY EXCEEDED" ERROR
	MOVSI	T1,LRLGRT##	;SINCE THIS IS AN UNSOLICITED TTY CONNECT
	ANDCAM	T1,LDBREM(U)	;FLAG THE TERMINAL TO BE "GREETED" ASAP
	JRST	UPOPJ1##	;CONNECT COMPLETED SUCCESSFULLY


MCRXNU:	MOVEI	T1,RSN.XN	;GET CAPACITY EXCEEDED ERROR CODE
	PJRST	UPOPJ##		;RESTORE "U" AND GIVE ERROR RETURN
SUBTTL 2.2.5        DATA REQUEST

;MCRDRQ	ROUTINE TO PROCESS A DATA REQUEST FOR A MCR.
;CALL	MOVEI	T4,"DRQ" FIELD OF THE MESSAGE (READ IN ICMDRQ)
;	MOVEI	F,LDB
;	PUSHJ	P,MCRDRQ	;(ACTUALLY MCRNDP+NDPDRQ)
;RETURN	CPOPJ			;MESSAGE BAD.
;	CPOPJ1			;DATA REQUEST ACCEPTED
;
MCRDRQ:
	NTDBUG			;VERIFY THE INTERLOCK
	PUSH	P,U		;SAVE THE PCB
	MOVEI	U,(F)		;COP THE LDB POINTER
	LDB	T2,LDPDRQ##	;GET THE CURRRENT DATA REQUEST COUNT
	ADD	T2,T4		;FORM NEW SUM
	CAILE	T2,^D256	;UNREASONABLE?
	PJRST	UPOPJ##		;YES, IGNORE THE REQUEST
	DPB	T2,LDPDRQ##	;STORE THE NEW COUNT
	MOVSI	T1,LRLTTW##	;GET AND CLEAR THE
	ANDCAM	T1,LDBREM##(U)	; WAITING BIT
	PUSHJ	P,TOREQ##	;REQUEST SERVICE ON THE LINE
	PJRST	UPOPJ1		;GIVE GOOD RETURN
SUBTTL 2.3        DAP MESSAGE PROCESSING

SUBTTL 2.3.1        DAP DISPATCH ROUTINE

;NMCDSP	ROUTINE TO SEPARATE THE NCL SUB-MESSAGES
;CALL	MOVEI	F,LDB
;	MOVE	P1,BYTE POINTER TO THE FIRST "CNT" FIELD IN THE MESSAGE
;	PUSHJ	P,NMCDSP	;DO DAP DISPATCHING
;RETURN	CPOPJ
;
NMCDSP:				;HERE FROM IDCCTL WITH A MESSAGE TO INTERPRET
	PUSH	P,U		;SAVE THE PCB
	MOVEI	U,(F)		;SET UP POINTER TO THE LDB
NMCDS1:				;LOOP FOR DISPATCHING EACH SUB-MESSAGE
	JUMPLE	P4,UPOPJ##	;EXIT IF ALL SUB-MESSAGES HAVE BEEN DONE
;CNT
	PUSHJ	P,EBI2BI##	;GET THE LENGTH OF NEXT SUB-MESSAGE
	SUB	P4,T1		;UPDATE TOTAL MESSAGE LEFT LENGTH
	SKIPGE	P4		;MAKE SURE SUB-MSG IS A REASONABLE LENGTH
	JSP	T1,NMCDS3	;++ SUB-MSG EXTENDS PAST TOTAL MESSAGE'S END
	PUSH	P,P4		;SAVE LENGTH OF REST OF TOTAL MESSAGE
	MOVEI	P4,(T1)		;COPY THE LENGTH OF THE SUB-MESSAGE
;TYP
	PUSHJ	P,EBI2BI##	;GET THE IDC TYPE FIELD
	CAIL	T1,DC.DAT	;RANGE CHECK
	CAILE	T1,DC.MAX	; THE TYPE FEILD
	PJSP	T1,NMCDS2	;BAD MESSAGE. ILLEGAL TYPE.
	PUSHJ	P,MCRNDP(T1)	;DO THE DISPATCH
	  PJSP	T1,NMCDS2	;THE DRIVER DIDN'T LIKE THE MESSAGE?
	SOJG	P4,[IBP P1	;MAKE SURE P1 POINTS AT THE NEXT "CNT" BYTE
		    JRST .]
	POP	P,P4		;GET LENGTH OF "REST" OF MESSAGE BACK
	JRST	NMCDS1		;LOOP OVER ALL SUB-MESSAGES

NMCDS2:	POP	P,T2		;POP TOTAL MESSAGE LENGTH OFF STACK
NMCDS3:	POP	P,U		;HERE IF BAD MSG, RESTORE PCB POINTER
	PJRST	INCTBD##	;  CALL INCTBD WITH T1 = ADDR OF ERROR
SUBTTL 2.3.2        DAP DATA MESSAGE (WITH AND WITH E-O-R)

;MCRDAR/MCRDAT ROUTINES TO PROCESS TERMINAL INPUT DATA.
;CALL	MOVEI	U,PCB
;	MOVEI	F,LDB
;	P1, P4 := POINTER TO THE FIRST BYTE OF DATA.
;RETURN	CPOPJ1			;ALWAYS (IT DOESN'T DETECT ANY ERRORS)
;
MCRDAR:				;DATA WITH END OF RECORD
MCRDAT:
	PUSH	P,F		;RECINT CLOBBERS F
MCRDA1:	SOJL	P4,FPOPJ1##	;ALL DONE
	ILDB	T3,P1		;GET NEXT CHARACTER
	PUSH	P,U		;SAVE THE LINE DATA BLOCK
	LDB	U,LDPLNO##	;GET LINE NUMBER (LINTAB INDEX)
	PUSHJ	P,RECINT##	;PROCESS CHARACTER
	POP	P,U		;RESTORE LDB POINTER
	JRST	MCRDA1		;AND PROCESS NEXT CHAR, IF ANY.
SUBTTL 2.3.3        DAP STATUS MESSAGE

;MCRSTS	ROUTINE TO PROCESS DAP TERMINAL STATUS MESSAGES
;CALL	MOVEI	U,PCB
;	MOVEI	F,LDB
;	P1, P4 := POINTER TO THE "STC" BYTE OF A DAP STATUS MESSAGE
;RETURN	CPOPJ			;MESSAGE'S "STC" WAS BAD
;	CPOPJ1			;MESSAGE PROCESSED OK
;
MCRSTS:
;STC
	PUSHJ	P,EBI2BI	;GET THE STATUS CODE
	JUMPN	T1,CPOPJ##	;WE ONLY ACCEPT THE "STC=0" TYPE STATUS MESSAGES
;STY
	PUSHJ	P,EBI2BI	;GET THE STATUS BITS
	DPB	T1,LDPSTS##	;STORE THE NEW STATUS BITS
	TRNN	T1,STY.DE	;IF THE REMOTE IS LOCAL ECHOING
	JRST	[		;  SEE IF WE THINK THAT'S OK
		IFE FTYORK,<PUSHJ P,MCROKE>
		IFN FTYORK,<PUSHJ P,MCROK5>
		 PUSHJ P,D85CHP	;IF HE'S NOT SUPPOSED TO, QUEUE A STATUS CHECK
		 LDB T1,LDPSTS## ;GET STATUS BITS BACK
		 JRST .+1]	;BACK TO MAIN FLOW.

;FALL THROUGH TO PLAY WITH THE MODEM-CONTROL BITS
SUBTTL 2.3.3.1        INCOMING MODEM CONTROL

MCRTIW:
IFE FTMODM,<JRST CPOPJ1>	;NO MODEM CODE TO DEAL WITH
IFN FTMODM,<
	MOVE	T2,LDBDCH##(U)	;THE UBIQUITOUS DCH BITS
	TRNN	T2,LDRDSD##	;SEE IF THIS IS A DATA SET
	JRST	CPOPJ1##	;NOT A DATA SET LINE
	MOVE	T2,LDBREM##(U)	;GET THE DATA SET BITS
	SETZ	T3,		;START OUR STATE VARIABLE WITH A ZERO
	TRNE	T1,STY.RG	;MAP REMOTE CARRIER/RING INTO
	IORI	T3,1		; BIT 35
	TRNE	T1,STY.DT	;MAP REMOTE DATA TERMINAL READY INTO
	IORI	T3,2		; BIT 34
	TLZE	U,-1		;***
	 PUSHJ	P,NTDSTP	;*** JUST FOR KICKS
	CAMN	U,DIALDB##	;IS THIS THE DIALOUT LINE?
	IORI	T3,4		;YES, DTR/CARRIER HAS DIFFERENT MEANING THEN
	PUSHJ	P,@MCRSTD(T3)	;DISPATCH ON STATE VAR
	PJRST	CPOPJ1		;AND WE ARE DONE!

MCRSTD:				;MODEM STATUS DISPATCH TABLE
	D85LST			;(I00) MAYBE NOTHING, MAYBE LOST CARRIER
	D85RNG			;(I01) THE PHONE IS RINGING.
	D85MLC			;(I10) MOMENTARY LOSS OF CARRIER?
	D85RUN			;(I11) DTR AND CARRIER - DATASET UP AND RUNNING
	D85DL0			;(O00) POSSIBLE SYNCHRONIZATION
	D85DLR			;(O01) RING - ACKNOWLEDGEMENT OF DIALOUT REQ
	D85DLX			;(O10) DTR - DIALOUT SUCCEEDED (BUT NO CARRIER)
	D85DLW			;(O11) DTR - DIALOUT SUCCEEDED, LINE IS UP
;STILL IFN FTMODM

D85LST:				;HERE TO SEE IF LOST THE PHONE
	TLNN	T2,LRLDSR	;DID WE USED TO HAVE CARRIER?
	POPJ	P,		;NO, IGNORE
	MOVEI	T3,DSTOFF##	;GET PSISER'S MODEM OFFLINE FLAG
	PUSHJ	P,DSCSG		;SIGNAL LOST CARRIER
	PUSHJ	P,RMVTTY	;DETACH THE JOB (OR WHATEVER)
	MOVSI	T1,LRLDSR##	;NOW CLEAR DSR SO WE KNOW THAT HE HAS
	ANDCAM	T1,LDBREM##(U)	;  GONE.  (KEEPS D85LST FROM RUNNING)
	POPJ	P,		;THAT'S THE END OF THAT PHONE CONVERSATION


D85RNG:				;HERE IF THE PHONE IS RINGING
	HRRZ	T1,LDBDDB(U)	;HERE SEE IF THE TERMINAL HAS BEEN OPENED.
	JUMPE	T1,CPOPJ##	; NOT, WAIT FOR THE REMOTE
	MOVEI	T3,DSTRNG##	;OTHERWISE JUST SIGNAL THE FACT
	PJRST	DSCSG		;THAT A DATASET LINE IS RINGING


D85MLC:				;HERE IF MOMENTARY LOSS OF CARRIER
	TLNN	T2,LRLDSR##	;DID WE HAVE CARRIER BEFORE?
	POPJ	P,		;NO, NOT TO WORRY THEN
	HRRZ	T1,LDBDDB##(U)	;ADDRESS OF ASSOCIATED DDB
	JUMPE	T1,CPOPJ##	;IGNORE IF NO TTY DDB
	MOVE	T2,DEVMOD(T1)	;GET DEVICE CHARACTERISTICS
	TRNN	T2,ASSPRG	;IN USE AS I/O DEVICE?
	POPJ	P,		;NO, NOBODY CARES
	MOVEI	T2,IODERR	;YES, SET THE DEVICE-ERROR FLAG
	IORM	T2,DEVIOS(T1)	;TO TELL USER THAT HIS I/O DEVICE HICCUPPED
	POPJ	P,		;OTHERWISE IGNORE MOMENTARY LOSS OF CARRIER


D85RUN:				;DTR AND CARRIER - DATASET IS UP AND RUNNING
	TLNE	T2,LRLDSR##	;WAS CARRIER UP BEFORE??
	POPJ	P,		; IF IT WAS, THEN EVERYTHING'S OK
	PUSH	P,W		;THIS LINE JUST CAME UP. SAVE W,
	PUSHJ	P,TSETBI##	; AND CLEAR THE INPUT BUFFER.
	POP	P,W		; ...
	MOVSI	T1,LRLGRT##	;THE NEED-TO-BE-GREETED FLAG
	TDNE	T1,LDBREM(U)	;IS THIS GUY LONELY?
	JRST	D85RU4		;NO, HE'S HAPPY
	IORM	T1,LDBREM(U)	;YES, SO TAKE NOTICE OF HIM
	PUSHJ	P,TTFGRT##	;"WELL HELLO THERE"
D85RU4:	MOVSI	T1,LRLDSR##	;NOW SET A BIT TO REMEMBER THAT THIS
	IORM	T1,LDBREM##(U)	;LINE THINK'S THAT IT'S UP.
	PUSHJ	P,D85CHP	;KICK THE REMOTE TO LET IT KNOW WE CARE
	MOVEI	T3,DSTON##	;AND FINALLY TELL PSISER
	PJRST	DSCSG		; THAT IT'S UP.
;STILL IFN FTMODM

D85DL0:				;HERE FOR NO DTR/CARRIER ON DIALOUT
	MOVSI	T2,LRLCHR##	;A TIMESHARED FLAG NAME HERE
	TDNN	T2,DIALFL##	;HAS REMOTE ACKNOWLEDGED THE DIALOUT REQ?
	POPJ	P,		;NO, JUST IGNORE
	MOVSI	T2,400000	;YES, THE LACK OF DTR IS DIALOUT FAILED
	IORM	T2,DIALFL##	;SET DIALOUT COMPLETION SANS SUCCESS
	POPJ	P,		;THAT'S THE END OF THAT


D85DLR:				;DIALOUT "RING" IS ACKNOWLEDGEMENT
	MOVSI	T2,LRLCHR##	;A TIMESHARED FLAG NAME
	IORM	T2,DIALFL##	;WHICH IN THIS CASE MEANS REMOTE ACK OF DIALOUT
	POPJ	P,		;WHICH IS ALWAYS NICE TO KNOW


D85DLW:				;DIALOUT DTR AND CARRIER = HAPPINESS
	MOVSI	T2,LRLDSR##	;OUR COPY OF CARRIER
	IORM	T2,LDBREM##(U)	;WE HAVE AN UP AND RUNNING DATASET LINE
D85DLX:				;DIALOUT DTR SANS CARRIER = PUZZLEMENT
	MOVSI	T2,LRLDSR##!400000  ;THE DIALOUT HAS SUCCEEDED
	IORM	T2,DIALFL##	;SET COMPLETION AVEC SUCCESS
	POPJ	P,		;LET D85CRQ WAKE UP AND FIND THE GOOD NEWS


IFN FTPI,<
DSCSG:	PUSH	P,T1
	PUSH	P,F
	LDB	T2,LDPLNO##	;PSISER WANT'S ITS ARG AS A LINE NUMBER
	PUSHJ	P,SIGDSC##	;SIGNAL DATA SET STATUS CHANGE
	POP	P,F
	JRST	TPOPJ##
> ;END IFN FTPI

IFE FTPI,<
DSCSG:	POPJ	P,		;NO PSISER
> ;END IFE FTPI
> ;END IFN FTMODM
SUBTTL 2.3.4        DAP CONTROL

;MCRCTL	ROUTINE TO PROCESS DAP TERMINAL CONTROL MESSAGES
;CALL	MOVEI	U,PCB
;	MOVEI	F,LDB
;	P1, P4 := POINTER TO THE "DCT" FIELD OF A DAP CONTROL MESSAGE
;RETURN	CPOPJ			;CONTROL TYPE NOT RECOGNIZED
;	CPOPJ1			;MESSAGE ACCEPTED

MCRCTL:				;SET LDB FIELDS AS FROM "SET TERMINAL" COMMAND.

;DCT

	PUSHJ	P,EBI2BI	;READ THE TYPE OF CONTROL
	CAIN	T1,DCT.EP	;ECHO PIPLINE
	JRST	MCREPM		;YES
	CAIN	T1,DCT.TC	;TERMINAL CHARACTERISTICS
	JRST	MCRCHR		;YES,
	JRST	CPOPJ##		;NONE OF THE ABOVE EXIT

MCREPM:				;HERE TO PROCESS AN ECHO PIPELINE MARKER

;CDT

	ILDB	T1,P1		;GET THE SERIAL NUMBER
	SUBI	P4,1		;REDUCE THE COUNT
	DPB	T1,LDPEPM##	;STORE THE PIPELINE MARKER
	MOVSI	T1,LRLEPW##	;RETURN MARKER AT ONCE
	IORM	T1,LDBREM##(U)
	PUSHJ	P,MCROKE	;OK TO ECHO (TEST THE LDB)?
	  PJRST	CPOPJ1##	;EXIT. CAN'T SEND IT NOW
	PUSHJ	P,D85CHP	;QUEUE THE REQUEST SO IT GOES QUICK
	PJRST	CPOPJ1##	;EXIT
MCRCHR:				;HERE FOR A TERMINAL CHARACTERISTICS MSG
	MOVSI	T1,LRLCHR##	;THE CHARACTERISTICS-SEEN FLAG
	TDNE	T1,LDBREM(U)	;BEEN HERE BEFORE?
	JRST	MCRCH4		;YEAH, JUST PROCESS THE NEW CHARACTERISTICS

;HERE WHEN A NEWLY-CONNECTED TERMINAL HAS SENT THE INITIAL CHARACTERISTICS

	IORB	T1,LDBREM##(U)	;MARK WE HAVE NOW RECEIVED CHARACTERISTICS
	MOVE	T2,LDBDCH##(U)	;GET GENERAL DEVICE CHARACTERISTICS
	TLNN	T1,LRLGRT##	;IF TERMINAL NEEDS TO BE GREETED
	TRNE	T2,LDRDSD##	;AND ISN'T A DATASET (D85RUN HANDLES THIS CASE)
	JRST	MCRCH4		;ALREADY GREETED, OR A DATASET
	MOVSI	T1,LRLGRT##	;THE GREETED FLAG
	IORM	T1,LDBREM##(U)	;WE ARE NOW GREETING IT
	PUSHJ	P,TTFGRT##	;"WELL HELLO THERE"

MCRCH4:	PUSHJ	P,XSKIP##	;READ
	PUSHJ	P,XSKIP##	; AND
	PUSHJ	P,XSKIP##	;  IGNORE
	PUSHJ	P,XSKIP##	;   THE
	PUSHJ	P,XSKIP##	;    FILL
	PUSHJ	P,XSKIP##	;     TIME(S)

	PUSHJ	P,EBI2BI	;GET THE RECEIVE SPEED
	MOVEI	T2,(T1)		;COPY TO T2
	PUSHJ	P,TTCSP1##	;GET THE SPEED INDEX
	CAIA			;DON'T SAVE INVALID SPEED
	DPB	P2,LDPRSP##	;STORE

	PUSHJ	P,EBI2BI	;GET THE TRANSMIT SPEED
	MOVEI	T2,(T1)		;COPY THE SPEED
	PUSHJ	P,TTCSP1##	;GET THE SPEED INDEX
	CAIA			;DON'T SAVE INVALID SPEED
	DPB	P2,LDPTSP##	;STORE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	LDB	T2,LDPRSP##	;GET THE RECEIVE SPEED BACK
	MOVEI	T1,LDR274##	;GET 2741 BIT
	CAIN	T2,(P2)		;RECEIVE AND TRANSMIT THE SAME
	CAIE	T2,LS0134##	;IS IT AN IBM 2741
	SKIPA	T2,[ANDCAM T1,LDBDCH##(U)]	;CLEAR THE BIT
	MOVE	T2,[IORM T1,LDBDCH##(U)]	;SET THE BIT
	XCT	T2		;DO IT

	PUSHJ	P,EBI2BI	;WIDTH OF TERMINAL'S CHARRIAGE
	SKIPE	T1
	...DPB	T1,LDPWID##	;STORE

	PUSHJ	P,EBI2BI	;GET THE AUTO CRLF
	SKIPE	T1
	...DPB	T1,LDPACR##	;STORE

	PUSHJ	P,EBI2BI	;READ THE ELEMENT #
	MOVE	T3,T1		;COPY TO T3
	PUSHJ	P,ELEINX##	;GET THE INDEX
	  SETZ	T2,		;ILLEGAL
	DPB	T2,LDPELE##	;STORE THE ELEMENT NUMBER

	PUSHJ	P,EBI2BI	;GET THE 2741 BITS
	MOVE	T2,LDBISR##(U)	;GET THE FLAGS
	TRNE	T1,CDT.PL	;APL
	TLOA	T2,LILAPL##	;YES, SET
	TLZ	T2,LILAPL##	;NO, CLEAR
	TRNE	T1,CDT.CB	;DEBREAK
	TLOA	T2,LILDBK##	;YES, SET
	TLZ	T2,LILDBK##	;NO, CLEAR
	TRNE	T1,CDT.TD	;TIDY MODE?
	TLOA	T2,LILTDY##	;YES, SET
	TLZ	T2,LILTDY##	;NO, CLEAR
	HLLM	T2,LDBISR##(U)	;STORE THE RESULT
	PJRST	CPOPJ1		;RESTORE PCB AND GIVE GOOD RETURN
SUBTTL 3.0      INTERFACE TO NETSER FOR OUTPUT OF DATA

SUBTTL 3.1        NETWORK CONTROL MESSAGE OUTPUT (NCL)

SUBTTL 3.1.1        OUTPUT A CONNECT MESSAGE


;MCRXCN	ROUTINE TO SEND A MCR CONNECT MESSAGE.
;CALL	MOVEI	W,NDB		;NODE THAT OWNS THE TERMINAL
;	MOVEI	U,LDB		;LDB OF MCR TO CONNECT.
;				; SLA MUST BE SET UP.  DLA = 0 IMPLIES INITIATE.
;RETURN	CPOPJ			;COULDN'T SEND. NO CORE
;	CPOPJ1			;MESSAGES GIVEN TO NCL
;
MCRXCN:				;HERE TO SEND A MCR CONNECT MESSAGE
	PUSH	P,U		;SAVE THE LDB FOR A BIT
	PUSHJ	P,NCMHDR##	;U := PCB, (P)+ := "CNT" BYTE POINTER
	  JRST	UPOPJ##		;NO CORE?  GIVE ERROR RETURN
	EXCH	U,-1(P)		;GET THE LDB BACK FOR A WHILE.
;TYP
	XMTI	NC.CNT		;THIS IS A CONNECT MESSAGE
;DLA
	XMTB	LDPDLA##	;SEND DLA (OR 0 IF CONNECT INITIATE)
;SLA
	LDB	T1,LDPSLA##	;WE MUST HAVE A LAT ASSIGNED. SO
	SKIPN	T1		; MAKE SURE THAT THE SLA IS NON-ZERO
	PUSHJ	P,NTDSTP##	;IF IT'S NOT, STOP
	XMT	T1		;WRITE THE SLA
;DPN(OBJ)
	XMTI	OBJ.TY		;WE ARE CONNECTING TO A TERMINAL
;DPN(PID)
	XMTB	LDPRLN##	; AND THIS IS HIS LINE NUMBER
;SPN(OBJ)
	XMTI	OBJ.TT		;WE ARE THE MONITOR CONTROL ROUTINE (MCR)
;SPN(PID)
	XMTS	STANAM##	; AND THIS IS OUR NAME
;MML
	XMTI	^D512		;SEND THE MAX-MESSAGE-LENGTH (BUT NO-ONE CARES)
;FEA(DCM)
	XMTI	DCM.AS		;ASCII MODE
;FEA(RLN)
	XMTI	0		;VARIABLE RECORD LENGTH
;FEA(DTY)
	XMTI	DTY.MC!DTY.AB!DTY.SB!DTY.27 ;OUR ATTRIBUTES

	EXCH	U,-1(P)		;GET THE PCB BACK
	JSP	T1,NETWRC##	;GIVE THE MESSAGE TO NCL
	PJRST	UPOPJ1##	;GIVE A GOOD RETURN
SUBTTL 3.1.2        OUTPUT A DISCONNECT MESSAGE

;TRMXDC	ROUTINE TO SEND A DISCONNECT TO A REMOTE TERMINAL.
;CALL	MOVE	T1,XWD NODE,RSN	;NODE IS NODE TO RE-CONNECT TO IF REASON
;				; IS RSN.RC (IE A SET-HOST STYLE DISCONNECT)
;	MOVEI	U,LDB
;	MOVEI	W,NDB
;	PUSHJ	P,TRMXDC
;RETURN	CPOPJ			;NO CORE.
;	CPOPJ1			;MESSAGE SENT
;
TRMXDC::			;HERE TO SEND A REMOTE TERMINAL A DISCONNECT.
	PUSH	P,T1		;SAVE THE "XWD NODE,RSN" FOR A BIT
	PUSH	P,U		;SAVE THE LDB
	PUSHJ	P,NCMHDR##	;GET A PCB, PUSH "CNT" POINTER ON STACK
	  JRST	[POP P,U	;IF NO CORE, REPLACE THE LDB,
		 JRST TPOPJ##]	; AND GIVE A BAD RETURN
	EXCH	U,-1(P)		;GET THE LDB ADDRESS BACK
;TYP
	XMTI	NC.DSC		;THIS IS A DISCONNECT MESSAGE
;DLA
	XMTB	LDPDLA##	;INSERT THE REMOTE'S LINK ADDRESS
;SLA
	XMTB	LDPSLA##	;INSERT OUR LINK ADDRESS
;RSN
	HRRZ	T1,-2(P)	;GET THE REASON
	XMT	T1		;SEND IT
;NNM
	HRRZ	T1,-2(P)	;GET THE REASON AGAIN
	CAIE	T1,RSN.RC	;IS THIS A "SET HOST" STYLE DISCONNECT?
	JRST	MCRXD1		;NO. DON'T SEND THE "NNM" BYTE
	HLRZ	T1,-2(P)	;GET THE "NNM"
	XMT	T1		; AND SEND THAT TOO

MCRXD1:	EXCH	U,-1(P)		;GET THE PCB BACK
	JSP	T1,NETWRC##	;GIVE THE MESSAGE TO NCL TO SEND
	POP	P,U		;RESTORE THE LDB
	LDB	T1,LDPSLA##	;NOW GET THE LAT ADDRESS, AND
	MOVEI	T2,LAT.DC	; CHANGE THE STATE TO BE
	DPB	T2,LATSTA##	; DISCONNECT CONFIRM WAIT.
	MOVSI	T1,LRLCON##	;GET THE "CONNECTED BIT"
	ANDCAB	T1,LDBREM##(U)	;AND CLEAR IT SO SCNMCR WON'T RUN
	JRST	TPOPJ1##	;GIVE GOOD RETURN
SUBTTL 3.2        TERMINAL OUTPUT SERVICE (SCNMCR)

				COMMENT @

There are three basic phases to the SCNMCR routine. They are:

   1)	Save and set up registers, and ensure that the terminal is connected.

   2)	Do a priority based scan looking for messages to send.  In decreasing
	priority these messages are:
	   a)	XOFF (DAP control)
	   b)	Character Gobbler (DAP control)
	   c)	Terminal Status (DAP status)  (From SCNCHP routine)
	   d)	Terminal Characteristics (DAP control)  (From SCNCHP routine)
	   e)	Terminal Data (DAP data)
	   f)	Auto Dial (DAP control)
	   g)	Terminal Echo Pipeline Marker (DAP control)

   3)	Send the message.  (Give it to NCL to send)

				    @
;SCNMCR	ROUTINE TO CONSTRUCT MCR MESSAGES.  (CALLED FROM NETSCN)
;CALL	MOVEI	U,LDB		;LDB WANTING SERVICE
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;LDB PROCESSED OK
;CLOBBERS W

SCNMCR::NTDBUG			;VERIFY THE INTERLOCK
	PUSHJ	P,SAVE4##	;SAVE THE P'S CAUSE SCNSER CALLS US.
	PUSHJ	P,MCRCHK	;MAKE SURE WE ARE STILL CONNECTED.
	  JRST	CPOPJ1		; IF NOT GIVE GOOD RETURN (SO WON'T REQUEUE)
	LDB	T1,LDPRNN##	;GET THE NODE NUMBER, AND USE IT
	PUSHJ	P,SRCNDB##	; TO SET UP W (POINTER TO THE NDB)
	  JRST	CPOPJ1##	; IF NO NDB GIVE GOOD RETURN.
	;DROP INTO SCNMC1

;COME HERE WITH U := LDB ADDRESS
;HERE IS WHERE WE SEE WHAT SORT OF SERVICE A MCR NEED'S

SCNMC1:	MOVE	T1,LDBREM##(U)	;GET THE REMOTE STATION BITS
	TLNN	T1,LRLXOF!LRLSCG ;NEED AN XOFF OR A GOBBLER?
	JRST	SCNMC2		; IF NOT, THEN CHECK THE PARMS
	TLNE	T1,LRLXOF##	;WAS IT AN XOFF WE NEEDED?
	JRST	[PUSHJ P,MCXXOF	; IF SO, THEN SEND THE XOFF, AND
		  JRST SCNMC6	; IF NO CORE, RE-QUEUE THE LINE
		 JRST SCNMC1]	; SEE IF THE MCR NEEDS OTHER SERVICE
	PUSHJ	P,MCXGBL	;IF IT WAS A GOBBLER, THEN SEND THAT,
	  JRST	SCNMC6		;IF NO CORE, RE-QUEUE THE LINE
	JRST	SCNMC1		; AND PERFORM OTHER SERVICES.

SCNMC2:	MOVE	T2,LDBBYT##(U)	;GET SCNSER'S FLAGS.
	TRNE	T2,L1RCHP##	;DOES SCNSER WANT A PARM CHANGE?
	JRST	[PUSHJ P,SCNCHP	; IF SO, THEN SEND THE CHANGE,
		  JRST SCNMC6	; IF NO CORE, REQUEUE THE LINE
		 JRST SCNMC1]	; AND PERFORM OTHER SERVICES.
	TLNE	T1,LRLTTW##	;ARE WE WAITING FOR A DATA-REQUEST?
	JRST	SCNMC4		; IF SO, THEN SKIP OUTPUT CHECK
	TLNE	T1,LRLTTO##	;DO WE ALREADY HAVE A CHAR IN LDPCHR?
	JRST	SCNMC3		;IF WE HAVE THE CHAR, DON'T CALL XMTCHR
	PUSHJ	P,XMTCHR##	;SEE IF SCNSER WILL GIVE US A CHAR
	  JRST	SCNMC4		;NO OUTPUT.  GO LOOK FOR OTHER WORK
	DPB	T3,LDPCHR##	;SAVE THE CHAR WHERE MCXDAT WILL LOOK
	MOVSI	T1,LRLTTO##	;GET THE "CHAR IN LDPCHR" BIT
	IORB	T1,LDBREM##(U)	; AND SET IT SO WE DON'T LOSE THE CHAR
SCNMC3:	PUSHJ	P,MCXDAT	; SEND THE DATA, AND
	  JRST	SCNMC6		; IF NO CORE, GET OUT NOW, OTHERWISE
	JRST	SCNMC1		; FINISH THE SERVICE

SCNMC4:	MOVE	T1,LDBREM(U)	;RELOAD T1
	TLNE	T1,LRLADR	;IS THERE AN AUTO DIAL REQUEST?
	JRST	[PUSHJ P,MCX801	; IF SO, THEN SEND THE NUMBER, AND
		  JRST SCNMC6	; IF NO CORE, RE-QUEUE THE LINE
		 JRST SCNMC1]	; CONTINUE PROCESSING
	TLNE	T1,LRLEPW	;IS ECHO PIPELINE MARKER WAITING?
	PUSHJ	P,MCROKE	;LOCAL ECHO OK NOW?
	  JRST	SCNMC5		; IF NOT, DON'T SEND EPM
	PUSHJ	P,TRXEPM	;OTHERWISE SEND THE EPM
	  JRST	SCNMC6		;NO CORE. REQUEUE THE LINE
SCNMC5:	AOS	(P)		;GIVE SKIP RETURN (WON'T REQUE THE LINE)
SCNMC6:	PUSHJ	P,TSDPCB	;FINALLY SEND THE MULTIPART MESSAGE
	POPJ	P,		; AND RETURN
;SCNCHP	ROUTINE TO DETERMINE IF TERMINAL STATUS, OR TERMINAL CHARACTERISTICS
;	MESSAGE NEEDS TO BE SENT.  ROUTINE IS CALLED FROM "SCNMCR" WHENEVER
;	SCNSER LITES THE "L1RCHP" BIT.  (THIS IS DONE BY THE "SETCHP" ROUTINE.)
;	THIS ROUTINE PERFORMS THE NECESSARY TRANSLATION FROM SCNSER'S BIT'S
;	TO NETMCR'S.
;CALL	MOVEI	U,LDB
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;WITH "L1RCHP" OFF.
;
SCNCHP:	PUSHJ	P,SAVE1##	;SAVE THE P'S
	SETZ	P1,		;LH = BITS TO SET, RH = CLEAR
IFE FTYORK,<PUSHJ P,MCROKE>	;CHECK ON ECHOING MODE
IFN FTYORK,<PUSHJ P,MCROK5>	;Check on echoing mode.
	  TLO	P1,STY.DE	; AND CLEAR DE IF WE CAN'T ECHO NOW
	MOVE	T4,LDBDCH##(U)	;CARRY THE UBIQITOUS DCH IN T4
	TLNN	T4,LDLLCT##	;"TTY LC" SET?
	TROA	P1,STY.CV	;DONT TRANSLATE
	TLO	P1,STY.CV	;TRANSLATE
	MOVEI	T2,LRRXFF##	;GET SEND-XOFF STATUS BIT
	TDNN	T2,LDBREM##(U)	;SET FOR REMOTE?
	JRST	SCNCH0		;NO, SKIP IT
	ANDCAM	T2,LDBREM##(U)	;CLEAR THE BIT
	TLNN	T4,LDLSTP##	;IS OUTPUT-STOPPED (I.E., ^S) SET IN LDBDCH?
	TROA	P1,STY.XS	;NO.
	TLO	P1,STY.XS	;YES.
SCNCH0:	TLNE	T4,LDLIMI##	;IF IMAGE MODE IS SET IN LDBDCH,
	TLOA	P1,STY.II	; TELL REMOTE TO SEND EVERYTHING
	TRO	P1,STY.II	;IF NOT, USE ASCII MODE
	MOVSI	T1,LRLIMO##	;IMAGE OUTPUT BIT
	TDNN	T1,LDBREM##(U)	;IMAGE OUTPUT?
	TROA	P1,STY.IO	;NO
	TLO	P1,STY.IO	;YES
	TLNE	T4,LDLPIM##	;IF WE ARE IN PIM MODE, THEN OVER-RIDE
	JRST	[TRZ P1,STY.II!STY.IO	; ANY OTHER IMAGE MODE DECISIONS, AND
		 TLO P1,STY.II!STY.IO	; SINCE PIM DOESN'T ALWAYS GET THE
		 JRST .+1]		; BITS RIGHT CONTINUE.

	;FALL INTO NEXT PAGE
	;FROM ABOVE

	MOVE	T1,LDBPAG##(U)	;GET PAGING CONTROL
	MOVE	T2,LDBBY2##(U)	;AND CLOSELY RELATED BITS
	TLNE	T1,LPLXNF##	;IS XON/XOFF PROCESSING ENABLED?
	TLNE	T2,L2LTAP##	;YES, BUT "TTY TAPE" OVERRIDES IT
	TROA	P1,STY.TP	;NO - CLEAR XONXOFF PROCESSING IN REMOTE.
	TLO	P1,STY.TP	;YES - SET XONXOFF PROCESSING IN REMOTE.
	TRNN	T2,L2RXON##	;CHECK "TAPE IS XON'ED" BIT
	TROA	P1,STY.TT	;NOT IN TAPE MODE
	TLO	P1,STY.TT	;IN TAPE MODE
	TLNN	T4,LDLTAB##	;IS "TTY TAB" SET IN LDBDCH?
	TROA	P1,STY.HT	;NO.
	TLO	P1,STY.HT	;YES.
	TLNN	T4,LDLFRM##	;IS "TTY FORM" SET IN LDBDCH?
	TROA	P1,STY.FF	;NO.
	TLO	P1,STY.FF	;YES.
	TLNN	T4,LDLNFC##	;IS "TTY CRLF" SET IN LDBDCH?
	TROA	P1,STY.CR	;NO.
	TLO	P1,STY.CR	;YES.
	MOVSI	T2,LRLHUR##	;THE HANG-UP PHONE BIT
	TRNE	T4,LDRDSD##	;IS THIS A DATA-SET-LINE,
	TDNN	T2,LDBREM##(U)	; WITH A HANG-UP REQUEST PENDING?
	JRST	SCNCH1		;NO CONTINUE
	TRO	P1,STY.DT+STY.RG;TELL REMOTE TO CLEAR DTR AND CARRIER
SCNCH1:	ANDCAB	T2,LDBREM##(U)	;AND NOTE REQUEST HONORED

	HLRZ	T1,P1		;GET THE BITS TO "SET"
	TRNE	T1,STY.XS	;ARE WE SETTING XOFF?
	 JRST	SCNC1A		;YES, ALWAYS SEND XOFF STATUS
	LDB	T2,LDPSTS##	;GET THE CURRENT STATUS
	ANDCM	T1,T2		;WILL ANY REALLY GET SET?
	JUMPE	T1,SCNCH2	;IF NOT, DON'T SEND A "SET BITS" MESSAGE
SCNC1A:	PUSHJ	P,MCXSST	;SET THE BITS (IN REMOTE AND LDPSTS)
	  POPJ	P,		;GIVE ERROR RETURN IF NO CORE
SCNCH2:	HRRZ	T1,P1		;GET THE BITS TO "CLEAR"
	TRNE	T1,STY.XS	;ARE WE CLEARING XOFF?
	 JRST	SCNC2A		;YES, ALWAYS SEND XOFF STATUS
	LDB	T2,LDPSTS##	;GET THE CURRENT STATUS
	IORI	T2,STY.DT!STY.RG;ALWAYS SEND REQUEST TO CLEAR DTR/CARRIER
	AND	T1,T2		;WILL ANY BITS REALLY BE CLEARED
	JUMPE	T1,SCNCH3	;IF NOT, DON'T TRY TO CLEAR THEM
SCNC2A:	PUSHJ	P,MCXCST	;CLEAR THE BITS IN REMOTE AND LDPSTS
	  POPJ	P,		;GIVE ERROR RETURN IF NO CORE

	;DROP THROUGH
	;FROM ABOVE

;NOW CHECK TO SEE IF WE MUST SEND TERMINAL CHARACTERISTICS.

SCNCH3:	MOVE	T1,LDBREM##(U)	;GET REMOTE TERMINAL BITS
	TRC	T1,LRRSHC##	;CHANGE "CAN SET HOST" INTO "DC72" BIT
	TDNN	T1,[XWD LRLCHR##,LRRSHC##] ;IF DC72 OR WE HAVE RECEIVED CHARACTERSISTICS, OK TO SEND
	JRST	SCNCH4		;OTHERWISE, DON'T SEND ONE (***SEE FOOTNOTE)
	PUSHJ	P,GETCR		;TRANSLATE SPEED ETC TO CHARACTERISTICS WORD

	CAMN	T1,LDBCCH##(U)	;ANY CHANGE?
	JRST	SCNCH4		;NO CHANGE. GIVE GOOD RETURN
	PUSHJ	P,TRXTCR	;SEND THE CHARACTERISTICS. (WILL PUT T1 IN LDBCCH)
	  POPJ	P,		;NO CORE. GIVE ERROR RETURN

SCNCH4:	MOVEI	T1,L1RCHP##	;WE'VE SUCCESSFULY SCANED THE PARAMETERS
	ANDCAB	T1,LDBBYT##(U)	;SO CLEAR REQUEST SO WE DON'T DO IT AGAIN
	JRST	CPOPJ1##	;GOOD RETURN

;GETCR	ROUTINE TO TRANSLATE THE VARIOUS "CHARACTERISTICS"  IN TO A SINGLE WORD
GETCR::	MOVSI	T1,400000	;BUILD ENCODED CHARASTICS
	LDB	T2,LDPFLC##	;GET FILL CLASS
	DPB	T2,[POINT 4,T1,35]	;BITS 35-32
	LDB	T2,LDPRSP##	;GET RECEIVE SPEED
	DPB	T2,[POINT 4,T1,31]	;BITS 31-28
	LDB	T2,LDPTSP##	;GET TRANSMIT SPEED
	DPB	T2,[POINT 4,T1,27]	;BITS 27-24
	LDB	T2,LDPWID##	;GET WIDTH
	DPB	T2,[POINT 8,T1,23]	;BITS 23-16
	LDB	T2,LDPACR##	;GET AUTO CRLF POINT
	DPB	T2,[POINT 8,T1,15]	;BITS 15-8
	LDB	T2,LDPELE##	;GET THE ELEMNET NUMBER
	DPB	T2,[POINT 4,T1,7]	;BITS 4-7
	MOVE	T2,LDBISR##(U)	;GET THE CONTROL BITS
	TLNE	T2,LILAPL##	;APL MODE
	TLO	T1,(1B3)	;YES
	TLNE	T2,LILDBK##	;DEBREAK
	TLO	T1,(1B2)	;YES
	TLNE	T2,LILTDY##	;TIDY?
	TLO	T1,(1B1)	;YES
	POPJ	P,

;*** FOOTNOTE ***

				COMMENT @

     The terminal characteristics "protocol" is laden with races.  If both
the remote and the host decide to change the characteristics at the same time,
there is no telling what may happen.  This "hack" of the LRLCHR bit is a lame
effort to minimize the effects of this race.  It avoids the case of the host
sending a characteristics message with a speed of zero baud before the remote
has had a chance to tell the host what it's speed really is.

				    @
;MCXDAT	ROUTINE TO PACKAGE CHARACTERS INTO A DATA MESSAGE.
;CALL	PUSHJ	P,MCXDAT
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;SENT DATA

MCXDAT:	NTDBUG			;VERIFY THE INTERLOCK
	LDB	T1,LDPDRQ##	;GET THE NUMBER OF OUTSTANDING DATA-REQUESTS
	JUMPE	T1,[MOVSI T1,LRLTTW## ;IF WE DON'T HAVE ANY,
		    IORB T1,LDBREM##(U) ; THEN LITE LRLTTW SO WE WON'T
		    JRST CPOPJ1##] ; CALLED UNTIL SOME COME IN.
	LDB	T3,LDPCHR##	;GET THE STORED CHAR (FOR IT'S IMAGE BIT)
	PUSHJ	P,MCXDAM	;SEE IF IT'S BIT AGREES WITH LAST STATUS MSG
	  JRST	CPOPJ1##	;NEED TO SEND STATUS MSG. RETURN TO SCNMCR
	MOVEI	T1,2		;REQUEST A 2 BYTE MESSAGE (MINIMUM...)
	PUSHJ	P,TRQPCB	;TRY TO GET THE PCB
	  PJRST	TOPOKE##	;NO CORE.  REQUEUE THE LINE AND LEAVE.
	PUSH	P,W		;RUMOR HAS IT THAT SCNSER WILL CLOBBER THIS.
;TYP
	XMTI	DC.DAT		;WE ARE SENDING A DATA MESSAGE
	MOVSI	T1,LRLTTO##	;GET THE "OUTPUT CHAR IN LDPCHR" BIT

IFN PARANOID&P$MCR,<		;IF WE'RE PARANOID, WE SHOULD MAKE SURE
	TDNN	T1,LDBREM##(U)	;BY CHECKING THE MCR-OUTPUT BIT
	PUSHJ	P,NTDSTP##	;++ WE WERE CALLED WITH NO CHAR TO OUTPUT
>
	ANDCAB	T1,LDBREM##(U)	;CLEAR THE "CHARACTER WAITING" BIT
	LDB	T3,LDPCHR##	;GET THE WAITING CHARACTER
	JRST	MCXD.2		;JUMP INTO THE MIDDLE OF THE COPY LOOP.

MCXD.1:	MOVEI	T1,L1RCHP##	;GET SCNSER'S "PARM CHANGE NEEDED" BIT
	TDNN	T1,LDBBYT##(U)	;AND SEE IF WE SHOULD SEND A STATUS MSG FIRST
	CAIL	P3,(P4)		;SEE IF WE HAVE FILLED UP THE ENTIRE MSG
	JRST	MCXD.4		;FILLED ENTIRE MESSAGE, OR PARM CHANGE NEEDED
	PUSHJ	P,XMTCHR##	;GET THE NEXT CHAR TO GO
	  JRST	MCXD.4		;NO OUTPUT READY.  CLOSE OFF MSG AND EXIT
MCXD.2:	PUSHJ	P,MCXDAM	;MAKE SURE THE IMAGE MODE BITS AGREE
	  JRST	MCXD.3		; IF NOT, STASH THE CHAR AWAY & SEND STATUS
	IDPB	T3,P2		;SEND THE CHAR
	AOJA	P3,MCXD.1	;COUNT THE CHAR AND TRY TO GET ANOTHER.
MCXD.3:	MOVSI	T1,LRLTTO##	;HERE TO GET OUT WHILE HOLDING A CHAR.
	IORB	T1,LDBREM##(U)	;SIGNIFY WE HAVE A CHAR IN LDPCHR
	DPB	T3,LDPCHR##	;STORE THE CHAR FOR NEXT TIME

MCXD.4:	POP	P,W		;GET OUR NDB POINTER BACK
	PUSHJ	P,TWRPCB	;SEND THE SUB MESSAGE
	HRRZ	T1,NTRPCB	;GET A POINTER TO OUR PCB
	MOVSI	T2,(<NCT.IT>B7)	;GET THE "INTERRUPT MESSAGE" BIT
	TDNN	T2,@PCBOAD(T1)	;SEE IF WE'VE ALREADY COUNTED THIS DRQ
	JRST	CPOPJ1##	;IF WE'VE COUNTED THE DRQ, THEN JUST LEAVE
	ANDCAB	T2,@PCBOAD(T1)	;CLEAR THE INT BIT (SO MESSAGE WILL COUNT)
	LDB	T2,LDPDRQ##	;GET THE DATA-REQUEST COUNT
	SOSGE	T2		;AND DECREMENT IT
	STOPCD	.+1,STOP,DRN,	;++ DATA REQUEST WENT NEGATIVE
	DPB	T2,LDPDRQ##	;SAVE THE UPDATED DRQ COUNT
	JRST	CPOPJ1##	;GIVE A GOOD RETURN
;MCXDAM	ROUTINE TO CHECK THE STATE OF THE IMAGE-OUTPUT BITS
;	USED ONLY BY MCXDAT
;CALL	T3 := CHAR (WITH 400 BIT ON/OFF)
;	J  := LDB
;RETURN	NONSKIP			;MODES ARE DIFFERENT
;	SKIP			;MODES ARE THE SAME
;PRESERVES T3
MCXDAM:	SETZ	T1,		;START WITH A ZERO
	TRNE	T3,400		;IS THE "IMAGE MODE CHAR" BIT SET?
	TRC	T1,1		;IF AN IMAGE MODE CHAR, THEN T1 := 1
	MOVSI	T2,LRLIMO##	;GET THE IMAGE MODE OUTPUT BIT
	TDNE	T2,LDBREM##(U)	;SEE IF WE ARE IN IMAGE OUTPUT MODE
	TRC	T1,1		;IF WE ARE IN IMAGE MODE OUTPUT, COMPLEMENT T1
	JUMPE	T1,CPOPJ1##	;GIVE GOOD RETURN IF MODES ARE OK
	XORM	T2,LDBREM##(U)	;FLIP THE STATE OF THE LRLIMO
	PUSH	P,T3		;PRESERVE THE CHAR FOR A BIT
	PUSHJ	P,SETCHP##	;TELL SCNMCR TO SEND A STATUS MSG
	POP	P,T3		;GET THE CHAR BACK
	POPJ	P,		; AND GIVE AN ERROR RETURN
SUBTTL 3.2.2        OUTPUT DAP STATUS MESSAGE

;MCXSST/MCXCST ROUTINES TO SET AND CLEAR STATUS BITS
;CALL	MOVEI	T1,BITS		;TO BE CLEARED OR SET
;	PUSHJ	P,MCXSST/MCXCST
;	CPOPJ			;NO CORE
;	CPOPJ1			;MESSAGE SENT,  BITS SET/CLEARED IN LDPSTS

MCXSTA::MOVEI	T2,0		;SEND STATUS
	JRST	MCXST1		;GO TO COMMON CODE
MCXSST:	SKIPA	T2,[1]		;SET STATUS
MCXCST:	MOVEI	T2,2		;CLEAR STATUS
MCXST1:	PUSH	P,T1		;SAVE STD
	PUSH	P,T2		;SAVE STC
	MOVEI	T1,4		;WE WANT A 4 BYTE SUBMESSAGE
	PUSHJ	P,TRQPCB	; SET UP P3 & MUNG THE STACK
	  JRST	[POP P,(P)	;NO CORE. GIVE ERROR RETURN
		 JRST TPOPJ##]	; AND HOPE WE GET IT OUT LATER
	MOVEI	T1,DC.STS	;GET STATUS MESSAGE CODE
	PUSHJ	P,BI2EBI	;WRITE
;STC
	MOVE	T1,-1(P)	;GET THE STC
	PUSHJ	P,BI2EBI	;WRITE
;STD
	MOVE	T1,-2(P)	;GET THE STD
	PUSHJ	P,BI2EBI	;WRITE
;CNT
	PUSHJ	P,TWRPCB	;STORE BACK P3 & FIXUP THE STACK
	POP	P,T3		;GET THE STC BACK (1 = SET, 2 = CLEAR)
	POP	P,T2		;GET THE STD BACK (BITS TO SET/CLEAR)
	JUMPE	T3,CPOPJ1##	;IF SEND STATUS, DONT UPDATE STATUS
	LDB	T1,LDPSTS	;GET THE UN-UPDATED STATUS
	CAIN	T3,1		;WAS CODE SET OR CLEAR?
	TROA	T1,(T2)		;IS WAS SET. SET THE BITS
	TRZ	T1,(T2)		;IT WAS CLEAR.  CLEAR THE BITS
	DPB	T1,LDPSTS	;STORE THE UPDATED STATUS
	JRST	CPOPJ1##	;GOOD RETURN
SUBTTL 3.2.3        OUTPUT DAP CONTROL MESSAGE

SUBTTL 3.2.3.1        ECHO PIPELINE MARKER MESSAGE

;TRXEPM ROUTINE TO SEND AN ECHO PIPE LINE MARKER
;CALL	MOVEI	U,LDB
;	PUSHJ	P,TRXEPM
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;MESSAGE SENT

TRXEPM::
	MOVEI	T1,4		;REQUEST A 4 BYTE SUBMESSAGE
	PUSHJ	P,TRQPCB	; AND SET UP P3 AND STACK
	  POPJ	P,		;NO CORE, ERROR RETURN
;TYP
	MOVEI	T1,DC.CTL	;CONTROL MESSAGE
	PUSHJ	P,BI2EBI##	;SEND

;DCT
	MOVEI	T1,DCT.EP	;PIPE LINE MARKER FLAG
	PUSHJ	P,BI2EBI	;SEND

;CDT
	LDB	T1,LDPEPM##	;GET THE PIPE LINE MARKER
	PUSHJ	P,DPBBIN##	;SEND
;CNT

	MOVSI	T1,LRLEPW##	;EPM NO LONGER WAITING
	ANDCAM	T1,LDBREM##(U)	;CLEAR
	PUSHJ	P,TWRPCB	;STORE BACK P3 AND FIXUP STACK
	JRST	CPOPJ1##	;GOOD RETURN
SUBTTL 3.2.3.2        CHARACTER GOBBLER MESSAGE

;MCXGBL ROUTINE TO SEND A CHARACTER GOBBLER
;CALL	MOVEI	U,LDB
;	PUSHJ P,MCXGBL
;RETURN	CPOPJ		;MESSAGE SENT

MCXGBL:			;ENTRY
	MOVEI	T1,2		;REQUEST A 2 BYTE SUBMESSAGE
	PUSHJ	P,TRQPCB	; SET UP P3 AND STACK
	  POPJ	P,		;NO CORE, GIVE ERROR RETURN
;TYP
	MOVEI	T1,DC.CTL	;TELETYPE CONTROL MESSAGE
	PUSHJ	P,BI2EBI	;SEND
;DCT
	MOVEI	T1,DCT.CG	;CHARACTER GOBLER CODE
	PUSHJ	P,BI2EBI	;SEND
	MOVSI	T1,LRLSCG##	;CHARACTER GOBBLER BIT
	ANDCAM	T1,LDBREM##(U)	;CLEAR IT
;CNT
	PUSHJ	P,TWRPCB	;WRITE BACK P3 AND FIXUP STACK
	JRST	CPOPJ1##	;GIVE GOOD RETURN
SUBTTL 3.2.3.3        TERMINAL CHARACTERISTICS MESSAGE

;TRXTCR ROUTINE TO SEND TERMINAL CHARACTERISTICS MESSAGE.
;CALL	MOVEI	U,LDB
;	MOVE	T1,NEW-CHARACTERISTICS (WILL BE PUT IN LDBCCH IF SUCCESSFUL)
;	PUSHJ	P,TRXTCR
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;CHARACTERISTICS SENT

TRXTCR::PUSHJ	P,SAVE1##	;WE WANT TO USE P1 FOR A TEMP
	MOVE	P1,T1		;SAVE CHARACTERISTICS TO SEND

	MOVEI	T1,27		;REQUEST A LARGE SUBMESSAGE
	PUSHJ	P,TRQPCB	; AND SET UP P3 AND STACK
	  POPJ	P,		;NO CORE. GIVE AN ERROR RETURN
;TYP
	MOVEI	T1,DC.CTL	;SET UP CONTROL MESSAGE
	PUSHJ	P,BI2EBI	;WRITE
;DCT
	MOVEI	T1,DCT.TC	;TELETYPE CHARASTICS
	PUSHJ	P,BI2EBI	;WRITE
;CDT
	PUSH	P,P1			;SAVE "P1" OVER THIS LOOP
	LDB	T1,[POINT 2,P1,35]	;FILL CLASS
	MOVE	P1,FILTAB(T1)	;GET POINTER TO CONSTANTS
	MOVEI	T4,6		;COUNTER
MCRTC1:	ILDB	T1,P1		;GET FILL VALUE
	LDB	T2,[POINT 4,(P),27]	;XMIT SPEED
	MOVE	T2,LSPTAB##(T2)	;GET SPEED VALUE
	SKIPN	T2		;PRESENT?
	MOVEI	T2,^D110	;NO, ASSUME 110 BAUD.
	MOVEI	T3,^D10000	;COMPUTE BAUD RATE FACTOR
	CAIN	T2,^D110	;110 BAUD?
	MOVEI	T3,^D11000	;YES, ASSUME 11-UNIT CODE
	IMUL	T1,T3		;MULTIPLY BY FACTOR
	IDIV	T1,T2		;COMPUTE WAIT TIME IN MS.
	PUSHJ	P,BI2EBI	;WRITE
	SOJG	T4,MCRTC1	;DO FOR ALL SIX TIMES
	POP	P,P1		;GET OUR CHARACTERISTICS BACK
	LDB	T1,[POINT 4,P1,31]
	MOVE	T1,LSPTAB##(T1)	;GET RECEIVE SPEED
	PUSHJ	P,BI2EBI	;WRITE
	LDB	T1,[POINT 4,P1,27]
	MOVE	T1,LSPTAB##(T1)	;GET TRANSMIT SPEED
	PUSHJ	P,BI2EBI	;WRITE
	LDB	T1,[POINT 8,P1,23]
	PUSHJ	P,BI2EBI	;WRITE
	LDB	T1,[POINT 8,P1,15]
	PUSHJ	P,BI2EBI	;WRITE
	LDB	T1,LDPELE##	;ELEMENT NUMBER NOT IMPLEMENTED
	MOVE	T1,ELETAB##(T1)	;GET THE VALUE FROM THE TABLE
	PUSHJ	P,BI2EBI	;WRITE
	MOVEI	T1,0		;IBM 2741 BITS
	MOVE	T2,P1		;GET THE 2741 BITS
	TLNE	T2,(1B3)	;APL MODE
	TRO	T1,CDT.PL	;YES, SET THE BIT
	TLNE	T2,(1B2)	;DEBREAK FEATURE
	TRO	T1,CDT.CB	;YES, SET THE BIT
	TLNE	T2,(1B1)	;TIDY?
	TRO	T1,CDT.TD	;YES
	PUSHJ	P,BI2EBI	;WRITE
	PUSHJ	P,TWRPCB	;WRITE BACK P3
	MOVEM	P1,LDBCCH(U)	;STORE THE NEW CHARACTERISTICS
	JRST	CPOPJ1##	;GIVE A GOOD RETURN
SUBTTL 3.2.3.4        AUTO DIAL MESSAGE

;MCX801 ROUTINE TO SEND A AUTO DIAL MESSAGE TO THE REMOTE DN80
;CALL	MOVEI	U,LDB
;	PUSHJ	P,MCX801
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;ALWAYS (WE CHECKED FOR CORE)

MCX801:				;ENTRY
	MOVEI	T1,30		;REQUEST A 24 BYTE SUBMESSAGE
	PUSHJ	P,TRQPCB	; AND SET UP P3 AND STACK
	  POPJ	P,		;GIVE ERROR RETURN IF NO CORE
;TYP
	MOVEI	T1,DC.CTL	;CONTROL MESSAGE
	PUSHJ	P,BI2EBI	;SEND
;DCT
	MOVEI	T1,DCT.AD	;AUTO DIAL CODE
	PUSHJ	P,BI2EBI	;SEND
;CDT
	MOVE	T4,[POINT 4,DIALNM##]	;GET THE POINTER TO THE PHONE NUMBER
MCX802:	ILDB	T1,T4		;GET A DIGIT
	ADDI	T1,"0"+200	;MAKE EXTENSIBLE ASCII
	IDPB	T1,P2		;STORE IN THE MESSAGE
	CAIE	T1,17+"0"+200	;IS IT THE END
	AOJA	P3,MCX802	;COUNT THE CHARACTER
	ADDI	P3,1		;COUNT THE LAST BYTE
	TRZ	T1,200		;CLEAR THE CONTINUE BIT
	DPB	T1,P2		;RESTORE IT
	MOVE	U,DIALDB##	;GET THE LDB FOR THE DIAL
	MOVSI	T1,LRLADR##	;GET THE AUTO DIAL BIT
	ANDCAM	T1,LDBREM##(U)	;CLEAR THE REQUEST
	MOVEM	T1,DIALFL##	;NOTE DIALOUT REQUEST PROCESSED
				; WAITING FOR REMOTE TO ACKNOWLEDGE
				;   RING = ACKNOWLEDGEMENT OF DIALOUT REQ, THEN
				;      DTR ASSERTED = SUCCESS, OR
				;      DTR CLEARED  = FAILURE
;CNT
	PUSHJ	P,TWRPCB	;WRITE BACK P3 AND FIXUP STACK
	JRST	CPOPJ1##	;GIVE SUCCESSFUL RETURN
SUBTTL 3.2.3.5        XOFF MESSAGE

;MCXXOF ROUTINE TO ASK THE REMOTE TO XOFF A USER
;CALL	MOVEI	U,LDB
;	PUSHJ	P,MCXXOF
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;XOFF MESSAGE SENT SUCCESSFULY


MCXXOF:
	MOVEI	T1,2		;GET A 2 BYTE SUBMESSAGE
	PUSHJ	P,TRQPCB	; AND SET UP P3 AND STACK
	  POPJ	P,		;GIVE ERROR RETURN IF NO CORE
;TYP
	MOVEI	T1,DC.CTL	;TERMINAL CONTROL MSG
	PUSHJ	P,BI2EBI	;SEND THAT TOO
;DCT
	MOVEI	T1,DCT.XF	;XOFF REQUEST
	PUSHJ	P,BI2EBI	;SEND THAT
	MOVSI	T1,LRLXOF##	;GET AND CLEAR THE BIT
	ANDCAM	T1,LDBREM##(U)	; SO WE DON'T DO IT AGAIN
;CNT
	PUSHJ	P,TWRPCB	;WRITE BACK P3 AND FIXUP STACK
	JRST	CPOPJ1##	; AND GIVE A GOOD RETURN
SUBTTL 3.3        OUTPUT PCB MANIPULATION

;THE FOLLOWING FOUR ROUTINES ARE USED FOR HANDLING TERMINAL PCB'S.  THE
; REASON THAT THEY ARE SO COMPLEX IS TO MAKE IT EASY TO SEND
; MULTI-PART MESSAGES.
;
;TRQPCB	REQUEST A TERMINAL PCB.
;CALL	PUSHJ	P,TRQPCB
;ARGS	T1 := MINIMUM NUMBER OF BYTES REQUIRED (LESS COUNT FIELD)
;RET	CPOPJ	;COULD NOT GET THE PCB.  "U" NOT SET UP.
;	CPOPJ1	;DID GET THE PCB. THE FOLLOWING HAS BEEN DONE:
;		;  A)	P2 := BYTE POINTER (TO IDPB WITH)
;		;  B)	P3 := ZERO (USE TO COUNT BYTES)
;		;  C)	P4 := MAX NUMBER OF BYTES LEFT IN THIS
;		;	      SUB MESSAGE. (IE. TO END OF PCB)
;		;  D)	A "PUSH P,P2" HAS BEEN DONE. (IE THIS
;		;	ROUTINE HAS LEFT A COPY OF P2 ON THE STACK)
;		;	THIS IS TO MAKE IT EASY TO FILL IN THE
;		;	COUNT FIELD LATER.  TWRPCB MUST BE CALLED
;		;	TO PERFORM THIS ACTION. (CANNOT BE CALLED WITH
;		;	A ZERO COUNT)
;
;TWRPCB	WRITE BACK THE PCBOAD AND PCBOCT FIELDS AND POP OLD BYTE
;	POINTER OFF OF THE STACK
;CALL	PUSHJ	P,TSRPCB
;RET	CPOPJ
;
;TSDPCB	SEND THE CURRENT PCB. (QUEUE IT FOR OUTPUT)
;CALL	PUSHJ	P,TSDPCB
;RET	CPOPJ	;NTRPCB WILL BE CLEARED TO INDICATE PCB WAS SENT.
SUBTTL 3.3.1        REQUEST AN OUTPUT PCB

;TRQPCB	GET A TERINAL PCB
;	T1 := MINIMUM NUMBER OF BYTES
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;PCB ACQUIRED SUCCESSFULY

TRQPCB::SKIPLE	T1		;WE DON'T ALLOW NEGATIVE REQUESTS
	CAIL	T1,NTTPLN##*4-7	;HERE MAKE SURE HE ASKED FOR A REASONABLE AMT.
	STOPCD	.,STOP,RTM,	;++REQUESTED TOO MUCH.
	PUSH	P,T1		;REMEMBER THIS FOR LATER
	PUSH	P,U		;SAVE THE LDB (WILL SWAP FOR PCB LATER)
	HRRZ	U,NTRPCB	;NOW GET CURRENT PCB (IF ANY)
	SKIPE	U		; IF THERE WAS ONE, THEN
	JRST	[HRRZ P3,PCBOCT(U) ; SET UP THE COUNT AND SKIP THE CODE THAT
		 JRST TRQP.2]	   ; TRIES TO ALLOCATE A NEW PCB
TRQP.1:	MOVEI	T1,NTTPLN##	;GET LENGTH OF A TERMINAL PCB
	SETZ	F,		;MAKE SURE MAKPCB DOESN'T HACK ANY DDB
	PUSHJ	P,MKNPCB##	; AND GO GET A NEW PCB.
	  JRST	[POP P,U	;NO CORE. RESTORE THE LDB
		 JRST TPOPJ##]	; AND GIVE AN ERROR RETURN
	HRRM	U,NTRPCB	;NOW STORE THE FACT WE HAVE A PCB.
	MOVE	P2,PCBOAD(U)	; AND SET UP THE INITIAL BYTE POINTER
	MOVEI	T1,NCT.IT	;GET THE NCT BITS
	PUSHJ	P,NCSWHD##	;WRITE THE NCL HEADER.
	SETZ	P3,		;NOW WRITE OUR DLA.  TO DO THIS WE MUST
	EXCH	U,(P)		; GET BACK OUR LDB,
	LDB	T1,LDPDLA##	; USE IT TO EXTRACT OUR DESTINATION LINK,
	PUSHJ	P,BI2EBI	; AND THIS WILL WRITE IT OUT.
	EXCH	U,(P)		;NOW GET BACK THE PCB POINTER,
	ADDB	P3,PCBOCT(U)	; UPDATE THE POINTERS, AND DROP INTO MAIN FLOW

TRQP.2:	MOVEI	P4,NTTPLN##*4	;HERE WE MUST CALCULATE TO SEE IF THE CURRENT
	SUBI	P4,1(P3)	; PCB WILL HOLD AS MUCH AS OUR CALLER
	CAMGE	P4,-1(P)	; REQUESTED IT SHOULD.  IF IT CAN'T, THEN
	JRST	[PUSHJ P,TSDPCB	; SEND THIS PCB OUT, AND
		 JRST TRQP.1]	; START ON A NEW ONE.
	POP	P,U		;RESTORE THE LDB
	POP	P,T1		; THE REQUEST (WHICH WE CAN NOW IGNORE)
	POP	P,T1		; AND POP OFF OUR RETURN ADDRESS.
	PUSH	P,P2		;NOW SAVE A BYTE POINTER TO COUNT FIELD
	IBP	P2		; AND MAKE POINTER POINT TO THE TYP FIELD
	SETZ	P3,		;SET THE INITIAL COUNT TO ZERO.
	JRST	1(T1)		;ALL DONE.  RETURN TO CALLER.
				; (WITH UNESTHETIC GARBAGE ON THE STACK ...)
SUBTTL 3.3.2        CLOSE OFF A DAP SUB-MESSAGE

;TWRCPB	THIS ROUTINE WRITES BACK THE COUNT FIELD AND UPDATES THE POINTER
;	IN THE PCB.  IT ALSO REMOVES UNESTHETIC GARBAGE FROM THE STACK
;CALL	PUSHJ	P,TWRPCB
;RETURN	CPOPJ		;WITH ONE LESS WORD ON THE STACK

TWRPCB::SKIPG	P3		;IF NO-ONE WROTE ANYTHING, THEN COMPLAIN
	STOPCD	.,STOP,NWA,	;++NO-ONE WROTE ANYTHING?
	PUSH	P,U		;SAVE THE LDB, AND
	HRRZ	U,NTRPCB	; GET BACK A POINTER TO THE PCB
	SKIPE	U		;HERE JUST MAKE A LITTLE CHECK ON U'S VALIDITY
	CAILE	P3,(P4)		; AND MAKE SURE NO ONE WROTE TOO FAR
	STOPCD	.,STOP,SNS,	;++NTRPCB NOT SETUP??
	ADDM	P3,PCBOCT(U)	;NOW UPDATE THE COUNT AND
	AOS	PCBOCT(U)	; DON'T FORGET ABOUT THE 'COUNT' BYTE
	POP	P,U		;RESTORE THE LDB,
	POP	P,T1		; GET OUR RETURN ADDRESS,
	POP	P,T2		; AND GET BACK THE POINTER TO THE COUNT FIELD.
	IDPB	P3,T2		;STORE THE COUNT,
	JRST	(T1)		; AND RETURN
SUBTTL 3.3.3        SEND A COMPLETED NCL MESSAGE

;TSDPCB	SEND A PCB OUT.  THIS NUMBERS AND SENDS THE CURRENT PCB.
;CALL	PUSHJ	P,TSDPCB
;RETURN	CPOPJ			;ALWAYS

TSDPCB::PUSH	P,U		;SAVE THE LDB (OR WHATEVER)
	HRRZ	U,NTRPCB	;GET THE PCB POINTER
	JUMPE	U,UPOPJ		; BUT RETURN QUICK IF THERE ISN'T ONE
	PUSHJ	P,NETWRT##	;ASSIGN MESSAGE NUMBERS AND SEND THE MESSAGE
	HLLZS	NTRPCB		;CLEAR POINTER TO PCB
	JRST	UPOPJ		; AND RETURN
SUBTTL 4.0      UTILITY ROUTINES AND INTERFACE TO UUOCON
SUBTTL 4.1        PARSE THE NCL CONNECT MESSAGE FOR A TERMINAL


;TTYRPN	ROUTINE TO READ THE "SPN" FIELD OF A CONNECT AND LOOK FOR OPR TERMINALS.
;CALL	MOVEI	U,LDB		;OF TTY BEING CONNECTED
;	P1, P4 POINT TO THE "SPN" FIELD OF THE CONNECT (OBJ AND PID)
;RETURN	CPOPJ			;WITH NDBOPR SET IF THIS WAS TERMINAL #0
;
TTYRPN:				;HERE TO READ THE "SPN" ON A MCR CONNECT
;SPN(OBJ)
	PUSHJ	P,EBI2BI##	;GET THE OBJECT TYPE
	CAIE	T1,OBJ.TY	;SEE IF IT'S A TERMINAL.
	PJRST	XSKIP##		;DON'T LET TASKS BECOME "OPR'S"
;SPN(PID)
	PUSHJ	P,EBI2BI##	;READ THE LINE NUMBER
	DPB	T1,LDPRLN##	;SAVE IT FOR POSTERITY
	CAIN	T1,0		;IS IT THE OPR'S LINE
	HRRM	U,NDBOPR(W)	;IF SO, REMEMBER THIS LDB
	POPJ	P,
;TTYRAT	ROUTINE TO READ THE "ATTRIBUTES" FROM A TERMINAL'S CONNECT MESSAGE
;CALL	MOVEI	U,LDB		;TERMINAL TO READ ATTRIBUTES FOR
;	P1, P4 POINT TO THE "MML" BYTE OF THE CONNECT MESSAGE (AFTER DPN)
;RETURN	CPOPJ			;AFTER SETTING/CLEARING THE PROPER BITS IN LDB
;				; AND FORCING A "GREETING"
;
TTYRAT:				;HERE TO READ ATTRIBUTES OF A CONNECT

;MML
	PUSHJ	P,XSKIP##	;SO FAR WE IGNORE MAX-MESSAGE-LENGTH...

;FEA(DCM)

	PUSHJ	P,XSKIP##	;WE KNOW MORE ABOUT THE MODES THAN THE REMOTE...

;FEA(RLN)

	PUSHJ	P,XSKIP##	;WE ASSUME A VARIABLE RECORD LENGTH

;FEA(DVT)=DTY

	PUSHJ	P,EBI2BI##	;READ THE ATTRIBUTES
	MOVE	T2,[XWD LRLADL##!LRLATO##!LRLDSR##,LRRSHC##]
	ANDCAM	T2,LDBREM##(U)	;CLEAR ALL "ATTRIBUTE" TYPE BITS
	MOVEI	T2,LDRDSD##!LDR274##	;DATASET, 2741 LINE FLAGS
	ANDCAM	T2,LDBDCH##(U)	;CLEAR OTHER "ATTRIBUTE" TYPE BITS
	MOVEI	T3,APCHWD##	;ASSUME A HARDWIRED LINE

;FIRST, THE DCH ATTRIBUTES

	TRNE	T1,DTY.MC	;MODEM CONTROL ON THIS LINE
	SKIPA	T3,[APCDSD##]	;YES--GET DATASET APC CODE
	TDZA	T2,T2		;NOT A DATASET
	MOVEI	T2,LDRDSD##	;MARK TTY AS A DATASET TTY
	TRNE	T1,DTY.27	;IBM 2741?
	TRO	T2,LDR274##	;YES, SET THE BIT
	IORM	T2,LDBDCH##(U)	;SET APPROPRIATE DCH ATTRIBUTES/CHARACTERISTICS

;SECOND, THE REM ATTIBUTES

	TRNE	T1,DTY.AD	;AUTO DIAL LINE (BELL 801)
	SKIPA	T3,[APCADL##]	;YES--GET DIALOUT APC CODE
	TDZA	T2,T2		;NOT AUTO DIAL
	MOVSI	T2,LRLADL##	;FLAG AS DIALOUT CAPABLE
	TRNE	T1,DTY.AB	;AUTO BAUD LINE
	TLO	T2,LRLATO##	;YES, SET THE BIT
	TRNE	T1,DTY.SH	;CAN THIS LINE DO "SET HOST"
	TRO	T2,LRRSHC##	;IF SO, THEN ENABLE THE COMMAND
	IORB	T2,LDBREM##(U)	;SET APPROPRIATE REM ATTRIBUTES
	DPB	T3,LDPAPC##	;SET ASYNC PORT CHARACTERISTIC

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;FEA(DVU)

	PUSHJ	P,EBI2BI	;GET THE "UNIT" TYPE
	CAILE   T1,APCMAX##	;APC CODE OUT OF RANGE
	MOVEI	T1,APCHWD##	;YES--ASSUME A HARD WIRED LINE
	CAIE	T1,APCUNK##	;UNKNOWN?
	DPB	T1,LDPAPC##	;NO--STORE APC FOR CURIOUS PROGRAMS

;FEA(DVV)

	PUSHJ	P,EBI2BI	;GET THE "CONTROLLER" TYPE
				; AND PITCH IT TOO

;ALL DONE WITH TTY "ATTRIBUTES"

	PJRST	SETCHP##	;MAKE SURE WE SEND STATUS SOON
SUBTTL 4.2        MANIPULATE LDB'S

;MCRCHK	ROUTINE TO ENSURE THAT A LDB IS USABLE
;CALL	MOVEI	U,LDB
;	PUSHJ	P,MCRCHK
;RETURN	CPOPJ			;LDB NOT CONNECTED, (OR WORSE...)
;	CPOPJ1			;LOOKS OK AS FAR AS I CAN TELL ...
;
MCRCHK::
	MOVE	T1,LDBREM##(U)	;GET THE REMOTE BITS
	TLNN	T1,LRLCON##	;IS THIS LDB "CONNECTED"
	POPJ	P,		;IF NOT, DON'T USE IT (ERROR RETURN)
	LDB	T2,LDPLNO##	;YES, GET PHYSICAL LINE NO.
	SUBI	T2,NETOFS##	;RELOCATE TO A REMOTE LINE
	JUMPL	T2,CPOPJ##	;NOR IN RANGE
	CAIG	T2,M.RMCR##	;CHECK LENGTH
	AOS	(P)		;OK
	POPJ	P,		;NO ERROR

;MCROKE	ROUTINE TO TEST THE LDB AND SKIP RETURN IF LOCAL
;  ECHOING SHOULD BE ALLOWED.
;LDB ADDRESS IN U.
;
IFE FTYORK,<			;*** Rethink this routine.
MCROKE:	MOVE	T1,LDBREM##(U)	;GET REMOTE STATION BITS
	TLNE	T1,LRLTTW##!LRLTTO##	;THIS TERMINAL WAITING?
	POPJ	P,		; THEN DONT SEND EPM.
	MOVE	T1,LDBBY2##(U)	;NO, GET MISC. TERMINAL BITS
	SKIPL	LDBBKM##(U)	;IN USER DEFINED BREAK SET MODE
	TLNE	T1,L2LDEL##	;NO, ARE WE IN RUBOUT SEQUENCE?
	POPJ	P,		;YES, DONT RETURN EPM.
	SKIPGE	T1,LDBDCH##(U)	;GET STATUS BITS, SKIP IF OUTPUT ACTIVE
	TLNE	T1,LDLNEC##!LDLLCP##!LDLBKA##!LDLIMI##	;PROGRAM CONTROL?
	POPJ	P,		;YES
	MOVE	T1,LDBBYT##(U)	;GET THE DEFERED ECHO BITS
	TRNE	T1,L1RDEM##	;IF NOT DEFERED ECHO,
	TRNE	T1,L1RDEL##	; OR IF WAITING FOR A LINE
	AOS	(P)		; THEN OK
	POPJ	P,		;FAIL IF NOT WAITING FOR A LINE
>;End IFE FTYORK
IFN FTYORK,<
MCROKE:	LDB	T1,LDPRNN##	;Get the terminals node number.
	CAIN	T1,41		;*KLUDGE* is it JANUS?
	 JRST	MCROK5		; Yes.
	MOVE	T1,LDBREM##(U)	;GET REMOTE STATION BITS
	TLNE	T1,LRLTTW##!LRLTTO##	;THIS TERMINAL WAITING?
	 POPJ	P,		; THEN DONT SEND EPM.
	SKIPLE	T1,LDBDCH##(U)	;OUTPUT IDLE?
	 POPJ	P,		;NO, DON'T RETURN EPM

MCROK5:	MOVE	T1,LDBDCH##(U)	;GET STATUS BITS
	TLNE	T1,LDLNEC##!LDLLCP##!LDLBKA##!LDLIMI##	;PROGRAM CONTROL?
	POPJ	P,		;YES
	MOVE	T1,LDBBY2##(U)	;NO, GET MISC. TERMINAL BITS
	TLNE	T1,L2LDEL##	;NO, ARE WE IN RUBOUT SEQUENCE?
	POPJ	P,		;YES, DONT RETURN EPM.
	MOVE	T1,LDBBYT##(U)	;GET THE DEFERED ECHO BITS
	TRNE	T1,L1RDEM##	;IF NOT DEFERED ECHO,
	TRNE	T1,L1RDEL##	; OR IF WAITING FOR A LINE
	AOS	(P)		; THEN OK
	POPJ	P,		;FAIL IF NOT WAITING FOR A LINE
>;End IFN FTYORK
;TRM.UP	ROUTINE TO DECLARE AN LDB AS "ON LINE".
;CALL	MOVEI	U,LDB		;WITH DLA, SLA SET UP
;	PUSHJ	P,TRM.UP
;RETURN	CPOPJ			;WITH LDB READY TO MASH BITS
;
TRM.UP::			;HERE TO DECLARE A LDB UP
	LDB	T1,LDPSLA##	;GET OUR LAT ADDRESS
	MOVEI	T2,LAT.OK	; AND SET OUR STATE
	DPB	T2,LATSTA##	; TO BE "OK"
	MOVSI	T1,LRLCON##	;GET THE "CONNECTED" BIT
	IORB	T1,LDBREM##(U)	; AND SET IT.  LDB IS OFFICIALLY "ON LINE"
	MOVSI	T1,L1LOFL##	;SCNSER OFF-LINE BIT
	ANDCAM	T1,LDBOFL##(U)	;CLEAR NOW, IRMA WON"T BE AROUND FOR AWHILE
	POPJ	P,


;GETLDB ROUTINE TO SEARCH FOR A FREE DDB/LDB
;CALL	PUSHJ	P,GETLDB
;RETURN	CPOPJ			;NO TERMINALS FREE
;	CPOPJ1			;FOUND A FREE LDB/DDB U=LDB
;
GETLDB::			;ENTRY
	MOVE	T4,NETRTY##	;GET THE POINTER TO THE REMOTE LDBs
GETLD1:	MOVE	U,LINTAB##(T4)	;GET THE LDB POINTER
	MOVEI	T1,LDRREM##	;GET REMOTE TERMINAL BIT
	TDNN	T1,LDBDCH##(U)	;IS THIS A REMOTE LINE
	JRST	GETLD9		;NO SKIP THE LINE
	LDB	T1,LDPRNN##	;GET THE REMOTE NODE NUMBER
	JUMPN	T1,GETLD9	;ALREADY ASSIGNED
	MOVE	T1,LDBDDB##(U)	;IF THERE IS AN ATTACHED DDB
	TRNN	T1,-1		;SKIP IF THERE IS ALREADY
	TLNE	T1,LDBCMF##	;  AN LDB OR FORCED COMMAND
	JRST	GETLD9		;THEN THIS LDB IS NOT AVAILABLE
	SETZM	LDBREM##+1(U)	;CLEAR THE BLOCK
	SETZM	LDBREM##+2(U)	;..
	SETZM	LDBREM##+3(U)	;..
	SETZM	LDBREM##+4(U)	;..
	SETZM	LDBPBK##(U)	;CLEAR THE PIM BREAK SET TOO!
	SKIPE	W		;IF NO NDB SET UP (NETLDR FRCUUO) USE ZERO
	HLRZ	T1,NDBNNM(W)	;GET THE NODE NUMBER
	DPB	T1,LDPRNN##	; AND ASSIGN TO THIS STATION
	PUSH	P,T4		;SAVE THE LINTAB INDEX
	MOVSI	T1,777740	;CLEAR THE BAUD SPEED AND FLAGS
	ANDCAM	T1,LDBISR##(U)	;IN THE LDB
	HRL	U,(P)		;PUT THE PHYSICAL -10 LINE IN THE LEFT

	SETO	T1,		;WE CAN RUN ON ANY CPU.  USE -1 FOR NOW
;	MOVE	T1,.CPCPN##	;CPU NUMBER
	DPB	T1,LDPCPU##	;IN LDB

	PJRST	TPOPJ1##	;EXIT U=LDB

GETLD9:	AOBJN	T4,GETLD1	;CONTINUE
	POPJ	P,		;ALL DONE
;NMCWAK	ROUTINE TO TRY TO WAKE A JOB WAITING FOR A TERMINAL CONNECT.
;CALL	MOVEI	U,LDB
;	PUSHJ	P,NMCWAK
;RETURN	CPOPJ			;ALWAYS.
;
NMCWAK:	LDB	T1,LDPJOB##	;GET THE NUMBER OF JOB WAITING
	SKIPE	T1		;IF NONE, DON'T WAKE JOB ZERO
	PUSHJ	P,EWAKE##	;WAKE THE JOB
	SETZ	T1,		;GET A ZERO,
	DPB	T1,LDPJOB##	;  AND CLEAR THE JOB NUMBER FIELD
	POPJ	P,		;ALL DONE


;CLRTTY	ROUTINE TO FREE THE LAT ASSOCIATED WITH A TERMINAL, AND RETURN THE LDB
;CALL	MOVEI	U,LDB
;	PUSHJ	P,CLRTTY
;RETURN	CPOPJ
;
CLRTTY::NTDBUG
	LDB	T1,LDPSLA##	;WERE WE CONNECTED?
	JUMPE	T1,CLRTY1	;NO, DON'T TOUCH NDBOPR OR NETLAT
	SETZM	NETLAT##(T1)	;CLEAR THE POINTER
	LDB	T2,LDPRLN##	;GET THE REMOVE LINE NUMBER
	JUMPN	T2,CLRTY1	;JUMP IF THIS IS NOT AN OPR LINE
	LDB	T1,LDPRNN##	;GET THE NUMBER OF THE NODE
	PUSHJ	P,SRCNDB##	;GET "W" POINTING TO THE NDB
	  CAIA			;IF NODE GONE, THEN DON'T BLAST MEMORY
	HLLZS	NDBOPR(W)	;CLEAR THE OPR POINTER
CLRTY1:
	SETZB	T1,T2		;GET SEQUENTIAL ZEROS
	DMOVEM	T1,LDBREM##(U)	;CLEAR THE FIRST TWO WORDS
	DMOVEM	T1,LDBREM##+2(U);CLEAR THE THIRD AND FOURTH
	MOVEM	T1,LDBREM##+4(U);CLEAR THE LAST
	MOVEI	T1,APCUNK##	;GET UNKNOWN STATUS CODE
	DPB	T1,LDPAPC##	;SET ASYNC PORT CHARACTERISTIC
	POPJ	P,		;RETURN
;RMVTTY ROUTINE TO DETACH A TERMINAL FROM THE JOB
;CALL	MOVEI	U,LDB
;	PUSHJ	P,RMVTTY
;RETURN	CPOPJ

RMVTTY::
	PUSHJ	P,SAVT##	;SAVE THE TEMP
	PUSHJ	P,SAVJW		;SAVE F,W
	PUSH	P,F		;SAVE F
	HRRZ	F,LDBDDB##(U)	;GET THE DDB
	JUMPE	F,RMVTT3	;EXIT IF NO DDB
	LDB	J,PJOBN##	;GET THE JOB NUMBER
	MOVE	T1,DEVMOD(F)	;CHARACTERISTICS
	TLNE	T1,TTYATC	;CONSOLE TERMINAL?
	JRST	RMVTT1		;YES, DETACH IT
	MOVEI	S,IOIMPM!IODERR!IODTER!IOBKTL	;ERROR BITS
	IORB	S,DEVIOS(F)	;LITE THEM FOR THE OWNER OF THIS TERMINAL
	MOVEI	T1,IONND%	;"NETWORK NODE DOWN"
	DPB	T1,PDVESE##	;
	JRST	RMVTT2		;DON'T DETACH TERMINAL USED AS AN I/O DEVICE
RMVTT1:	MOVEI	T1,TTFCXD##	;NOW FORCE A
	PUSHJ	P,TTFORC##	;.BYE COMMAND
RMVTT2:
IFN FTPI,<
	PUSHJ	P,PSIDWN##	;SIGNAL DEVICE DOWN
>
RMVTT3:	PUSHJ	P,TSETBO##	;THROW AWAY STUFF IN CHUNKS
	JRST	FPOPJ##		;EXIT
SUBTTL 4.3        CONNECT TO REMOTE TERMINALS

;MCRCNT	ROUTINE TO SEND A CONNECT TO A REMOTE TERMINAL.
;CALL	MOVE	T1,[XWD NODE#,LINE#]
;	PUSHJ	P,MCRCNT
;RETURN	CPOPJ			;CONNECT REJECTED,  NO CORE, NO LDB'S, ...
;	CPOPJ1			;CONNECTED.  U := LDB THAT WAS USED.
;NOTE!	THIS ROUTINE WILL SEND A CONNECT EVEN IF THE TERMINAL IS ALREADY
;	CONNECTED.  USE ASGTTY IF YOU JUST WAN'T THE LINE.

MCRCNT::			;HERE TO TRY TO CONNECT A TERMINAL
	PUSHJ	P,SAVE3##	;WE CLOBBER THESE WHEN SENDING THE MESSAGE
	PUSHJ	P,SAVJW##	;THESE WHEN WE LOOK AT THE NDB
	PUSH	P,T1		;SAVE THE ARGUMENT FOR LATER.
	HLRZ	T1,T1		;GET THE NODE NUMBER
	PUSHJ	P,SRCNDB##	; AND TRY TO FIND THE NDB.
	  JRST	TPOPJ##		; GIVE ERROR RETURN IF NO NDB
	PUSHJ	P,GETLDB	;GO GET A FREE LDB. (SET UP U)
	  JRST	TPOPJ##		; GIVE ERROR RETURN IF NONE AVAILABLE
	PUSHJ	P,LDBCLR##	;GET SCNSER TO CLEAR NEW LDB
	MOVEI	T1,(U)		;COPY THE LDB POINTER FOR GETSLA
	TLO	T1,LAT.TY!LAT.CC ;SET "TERMINAL" AND CONNECT CONFIRM WAIT
	PUSHJ	P,GETSLA##	;TRY TO ASSIGN AN SLA
	  JRST	MCRCN3		; NO LUCK.  CLEAN UP AND FAIL
	DPB	T1,LDPSLA##	;REMEMBER THE LAT ADDRESS
	HRRZ	T1,(P)		;GET THE NUMBER OF THE LINE TO CONNECT TO
	DPB	T1,LDPRLN##	; AND SAVE IT SO THAT MCRXCN CAN SEND IT

	SKIPN	J,.CPJOB##	;LOAD OUR JOB NUMBER
	PUSHJ	P,NTDSTP##	;BETTER NOT BE ZERO
	DPB	J,LDPJOB##	;STORE OUR JOB NUMBER (FOR NMCWAK)
	PUSHJ	P,MCRXCN	;ATTEMPT TO SEND A CONNECT.
	  JRST	MCRCN3		;NO CORE.  CLEAN UP AND RETURN
;HERE TO WAIT FOR A CONNECT CONFIRM/REJECT.

MCRCN2:	MOVE	J,.CPJOB##	;GET OUR JOB NUMBER BACK
	MOVEI	T1,EV.NTC	;GET THE TERMINAL CONNECT EVENT WAIT CODE
	PUSHJ	P,[NTSAVE	;RETURN THE "NT" RESOURCE, AND SLEEP
		   JRST ESLEEP##] ;  TILL REJECT/CONFIRM COMES
	LDB	T1,LDPSLA##	;WE WOKE UP.  SEE IF LAT STILL ASSIGNED
	JUMPE	T1,MCRCN3	;IF LAT HAS BEEN CLEARED, CONNECT WAS REJECTED.
	LDB	T2,LATSTA##	;SEE WHAT STATE WE'RE IN
	CAIN	T2,LAT.OK	;IF WE'RE "OK" THEN CONNECT SUCCEEDED
	JRST	TPOPJ1##	;  AND THEN WE CAN GIVE GOOD RETURN
	CAIN	T2,LAT.DC	;IT IS POSSIBLE FOR SOMEONE TO DISCONNECT
	JRST	TPOPJ##		;  THE TERMINAL WE JUST CONNECTED BEFORE WE
				;  WAKE UP.  IF SOME ONE DID SNEAK IN,
				;  JUST GIVE UP GRACEFULLY.

IFN PARANOID&P$LAT,<

	CAIE	T2,LAT.CC	;THE ONLY OTHER LEGAL STATE IS CONFIRM WAIT
	PUSHJ	P,NTDSTP##	;STOP IF WE ARE CONFUSED
>
	JRST	MCRCN2		;LOOP UNTIL CONNECT/DISCONNECT COMES IN

MCRCN3:	PUSHJ	P,CLRTTY	;FREE THE LAT AND THE LDB
	PJRST	TPOPJ##		;CLEAN THE STACK AND GIVE FAILURE RETURN
SUBTTL 4.4        INTERFACE TO ASSIGN COMMAND

;ASGTTY	ROUTINE TO HELP THE ASSIGN FUNCTION OF THE NETWORK ASSIGN COMMNADS
;CALL	MOVE	T1,[XWD NODE#,LINE#]
;	PUSHJ	P,ASGTTY
;RETURN	CPOPJ			;TERMINAL NOT AVAILABLE
;	CPOPJ1			;T1 := SIXBIT /TTYNNN/
;NOTE:	THIS ROUTINE SENDS A CONNECT IF NECESSARY.
;	THIS ROUTINE ALSO PRESERVS M & U

ASGTTY::PUSH	P,U		;SAVE THE LDB IN CASE COMCON CALLED
	PUSH	P,T1		;SAVE THE "XWD NODE,LINE"
	PUSH	P,M		;SAVE M OVER CALL TO SCREWY GTXTN
	TLO	M,400000	;SET SIGN BIT TO PROPERLY CONFUSE GTXTN
	PUSHJ	P,GTXTN##	;SEE IF LINE IS ALREADY CONNECTED.
	  JRST	ASGTT1		;IF NOT. THEN GO TRY TO CONNECT IT
	POP	P,M		;IT IS CONNECTED. T1 := 'TTYNNN'
	POP	P,(P)		;CLEAN UP THE STACK
	JRST	UPOPJ1##	;AND GIVE A GOOD RETURN

ASGTT1:	POP	P,M		;WE WON'T CLOBBER M NOW
	POP	P,T1		;GET OUR ARGUMENTS BACK
	PUSHJ	P,MCRCNT	;TRY TO CONNECT THE TERMINAL
	  JRST	UPOPJ##		;FAILURE... GIVE BAD RETURN
	LDB	T1,LDPLNO##	;GET THE LINE NUMBER
	PUSHJ	P,CVTSBT##	;CONVERT IT TO SIXBIT
	HLRZ	T1,T1		;PUT IT IN THE RIGHT HALV
	HRLI	T1,'TTY'	;PUT IN THE GENERIC "TTY"
	JRST	UPOPJ1##	;GIVE A GOOD RETURN
SUBTTL 4.5        DISCONNECT/RECONNECT TERMINALS (SET HOST)

HOST.U::PUSHJ	P,TTYFNU##	;SET UP U & F
	JUMPE	U,CPOPJ##	;0 IN U IS AN ERROR TO US
	MOVE	T1,JBTLIM##(J)	;Get some flags.
	TLNE	T1,(JB.LBT)	;Is this a batch job?
	 POPJ	P,		; Yes, can't set host.
	HRR	M,T2		;GET THE LOCATION OF THE ARGUMENT
	PUSHJ	P,GETWDU##	;GET THE NODE NUMBER
	PUSHJ	P,SAVE4##	;SAVE THE P'S
	NETDBJ			;INTERLOCK THE REST OF THIS
	PUSHJ	P,SRCNDB##	;GO FIND THE NODE
	  POPJ	P,		;IF NO NODE, GIVE THE ERROR RETURN
	CAIN	W,NETNDB##	;SEE IF HE'S TRYING TO SET HOST HERE
	RETSKP			;  IF SO, JUST GIVE A GOOD RETURN
	LDB	T1,NETCNF##	;SEE IF THE NODE HAS A MCR
	JUMPE	T1,CPOPJ##	;  IF NO MCR, DON'T LET HIM SET HOST
	MOVE	T1,LDBDCH##(U)	;GET THE CHARACTERISTS
	TRNN	T1,LDRREM##	;IF THIS IS A LOCAL TERMINAL
	PJRST	VTMHST##	;  CALL NETVTM TO DO THE WORK
	MOVE	T1,LDBREM##(U)	;GET THE REMOTE BITS, AND MAKE
	TRNN	T1,LRRSHC##	;  MAKE SURE THIS STATION ISN'T A 72
	POPJ	P,		;GIVE ERROR IF STATION DOESN'T ALLOW SET HOST
	PJRST	HOSTDT		;GO DETACH THE GUY AND DO THE SET HOST
HOST.A::
	MOVE	T2,JBTLIM##(J)	;Get some flags.
	TLNE	T2,(JB.LBT)	;Skip if not a batch job.
	 JRST[	MOVEI	T1,[ASCIZ "BATCH jobs cannot be switched by SET HOST."]
		PJRST	ERRMES##] ;...since BATCON would be confused.
	MOVE	S,T1		;SAVE NAME
	JSP	T2,SAVCTX##	;RUN THE REST OF THIS AS A JOB
	MOVE	T1,S		;RESTORE NAME
	NETDBJ			;GET THE NETSER INTERLOCK
	PUSHJ	P,SRCNDB##	;LOOKUP UP THE NDB
	  JRST	[MOVE T1,NRTUNN## ;GET THE "NO SUCH NODE" ERROR MSG
		 PJRST ERRMES##];  AND GO PRINT IT
	CAIN	W,NETNDB##	;SEE IF IT'S SET HOST SELF
	JRST	[MOVEI T1,[ASCIZ /% Already at node /]
		PUSHJ P,CONMES## ;PRINT THE FIRST PART
		  PUSHJ P,TYPNOD## ;PRINT THE NODE NAME
		PJRST PCRLF##]	;FINISH OFF THE MESSAGE AND EXIT
ifn stupid&ftcimp,<		;Hooligan!
	hlrz	t1,ndbnnm(w)	;Get target node number.
	sojn	t1,okey.a	;Allow all non-1 nodes.
	move	t1,ldbdch##(u)
	trnn	t1,ldrimp##	;Telnetted in?
	 jrst	okey.a		; Nope, say OK.
	ldb	t1,ldplno##	;Yes, ger line number.
	skipn	t1,ityofs##(t1)	;Get IMP DDB pointer.
	 jrst	okey.a		; None, well...
	move	t1,RmtAdr(t1)	;Get source address.
	xor	t1,ipaddr##	;Allow nodes on our own class-C net.
	trz	t1,377
	jumpe	t1,okey.a
	movei	t1,[asciz "No paying account."]
	jrst	errmess		;Bam!
okey.a:

>;ifn stupid&ftcimp

	LDB	T1,NETCNF##	;SEE IF THE NODE HAS A MCR
	JUMPE	T1,[MOVEI T1,[ASCIZ /Node does not support remote terminals./]
		    PJRST ERRMES##] ;PRINT THE ERROR
	MOVE	T1,LDBDCH##(U)	;GET THE CHARACTERISTICS AGAIN
	TRNN	T1,LDRREM##	;IF THIS IS A LOCAL (NOT REMOTE) TERMINAL
	PJRST	VTMHST##	;  CALL NETVTM TO DO THE WORK
	MOVE	T1,LDBREM##(U)	;GET THE REMOTE BITS, AND
	TRNN	T1,LRRSHC##	;  SEE IF THIS STATION HAS SET HOST CAPABILITY
	JRST	[MOVEI T1,[ASCIZ /Your station does not support SET HOST./]
		PJRST ERRMES##];PRINT THE MESSAGE AND EXIT

HOSTDT:	PUSHJ	P,TSETBI##	;CLEAR OUT THE INPUT BUFFER
	PUSHJ	P,TSETBO##	; AND THE OUTPUT BUFFER
	MOVE	T1,LDBREM##(U)	;NOW, SINCE I CAN'T SEEM TO FATHOM THE
	TLNN	T1,LRLCON	; OBSCURITIES OF SAVCTX, MAKE SURE WE ARE
	POPJ	P,		; STILL "CONNECTED".  (SHOULDN'T HAPPEN BUT)
	MOVEI	P4,RSN.RC	;BUILD THE ARGUMENTS FOR TRMXDC
	HLL	P4,NDBNNM(W)	;ARG IS "XWD NODE,REASON" REASON = RECONNECT
	LDB	T1,LDPRNN##	;GET THE NODE NUMBER OF THIS TERMINALS STATION
	PUSHJ	P,SRCNDB##	;FIND HIS NDB SO WE CAN SEND HIM A DISCONNECT
	  PUSHJ	P,NTDSTP##	;++ THE INTERLOCK SHOULD PREVENT THIS...
	MOVE	T1,P4		;GET THE ARGUMENT WE JUST CONSTRUCTED
	PJRST	TRMXDC		;  AND GO SEND THE DISCONNECT/RECONNECT
SUBTTL 4.6        TIMING LOGIC FOR THE AUTO-DISCONNECT FEATURE

;NMCSEC	ROUTINE TO DO DISCONNECT TIMING FOR NETWORK LINES.
;  THIS ROUTINE DISCONNECTS (AND HANG'S UP) ANY LINE THAT HAS BEEN
;  "IDLE" FOR MORE THAN "IDLMAX" SECONDS.  "IDLE" IS DEFINED AS
;  NOT POSSESSING A DDB, AND NOT PROCESSING A COMMAND.
;CALLED	FROM NETSER ONCE/SECOND

NMCSEC::SKIPE	[IDLSEC##]	;SKIP IF NO DISCONNECT TIMER
	SOSLE	MCRTMR		;HAVE WE COUNTED DOWN OUR "DIVISOR" YET?
	POPJ	P,		;NOT TIME TO DO A SCAN OF THE LDB'S
	MOVEI	T1,IDLQTM##	;GET THE "QUANTUM" IDLE TIMER TIME
	MOVEM	T1,MCRTMR	;AND RESET THE TIMER
	PUSH	P,P4		;WE USE P4 FOR AN AOBJN POINTER TO THE LDB'S
	MOVE	P4,NETRTY##	;GET AOBJN POINTER TO NETWORK TERMINALS'S
NMCSE1:	HRRZ	U,LINTAB##(P4)	;GET ADDRESS OF NEXT LDB TO CHECK.
	MOVEI	T1,LDRREM##	;BIT INDICATING REMOTE LINE
	TDNN	T1,LDBDCH##(U)	;OWNED BY ANF?
	JRST	NMCSE6		;NO, LEAVE IT ALONE.
	SKIPE	T2,LDBREM##(U)	;GET THE REMOTE'S ATTRIBUTES/ET AL
	TLNN	T2,LRLCON##	;STILL CONNECTED?
	JRST	NMCSE8		;DUD TTY, SKIP IT
	HRRZ	T1,LDBDDB##(U)	;CHECK TO SEE IF THIS LINE HAS A DDB
	JUMPN	T1,NMCSE6	;IF IT HAS A DDB, RESET THE TIMER
	MOVE	T1,LDBDCH##(U)	;GET TTY CHARACTERISTICS
	TRNN	T1,LDRDSD##	;IS THIS A DATASET TTY?
	JRST	NMCSE2		;NO
	TLNN	T2,LRLDSR##	;IS DATASET STILL RUNNING (DTR/CARRIER)?
	JRST	NMCSE4		;NO, DISCONNECT HIM NOW
NMCSE2:	LDB	T3,LDPADT##	;GET THE TIMER VALUE
	CAIGE	T3,IDLMAX##	;HAS THIS GUY BEEN IDLE TOO LONG?
	AOJA	T3,NMCSE7	;IF NOT, BUMP HIS TIMER AND GO DO NEXT LDB
	TRNN	T2,LRRSHC##	;DON'T DISCONNECT IF HE CAN'T RE-CONNECT
	JRST	NMCSE6		;CLEAR IT'S TIMER AND GO TO NEXT LDB
	TRNE	T1,LDRDSD##	;IF THIS IS NOT A DATA-SET LINE, OR
	TLNN	T2,LRLDSR##	;  THE PHONE HAS BEEN HUNG UP.
	JRST	NMCSE4		;THEN WE CAN DISCONNECT HIM RIGHT NOW.
	PUSHJ	P,D85OFF	;GET SCNCHP TO SEND A "HANGUP" MESSAGE.
	 JFCL			;HMMM...
	JRST	NMCSE8		;ADVANCE TO NEXT LDB

NMCSE4:	LDB	T1,LDPRNN##	;GET NUMBER OF NODE THAT OWNS THIS TERMINAL
	PUSHJ	P,SRCNDB##	;USE IT TO SET UP W AS A POINTER TO THE NDB
	  PUSHJ	P,NTDSTP##	;?? MCRNWD SHOULD HAVE DISCONNECTED US...??
	MOVEI	T1,RSN.OK	;NO PARTICULAR REASON FOR THE DISCONNECT.
	PUSHJ	P,TRMXDC	;SEND THE DISCONNECT MESSAGE. CLEAR LRLCON
	  JFCL			;NO CORE. WE'LL TRY LATER.
NMCSE6:	SETZ	T3,		;CLEAR THE TIMER
NMCSE7:	DPB	T3,LDPADT##	;STORE THE UPDATED TIMER
NMCSE8:	AOBJN	P4,NMCSE1	;LOOP OVER ALL REMOTE TERMINALS
	POP	P,P4		;RESTORE P4
	POPJ	P,		;ALL DONE.  BACK TO NETSCN
	SUBTTL	4.7	  ONCE/JIFFY PROCESSING

;MCRJIF	ROUTINE TO START NETWORK TERMINALS
;CALL	PUSHJ	P,MCRJIF
;RET	CPOPJ

MCRJIF::MOVEI	T1,NETRTQ##	;GET THE QUEUE HEADER
	PUSHJ	P,TOTAKE##	;GET U := TERMINAL NEEDING SERVICE
	  POPJ	P,		;IF NONE, THEN ALL DONE
	PUSHJ	P,SCNMCR	;SEE WHAT MESSAGES NEED BE SENT
	  PJRST	TOPOKE##	;IF NO CORE, RE-QUEUE THIS LDB AND EXIT
	JRST	MCRJIF		;GO SEE IF ANY MORE TERMINALS TO START
SUBTTL 4.8        TABLES

;TABLES FOR FILL.  THE TABLE ENTRIES ARE FOR BS, TAB, LF, VT,
;  FF AND CR FROM LEFT TO RIGHT, AND FILL 0-3 FROM TOP
;  TO BOTTOM.  THE VALUE OF THE ENTRY IS THE NUMBER OF FILL
;  CHARACTERS.  THIS IS CONVERTED TO MILLISECONDS BY DIVIDING
;  BY THE TRANSMIT SPEED OVER 1000.  SOMEDAY MAYBE THE USER
;  WILL BE ABLE TO SET THE TIMES DIRECTLY, BUT THIS METHOD
;  IS USED NOW FOR COMPATABLILTY WITH LOCAL FILLING, WHICH SENDS
;  RUBOUTS INSTEAD OF USING TIMEING.

FILTAB:	POINT	6,[BYTE (6) 0,0,0,0,00,0]	;CLASS 0
	POINT	6,[BYTE (6) 2,2,2,2,14,2]	;CLASS 1
	POINT	6,[BYTE (6) 6,0,6,6,25,4]	;CLASS 2
	POINT	6,[BYTE (6) 6,2,6,6,25,4]	;CLASS 3

SUBTTL 4.8        VARIABLES

	$LOW

MCRTMR:	EXP	0		;QUANTUM TIMER FOR TERMINAL AUTO-DISCONNECT.
NTRPCB:	EXP	0		;CELL THAT CONTAINS A POINTER TO THE CURRENT
				; PCB IN USE WHEN CONSTRUCTING A "MCR" MSG.
				; BECAUSE ALL THIS CODE RUNS UNDER THE NETSER
				; INTERLOCK WE CAN USE A GLOBAL CELL WITH OUT
				; FEAR OF RACES.

	$HIGH

	XLIST			;DON'T LIST THE LITERALS
	$LIT
	LIST
NMCEND::PRGEND
TITLE	NETVTM - VIRTUAL TERMINAL ROUTINES VERSION 001
SUBTTL	NETVTM -- MAT/	21-FEB-79
	SEARCH	F,S,NETPRM
	$RELOC
	$HIGH
;This software is furnished under a license and may only be used
;  or copied in accordance with the terms of such license.
;
; Copyright (C) 1979 By Digital Equipment Corp., Maynard, Ma.

xp	vnetvtm,002	;version number in Glob and Loader Map

NETVTM::ENTRY NETVTM
;VTMREC	ROUTINE TO PROCESS LOCALLY INPUT CHARS THAT ARE DESTINED FOR
;	A REMOTE MCR.
;CALL	U  := POINTER TO THE LDB OF THE "VTM" LINE
;	T3 := THE CHAR
;RETURN	CPOPJ			;ALWAYS
VTMREC::MOVE	T2,LDBREM##(U)	;GET THE REMOTE STATUS BITS
	TLNN	T2,LRLCON##	;MAKE SURE WE'RE CONNECTED
	JRST	[PUSHJ P,PCRLF##;GIVE THE USER A HINT AS TO HOW HE'S SCREWED
		 MOVEI T1,[ASCIZ /Waiting for connect confirm./]
		 PJRST CONMES##];  IF THE CONNECT IS NOT COMPLETE
	TLNE	T2,LRLDIP##	;IF A DISCONNECT IS IN PROGRESS,
	JRST	[PUSHJ P,PCRLF##;TELL THE TYPIST THAT HIS CHARACTER IS LOST
		 MOVEI T1,[ASCIZ /Waiting for disconnect confirm./]
		 PJRST CONMES##];  AND WAIT TILL THE CONFIRM FINALLY COMES IN

;MAKE SURE WE HAVE THE RESOURCES (CHUNKS) TO HANDLE THIS CHARACTER.

	MOVE	T2,LDBTIC##(U)	;GET THE NUMBER OF CHARS IN THE INPUT BUFFER.
				;  (DON'T BOTHER WITH COUNT IN LDBECC)
	CAIG	T2,^D150	;IF MORE THAN THIS ARBITRARY NUMBER,
	SKIPG	TTFREN##	;  OR THERE ARE NO MORE CHUNKS,
	JRST	[MOVE T2,FLPBEL## ;THEN DING THE USER'S BELL TO TELL
		 PJRST SETXNP##];  THE USER HIS CHARACTER WAS DESTROYED
	CAIL	T2,^D100	;IF MORE THAN THIS ARBITRARY NUMBER,
	PUSHJ	P,SNDXOF##	;  THEN TELL THE USER'S MACHINE TO STOP

;CHECK FOR ^S

	MOVE	T2,LDBREM##(U)	;GET THE DAP STATUS BITS
	MOVEI	T1,(T3)		;GET A COPY OF THE CHARACTER
	ANDI	T1,177		; AND IGNORE THE PARITY BIT
	TRNN	T2,STY.TP	;IF WE'RE NOT IN "TERMINAL PAGE" MODE
	JRST	VTMRE1		;  DON'T STOP OUTPUT.
	CAIE	T1,"S"-100	;IF IT'S NOT A ^S,
	JRST	VTMRE0		;  THEN CHECK FOR ^Q
	MOVSI	T1,LDLSTP##	;GET SCNSER'S BIT MEANING THE SAME THING,
	IORM	T1,LDBDCH##(U)	;  AND SET IT SO OUTPUT WILL STOP.
	JRST	VTMRE3		;GO SHIP THE ^S TO THE REMOTE MCR.
;CHECK FOR ^Q

VTMRE0:	CAIE	T1,"Q"-100	;IF IT'S NOT A ^Q,
	JRST	VTMRE1		;  THEN KEEP GOING
	MOVSI	T1,LDLSTP##	;GET SCNSER'S BIT MEANING THE SAME THING
	ANDCAM	T1,LDBDCH##(U)	;  AND CLEAR IT SO OUTPUT WILL START.
	PUSHJ	P,SETCHP##	;  AND START OUTPUT
	JRST	VTMRE3		;GO SHIP THE ^Q TO THE REMOTE MCR

;SEE IF IMAGE INPUT MODE.  IF NOT, DO AUTO-CRLF, ^S AND CASE CONVERSION

VTMRE1:	TRNE	T2,STY.II	;  AND SEE IF WE'RE IN IMAGE INPUT.
	JRST	VTMRE3		;  IF IMAGE INPUT, SKIP THE NEXT FEW CHECKS.

	ANDI	T3,177		;NOT IMAGE MODE, SO GET RID OF PARITY BIT
	JUMPE	T3,CPOPJ##	;THROW AWAY ANY NULL CHARACTERS.
;CHECK FOR CASE CONVERSION

	TRNN	T2,STY.CV	;SEE IF CASE CONVERSION IS ENABLED
	JRST	VTMRE2		;IF NOT ENABLED, DON'T DO IT.
	CAIL	T3,140		;RANGE CHECK THE CHARACTER
	CAIL	T3,175		;  TO SEE IF IT SHOULD BE CONVERTED
	JRST	VTMRE2		;IF NOT A LOWER CASE CHAR, DON'T CONVERT IT
	TRZ	T3,40		;MAKE UPPER CASE LOWER CASE
	JRST	VTMRE3		;SKIP NEXT CHECK SINCE CHAR ISN'T A SPACE

;NOW DO AUTO-CRLF CHECK.

VTMRE2:	CAIE	T3,40		;IS THE CHAR A SPACE?
	JRST	VTMRE3		;  IF NOT, DON'T CONVERT IT TO A CR.
	LDB	T4,LDPACR##	;GET THE "AUTO-CRLF" POSITION
	JUMPE	T4,VTMRE3	;  IF AUTO-CRLF NOT ENABLED, CHECK NO FARTHER
	PUSHJ	P,HPOS##	;GET OUR CURRENT HORIZONTAL POSITION.
	CAIL	T2,(T4)		;  AND IF WE'RE PAST THE "AUTO-CRLF" LOCATION
	MOVEI	T3,15		;  THEN PRETEND THE USER TYPE "CR" NOT SPACE.
;ALL LOCAL CHARACTER PROCESSING IS DONE (EXCEPT POSSIBLY ECHO).  NOW
;  IT'S TIME TO SHIP THE CHARACTER TO THE REMOTE MCR.

VTMRE3:	SCNOFF			;IN PREPARATION FOR TICKLING CHUNK CHAINS
	MOVE	T2,LDBREM##(U)	;GET THE DAP STATUS ONCE AGAIN
	TRNE	T2,STY.DE	;  AND SEE IF WE'RE IN DEFERED (MCR) ECHO
	JRST	[PUSHJ P,VTMSTI	;  IF DEFERED ECHO, FIRST STORE THE CHARACTER
		 LDB T1,LDPEPM##;GET THE OLD ECHO PIPELINE SERIAL
		 AOS T1		;  AND MAKE A NEW ONE
		 DPB T1,LDPEPM##;STORE NEW ONE SO MARKER FROM HOST WON'T MATCH
		 SCNON		;INTERRUPTS OK NOW.
		 PJRST VTMENQ]	;QUEUE THE LINE SO THE DATA GETS SENT TO MCR.

;HERE IF WE'RE IN LOCAL ECHO.  NOW CHECK TO SEE IF THERE IS ANY REASON
;  FOR GOING INTO DEFERED ECHO.

	CAIG	T3,176		;SEE IF THIS CHARACTER IS
	CAIGE	T3,40		;  IN THE RANGE OF BREAK CHARACTERS
	JRST	[CAIE T3,11	;  OR IF IT IS THE "NON BREAK" TAB
		 JRST VTMRE4	;IF IT'S A BREAK GO ENTER DEFERED ECHO
		 JRST .+1]	;NON-BREAK TAB. STAY IN LOCAL ECHO
	PUSHJ	P,VTMSTE	;GO STORE THE CHARACTER AS "ECHOED"
	PUSHJ	P,VTMSTO	;ECHO THE CHARACTER BY PUTTING IN OUTPUT STREAM
	SCNON			;INTERRUPTS OK NOW.
	PUSHJ	P,TOPOKE##	;START THE OUTPUT GOING.
	MOVE	T1,LDBECC##(U)	;GET THE COUNT OF ECHOED CHARACTERS
	CAIL	T1,^D72		;  AND IF MORE THAN 30 WAITING TO GO,
	PUSHJ	P,VTMENQ	;  THEN QUEUE THE LINE FOR SERVICE.
	POPJ	P,		;RETURN.  CHAR HAS BEEN STORED AND ECHOED.


;HERE WHEN WE RECEIVE A BREAK CHARACTER WHILE WE ARE IN LOCAL ECHO MODE.
;  WE MUST STORE THE CHARACTER, ENTER DEFERED ECHO MODE, AND QUEUE
;  THE LINE SO THE DATA GETS SHIPPED TO THE MCR.  NOTE THAT "CR" IS
;  SPECIAL IN THAT IT IS THE ONLY BREAK CHARACTER THAT IS ECHOED LOCALLY.
;  THIS IMPROVES THE "FEEL" OF THE NETWORK AND GIVES AN ILLUSION OF
;  GREAT SPEED.

VTMRE4:	CAIE	T3,15		;WAS THIS A "CR"
	JRST	VTMRE5		;  IF NOT, DON'T DO THE FANCY LOCAL ECHO
	PUSHJ	P,VTMSTE	;STORE THE CHAR AS AN "ECHOED" CHAR
	PUSHJ	P,VTMSTO	;  AND ECHO A "CR" TO THE OUTPUT STRING
	MOVEI	T3,12		;GET A "LF"
	PUSHJ	P,VTMSTO	;  AND PUT THAT IN THE OUTPUT STRING TOO.
	SCNON			;ALL CHARS STORED.  INTERRUPTS OK NOW.
	PUSHJ	P,TOPOKE##	;START UP OUTPUT TO GET THE ECHO OUT.
	PJRST	VTMEDM		;ENTER DEFERED ECHO MODE (QUEUE LINE) & EXIT

VTMRE5:	PUSHJ	P,VTMSTI	;STORE THE CHAR AS A NORMAL NON-ECHOED CHAR
	SCNON			;INTERRUPTS OK NOW...
	PJRST	VTMEDM		;QUEUE THE LINE SO MCR GETS DATA & EXIT.
;VTMDSO	ROUTINE CALLED BY SCNSER WHEN A DATA-SET LINE COMES UP
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;ALWAYS
VTMDSO::MOVEI	T1,STY.RG	;GET THE RING/CARRIER BIT
	IORM	T1,LDBREM##(U)	;  AND SET IT IN THE STATUS
	PJRST	VTMSSS		;GO "SET SEND STATUS" AND QUEUE THE LINE


;VTMDSF	ROUTINE CALLED BY SCNSER WHEN A DATA-SET LINE HANGS UP
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;ALWAYS
VTMDSF::MOVEI	T1,STY.RG	;GET THE RING/CARRIER BIT
	ANDCAM	T1,LDBREM##(U)	;  AND CLEAR IT IN THE STATUS WORD
	MOVSI	T1,LRLDIP##	;GET THE "WE WANT TO DISCONNECT" BIT
	IORM	T1,LDBREM##(U)	;  AND SET IT
	PJRST	VTMENQ		;QUEUE THE LINE SO THAT IT GETS SENT


;VTMSSS	ROUTINE TO "SET SEND STATUS" AND QUEUE A LINE
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;ALWAYS
VTMSSS:	MOVSI	T1,LRLSTS##	;GET THE "PLEASE SEND STATUS BIT"
	IORM	T1,LDBREM##(U)	;  AND SET IT SO STATUS GOES SOON
	PJRST	VTMENQ		;QUEUE THE LINE SO IT GETS SCANNED
;NETWORK DISPATCH VECTOR.

	JRST	VTMNWD		;(-5) NODE SWND DOWN
	JRST	VTMDCC		;(-4) DISCONNECT MESSAGE
	JRST	VTMCNC		;(-3) CONNECT CONFIRM
	JRST	NTDSTP##	;(-2) CONNECT INITIATE
	JRST	CPOPJ##		;(-1) DATA REQUESTS (DON'T GET ANY ON THIS SIDE)
VTMNDP::JRST	VTMDSP		;( 0) INCOMING DAP MESSAGES.
	JRST	VTMDAT		;( 1) DATA WITH-OUT END OF RECORD
	JRST	VTMDAT		;( 2) DATA WITH END OF RECORD
	JRST	VTMSTS		;( 3) DAP STATUS MESSAGE
	JRST	VTMCTL		;( 4) DAP CONTROL MESSAGE



;DUMMY CONNECT INIT PROCESSOR

NVTMCI==:NJNKCI##		;A JUNK CI
;VTMNWD	THE "NODE WENT DOWN" NDP ENTRY
;CALL	F := LAT ENTRY
;	P1 := NODE NUMBER OF NODE THAT HAS JUST GONE OFFLINE
;RETURN	CPOPJ			;WITH TTY "LOCAL" IF LINE WAS "SET HOSTED"
;				;  TO THE JUST CRASHED NODE.
VTMNWD:	LDB	T1,LDPRNF##	;GET THE NODE NUMBER (INDEXED BY "F")
	CAIE	T1,(P1)		;COMPARE OUR NUMBER WITH THAT OF CRASHED NODE
	PUSHJ	P,NTDSTP##	;++ CLNNDB DOESN'T DO THIS ANYMORE
	PUSH	P,U		;WE WERE SET-HOSTED TO THIS NODE, SAVE U
	MOVEI	U,(F)		;  AND GET U := LDB ADDRESS
	MOVEI	T1,[ASCIZ \Path to host system was lost.\]
	PUSHJ	P,VTMLOP	;MAKE LINE LOCAL AND TELL USER WHAT HAPPENED.
	PJRST	UPOPJ##		;RESTORE "U" AND WE'RE DONE.  LINE IS NOW
				;  USABLE LOCALLY.
;VTMDCC	ROUTINE TO HANDLE DISCONNECT MESSAGES FOR A VTM.
;CALL	F := LDB ADDRESS (REALLY THE LAT ENTRY)
;	W := NODE WHO SENT THE DISCONNECT
;	P1 & P4 := POINTERS TO THE DISCONNECT MESSAGE
;RETURN	CPOPJ			;BAD MESSAGE (CAN'T HAPPEN)
;	CPOPJ1			;DISCONNECT PROCESSED.
;THIS ROUTINE CHECKS THE REASON FOR THE DISCONNECT.  IF IT IS
;  "RSN.RC" (REASON -- RECONNECT) AN IMPLICIT "SET HOST" IS DONE
VTMDCC:	PUSHJ	P,SAVJW##	;WE MAY CLOBBER THESE IF IT'S A "SET HOST"
	PUSH	P,U		;SAVE INCOMING PCB POINTER
	MOVEI	U,(F)		;  AND PUT THE LDB ADDRESS IN "U"

	LDB	T1,LDPSLA##	;GET OUR LOCAL LAT ADDRESS
	LDB	T2,LATSTA##	;  AND GET OUR CONNECTION STATE.

	CAIN	T2,LAT.CC	;SEE IF THIS IS A CONNECT REJECT.
	JRST	[MOVEI T1,[ASCIZ \Host rejected connection.\]
		PUSHJ P,VTMLOP	;  IF SO, MAKE LINE LOCAL AND PRINT MSG.
		  PJRST VTMDC2];  RESTORE "U" AND RETURN

	CAIN	T2,LAT.DC	;IS THIS A DISCONNECT CONFIRM
	JRST	VTMDC1		;  IF D-CONFIRM, PRINT GREETING AND MAKE LOCAL

IFN PARANOID&P$VTM,<		;IF WE'RE BEING CAUTIOUS,
	CAIE	T2,LAT.OK	;  MAKE SURE WE'RE IN A REASONABLE STATE
	PUSHJ	P,NTDSTP##	;  IF NOT, TELL SOME ONE TO LOOK AT THIS.
>

;FALL THROUGH TO PROCESS DISCONNECT INITIATE
;HERE WHEN WE RECEIVE A DISCONNECT INITIATE.  SEND THE DISCONNECT
;  CONFIRM, AND SEE IF WE MUST PERFORM AN IMPLICIT "SET HOST"

	MOVEI	T1,RSN.OK	;GIVE AN "OK" REASON FOR THE CONFIRM
	EMRGCY			;USE THE EMERGENCY FREE-POOL IF NECESSARY
	PUSHJ	P,TRMXDC##	;SEND THE DISCONNECT CONFIRM
	  PUSHJ	P,NTDSTP##	;++ BUT WE REQUESTED EMERGENCY FREE-CORE?
;SLA
	PUSHJ	P,XSKIP##	;SKIP OVER THE SLA (USELESS)
;RSN
	PUSHJ	P,EBI2BI##	;GET THE REASON FOR THE DISCONNECT.
	CAIE	T1,RSN.RC	;IF ITS NOT RECONNECT (SET HOST)
	JRST	[MOVEI T1,[ASCIZ \Host sent disconnect.\]
		PUSHJ P,VTMLOP	;TELL THE USER HE'S BEEN DISCONNECTED
		  PJRST VTMDC2];  AND LET HIM RUN ON THIS MACHINE.

;HERE TO DO THE IMPLICIT SET HOST.

;NNM
	PUSHJ	P,EBI2BI##	;GET THE NUMBER OF THE NODE TO RECONNECT TO.
	HLRZ	T2,NETNDB##+NDBNNM ;GET OUR LOCAL NODE NUMBER
	CAIN	T1,(T2)		;IF THEY ARE THE SAME, THEN
	JRST	VTMDC1		;  PRINT A GREETING AND LET HIM RUN HERE AGAIN

	PUSHJ	P,SRCNDB##	;GET NDB OF HOST TO RECONNECT TO
	  JRST	[MOVEI T1,[ASCIZ \? Unable to complete SET HOST command.\]
		PUSHJ P,VTMLOP	;NODE WENT AWAY.  GIVE USER A CRYPTIC ERROR.
		  PJRST VTMDC2]	;  PRINT GREETING AND LET HIM RUN HERE.

	PUSHJ	P,VTMLOC	;MAKE LINE LOCAL IN PREPARATION FOR CONNECT
	PUSHJ	P,VTMCNT	;SEND THE CONNECT INITIATE
	PJRST	UPOPJ1##	;RESTORE PCB POINTER AND EXIT


;HERE TO MAKE A LINE LOCAL AND FORCE A GREETING

VTMDC1:	PUSHJ	P,VTMLOC	;MAKE LINE LOCAL
VTMDC2: PUSHJ	P,TTFGRT##	;GREET THE  NEWFOUND TERMINAL
	PJRST	UPOPJ1##	;RESTORE PCB AND RETURN
;VTMCNC	ROUTINE TO PROCESS AN INCOMING CONNECT CONFIRM MESSAGE
;CALL	W := NDB OF NODE WE'VE SENT A CONNECT TO
;	F := LDB OF TERMINAL
;	P1 & P4 := POINTER TO THE CONNECT CONFIRM MESSAGE
;RETURN	CPOPJ			;ILLEGAL CONNECT CONFIRM MESSAGE
;	CPOPJ1			;LINK SET UP.  TERMINAL NOW "SET HOSTED" TO
;				;  OTHER SYSTEM.
VTMCNC:	PUSH	P,U		;SAVE THE INCOMING PCB ADDRESS
	MOVEI	U,(F)		;  AND SET "U" := LDB POINTER
	LDB	T1,LDPSLA##	;GET OUR LOCAL LAT ADDRESS
	LDB	T2,LATSTA##	;  AND FROM THAT OUR LOCAL CONNECT STATE
	CAIE	T2,LAT.CC	;IF WE'RE NOT IN CONNECT CONFIRM WAIT,
	JRST	UPOPJ##		;  THEN THIS IS AN ILLEGAL MESSAGE.
;DLA
	PUSHJ	P,EBI2BI##	;GET THE LAT ADDR ASSIGNED TO US BY THE MCR
	JUMPE	T1,UPOPJ##	;DON'T EVER USE A ZERO DLA...
	DPB	T1,LDPDLA##	;STORE THE REMOTE LINE ADDRESS

	PUSHJ	P,TRM.UP##	;INITIALIZE THE LINE, SET LRLCON.
IFN FTMODM,<
	MOVE	T1,LDBDCH##(U)	;GET THE CHARACTERISTICS FOR THIS LINE
	TRNN	T1,LDRDSD##	; ARE WE A DATA-SET LINE?
	  JRST	VTMCN1		;NOT A DATA SET, NEVER MIND
	LDB	T1,LDPDSC##	;GET DATASET TABLE INDEX
	MOVE	T1,DSCTAB##(T1)	;GET DATASET DATA
	TLNE	T1,DSCSWC##	;IS THE CARRIER THERE?
	SKIPA	T1,[XWD LRLSTS##+LRLSCH##,STY.DE+STY.DT+STY.RG]
VTMCN1:
>
	MOVE	T1,[XWD LRLSTS##+LRLSCH##,STY.DE]
	IORM	T1,LDBREM##(U)	;SAY WE NEED TO SEND STATUS, GO TO DEFERED ECHO
	PUSHJ	P,VTMENQ	;QUEUE THE VTM SO WE SEND THESE MESSAGES
	JRST	UPOPJ1##	;DONE PROCESSING THE CONNECT-CONFIRM
;VTMDSP	ROUTINE TO DIS-ASSEMBLE AN INCOMING DAP MESSAGE AND DISPATCH
;  ON THE VARIOUS DAP SUB-MESSAGES.
;CALL	F := LAT ENTRY (RH(F) = LDB POINTER)
;	W := NDB THAT THE LINE IS CONNECTED TO
;	P1 & P4 := BYTE POINTER & COUNT TO THE INCOMING MESSAGE
;RETURN	CPOPJ			;MESSAGE WAS "BAD" IN ONE WAY OR ANOTHER
;	CPOPJ1			;MESSAGE HAS BEEN PROCESSED.
VTMDSP:	MOVE	T1,PCBIAD(U)	;GET MESSAGE POINTER (SO WE CAN GET NCT LATER)
	PUSH	P,U		;PRESERVE THE PCB ADDRESS
	MOVEI	U,(F)		;  AND SET UP THE LDB POINTER

;NOW LOOK AT THE NCT BYTE TO SEE IF THIS MESSAGE IS INTERRUPT OR NORMAL

	ILDB	T1,T1		;GET THE NCT BYTE
	TRNE	T1,NCT.IT	;  AND SEE IF IT HAS THE INTERRUPT BIT SET
	JRST	VTMDS1		;IT'S AN INTERRUPT MSG.  LEAVE DRQ ALONE.

	LDB	T1,LDPDRQ##	;IT'S NORMAL DATA. GET THE DRQ COUNT
	SOSGE	T1		;  AND COUNT OFF ONE LESS OUTSTANDING DRQ
	PJSP	T1,VTMDS3	;IF DRQ WENT NEGATIVE, REMEMBER OUR PC
				;  FIXUP THE STACK AND MARK THE MSG AS BAD.
	DPB	T1,LDPDRQ##	;STORE THE UPDATED DRQ

;DROP THROUGH TO DISSECT THE INCOMING MESSAGE.
VTMDS1:	JUMPLE	P4,UPOPJ##	;IF AT END OF MESSAGE, GIVE GOOD RETURN
;CNT
	PUSHJ	P,EBI2BI##	;GET THE LENGTH OF THIS SUB-MESSAGE
	SUB	P4,T1		;  CALCULATE LENGTH OF REMAINDER OF MSG.
	SKIPGE	P4		;MAKE SURE MSG LENGTH DOESN'T GO NEGATIVE
	PJSP	T1,VTMDS3	;IF SUB MSG LONGER THAN MSG, TOSS MSG AS BAD
	PUSH	P,P4		;REMEMBER HOW MUCH IS LEFT IN THE MESSAGE
	MOVEI	P4,(T1)		;  AND SET UP THE LENGTH FOR THIS SUB-MSG
;TYPE
	PUSHJ	P,EBI2BI##	;GET THE IDC TYPE FIELD
	CAIL	T1,DC.DAT	;RANGE CHECK IT
	CAILE	T1,DC.CTL	;  SO WE DON'T JUMP OFF INTO THE WEEDS
	PJSP	T1,VTMDS2	;IF OUT OF RANGE TYPE, REPORT BAD MESSAGE
	PUSHJ	P,VTMNDP(T1)	;CALL THE APPROIATE SUB-MSG PROCESSOR
	  PJSP	T1,VTMDS2	;  AND IF HE THINKS THE MSG IS BAD, TOSS IT.
	SOJG	P4,[IBP P1	;SKIP TO THE END OF THE SUB-MSG
		    JRST .]	;  SO WE'RE READY TO READ THE NEXT "CNT" FIELD
	POP	P,P4		;RECOVER THE LENGTH OF THE UNPROCESSED PART
	JRST	VTMDS1		;  AND GO DO THE NEXT SUB-MESSAGE

;HERE IF FOR SOME REASON WE THINK THE MESSAGE IS BAD.
;CALL	T1 := ADDRESS OF CODE THAT DECIDED IT DIDN'T LIKE THE MSG

VTMDS2:	POP	P,P4		;FIXUP THE STACK IF WE HAVE THE LENGTH ON IT
VTMDS3:	POP	P,U		;GET THE PCB POINTER BACK FOR INCTBD
	JRST	INCTBD##	;MARK THE MESSAGE AS BAD & RETURN
;VTMDAT	ROUTINE TO PROCESS INCOMING DAP-DATA MESSAGES
;CALL	U := POINTER TO LDB
;	P1 & P4 := POINTER AND LENGTH OF DATA TO STORE.
;RETURN	CPOPJ			;ONLY IF WE GOT A ZERO LENGTH MSG
;	CPOPJ1			;DATA COPIED INTO OUTPUT BUFFER AND
;				;  OUTPUT HAS BEEN STARTED.
VTMDAT:	JUMPLE	P4,CPOPJ##	;WE DON'T LIKE ZERO LENGTH MSGS

;FIRST MAKE SURE WE HAVE ENOUGH CHUNKS TO ACCOMODATE THIS DATA

	MOVE	T1,TTFREN##	;GET NUMBER FO FREE CHUNKS
	IMULI	T1,<TTCHKS##-1>*4 ;CONVERT THAT NUMBER INTO CHARACTERS
	CAIG	T1,10(P4)	;  AND SEE IF MSG (PLUS A FUDGE) WILL FIT
	POPJ	P,		;SAY THAT MESSAGE IS BAD IF IT WON'T FIT

	MOVE	T1,LDBTOC##(U)	;GET THE NUMBER OF CHARS TO OUTPUT
	CAIL	T1,<MAXODR*NTTPLN##*4>+100 ;SEE IF IT'S MORE THAN "MAXODR"
	POPJ	P,		;  DRQ'S WORTH OF DATA. IF SO, TOSS IT.
				;  SOME-ONE IS SENDING US DATA WE DIDN'T ASK
				;  FOR.  (CALCULATION IS BASED ON "NTTPLN" WORD
				;  MESSAGES OF 4 CHARS PER WORD)

	MOVE	T4,LDBREM##(U)	;GET THE DAP-STATUS WORD
	TRNN	T4,STY.IO	;  AND IF WE'RE NOT DOING IMAGE OUTPUT
	TDZA	T4,T4		;  MAKE OUR "IOR" MASK ZERO.
	MOVEI	T4,400		;  IF IMAGE-OUT, GET MASK TO SET "IMAGE" BIT
	SCNOFF			;GET A LITTLE PROTECTION WHILE WE HACK CHUNKS
	ADDM	P4,LDBTOC##(U)	;COUNT THE CHARS WE'RE ABOUT TO STUFF
VTMDA1:	ILDB	T3,P1		;GET THE NEXT CHAR
	IOR	T3,T4		;SET THE IMAGE BIT IF WE'RE IN IMAGE MODE
	STCHK	T3,LDBTOP##(U),VTMDA5  ;STORE THE CHAR IN THE OUTPUT CHAIN
	SOJG	P4,VTMDA1	;LOOP OVER ALL CHARS.
	SCNON			;ALL'S CONSISTANT AGAIN.  TURN ON INTS.
	PUSHJ	P,TOPOKE##	;START THE LINE TYPING
	RETSKP			;  AND GIVE A GOOD RETURN

	ILDB	T3,P1		;ADVANCE P1
VTMDA5:	SOJG	P4,.-1		;LOOP
	SCNON			;RELEASE INTERLOCK
	POPJ	P,		;ERROR
;VTMSTS	ROUTINE TO PROCESS INCOMING DAP-STATUS MESSAGES
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO, AND LENGTH OF THE MESSAGE
;RETURN	CPOPJ			;IF IT'S A GARBAGE MESSAGE
;	CPOPJ1			;STATUS MESSAGE PROCESSED.
VTMSTS:
;STC
	PUSHJ	P,EBI2BI##	;READ THE STATUS CODE
	CAIL	T1,STC.SB	;RANGE CHECK THE CODE (1 = SET BITS)
	CAILE	T1,STC.CB	;  (2 = CLEAR BITS)
	POPJ	P,		;STATUS CODE NOT SET/CLEAR.
	SOS	T4,T1		;COPY THE STATUS CODE (MINUS ONE)
;STY
	PUSHJ	P,EBI2BI##	;READ THE STATUS BITS TO SET/CLEAR
IFN FTKL10,<
	TRNN	T1,STY.XS	;DO WE WANT OUTPUT STOPPED OR STARTED?
	 JRST	VTMST3		;NO
	HRRZ	T2,LDBISR##(U)	;GET ISR DISPATCH
	CAIE	T2,TTDDSP##	;IS THIS A -20F LINE
	 JRST	VTMST3		;NO
	MOVSI	T2,LTLXFF##	;YES, SET BIT TO INFORM -20F
	IORM	T2,LDBTTD##(U)	;
VTMST3:
>
	MOVE	T2,LDBREM##(U)	;SAVE THE PREVIOUS STATUS FOR A BIT
	XCT	[IORB T1,LDBREM##(U) ;SET OR CLEAR THE
		 ANDCAB T1,LDBREM##(U)](T4) ;  BITS AS DIRECTED
	TRNN	T2,STY.DE	;IF WE WERE IN LOCAL ECHO
	TRNN	T1,STY.DE	; AND WE ARE NOW IN REMOTE
	CAIA			; (IE DEFERRED ECHO)
	PUSHJ	P,VTMEDM	; THEN SEND THE HOST A STATUS MSG

;MAKE LDBDCH AGREE WITH LDPSTS (LH(T2) = BITS TO SET, RH(T2) = CLEAR)

	MOVE	T1,LDBREM##(U)	;RESTORE BITS
	SETZ	T2,		;START WITH NO BITS TO CHANGE
	TRNE	T1,STY.XS	;IF WE WANT OUTPUT STOPPED,
	TLOA	T2,LDLSTP##	;  THEN SET THIS BIT
	TRO	T2,LDLSTP##!LDLSSO## ;OTHERWISE CLEAR THESE BITS

	TRNE	T1,STY.HT	;IF WE HAVE HARDWARE TABS
	TLOA	T2,LDLTAB##	;  THEN TELL SCNSER
	TRO	T2,LDLTAB##	;  CLEAR BIT IF NO TABS

	TRNE	T1,STY.FF	;If we have TTY FORM
	 TLOA	T2,LDLFRM##	;  Set the bit
	  TRO	T2,LDLFRM##	;  Otherwise clear it

	TRNE	T1,STY.CV	;If we are doing case conversions
	 TLOA	T2,LDLLCT##	; Then tell SCNSER
	  TRO	T2,LDLLCT##	;  Else clear this bit

	TRNN	T1,STY.CR	;IF WE'RE DOING FREE CRLF
	TROA	T2,LDLNFC##	;  THEN CLEAR THE "NO FREE CRLF" BIT
	TLO	T2,LDLNFC##	;  OTHERWISE SET IT.

	HRLZ	T3,T2		;GET THE BITS TO CLEAR
	ANDCAM	T3,LDBDCH##(U)	;  AND CLEAR THEM
	HLLZ	T3,T2		;GET THE BITS TO SET,
	IORB	T3,LDBDCH##(U)	;  AND SET THEM.

;DROP THROUGH TO PROCESS THE REST OF THE STATUS MESSAGE BITS
;NOW MAKE LDBBY2 AGREE WITH LDPSTS

	MOVEI	T2,L2RXON##	;THE "SET TTY TAPE" BIT
	TRNE	T1,STY.TT	;IF WE'RE IN TERMINAL TAPE MODE
	SKIPA	T3,[IORM T2,LDBBY2##(U)] ;THEN SET THE BIT
	MOVE	T3,[ANDCAM T2,LDBBY2##(U)] ;OTHERWISE CLEAR IT
	XCT	T3		;SET/CLEAR THE BIT

;NOW MAKE THE MODEM CONTROL BITS AGREE WITH THE MODEM STATUS

	PUSHJ	P,SETCHP##	;KICK THE LINE INCASE WE JUST STARTED OUTPUT
	RETSKP			;ALL DONE WITH STATUS MESSAGE
;VTMCTL	ROUTINE TO DISPATCH ON INCOMING DAP-CONTROL MESSAGES
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO, AND LENGTH OF THE CONTROL MESSAGE
;RETURN	CPOPJ			;IF MESSAGE IS BAD
;	CPOPJ1			;IF MESSAGE IS PROCESSED.
VTMCTL:	PUSHJ	P,EBI2BI##	;GET THE CONTROL-MESSAGE TYPE
	SKIPL	T1		;RANGE CHECK THE TYPE
	CAILE	T1,DCT.XF	;  SO WE DON'T JUMP OFF INTO THE WEEDS
	POPJ	P,		;BAD CONTROL TYPE.  GIVE "BAD-MSG" RETURN
	JRST	@.+1(T1)	;DISPATCH ON THE CONTROL CODE
	JRST	VTMEPM		; (0) = ECHO PIPELINE MARKER
	JRST	VTMCGB		; (1) = CHARACTER GOBBLER (^O)
	JRST	VTMCHR		; (2) = "CHARACTERISTICS" (SPEED ETC.)
	JRST	VTMADL		; (3) = AUTO DIAL-OUT
	JRST	VTMXOF		; (4) = SEND "XOFF" IMMEDIATLY
;VTMEPM	ROUTINE TO PROCESS AN INCOMING ECHO-PIPELINE-MARKER.
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO AND LENGTH OF SUB MESSAGE
;RETURN	CPOPJ			;NEVER
;	CPOPJ1			;EPM PROCESSED.
;FCN	IF THE EPM SERIAL NUMBER MATCHES THE LAST ONE SENT, THEN
;	THERE ARE NO MORE CHARS IN THE "PIPELINE".  IN THIS CASE
;	WE CAN GO INTO LOCAL ECHO ONLY IF WE HAVE NO INPUT CHARS
;	QUEUED FOR THE REMOTE HOST.
VTMEPM:	PUSHJ	P,BYT2BI##	;GET THE 8 BIT EPM SERIAL NUMBER
	LDB	T2,LDPEPM##	;GET THE SERIAL NUMBER OF THE LAST EPM SENT
	CAIE	T1,(T2)		;IF WE HAVEN'T GOTTEN OUR LAST EPM BACK
	RETSKP			;  THEN THERE ARE STILL CHARS IN THE PIPE
	MOVEI	T1,STY.DE	;GET THE "REMOTE IS ECHOING" BIT
	TDNN	T1,LDBREM##(U)	;SEE IF WE ARE ALREADY IN LOCAL ECHO
	RETSKP			;  IF IN LOCAL ECHO, IGNORE EXTRA EPM
	SCNOFF			;MAKE SURE WE DON'T ECHO A CHAR FOR A WHILE
	SKIPN	LDBTIC##(U)	;MAKE SURE THAT NO CHARS HAVE
	SKIPE	LDBECC##(U)	;  SNUCK IN WHILE WE WEREN'T LOOKING
	JRST	SONPJ1##	;IF CHARS QUEUED, DON'T ENTER LOCAL ECHO MODE
	ANDCAB	T1,LDBREM##(U)	;CLEAR REMOTE ECHO (ENABLE LOCAL ECHO)
	DPB	T1,LDPDST##	;SAVE THE STATUS MESSAGE
	MOVSI	T1,LRLDST##	;GET THE BIT SAYING A STATUS MSG IS "SAVED"
	IORM	T1,LDBREM##(U)	;  SO THAT NEXT TIME WE START A MESSAGE
				;  FOR THE REMOTE WE WILL SEND A STATUS
				;  MESSAGE TELLING HIM WE'RE LOCAL ECHOING
	SCNON			;INTERRUPTS OK NOW.
	AOS	(P)		;GIVE GOOD RETURN
	PJRST	VTMENQ		;NOW QUEUE THE LINE TO SEND THE STATUS
				;  *** NOTE ***  WHILE IT WOULD BE NICE
				;  TO BE ABLE TO DELAY SENDING THIS STATUS
				;  MESSAGE, UNTIL NETMCR GETS SMARTER ABOUT
				;  TELLING US IF WE SHOULD ECHO OR NOT, WE
				;  MUST INFORM IT IMMEDIATLY UPON ENTERING
				;  LOCAL ECHO MODE.  IF WE DON'T, PASSWORDS
				;  WILL ECHO...
;VTMCGB	ROUTINE TO PROCESS A "CHARACTER GOBBLER" (^O) REQUEST
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO, AND LENGTH OF SUB MSG (WE IGNORE IT)
;RETURN	CPOPJ			;NEVER
;	CPOPJ1			;OUTPUT STREAM "GOBBLED"
VTMCGB:	PUSHJ	P,TSETBO##	;SCNSER DOES ALL THE WORK
	RETSKP			;GIVE GOOD RETURN
;VTMCHR	ROUTINE TO PROCESS AN INCOMING CHARACTERISTICS MESSAGE
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO, AND LENGTH OF THIS SUB-MESSAGE
;RETURN	CPOPJ			;SOMETHING WAS WRONG WITH THE MESSAGE
;	CPOPJ1			;MESSAGE PROCESSED
VTMCHR:	PUSHJ	P,EBI2BI##	;GET BACK-SPACE FILL TIME
	PUSH	P,T1		;  AND SAVE FOR JUST A BIT
	PUSHJ	P,EBI2BI##	;GET H-TAB FILL TIME
	HRLM	T1,(P)		;  AND SAVE THAT TOO.
	PUSHJ	P,EBI2BI##	;GET LF FILL TIME (IGNORE)
	PUSHJ	P,EBI2BI##	;GET V-TAB FILL TIME (IGNORE)
	PUSHJ	P,EBI2BI##	;GET FORM FEED FILL TIME (IGNORE)
	PUSHJ	P,EBI2BI##	;GET CR FILL TIME (IGNORE)

;NOW WE MUST GUESS WHAT FILL CLASS WE WANT GIVEN THE TIMES.
;  RATHER THAN TRY TO INVERT THE ALGORITHM IN NETMCR(TTXTCR),
;  THIS CODE RELYS ON THE FACT THAT ONE CAN DETERMINT THE
;  CLASS FROM THE FIRST TWO ENTRIES IN FILTAB.
;EG.	BSP	H-TAB	CLASS
;	 0	  0	  0
;	 2	  2	  1
;	 6	  0	  2
;	 6	  2	  3

	POP	P,T2		;GET XWD H-TAB,BSP FILL TIMES BACK
	MOVEI	T1,3		;INITIALIZE "T1" FOR THE SOS'ES COMING UP
	JUMPE	T2,VTMCH1+0	;IF BOTH ARE "0" THEN FILL CLASS MUST BE TOO.
	TLNN	T2,-1		;IF "H-TAB" IS ZERO, THEN
	JRST	VTMCH1+2	;  WE HAVE FILL CLASS "2"
	TSC	T2,T2		;COMPARE THE TWO TIMES
	JUMPE	T2,VTMCH1+1	;IF EQUAL, THEN FILL CLASS = 1
	JRST	VTMCH1+3	;IF NOT EQUAL, THEN CLASS = 3

VTMCH1:	SOS	T1		;HERE FOR FILL CLASS 0
	SOS	T1		;HERE FOR FILL CLASS 1
	SOS	T1		;HERE FOR FILL CLASS 2
;	JFCL			;HERE FOR FILL CLASS 3
	...DPB	T1,LDPFLC##	;REMEMBER THE FILL CLASS

;DROP THROUGH TO PROCESS THE REST OF THE MSG (SPEEDS ETC...)
;NOW PROCESS THE SPEEDS ETC.

	PUSH	P,P2		;PROTECT P2 FROM RAVAGES OF COMCON
	PUSHJ	P,EBI2BI##	;GET THE RECEIVE SPEED
	MOVEI	T2,(T1)		;COPY IT FOR COMCON
	PUSHJ	P,TTCSP1##	;TRANSLATE SPEED INTO AN INDEX
	  LDB	P2,LDPRSP##	;IF ILLEGAL SPEED, THEN DON'T CHANGE IT
	DPB	P2,LDPRSP##	;STORE THE NEW SPEED

	PUSHJ	P,EBI2BI##	;GET THE TRANSMIT SPEED
	MOVEI	T2,(T1)		;COPY IT FOR COMCON
	PUSHJ	P,TTCSP1##	;TRANSLATE SPEED INTO INDEX
	  LDB	P2,LDPTSP##	;DON'T CHANGE SPEED IF IT'S ILLEGAL
	DPB	P2,LDPTSP##	;STORE THE NEW TRANSMIT SPEED
	POP	P,P2		;RESTORE P2

	PUSHJ	P,EBI2BI##	;READ THE WIDTH
	SKIPE	T1		;DON'T SET WIDTH TO ZERO
	...DPB	T1,LDPWID##	;STORE THE NEW WIDTH

	PUSHJ	P,EBI2BI##	;READ THE AUTO-CRLF POSITION
	...DPB	T1,LDPACR##	;  AND STORE THAT (ZERO IS OK)

	PUSHJ	P,XSKIP##	;SKIP 2741 ELEMENT NUMBER (NOT IMPLEMENTED)
	PUSHJ	P,XSKIP##	;SKIP 2741 "BITS" (NOT IMPLEMENTED)

	PUSHJ	P,SETCHP##	;QUEUE A KICK TO THE LINE DRIVER'S HARDWARE
	RETSKP			;GIVE GOOD RETURN
;VTMADL	ROUTINE TO PROCESS AN AUTO-DIAL MESSAGE
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO, AND LENGTH OF THE SUB MSG
;RETURN	CPOPJ			;IF MESSAGE IS BAD
;	CPOPJ1			;WITH AUTO-DIAL MESSAGE PROCESSED
VTMADL:	POPJ	P,		;WE DON'T HANDLE THIS MESSAGE
;VTMXOF	ROUTINE TO PROCESS THE "SEND XOFF IMMEDIATLY" REQUEST
;CALL	U := POINTER TO THE LDB
;	P1 & P4 := POINTER TO, AND LENGTH OF THE SUB MSG (NULL)
;RETURN	CPOPJ			;NEVER
;	CPOPJ1			;XOFF FILLER POINTER SET.
VTMXOF:	MOVE	T2,FLPPXF##	;GET THE XOFF FILLER POINTER
	PUSHJ	P,SETXNP##	;CALL SCNSER TO SET THE "XON CLASS" FILL PTR
	PUSHJ	P,TOPOKE##	;KICK THE LINE (PROBABLY NOT NECESSARY...)
	RETSKP			;GIVE GOOD RETURN, XOFF FILLER QUEUED TO GO.
;VTMSCN	ROUTINE TO SCAN THE STAUS OF A VTM AND SEND MESSAGES NEEDED.
;CALL	U := LDB OF VTM
;RETURN	CPOPJ			;NO CORE.  REQUEUE THE LINE
;	CPOPJ1			;PROCESSING COMPLETED.
;FUNCTION
;	VTMSCN CHECKS FOR MESSAGES TO SEND IN THE FOLLOWING PRIORITY:
;	    .	CHARACTERISTICS (NEEDED IMMEDIATLY AFTER A CONNECT)
;	    .	DELAYED STATUS (STATUS SAVED JUST AS LINE GOES INTO LOCAL ECHO)
;	    .	CHARACTERS IN THE "LOCAL ECHOED" CHAIN.
;	    .	NORMAL STATUS
;	    .	CHARACTERS IN THE "REMOTE ECHO" CHAIN
;	    .	ECHO PIPELINE MARKERS.
VTMSCN:	MOVE	T1,LDBREM##(U)	;GET THE REMOTE STATUS BITS
	TLNE	T1,LRLSCH##	;SEE IF WE NEED TO SEND CHARACTERISTICS
	JRST	[PUSHJ P,VTMXCH	;SEND THE CHARACTERISTICS
		   JRST VTMSC1	;REQUEUE THE LINE IF NO CORE
		 JRST VTMSCN]	;SEE WHAT ELSE THERE IS TO DO.

	TLNE	T1,LRLDST##	;DO WE HAVE A "DELAYED STATUS" MESSAGE TO SEND
	JRST	[PUSHJ P,VTMXDS	;SEND THE DELAYED STATUS
		   JRST VTMSC1	;REQUEUE THE LINE IF NO CORE
		 JRST VTMSCN]	;SEE WHAT ELSE THERE IS TO DO

	SKIPE	LDBECC##(U)	;ANY "LOCALLY ECHOED" CHARS TO GO
	JRST	[PUSHJ P,VTMXEC	;SEND THE "ECHOED" CHARS
		   JRST VTMSC1	;NO CORE. REQUEUE LINE
		 JRST VTMSCN]	;GO LOOK AT THE LINE AGAIN

	TLNE	T1,LRLSTS##	;DO WE NEED TO SEND "NORMAL" STATUS
	JRST	[PUSHJ P,VTMXST	;SEND THE STATUS
		   JRST VTMSC1	;NO CORE
		 JRST VTMSCN]

	SKIPE	LDBTIC##(U)	;ANY "REMOTE ECHO" CHARS TO GO
	JRST	[PUSHJ P,VTMXUC	;SEND THE "UN-ECHOED CHARS"
		   JRST VTMSC1	;NO CORE
		 JRST VTMSCN]	;RELOAD T1 AND HAVE ANOTHER GO AT IT...

	PUSHJ	P,CHKXON##	;SEND AN XON (IF WE OWE ONE) NOW THAT
				;  WE'VE EMPTIED THE CHUNKS.
	PUSHJ	P,VTMXEP	;TRY TO SEND AN ECHO-PIPELINE MARKER
	  JRST	VTMSC1		;NO CORE.  REQUEUE

	AOS	(P)		;SCAN IS COMPLETE.  GIVE GOOD RETURN
VTMSC1:	PUSHJ	P,TSDPCB##	;FORCE ANY PARTIAL MESSAGES OUT.
	POPJ	P,		;ALL DONE. RETURN
;VTMXCH	ROUTINE TO SEND THE "CHARACTERISTICS" MESSAGE FOR A VTM
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;MESSAGE SENT
VTMXCH:	PUSHJ	P,GETCR##	;GET THE "CONDENSED CHARACTERISTICS" IN T1
	PUSHJ	P,TRXTCR##	;CALL ROUTINE IN NETMCR TO SEND THEM
	  POPJ	P,		;NO CORE. GIVE ERROR ROUTINE
	MOVSI	T1,LRLSCH##	;GET THE "CHARACTERISTICS REQUEST" BIT
	ANDCAB	T1,LDBREM##(U)	;  AND CLEAR THE REQUEST.
	RETSKP			;GIVE GOOD RETURN
;VTMXDS	ROUTINE TO SEND THE "DELAYED" STATUS MESSAGE FOR A VTM.
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;DELAYED STATUS SENT, LRLDST CLEARED
VTMXDS:	LDB	T1,LDPDST##	;GET THE DELAYED STATUS
	MOVEI	T2,0		;GET THE DAP STATUS CODE (FULL STATUS)
	PUSHJ	P,MCXSTA##	;CALL NETMCR TO SEND THE MSG
	  POPJ	P,		;GIVE ERROR RETURN IF NO CORE
	MOVSI	T1,LRLDST##	;GET THE "DELAYED STATUS" QUEUED BIT
	ANDCAB	T1,LDBREM##(U)	;  AND CLEAR IT SO WE DON'T SEND IT AGAIN
	RETSKP			;GIVE GOOD RETURN WITH MSG SENT
;VTMXST	ROUTINE TO SEND THE "NORMAL" STATUS MESSAGE FOR A VTM.
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;IF NO CORE
;	CPOPJ1			;STATUS SENT
VTMXST:	LDB	T1,LDPSTS##	;GET THE DAP STATUS BITS
	PUSHJ	P,MCXSTA##	;CALL NETMCR TO SEND THE STATSU
	  POPJ	P,		;GIVE AN ERROR RETURN IF NO CORE
	MOVSI	T1,LRLSTS##	;GET THE "PLEASE SEND STATUS" REQUEST
	ANDCAB	T1,LDBREM##(U)	;  BIT, AND CLEAR IT SO WE DON'T SEND IT AGAIN
	RETSKP			;GIVE GOOD RETURN NOW THAT MSG HAS GONE.
;VTMXEC	ROUTINE TO SEND THE "LOCALLY ECHOED" CHARACTERS
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;NO CORE.
;	CPOPJ1			;ALL CHARACTERS SENT.
VTMXEC:	MOVEI	T1,2		;MINIMUM ACCEPTABLE LENGTH
	PUSHJ	P,TRQPCB##	;REQUEST A PCB
	  POPJ	P,		;GIVE ERROR RETURN IF NO CORE
;TYP
	XMTI	DC.DAT		;SEND "DATA WITH EOR"

	SCNOFF			;NO INTERRUPTS WHILE WE LOOK AT CHUNKS.
	PUSH	P,P4		;SAVE NETMCR'S "P4"
	SOS	P4		;ACCOUNT FOR THE DAP MSG TYPE JUST WRITTEN
	CAMLE	P4,LDBECC##(U)	;IF ALL THE CHARS WILL FIT IN THE MESSAGE
	MOVE	P4,LDBECC##(U)	;  THEN USE THE SMALLER VALUE.
	MOVN	P4,P4		;GET "MINUS" THE NUMBER
	ADDM	P4,LDBECC##(U)	;ACCOUNT FOR THE NUMBER WE'RE ABOUT TO SEND

IFN PARANOID&P$VTM,<
	SKIPGE	P4		;MAKE SURE THIS COUNT IS NEGATIVE,
	SKIPGE	LDBECC##(U)	;  AND THIS ONE ISN'T
	PUSHJ	P,NTDSTP##	;++ COUNTS ARE ALL MESSED UP
>
VTMXE1:	LDCHKR	T1,LDBTIT##(U),VTMXE3  ;GET THE NEXT CHARACTER
	XMT1	T1		;WRITE THE CHAR
	AOJL	P4,VTMXE1	;LOOP OVER ALL THE CHARS
VTMXE3:	POP	P,P4		;GET THE MESSAGE LENGTH BACK FOR NETMCR
	SCNON			;CHUNKS ARE CONSISTANT AGAIN
	PUSHJ	P,TWRPCB##	;SEND THE DATA
	SKIPE	LDBECC##(U)	;IF THERE ARE MORE CHARS,
	JRST	VTMXEC		;  THEN GO SEND THEM
	RETSKP			;ALL DONE.  GIVE GOOD RETURN
;VTMXUC	ROUTINE TO SEND THE "NOT LOCALLY ECHOED" CHARACTERS
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;NO CORE.
;	CPOPJ1			;ALL CHARACTERS SENT.
VTMXUC:	MOVEI	T1,2		;MINIMUM ACCEPTABLE LENGTH
	PUSHJ	P,TRQPCB##	;TRY TO GET A PCB (AND SCREW UP THE STACK)
	  POPJ	P,		;NO CORE.  GIVE ERROR RETURN
;TYP
	XMTI	DC.DAT		;SEND "DATA WITH EOR"

	PUSH	P,P1		;SAVE "P1" AND KEEP THE CONTENTS OF
	MOVE	P1,LDBREM##(U)	;  LDBREM IN IT FOR THE ENTIRE LOOP
	SCNOFF			;NO INTERRUPTS WHILE WE LOOK AT CHUNKS.
	PUSH	P,P4		;SAVE NETMCR'S "P4"
	SOS	P4		;ACCOUNT FOR THE DAP MSG TYPE JUST WRITTEN
VTMXU1:	SOSGE	LDBTIC##(U)	;COUNT OUT ONE MORE CHAR FROM CHUNKS
	JRST	[AOS LDBTIC##(U);  IF NO MORE, FIX UP THE COUNT
		 JRST VTMXU2]	;  AND SEND THE MESSAGE.
	LDCHKR	T1,LDBTIT##(U),VTMXU2  ;GET THE NEXT CHARACTER
	XMT1	T1		;WRITE THE CHAR
	ANDI	T1,177		;MASK OFF PARITY
	CAIN	T1,"S"-100	;IF THE CHAR IS A CONTROL "S"
	 JRST	VTMXU2		;EXIT THE LOOP TO LET XOFF BE SENT
	SOJG	P4,VTMXU1	;LOOP OVER ALL THE CHARS
VTMXU2:	POP	P,P4		;GET THE MESSAGE LENGTH BACK FOR NETMCR
	SCNON			;CHUNKS ARE CONSISTANT AGAIN
	POP	P,P1		;RECOVER "P1"
	PUSHJ	P,TWRPCB##	;SEND THE DATA
	SKIPE	LDBTIC##(U)	;IF THERE ARE MORE CHARS,
	JRST	VTMXUC		;  THEN GO SEND THEM
	RETSKP			;ALL DONE.  GIVE GOOD RETURN
;VTMXEP	ROUTINE TO SEND AN ECHO-PIPELINE-MARKER (IF NECESSARY)
;CALL	U := LDB POINTER
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;EITHER NO REASON SEND AN EPM, OR EPM SENT.
VTMXEP:	MOVE	T1,LDBREM##(U)	;GET THE REMOTE STATUS BITS
	TRNE	T1,STY.DE	;IF WE'RE ALREADY IN LOCAL ECHO,
	TRNE	T1,STY.II	;  OR WE'RE DOING IMAGE MODE INPUT,
	RETSKP			;THEN THERE'S NO REASON TO SEND AN EPM.
	PJRST	TRXEPM##	;LET NETMCR DO ALL THE WORK...
;VTMXDQ	ROUTINE TOSEND ANY DATA-REQUESTS THAT ARE NECESSARY.
;CALL	U := POINTER TO THE LDB
;RETURN	CPOPJ			;NO CORE
;	CPOPJ1			;ALL CAUGHT UP W.R.T. DRQ'S
VTMXDQ:	MOVE	T1,LDBTOC##(U)	;GET THE COUNT OF CHARS TO OUTPUT
	CAILE	T1,^D100	;IF THERE ARE MORE THAN THIS MANY,
	RETSKP			;  THEN DON'T SEND ANY MORE DRQ'S
	MOVE	T1,TTFREN##	;GET THE COUNT OF FREE CHUNKS
	CAIG	T1,^D25		;  AND REQUIRE THAT THERE BE AT LEAST
	RETSKP			;  THIS MANY FREE.
	LDB	T1,LDPDRQ##	;GET THE NUMBER OF OUTSTANDING DRQ'S
	MOVN	T1,T1		;GET MINUS THE NUMBER OF DRQ
	ADDI	T1,MAXODR##	;T1 = (MAXODR - NUMBER OF DRQ'S)
	SKIPG	T1		;SKIP IF WE NEED TO SEND SOME.
	RETSKP			;RETURN IF WE'VE ALREADY SENT THE DRQ'S

	PUSH	P,T1		;SAVE THE NUMBER OF MESSAGES WE WILL REQUEST
	PUSH	P,U		;SAVE OUR LDB POINTER
	PUSHJ	P,NCMHDR##	;CALL NETSER TO GET A CONTROL MESSAGE HEADER.
	  JRST	[POP P,U	;IF NO CORE, FIXUP THE STACK
		 JRST TPOPJ##]	;  AND GIVE THE "NO CORE" RETURN.
	EXCH	U,-1(P)		;GET OUR LDB ADDRESS BACK
;TYP
	XMTI	NC.DQR		;THE "TYPE" IS DATA-REQUEST
;DLA
	XMTB	LDPDLA##	;SEND OUR FRIENDS REMOTE LINK ADDRESS
;DRQ
	XMT	-2(P)		;WRITE THE DATA-REQUEST COUNT
	EXCH	U,-1(P)		;GET THE PCB BACK, SAVE LDB ADDRESS
	JSP	T1,NETWRC##	;FINISH OFF AND SEND THE CONTROL MSG
	POP	P,U		;CLEAN UP THE STACK
	LDB	T1,LDPDRQ##	;GET THE OLD DATA-REQUEST COUNT
	POP	P,T2		;GET THE VALUE OF THIS DRQ
	ADD	T1,T2		;GET THE TOTAL OUTSTANDING DRQ
	DPB	T1,LDPDRQ##	;  AND SAVE THAT
	RETSKP			;ALL DONE.  RETURN SUCCESSFULLY
;VTMSTE & VTMSTI  --  ROUTINES TO STORE CHARACTERS IN THE LDB'S INPUT STRING.
;CALL	T3 := CHAR TO STORE
;	U  := POINTER TO THE LDB
;	<SCANNER INTERRUPTS OFF>
;RETURN	CPOPJ			;WITH T3 STORED AND EITHER
;				;  LDBECC (VTMSTE) OR LDBTIC (VTMSTI)
;				;  INCREMENTED
VTMSTE:	AOS	LDBECC##(U)	;COUNT UP ONE MORE "ECHOED" CHAR
	JRST	VTMST1		;  NOW GO STORE THE CHAR IN THE INPUT BUFFER

VTMSTI:	AOS	LDBTIC##(U)	;COUNT UP ONE MORE "UN-ECHOED" CHAR
VTMST1:	STCHK	T3,LDBTIP##(U),VTMST2  ;STORE THE CHARACTER
VTMST2:	POPJ	P,		;  AND RETURN


;VTMSTO	ROUTINE TO STORE A CHARACTER IN THE LDB'S OUTPUT BUFFER
;CALL	T3 := CHAR TO STORE
;	U  := POINTER TO THE LDB
;	<SCANNER INTERRUPTS OFF>
;RETURN	CPOPJ			;WITH T3 STORED AND LDBTOC INCREMENTED
VTMSTO:	AOS	LDBTOC##(U)	;COUNT THE CHAR,
	STCHK	T3,LDBTOP##(U),VTMST2  ;  STORE IT IN THE OUTPUT BUFFER,
	POPJ	P,		;  AND RETURN.

;VTMEDM	ROUTINE TO "ENTER DEFERED ECHO MODE" FROM LOCAL ECHO MODE.
;CALL	U := LDB.
;RETURN	CPOPJ			;WITH EPM SERIAL# INCREMENTED AND
;				;  ALL (HOPEFULLY) RELEVANT BITS SET/CLEARED.
VTMEDM:	LDB	T1,LDPEPM##	;GET THE SERIAL OF THE LAST EPM SEND
	AOS	T1		;  INCREMENT THE NUMBER AND STORE SO WE DON'T
	DPB	T1,LDPEPM##	;  HAVE TO WORRY ABOUT AN EPM RACE.
	MOVE	T1,[XWD LRLSTS##,STY.DE] ;SAY SEND STATUS, NOW DEFERED ECHO
	IORM	T1,LDBREM##(U)	;  AND SET THESE IN THE DAP STATUS WORD
	PJRST	VTMENQ		;QUEUE THE LINE AND EXIT
;VTMLOC	ROUTINE TO CLEAN UP A LINE THAT HAS BEEN "SET HOSTED" AWAY.
;CALL	U := LDB TO "MAKE LOCAL"
;RETURN	CPOPJ			;ALWAYS
VTMLOC:	PUSH	P,W		;PROTECT "W"
	PUSHJ	P,VTMDEQ	;MAKE SURE THE LINE IS NOT QUEUED.
	PUSHJ	P,CLRTTY##	;CLEAR LDBREM WORDS (IN PARTICULAR LRLVTM)
	PUSHJ	P,LDBINI##	;CLEAN UP PARAMETERS ETC.  (DOES A TSETBI
				;  WHICH FIXES UP THE INPUT CHUNK CHAIN)
	PUSHJ	P,CLRPCT##	;CLEAR THE PAGE COUNTERS.
	PJRST	WPOPJ##		;LINE IS NOW A LOCAL LINE.

;VTMLOP	ROUTINE TO MAKE LINE LOCAL (ALA VTMLOC) AND THEN PRINT A MESSAGE.
;CALL	T1 := ADDRESS OF ASCIZ STRING TO PRINT
;	U  := ADDRESS OF LDB
;RETURN	CPOPJ			;ALWAYS
VTMLOP:	PUSH	P,T1		;SAVE THE MESSAGE ADDRESS
	PUSHJ	P,VTMLOC	;MAKE THE LINE LOCAK
	PUSHJ	P,PCRLF##	;PRINT INITIAL "CRLF" TO GET MSG ON NEW LINE
	POP	P,T1		;GET THE MESSAGE POINTER BACK
	PUSHJ	P,CONMES##	;PRINT THAT.
	PJRST	PCRLF##		;  AND PRINT A LAST "CRLF" TO END THE MSG.
;VTMHST	ROUTINE TO PERFORM THE "SET HOST" FUNCTION FOR A LOCAL TERMINAL
;CALL	W := ADDRESS OF THE NODE TO "SET HOST" THIS TERMINAL TO
;	U := ADDRESS OF THE LDB TO THAT IS DOING THE "SET HOST"
;RETURN	CPOPJ			;WITH EITHER THE CONNECT DONE, OR AN
;				;  ERROR MESSAGE PRINTED
VTMHST::HRRZ	F,LDBDDB##(U)	;GET THE ADDRESS OF THIS GUY'S TTY DDB
	SKIPE	F		;DON'T DO THE DETACH IF NO DDB
	PUSHJ	P,TTYDET##	;DETACH THIS GUY
	PJRST	VTMCNT		;LET VTMCNT DO THE REST OF THE WORK
;VTMCNT	ROUTINE TO PERFORM THE CONNECT FUNCTION FOR A TERMINAL.
;CALL	W := ADDRESS OF NDB OF NODE TO CONNECT TO
;	U := ADDRESS OF LDB TO CONNECT
;RETURN	CPOPJ			;WITH EITHER THE CONNECT SENT, OR
;				;  AN ERROR MESSAGE PRINTED.
VTMCNT:	PUSHJ	P,VTMLOC	;CLEAN UP THE LDBREM WORDS.
	MOVSI	T1,LAT.TY!LAT.VT!LAT.CC ;VTM BITS + CONNECT CONFIRM STATE
	HRRI	T1,(U)		;RH(LAT ENTRY) := LDB ADDRESS
	PUSHJ	P,GETSLA##	;ATTEMPT TO ASSIGN AN SLA
	  JRST	[MOVEI T1,[ASCIZ \No free LAT entries.\]
		PJRST VTMLOP]	;MAKE THE LINE LOCAL AND PRINT THE ERROR
	DPB	T1,LDPSLA##	;SAVE THE SOURCE LINK ADDRESS
	HLRZ	T1,NDBNNM(W)	;GET THE NUMBER OF THE NODE TO CONNECT TO
	DPB	T1,LDPRNN##	;  AND SAVE THAT AS THE VTMS REMOTE NODE #
	PUSHJ	P,VTMXCN	;SEND THE CONNECT.
	  JRST	[MOVE T1,NRTNCE## ;GET THE "NETWORK CAPACITY EXCEEDED ERROR
		 PJRST VTMLOP]	;  PRINT ERROR AND MAKE LINE LOCAL AGAIN

;AT THIS POINT WE HAVE SENT THE CONNECT.  NOW MAKE THE LINE "REMOTE"

	MOVSI	T1,LRLVTM##	;GET THE "THIS IS A VTM" BIT
	IORM	T1,LDBREM##(U)	;  AND SET IT SO TYPEIN COMES TO US AND
				;  DOESN'T GO TO SCNSER
	POPJ	P,		;EXIT WITH LINE WAITING FOR CONNECT CONFIRM.
;VTMXCN	ROUTINE TO SEND A CONNECT MESSAGE FOR A VTM. (EITHER CONFIRM --
;  DLA SET UP, OR INITIATE -- DLA = 0)
;CALL	W := NDB OF THE NODE TO SEND THE CONNECT TO.
;	U := POINTER TO THE LDB TO SEND CONNECT FOR
;RETURN	CPOPJ			;NOT ENOUGH CORE TO BUILD A MSG
;	CPOPJ1			;CONNECT SENT
VTMXCN:	PUSH	P,U		;SAVE THE LDB WHILE WE GO GET A PCB
	PUSHJ	P,NCMHDR##	;GO GET A NUMBERED PCB WITH THE NCL HEADER
	  JRST	UPOPJ##		;GIVE ERROR RETURN IF NO CORE.
	EXCH	U,-1(P)		;REMEMBER PCB ADDRESS, RECOVER LDB ADDRESS
;TYP
	XMTI	NC.CNT		;CONNECT MESSAGE TYPE
;DLA
	XMTB	LDPDLA##	;SEND DLA (IF = 0, THEN CONNECT INIT)
;SLA
	LDB	T1,LDPSLA##	;GET OUR LOCAL LAT ADDRESS
	SKIPN	T1		;MAKE SURE THERE IS ONE
	PUSHJ	P,NTDSTP##	;++ LAT ADDRESS NOT SET UP (CALL GETSLA FIRST)
	XMT	T1		;WRITE THE SOURCE LINK ADDRESS FIELD
;DPN(OBJ)
	XMTI	OBJ.TT		;WE WANT A TERMINAL HANDLER (MCR)
;DPN(PID)
	XMTI	0		;(DUMMY PROCESS NAME)
;SPN(OBJ)
	XMTI	OBJ.TY		;WE ARE A TERMINAL (TTY)
;SPN(PID)
	XMTB	LDPLNO##	;THIS IS OUR LOCAL LINE NUMBER
;MML
	XMTI	^D512		;RECORD LENGTH (IGNORED EVERYWHERE)
;FEA(DCM)
	XMTI	DCM.AS		;ASCII DEVICE MODE
;FEA(RLN)
	XMTI	0		;VARIABLE RECORD LENGTH
;FEA(DTY)
	MOVEI	T1,DTY.SB!DTY.SH;WE CAN SET HOST AND CHANGE SPEEDS,
	MOVE	T2,LDBDCH##(U)	;  AND, IF WE
	TRNE	T2,LDRDSD##	;  ARE A DATA-SET LINE
	IORI	T1,DTY.MC	;  WE CAN PERFORM MODEM CONTROL.
	XMT	T1		;WRITE THE "ATTRIBUTES"

	EXCH	U,-1(P)		;GET PCB BACK, PRESERVE LDB ADDRESS
	JSP	T1,NETWRC##	;GO SEND THE MESSAGE
	PJRST	UPOPJ1##	;GIVE GOOD RETURN NOW THAT MESSAGE HAS GONE
;VTMENQ	ROUTINE TO QUEUE A VTM FOR PROCESSING.
;CALL	U := ADDR OF THE LDB TO QUEUE
;RETURN	CPOPJ			;WITH THE LINE QUEUED
VTMENQ::
IFN PARANOID&P$VTM,<		;IF WE'RE BEING CAREFUL,
	TRNN	U,-1		;MAKE SURE THAT WE'VE GOT A LDB POINTER
	PUSHJ	P,NTDSTP##	;STOP IF "U" := 0
>
	SCNOFF			;NO JOSTLING IN THE WAITING ROOM PLEASE.
	MOVSI	T1,LRLQED##	;GET THE "LDB ALREADY QUEUED BIT"
	TDNE	T1,LDBREM##(U)	;  AND SEE IF WEVE ALREADY BEEN QUEUED
	JRST	SONPPJ##	;IF ALREADY QUEUED, WE'RE DONE.
	IORM	T1,LDBREM##(U)	;MARK THIS LDB AS QUEUED.
	MOVE	T1,VTMQUE##	;GET THE FIRST QUEUE ENTRY
	HRRM	T1,LDBVTQ##(U)	;MAKE OUR LDB POINT TO IT.
	HRRZM	U,VTMQUE##	;MAKE OUR LDB THE HEAD OF THE LIST.
	JRST	SONPPJ##	;RE-ENABLE INTERRUPTS AND RETURN

;VTMDEQ	ROUTINE TO REMOVE A LINE FROM THE VTMQUE.
;CALL	U := POINTER TO THE LDB TO DE-QUEUE (CALLED BY VTMLOC ONLY)
;RETURN	CPOPJ			;WITH THE LINE DEQUEUED, BUT THE "QUEUED BIT"
;				;  STILL ON (SO LINE WON'T GET RE-QUEUED BY
;				;  AN INTERRUPT)
VTMDEQ:	SCNOFF			;NO INTERRUPTS WHILE THIS IS GOING ON.
	MOVSI	T1,LRLQED##	;GET THE "THIS VTM IS QUEUED BIT"
	TDNN	T1,LDBREM##(U)	;  AND SEE IF WE THINK IT IS QUEUED
	JRST	[IORM T1,LDBREM##(U) ;IF NOT, SET BIT TO PREVENT RE-QUEUE
		 JRST SONPPJ##]	;  AND WE'RE DONE
	HRRZ	T1,VTMQUE##	;GET ADDR OF FIRST LDB IN THE QUEUE
	CAIN	T1,(U)		;  AND SEE IF WE'RE FIRST
	JRST	[HRRZ T1,LDBVTQ##(U) ;GET POINTER TO THE "NEXT" LDB
		 HRRZM T1,VTMQUE##   ;  AND MAKE THAT THE "FIRST"
		 JRST SONPPJ##]	;EXIT WITH LINE DE-QUEUED.
	MOVEI	T2,(T1)		;REMEMBER THE ADDRESS OF THE "LAST" LDB
VTMDE1:	HRRZ	T1,LDBVTQ##(T1)	;STEP TO THE "NEXT" LDB
	CAIN	T1,(U)		;IF THIS LDB IS THE ONE WE WANT,
	JRST	[HRRZ T1,LDBVTQ##(T1) ;GET THE ADDR OF THE ONE AFTER THAT
		 HRRM T1,LDBVTQ##(T2) ;  AND PUT IT IN OUR PLACE
		 JRST SONPPJ##]	;EXIT WITH THE LINE DE-QUEUED.
	JUMPN	T1,VTMDE1	;LOOP UNTIL WE FIND THE LINE.
	PUSHJ	P,NTDSTP##	;++ LRLQED SET BUT LINE NOT QUEUED.
;VTMPRL	ROUTINE CALLED WHEN A PTY IS RELEASED.  IF SET-HOSTED,
;	A DISCONNECT IS QUEUED
;CALL	U := LDB
;	PUSHJ	P,VTMPRL
;RETURN	POPJ	P,		;ALWAYS.

VTMPRL::SKIPL	LDBREM##(U)	;IF NOT A "SET HOSTED" LINE,
	POPJ	P,		;  THEN RETURN NOW
	MOVSI	T1,LRLDIP##	;OTHERWISE GET THE DISCONNECT REQUEST BIT
	IORM	T1,LDBREM(U)	;  AND SET IT
	PJRST	VTMENQ		;QUEUE THE LINE AND RETURN
;VTMJIF	ONCE/JIFFY PROCESSING FOR VTMS.
;CALL	PUSHJ	P,VTMJIF	;FROM JIFFY CODE IN NETSER
;RETURN	CPOPJ			;ALWAYS (WITH VTMQUE PROCESSED)
VTMJIF::SKIPN	VTMQUE##	;JUST A QUICKY CHECK (SINCE WE GET HERE A LOT)
	POPJ	P,		;VTMQUE IS EMPTY.
	SCNOFF			;GET THE SCNSER INTERLOCK.
	HRRZ	U,VTMQUE##	;GET THE NEXT ENTRY
	JUMPE	U,SONPPJ##	;?? SOME ONE SNUCK IN.
	HRRZ	T1,LDBVTQ##(U)	;GET THE ADDRESS OF THE NEXT ENTRY
	HRRZM	T1,VTMQUE##	;  AND MAKE THAT LDB BE THE NEW "FIRST"
	MOVSI	T1,LRLQED##	;GET THE "THIS LDB IS QUEUED" BIT
	ANDCAB	T1,LDBREM##(U)	;  AND CLEAR IT SO WE CAN RE-QUEUE LATER.
	SCNON			;RE-ENABLE INTERRUPTS
	TLNN	T1,LRLCON##	;MAKE SURE WE'RE CONNECTED
	JRST	VTMJIF		;IF NOT CONNECTED YET, DON'T PROCESS
				;  (THIS HAPPENS WHEN WE RUN OUT OF CHARS
				;  AND "ZAPBUF" IN SCNSER RE-QUEUES THE
				;  LINE BEFORE THE CONNECT FINISHES)
	TLNE	T1,LRLDIP##	;IF WE WANT TO SEND A DISCONNECT-INIT
	JRST	VTMJI1		;  THEN SEE IF WE ALREADY HAVE
	LDB	T1,LDPRNN##	;GET THE NUMBER OF THE NODE WE'RE TALKING TO
	PUSHJ	P,SRCNDB##	;SET W := A POINER TO THE NODES NDB
	  PUSHJ	P,NTDSTP##	;++ SHOULD HAVE CAUGHT THIS AT VTMNWD?
	PUSHJ	P,VTMSCN	;GO DO WHATEVER IS NECESSARY FOR THE VTM
	  PJRST	VTMENQ		;  IF NO CORE. REQUEUE LINE, AND WAIT TILL
				;  NEXT JIFFY.
	PUSHJ	P,VTMXDQ	;TRY TO SEND DATA-REQUESTS
	  PJRST	VTMENQ		;REQUEUE IF NO CORE
	JRST	VTMJIF		;LOOP OVER ALL LINES IN VTMQUE.
;HERE SEE IF WE NEED TO SEND A DISCONNECT FOR THIS TERMINAL

VTMJI1:	LDB	T1,LDPSLA##	;GET THE SOURCE LAT ADDRESS
	SKIPN	T1		;MAKE SURE WE HAVE ONE
	PUSHJ	P,NTDSTP##	;++ NO LAT ADDRESS FOR VIRTUAL TERMINAL?
	LDB	T2,LATSTA##	;GET OUR CONNECTION STATE
	CAIE	T2,LAT.OK	;IF WE'RE NOT IN "OK" STATE
	JRST	VTMJIF		;  THEN WE'VE SEND THE DISCONNECT. NEXT TERMINAL
	LDB	T1,LDPRNN##	;GET THE REMOTE NODE NUMBER
	PUSHJ	P,SRCNDB##	;SET UP "W" WITH THE NDB ADDRESS
	  PUSHJ	P,NTDSTP##	;++ BUT VTMNWD SHOULD HAVE CAUGHT THIS
	MOVEI	T1,RSN.OK	;REASON = GOODNIGHT
	PUSHJ	P,TRMXDC##	;SEND THE DISCONNECT
	  PJRST	VTMENQ		;REQUEUE THE LINE IF NO CORE
	JRST	VTMJIF		;OTHERWISE GO DO THE NEXT LINE
VTMEND::END			;END OF NETWORK VIRTUAL TERMINAL SERVICE
