TITLE	ONCE - ONCE ONLY OPERATOR DIALOGUE AND I/O DEVICE INITIALIZATION V1024
SUBTTL	T. HASTINGS/CHW/RCC/AF/DAL	27 SEP 83
	SEARCH	F,S
	$RELOC
	$LOW

stupid==-1			;[JE] Fixes for KICKI.

	.DIRECTIVE	FLBLST		;CLEANER LISTINGS

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>



;DATE		LOAD	EDIT #
;----		----	------


;09-SEP-80	70115	764
;9397 MCO
;16-SEP-80	70116	765
;9404 MCO
;20-JAN-81	70135	766
;27-JAN-81	70136	767
;9548
;03-FEB-81	70137	770
;9555-
;7-APR-81	70150	771
;14-APR-81	70151	772
;05-MAY-81	70154	773
;9713-
;09-JUN-81	70161	774
;23-JUN-81	70163	775
;9778
;14-JUL-81	70166	776
;9824
;21-JUL-81	70167	777
;9827
;20-OCT-81	70112	1000
;27-OCT-81	70113	1001
;03-NOV-81	70114	1002
;10-NOV-81	70115	1003
;MCO 9963
;12-JAN-82	70126	1004
;19-JAN-82	70127	1005
;2-FEB-82	70132	1006
;16-FEB-82	70133	1007
;10109
;31-AUG-82	70166	1010
;14-sep-82	70170	1011
;10401
;28-SEP-82	70172	1012
;10428
;16-NOV-82	70112	1013
;08-DEC-82	70115	1014
;21-DEC-82	70116	1015
;08-FEB-83	70124	1016
;22-FEB-83	70126	1017
;12-JULY-83	70151	1020
;10836
;23-AUG-83	70157	1021
;10908
;30-AUG-83	70160	1022
;10936
;20-SEP-83	70163	1023
;10957
;27-SEP-83	70164	1024
;10977
;

XP VONCE,024
		;PUT VERSION NUMBER IN GLOB LISTING AND LOADER STORAGE MAP



;"ONCE" SHOULD BE THE LAST LOADED PROGRAM (AFTER SYSMAK AND DDT)

; THUS IF IT OVERFLOWS INTO THE USER AREA NO HARM IS DONE.
;HOWEVER, SINCE THE DISK REFRESHING ROUTINES HAVE NOW
; BEEN MADE INTO SEPARATE SUBPROGRAMS FOR LEVEL C
; (FHDREF, MDFREF, DPDREF, ETC.), THEY MAY BE LOADED FOLLOWING ONCE.
;HOWEVER, HOWEVER, UNDER LEVEL D, "ONCE" MUST BE LOADED AFTER
; REFSTR AND ONCMOD SINCE ONCEND IS USED AS THE STARTING ADDRESS OF
; FREE CORE USED BY DATA STUCTURES CREATED DURING ONCE TIME.


;ONCE ONLY CODE IS DIVIDED INTO 3 PARTS
; 1. MANDATORY ONCE ONLY (LINKSR) - NO CTY NEEDED
;	(GOOD FOR REPEATED STARTUPS DURING DEBUGGING)
; 2. USUAL SHORT ONCE ONLY CODE (ONCE) - CTY FOR DATE AND TIME
; 3. OPTIONAL ONCE ONLY CODE - CTY DIALOG TO CHANGE MONITOR
;	OR REFRESH DISK(S) - (ALT-MODE INSTEAD OF CR AFTER TIME)
;INITIALIZE PRIORITY CHANNELS AND SETUP INTERRUPT SERVICE ROUTINE CHAIN

;LINK TO SERVICE ROUTINES


LINKSR::0			;CALLED WITH JSR FROM SYSINI
	SKIPN	JRSTI1		;BEEN THROUGH JRSTI1 ALREADY?
	JSR	JRSTI1		;SETUP LOCS 40 THRU 61 & TEST FOR 2 RELOC HARDWARE
	MOVE	P,.CPNPD##


;INITIALIZE DISK(S)

	PUSHJ	P,FILMAN##	;INITIALIZE ALL DISK(S)
				; BEFORE OVERWRITING ONCE WITH DDB'S

	MOVE	T1,JRSTI
	MOVEM	T1,LINKSR+1	;DO ONCE ONLY
	SKIPN	DEVLST##	;HAVE DEVICE DATA BLOCKS BEEN LINKED ?
	JRST	LINKDB##	;NO, GO LINK DATA BLOCKS
				;RETURN @LINKSR
				;MULTIPLE DEVICE DATA BLOCKS ARE CREATED
				;AS SPECIFIED BY SYSSIZ AND MAY ERASE PART
				;OF ONCE ONLY CODE
JRSTI:	JRST	@LINKSR		;YES, RETURN

;CODE TO SET MONITOR FOR DEBUGGING SESSION WITH EXEC DDT
;MAKE STARTUP BE FAST
;SYSTEM PROGRAMMER TYPES DEBUG$G TO START MONITOR
;ALLOW SAME COPY OF MONITOR TO BE USED FOR REGULAR SYSTEM
;SIMPLY BY NOT STARTING AT DEBUG.

DEBUG::	MOVEI	T1,DDTEND##	;END OF DDT
	HRRM	T1,PATSIZ	;INCLUDE DDT IN SYSTEM SIZE
IFN FTLOCK,<
	MOVEI	T1,0		;NO LIMIT TO AMOUNT OF LOCKED CORE
	HRRM	T1,LOKLIM##	;
>
	SETOM	ERROK##		;SHUT UP ONCMOD
	SKIPA	T1,.+1		;OPR

;PATCH DDTOPR - SIXBIT OPR FOR DEBUGGING
DDTOPR:	SIXBIT	/CTY/		;ASSUME CTY - PATCH TO OTHER
	MOVEM	T1,DEVOPR##	;OPR SIXBIT NAME

	MOVSI	T1,(DF.SBD+DF.NAR)	;
	IORM	T1,DEBUGF##	;FLAG DEBUGGING MODE
				; SO WHY RELOAD, LONG DIALOG
				; UNITS OFF-LINE NOT ASKED
				;ALSO, CHANGES .SET CORMIN TO JUMP TO EDDT.
				; RETURN IS BY GOBACK$G
				;ALSO, NOTICES 21 NON-ZERO (OR S.S.6 ON KI-10)
				;  RETURN IS BY GOBACK$G
	MOVEI	T1,ST.NRT	;TURN OFF REMOTE
	IORM	T1,STATES##	;TTY'S
	JRST	SYSDSP##	;START UP SYSTEM (400)
;SUBROUTINE TO BUILD UP COMMAND STRING FOR BOOTS
;
BOOTFX:	SKIPN	U,BOOTSA##	;PHYSICAL ADDRESS OF BOOTS DATA PAGE
	JRST	BOOTF1		;SKIP THIS IF OLD BOOTS
	ADDI	U,1000		;ADDRESS OF BOOTS
	MOVE	W,U		;W NON-ZERO
	PUSHJ	P,REFMEM##
	CAMN	T1,[CONO APR,200000] ;SANITY CHECK
	JRST	BOOTF2		;MUST BE BOOTS WHICH READ THE MONITOR
BOOTF1:	MOVEI	U,ONCEND+40000	;FIRST PAGE TO LOOK IN
	ANDI	U,740000	;CLEAR LOW BITS
IFE FTKL10,<
	ADDI	U,36000		;OFFSET FROM START OF BLOCK TO START OF BOOTS
>
IFN FTKL10,<
	ADDI	U,34000		;RH20 BOOTS STARTS AT XX4000
>
	MOVEI	W,0		;ASSUME NO BOOTS
	MOVEI	T2,CORBLK##
	LSH	T2,P2WLSH##
BOOTLP:	PUSHJ	P,REFMEM##
	CAMN	T1,[CONO APR,200000]	;IS THIS BOOTS?
	MOVE	W,U		;YES--REMEMBER THE PLACE
IFN FTKL10,<
	TRNN	U,3000
	ADDI	U,1000
>
	ADDI	U,1000
	TRNE	U,2000
	JRST	BOOTLP
IFE FTKL10,<
	ADDI	U,36000		;NO--STEP TO NEXT 16K BLOCK
>
IFN FTKL10,<
	ADDI	U,34000
>
	CAMGE	U,T2		;DID WE FALL OFF THE END
	JRST	BOOTLP		;NO--KEEP LOOKING
IFN FTKI10,<
	CONO	APR,NXM##	;CLEAR NXM FLAG SINCE WE MAY HAVE SET IT
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM
>
IFN FTKS10,<
	WRAPR	SP.CSF+SP.NXM
>
	JUMPE	W,CPOPJ		;EXIT IF NO BOOTS ELSE R CONTAINS THE
				; ADDRESS OF THE HIGHEST BOOTS IN CORE. WE
				; USE THE HIGHEST TO AVOID FINDING A
				; MATCH IN THE SYMBOL TABLE.
BOOTF2:	SUBI	W,1000		;POINT TO DATA PAGE
	MOVE	U,W
	ADDI	U,140		;ANY DEVICE?
	PUSHJ	P,REFMEM##
	MOVEM	T1,DEVICE
	ADDI	U,1		;FILE NAME
	PUSHJ	P,REFMEM##
	MOVEM	T1,FNAME
	ADDI	U,1		;EXTENSION
	PUSHJ	P,REFMEM##
	HLLZM	T1,FEXT
	ADDI	U,1		;PPN
	PUSHJ	P,REFMEM##
	MOVEM	T1,PPN
	SKIPL	BOOTSA##	;MONBTS SETS SIGN BIT OF BOOTSA
	POPJ	P,		;OLD BOOTS, NO SFD LIST
	MOVSI	W,-5		;NEED 5 WORD OF SFD LIST
BOOTO1:	ADDI	U,1		;STEP TO NEXT WORD
	PUSHJ	P,REFMEM##	;GET IT
	MOVEM	T1,SFDLST(W)	;STORE IT
	AOBJN	W,BOOTO1	;GET THEM ALL
CPOPJ:	POPJ	P,		;DONE
BSTRNG:	JUMPE	W,CPOPJ		;RETURN IF COULDN'T FIND BOOTS
	MOVEI	T1,BOOTYO	;ROUTINE TO BUILD UP STRING
	MOVEM	T1,.CPTOA##	; SAVE AS TTY OUTPUT ROUTINE
	MOVE	T1,[POINT 7,BOOTXT##]	;BYTE POINTER
	MOVEM	T1,BOOTBP	;STORE THE POINTER
	MOVEI	T1,[ASCIZ ./D .];FIRST DO A DUMP
	PUSHJ	P,CONMES##	; ..
	SKIPN	T2,DEVICE	;A DEVICE SPECIFIED?
	POPJ	P,		;NO, LEAVE DEFAULT ALONE
	MOVEM	T2,STRMON##
	PUSHJ	P,PRNAME##	;YES--PUT IN COMMAND STRING
	MOVEI	T1,[ASCIZ /:/]	;DELIMIT WITH A COLON
	PUSHJ	P,CONMES##	; ..
	SKIPN	T2,FNAME	;FILE NAME?
	JRST	BSTRN2		;NO
	MOVEM	T2,FILMON##
	PUSHJ	P,PRNAME##	;PUT IN NAME
	HLLZ	T2,FEXT		;PICK UP EXTENSION
	JUMPE	T2,BSTRN2	;NONE--LOOK FOR PPN
	MOVEM	T2,EXTMON##
	LSH	T2,-6		;PUT IN A DOT
	TLO	T2,(16B5)	; ..
	PUSHJ	P,PRNAME##	;TOSS IN EXT
BSTRN2:	SKIPN	T2,PPN		;A PPN?
	JRST	BSTRN5		;NO
	MOVEM	T2,PPNMON##
	PUSHJ	P,PRLBK##	;FIRST A BRACKET
	HLRZ	T1,PPN		;GET PROJECT
	PUSHJ	P,PRTDI8##	;PRINT IN OCTAL
	PUSHJ	P,PRCOM##	;ADD A COMMA
	HRRZ	T1,PPN		;GET PROG NUMBER
	PUSHJ	P,PRTDI8##	;PRINT PROG
	PUSH	P,P1		;SAVE P1
	MOVSI	P1,-5		;SETUP AOBJN POINTER TO SFDLST
BSTRN3:	SKIPN	T2,SFDLST(P1)	;NEXT SFD SPECIFIED?
	JRST	BSTRN4		;NO
	PUSHJ	P,PRCOM##	;PRINT COMMA
	PUSHJ	P,PRNAME##	;PRINT SFD NAME 
	AOBJN	P1,BSTRN3	;LOOP FOR ALL
BSTRN4:	POP	P,P1		;RESTORE P1
	PUSHJ	P,PRRBK##	;ADD IN RIGHT SQUARE BRACKET
	MOVE	T1,[SFDLST,,SFDMON##] ;COPY SFD LIST TO
	BLT	T1,SFDMON##+4	;WHERE MONITOR WANTS IT
BSTRN5:	MOVEI	T3,15
	IDPB	T3,BOOTBP
	MOVEI	T3,0
	IDPB	T3,BOOTBP
	POPJ	P,0

BOOTYO:	IDPB	T3,BOOTBP	;STORE BYTE IN STRING
	POPJ	P,0		;RETURN

BOOTBP:	POINT	7,BOOTXT##	;RELOAD STRING POINTER

;ONCE ONLY CODE - OPERATOR SETUP DIALOGUE

	DEFINE	SETTYO <PUSHJ P,OTSET>
	DEFINE	TYPE <PUSHJ P,COMTYO##>
	DEFINE	NEXTC <PUSHJ P,COMTYI##>

PATFIX:	0			;ROUTINE TO FIXUP FOR PATCHES
	MOVE	T1,[RADIX50 4,PAT]
	MOVE	T2,.JBSYM##	;FIND "PAT" GLOBAL
	SETZM	MSTCKS##
	JUMPGE	T2,PATSIZ
PATLOP:	PUSHJ	P,PATMAP
	MOVE	T3,(T4)
	EXCH	T3,MSTCKS##
	ROT	T3,1
	ADD	T3,MSTCKS##
	EXCH	T3,MSTCKS##
	TLNN	T2,1
	AOBJN	T2,PATLOP
	PUSHJ	P,PATMA1
	CAMN	T1,(T4)
	JRST	GOTPAT		;YES
PATLO1:	AOBJN	T2,PATLOP	; ..LOOPING
	JRST	PATSIZ		;NOT FOUND
GOTPAT:	PUSHJ	P,PATMAP
	HRRZ	T3,(T4)
	HRRZ	T4,PATSIZ	;CHECK WITH PATCHED INDICATION
	CAILE	T3,(T4)		;USE MAX
	HRRM	T3,PATSIZ
	JRST	PATLO1
PATSLT:	0			;LAST PHYSICAL PAGE MAPPED
PATMA1:	HRRZ	T3,T2
	SOJA	T3,.+2
PATMAP:	HRRZ	T3,T2
	IDIVI	T3,PAGSIZ##
	MOVEI	T4,.ECKSM(T4)
	CAMN	T3,PATSLT
	POPJ	P,
	MOVEM	T3,PATSLT
	EXCH	T4,.CPMAP##
IFE FTKLP,<
	TRO	T3,PM.ACC+PM.WRT
	HRRM	T3,.MECKS(T4)
>
IFN FTKLP,<
	HRLI	T3,(<PM.DCD>B2+PM.WRT)
	MOVEM	T3,.ECKSM/PAGSIZ##(T4)
>
	EXCH	T4,.CPMAP##
	CLRPGT	(0,.ECKSM)
	POPJ	P,
PATSIZ::MOVEI	T1,PAT##	;SET SIZE OF SYSTEM TO BEGINING OF PATCH AREA IN CASE
	MOVEM	T1,SYSSIZ##	; ONCE ONLY DIALOG RESTARTED BEFORE OVERWRITTEN
				;PATSIZ SHOULD BE UPDATED EVERY TIME A PATCH IS MADE
PATSI3:	MOVSI	T2,-^D12	;NUMBER OF EDDT BREAKPOINTS
	CAIA			;ENTER LOOP
PATSI4:	ADDI	T2,$2B##-$1B##-1;OFFSET TO NEXT BREAKPOINT
	SKIPG	$1B##(T2)	;THIS BREAKPOINT SET?
	AOBJN	T2,PATSI4	;NO, CHECK THE REST
	JUMPGE	T2,PATNBK	;IF .GE. 0 THEN NO BREAKPOINTS SET
	CAIL	T1,DDTEND##	;YES--SEE IF EDDT
	JRST	PATNBK		;YES--CONSISTENT SO PROCEED
;HERE WHEN BREAKPOINTS BUT NO EDDT
	MOVEI	T1,[ASCIZ /?Breakpoints but no EDDT
Do you want to keep EDDT? (Y or <CR>) /]
	PUSHJ	P,YESNO		;ASK QUES. GET ANSWER
	  JRST	.+2		;NO--REMOVE BREAKPOINTS
	JRST	PATKBK		;YES--KEEP EDDT
	MOVEI	T1,[ASCIZ /Type "$B $P"
/]
	PUSHJ	P,ICONM		;OUTPUT STATEMENT
	PUSHJ	P,OPOUT		;ISSUE IT
	XCT	BPTXCT##	;FORCE A BREAKPOINT
	JRST	PATSI3		;CHECK AGAIN
PATKBK:	MOVEI	T1,DDTEND##	;KEEP EDDT
	MOVEM	T1,SYSSIZ##
PATNBK:	MOVSI	T2,(CAI)
	CAIL	T1,DDTEND##	;SEE IF EDDT INTACT
	TDZA	T3,T3		;YES--CLEAR MASK (PRESERVE DEBUGF BITS)
	SKIPA	T3,[DF.BPT]	;GET MASK OF ALL CPUS
	HLLM	T2,IOG5##	;LEAVE 401 ALONE
	ANDCAM	T3,DEBUGF##	;CLEAR CPU MASK IF NO EDDT
	PUSHJ	P,CPUDDT##	;MAKE SURE CPUS CAN ENTER EDDT
	JRST	@PATFIX		

	ENTRY	ONCE
ONCE::	0
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT+NUPMPP##
	HRLM	T1,NLUPMP##+.MUPMP
	HRRM	T1,NLUPMP##+.MUUPM
>
IFN FTKLP,<
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP##]
	MOVEM	T1,NLUPMP##+.UPMAP/PAGSIZ##
	MOVEM	T1,NLUPMP##+.UPMP/PAGSIZ##
	MOVEM	T1,NLUPMP##+.UUPMP/PAGSIZ##
>
	CLRPGT	(0)

	MOVE	P,.CPNPD##	;WE NEED A PUSH DOWN LIST
HIDONE:	JFCL	HIGHIN		;PATCHED TO A JRST WHEN THE HIGH SEGMENT HAS
				; BEEN MAPPED (TO MAKE RESTARTS WORK)
	PUSHJ	P,BOOTFX	;FIND OUT WHERE THE MONITOR WAS READ FROM
IFE FTEXE,<
	PUSH	P,R		;SAVE THE ADDRESS OF BOOTS
	MOVE	T1,SYSTEM	;DEFAULT READ-FILE NAME
	SKIPN	FNAME		;NAME SUPPLIED?
	MOVEM	T1,FNAME	;NO. PLUG IN DEFAULT.
	PUSH	P,FEXT		;SAVE THE EXTENSION THAT THE OPR TYPED
	PUSH	P,DEVICE	;AND THE FILE NAME
	MOVSI	T1,(SIXBIT /SHR/)
	MOVEM	T1,FEXT		;TRY 'SHR' FIRST
	SETZB	S,P1		;ZERO ACS THAT ARE USED IN LOOKUP/READ
	PUSHJ	P,LOOK		;LOOKUP FNAME.SHR
	  CAIA			;NOT FOUND
	JRST	ONCE0		;FOUND, GO READ IT
	MOVSI	T1,(SIXBIT /HGH/)
	MOVEM	T1,FEXT		;TRY 'HGH'
	MOVE	T1,(P)		;GET THE DEVICE BACK
	MOVEM	T1,DEVICE	;DO THE LOOKUP ON THE DEVICE THE OPR SAID
	PUSHJ	P,LOOK		;TRY TO FIND FILE
	  PUSHJ	P,ERROR		;NOT FOUND, LOSE
ONCE0:	POP	P,DEVICE	;RESTORE THE DEVICE NAME THE OPR TYPED FOR
				; AUTO-RELOAD
	POP	P,FEXT		; AND THE EXTENSION
	MOVE	T1,LENGTH	;LENGTH OF THE FILE
	TRZE	T1,PG.BDY##	;ROUND UP TO A PAGE BOUNDARY
	ADDI	T1,PAGSIZ##	; ..
>;END IFE FTEXE
IFN FTEXE,<
	MOVEI	T1,MONTOP-MONORG ;HIGHEST ADDRESS CONTAINING DATA IN THE HI SEG
	TRZE	T1,PG.BDY##	;ROUND UP
	ADDI	T1,PAGSIZ##	;LENGTH OF THE HIGH SEGMENT IN WORDS
>;END IFN FTEXE
	MOVEM	T1,SYSLEN##	;STORE THE LENGTH OF THE HIGH SEGMENT
	PUSHJ	P,SUNXMT	;SETUP NXMTAB AND FIND HIGHEST EXISTANT
				; PAGE IN MEMORY
	MOVSI	T1,(JFCL)	;PATCH OUT CALL TO SETUP NXMTAB TO READ IN
	MOVEM	T1,BNXMTS##	; BOOTS IF DEBUGGING
	MOVEM	T4,SYSORG##	;STORE HIGHEST ADDRESS AS WHERE TO START ALLOCATING
	LSH	T4,W2PLSH##	;PAGE NUMBER OF HIGHEST EXISTANT PAGE
	MOVE	T1,T4
	TRZE	T1,PG.BDY##	;ROUND UP TO 256K BOUNDARY
	ADDI	T1,PP256K##
	IDIVI	T1,^D36
	MOVNI	T1,1(T1)	;NUMBER OF WORDS IN NXMTAB
	HRLI	T1,NXMTAB##
	MOVSM	T1,NXMPTR##	;STORE AOBJN POINTER
IFN FTKL10&FTMBTS,<
	MOVE	T1,UCDADR##	;ADDRESS OF THE DX20 MICROCODE
	MOVEM	T1,MONPFF##	;KLUDGE TO GET GETPPG TO DO IT HERE
	HLRZ	T1,UCDSIZ##	;NUMBER OF PAGES NEEDED
	SKIPE	UCDADR##	;SKIP THIS IF NO MICROCODE
	PUSHJ	P,GETPPG	;MARK THE PAGES AS IN USE
	  SETZM	UCDADR##	;CAN'T DO IT SO INDICATE NO MICROCODE
>
	MOVE	T1,SYSLEN##	;NUMBER OF WORDS IN CODE SEGMENT
IFE FTKLP,<
	MOVEI	T2,PM.ACC+PM.WRT+IFE FTKI10,<PM.CSH> ;MAP BITS
>
IFN FTKLP,<
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.CSH)
>
	PUSHJ	P,ONCMAP##	;FILL IN MAP SLOTS
IFE FTEXE,<
	PUSHJ	P,RFILE		;READ THE HIGH SEGMENT
	POP	P,R		;RESTORE THE ADDRESS OF BOOTS
>;END IFE FTEXE

IFN FTEXE,<
	HRRZ	T1,JOBFF##	;GET HIGHEST ADDRESS IN THE MONITOR'S LOWSEG
	SUBI	T1,1		;POINT TO LAST WORD USED
	TRO	T1,PG.BDY##	;SET TO END OF THAT PAGE
	ADD	T1,SYSLEN##	;HIGHEST ADDRESS - 1 IN THE MONITORS HI SEG
	LSH	T1,W2PLSH##	;CONVERT TO HIGHEST PAGE - 1
	MOVE	T2,.CPMAP##
IFE FTKLP,<
	MOVEI	T1,PM.ACC(T1)	;ALLOW READING
	HRRM	T1,.MECKS(T2)
>
IFN FTKLP,<
	HRLI	T1,(<PM.DCD>B2)
	MOVEM	T1,.ECKSM/PAGSIZ##(T2)
>
	HRRI	T1,MONORG	;STARTING VIRTUAL ADDRESS OF THE MONITORS HI SEG
	ADD	T1,SYSLEN##	;HIGHEST VIRTUAL ADDRESS IN MONITORS HI SEG
	HRRZ	T2,T1		;COPY THAT
	MOVE	T3,SYSLEN##	;LENGTH OF THE MONITORS HI SEG
	LSH	T3,W2PLSH##	;NUMBER OF PAGES IN THE MONITORS HI SEG
	HRLI	T1,.ECKSM	;BLT HIGH SEG FROM THIS V.A.
ONCE5:	CLRPGT	(0,.ECKSM)	;LET THE PROCESSOR KNOW ABOUT THE CHANGE IN THE MAP
	SUBI	T1,PAGSIZ##	;DESTINATION
	PUSH	P,T1		;SAVE ACROSS THE BLT
	BLT	T1,-1(T2)	;BLT A PAGE OF THE HIGH SEG FROM WHERE IT
				; WAS READ TO WHERE IT IS TO LIVE
	MOVE	T1,.CPMAP##
IFE FTKLP,<
	SOS	.MECKS(T1)	;POINT THE MAP AT THE NEXT LOWEST PAGE
>
IFN FTKLP,<
	SOS	.ECKSM/PAGSIZ##(T1)
>
	POP	P,T1		;RESTORE THE BLT POINTER
	SUBI	T2,PAGSIZ##	;NEXT LOWEST PAGE BOUNDARY
	SOJG	T3,ONCE5	;LOOP UNTIL ALL HI SEG PAGES HAVE BEEN MOVED
	MOVSI	T1,(JRST)	;PREVENT ANOTHER ATTEMPT TO SETUP THE
	HLLM	T1,HIDONE	; MAPPING FOR THE HIGH SEGMENT
>;END IFN FTEXE
HIGHIN:	PUSHJ	P,BSTRNG	;CONVERT ARGUMENTS TO BOOTS TO A STRING
				; FOR AUTO-RELOAD
	SETZM	BOOTSA##	;CLEAR BOOTS PHYSICAL ADDRESS
	SETOM	DINITF##	;TELL AUTCON WHAT KIND OF CORE TO GET
IFN FTKLP,<
	MOVSI	T1,(MDSEC1)	;DATA SECTION FOR SATS, ETC.
	MOVEM	T1,RELMD1	;FIRST ALLOCATED WORD IN SECTION 2
	MOVEM	T1,FFMD1	;FIRST FREE WORD IN SECTION 2
	PUSHJ	P,ALCSMP	;ALLOCATE A MAP FOR THIS SECTION
	MOVSI	T1,(MDSEC2)	;DATA SECTION FOR PAGTAB/MEMTAB
	PUSHJ	P,ALCSMP	;ALLOCATE A SECTION MAP FOR SECTION 2
>
IFN FTAUTC,<
IFN FTKI10,<
	MOVE	T1,[XWD LOC40,.EPIL##]	;SETUP LOWER CORE PI LOCATIONS
	BLT	T1,.EPIL##+LOC40E-1	; SINCE AUTCON NEEDS TO SET UP SKIP-CHAIN
>
	MOVE	T1,MONVFF##	;WHERE TO START ALLOCATION
	MOVEM	T1,CORLOC##	;TELL AUTCON
	PUSHJ	P,AUTCON##	;SEE WHAT DISKS, TAPES WE HAVE
>
IFN FTKL10!FTKS10,<
	PUSHJ	P,ONCINT	;START INTERVAL TIMER GIVING CLOCK TICKS
				; FOR ONCE, SET UP ONCKLT SO APRINT AND
				; OPRFIL CAN USE IT TO START UP TIMER AGAIN.
>;END IFN FTKL10
	SETTYO
	SKIPGE	DEBUGF##	;IF DEBUGGING DO NOT
	JRST	ONCE6		; DO SYSCHK
	HLRZ	T1,SYSCKI##
	CAIE	T1,(JSR)
	JRST	ONCE6
	MOVE	P,.CPNPD##	;SET UP A STACK
	MOVEI	T1,[ASCIZ /SYSCHK(N,Y):/]
	MOVEI	T2,[ASCIZ /NO	;Default answer/]
	PUSHJ	P,ASKDEF	;ASK THE QUESTION
	  JRST	ONCE6		;JUST CR-LF
	PUSHJ	P,ALTM##
	PUSHJ	P,COMTYI##
	CAIN	T3,"Y"
	XCT	SYSCKI##
ONCE6:	MOVE	P,.CPNPD##	;SET UP A STACK
	SKIPL	DEBUGF##
	JRST	ONCE7
	SETZM	TTFCOM##+TTFCXI##

ONCE7:	SETTYO
	PUSHJ	P,CRLF##
	JSR	MOVSTP		;MOVE .JSYM TO DDTSYM
	JSR	PATFIX
	MOVEI	T1,CONFIG##
	PUSHJ	P,CONMES##
	MOVEI	T1,[ASCIZ / /]
	PUSHJ	P,CONMES##
	MOVEI	T1,SYSDAT##
	PUSHJ	P,CONMES##
	PUSHJ	P,CRLF##	;ADD CRLF
	PUSHJ	P,OPOUT
;HERE TO DETERMINE IF THIS CPU IS A 166, KA10, OR
;  KI10 AND SETUP THE NUMBER OF CLOCK TICKS PER
;  SECOND ACCORDING TO POWER LINE FREQUENCY.


	MOVEI	F,CT.P6		;ASSUME A 166 (PDP-6) PROCESSOR
	MOVEI	T4,M.TPS##	;ASSUME LINE FREQUENCY UNKNOWN
				;EXCEPT FROM MONGEN
	JFCL	17,.+1		;CLEAR ALL FLAGS
	JRST	.+1		;SET PC CHANGE FLAG IF CPU IS A 166
	JFCL	1,CPU166	;BRANCH IF PDP-6
IFN FTKL10!FTKS10,<
	SETZ	T1,		;THE TEST FOR A KL10 PROCESSOR
	BLT	T1,0		;IS A NO-OP BLKT LEAVING AC NON-ZERO
	JUMPE	T1,CPNTLS	;JUMP IF NOT KL OR KS
	APRID	T1
	ANDI	T1,17777	;GET ONLY SERIAL NUMBER
	CAIL	T1,10000	;SKIP IF NOT KS10
	JRST	CPKS10
	JRST	CPKL10
CPNTLS:
>
	HRLOI	T1,020640	;WE HAVE A KA OR KI, FIND ITS TYPE
	IBP	T1		; ..
	TLNN	T1,1		;SKAP IF KA10
	JRST	CPKI10		;NO--MUST BE KI10
;HERE IF CPU IS A KA10.  DETERMINE LINE FREQUENCY BY
;TIMING ROTATES
;DEPENDS ON:
;MAX. POWER LINE FREQUENCY VARIATION OF PLUS OR MINUS 2 HERTZ.
;SHIFT TIME IN KA10 OF 150NS. PLUS OR MINUS 5%

	MOVEI	F,CT.KA		;REMEMBER THIS IS A KA10
;HERE IF KL10
CPKL10:
IFN FTKL10!FTKS10,<
	APRID	T1		;READ SERIAL NUMBER
	ANDI	T1,7777		;MASK OUT UCODE VER
	MOVEM	T1,.CPASN##	;SAVE AS REAL #
	MOVEI	F,CT.KL		;SET TYPE AS KL10
	JRST	CPU166		;NO CLOCK ON A KL
CPKS10:	APRID	T1		;READ SERIAL NUMBER
	ANDI	T1,77777	;MASK OUT CRUFT
	MOVEM	T1,.CPASN##	;SAVE IN CDB
	MOVEI	F,CT.KS	;SET TYPE AS KS
	JRST	CPU166		;NO LINE CLOCK ON KS
>;END IFN FTKL10!FTKS10
;HERE IF CPU IS A KI10.  CHECK APR STATUS BIT
CPKI10:	CONI	PAG,T1		;READ THE PROCESSORS SERIAL NUMBER
	LSH	T1,-^D26	;RIGHT ADJUST IT
	MOVEM	T1,.CPASN##	;STORE IT FOR PROPRIETARY PROGRAMS
	MOVEI	F,CT.KI		;REMEMBER THIS IS A KI10
	CONI	APR,T1		;GET APR STATUS
	TLNE	T1,(IP.50H)	;50 HERTZ POWER?
	SKIPA	T4,[EXP ^D50]	;50 HERTZ POWER LINE FREQUENCY
	MOVEI	T4,^D60		;60 HERTZ POWER LINE FREQUENCY
CPU166:	CAME	F,.CPTYP##	;DO WHAT THE MONITOR WAS BUILT FOR AND
				; THE CURRENT MACHINE AGREE?
	JRST	CPUBAD		;NO, GO COMPLAIN
	MOVEM	T4,TICSEC##	;NUMBER OF CLOCK TICKS PER SECOND
	MOVSI	T1,(ST.CYC)	;SET BIT SIX OF STATES IF 50 HZ POWER
	CAIN	T4,^D50		;50 HERTZ POWER?
	IORM	T1,STATES##	;YES
	IMULI	T4,^D60		;NUMBER OF TICS PER MINUTE
	MOVEM	T4,TICMIN##	;SAVE THAT
	IMULI	T4,^D60*^D24	;NUMBER OF TICS PER DAY
	MOVEM	T4,MIDNIT##	;SAVE THAT FOR MIDNIGHT CHECKING
	JRST	WHYLOP		;GO ASK WHY RELOAD

;SETUP INTERNAL TIMER ON KL10 TO MIMIC CLOCKS OF EARLIER CPUS.

IFN FTKL10,<
ONCINT:	CONO	MTR,0		;MAKE SURE INT. TIME DOESNT INTERRUPT
	MOVEI	T2,^D1666+TO.SIT+TO.CTD	;WORD TO KEEP TIMER GOING
	MOVE	T1,STATES##	;GET STATES
	TLNE	T1,(ST.CYC)	;50 HZ?
	MOVEI	T2,^D2000+TO.SIT+TO.CTD	;50 HZ WORD TO KEEP TIMER GOING
	MOVEM	T2,ONCKLT	;CONO TIM,@ONCKLT STARTS TIMER GOING AGAIN
	CONO	TIM,TO.CIT(T2)	;CLEAR INTERNAL TIMER & START FIRST TIME
	POPJ	P,		;RETURN
>;END IFN FTKL10
IFN FTKS10,<
ONCINT:	WRAPR	SP.SSF!SP.ITI	;TURN ON INTERVAL TIMER
	MOVEI	T2,^D17*10000	;60HZ
	MOVE	T1,STATES	;GET STATES
	TLNE	T1,(ST.CYC)	;50HZ?
	MOVEI	T2,^D20*10000	;YES
	WRINT	T2		;SET UP INTERVAL REGISTER
	PUSHJ	P,UBAPIS##	;INIT AND SET UP UBA PI'S
	MOVEI	T1,VECTB1##	;GET UBA1'S INTERRUPT VECTOR TABLE
	MOVEM	T1,.EPVIT##	;INITIALIZE IN EPT
	MOVEI	T1,VECTB3##	;... DITTO FOR UBA3
	MOVEM	T1,.EPVIT##+2 ;...
	POPJ	P,
>;END IFN FTKS10

;ASK OPERATOR REASON FOR RELOAD
;ANSWER WILL BE PUT IN LOG FILE DAEMON
;ALONG WITH ARBITRARY OPERATOR COMMENT, IF ANY.
;ALLOW UNIQUE ABBREVIATION

	EOL==12			;END OF LINE CHARACTER IN ONCE

WHYLOP:	SETZM	CRSHAC##	;CLEAR OUT CRASH AC AREA FOR OPERATOR COMMENT
	MOVE	T1,[XWD CRSHAC##,CRSHAC+1]
	BLT	T1,CRSHAC##+17
	SKIPL	DEBUGF##	;DEBUGGING STAND-ALONE?
	JRST	WHY0		;NO,
	MOVE	T1,SACOD	;YES, FLAG STAND-ALONE
	MOVEM	T1,WHYCOD##	;FOR DAEMON
	JRST	DATLOP		;GO ASK DATE
WHY0:	HRRZ	T1,CRSWHY##	;GET STOPCD CODE FROM PREVIOUS LOAD
	JUMPE	T1,WHY01	;JUMP IF NONE
	PUSHJ	P,CHKDCS	;CHECK DATE/TIME CHECKSUM
	  JRST	WHY01		; IF PINK CRASH
	HRLI	T1,'S..'	;YES--SET STOPCD PREFIX
	MOVEM	T1,WHYCOD##	;AND STORE AS REASON FOR RELOAD
	JRST	DATLOP		;SKIP QUESTION
WHY01:	MOVEI	T1,[ASCIZ /Why reload: /]
	MOVEI	T2,[ASCIZ /OTHER	;OPR did not answer/]
	PUSHJ	P,ASKDEF	;TYPE OUT AND WAIT FOR INPUT
	  JRST	WHYSHT		;JUST CR TYPED, GIVE SHORT HELP
	PUSHJ	P,CTEXT##	;GET FIRST WORD LEFT JUSTIFIED SIXBIT IN T2
	JUMPN	T2,WHY1		;ANYTHING BEFORE FIRST BREAK?
	CAIN	T3,"/"		;NO, IS BREAK A SLASH?
	JRST	WHYLNG		;YES, ASSUME /H AND GIVE LONG HELP
	JRST	WHYSHT		;NO, GIVE SHORT HELP

WHY1:	MOVE	P1,T3		;SAVE BREAK
	MOVE	T1,[-WHYLEN,,WHYTAB]	;POINT TO TABLE
	PUSHJ	P,FNDNAM##	;LOOKUP ABBREV.
	  JRST	WHYSHT		;GIVE HELP
	MOVE	T1,WHYTAB(T1)	;NO, GET UNABBREVIATED SIXBIT CODE
	MOVEM	T1,WHYCOD##	;AND STORE IN GETTAB FOR DAEMON
	JUMPE	P1,[CAME T1,OTHCOD ;IF END OF LINE AND RESPONSE WAS OTHER,
		    JRST DATLOP	; TELL HIM THAT OTHER REQUIRES
		    MOVEI T1,OTHMSG ; A COMMENT AND GO BACK TO WHYLOP
		    JRST WHYTYP] ; TO ASK AGAIN
;HERE TO GET OPERATOR COMMENT AND STORE IN CRASH ACS
	MOVEI	T1,20*5-1	;YES, NO. OF ASCIZ CHAR IN 20 WORDS
				;OF CRASH ACS. SAVE ROOM FOR NULL
	MOVEM	T1,WHYCNT	;STORE FOR LOOP COUNT
	MOVE	P1,[POINT 7,CRSHAC##]	;BYTE PTR FOR WHERE TO PUT
WHY4:	PUSHJ	P,COMTYI##	;GET NEXT CHARACTER (EVEN IF ;)
	JUMPE	T3,WHY5		;END OF STRING (GETLIN STORES NULL)
	CAIL	T3,12		;NO, END OF LINE CHAR?
	CAILE	T3,15		;"
	SKIPA			;NO
	JRST	WHY5		;YES, DO NOT STORE, JUST GO STORE NULL
	SOSG	WHYCNT		;ANY MORE ROOM IN CRSHAC BLOCK?
	JRST	WHY5		;NO, GO STORE NULL AND QUIT
	IDPB	T3,P1		;YES, STORE ASCIZ CHARACTER
	JRST	WHY4		;GO GET MORE

;HERE WHEN FINISHED COPYING OPERATOR COMMENT TO CRASH ACS
WHY5:	MOVEI	T3,0		;NULL
	IDPB	T3,P1		;STORE ON END SO ASCIZ
	JRST	DATLOP		;GO ASK FOR DATE

;HERE TO TYPE SHORT HELP MESSAGE ON ANY ERROR
WHYSHT:	MOVEI	T1,WHYMS1	;ADR OF SHORT HELP MESSAGE
	PUSHJ	P,ICONM		;INITIALIZE BUFFER AND MOVE CHAR
	PUSHJ	P,OPOUT		;START TYPING
	JRST	WHYLOP		;GO BACK TO ASK WHY RELOAD AGAIN

;HERE TO TYPE LONG HELP MESSAGE ON /H
WHYLNG:	MOVEI	T1,WHYMS2	;ADR OF LONG HELP MESSAGE
WHYTYP:	PUSHJ	P,ICONM		;INITIALIZE AND MOVE CHAR TO OUTPUT BUFFER
	PUSHJ	P,OPOUT		;START TYPING
	JRST	WHYLOP		;GO BACK AND ASK WHY RELOAD AGAIN

WHYCNT:	0			;COUNT FOR NO CHAR LEFT IN CRASH ACS

;LIST OF POSSIBLE WHY RELOAD ANSWERS (CAN BE ABBREVIATED)
; ORDER IS IMPORTANT. OPERATOR SHOULD ANSWER THE EARLIEST ONE
; IN TABLE WHICH APPLIES (WHEN MORE THAN ONE DOES)

WHYTAB:

;PREVIOUS SYSTEM PROBLEM:

	SIXBIT	/OPR/
	SIXBIT	/PARITY/
	SIXBIT	/POWER/
	SIXBIT	/STATIC/
	SIXBIT	/HARDWA/
	SIXBIT	/NXM/
	SIXBIT	/HALT/
	SIXBIT	/LOOP/
	SIXBIT	/HUNG/
;PREVIOUS NON-TIMESHARED USE OF SYSTEM:
	SIXBIT	/PM/
	SIXBIT	/CM/
SACOD:	SIXBIT	/SA/
;DIFFERENT MONITOR WANTED:
	SIXBIT	/NEW/
	SIXBIT	/SCHED/
;OPERATOR DOESNT KNOW OR NOT IN TABLE (YET):
OTHCOD:	SIXBIT	/OTHER/		;ALWAYS LAST OF TABLE
WHYLEN==.-WHYTAB		;LENGTH
;ADD ENTRIES IN MIDDLE ACCORDING TO PRECEDENCE, NOT AT END

;SHORT MESSAGE FOR JOGGING MEMORY
WHYMS1:	ASCIZ	"OPR,PARITY,POWER,STATIC,HARDWARE
NXM,HALT,LOOP,HUNG
PM,CM,SA
NEW,SCHED
OTHER
/H for help
"
;LONG MESSAGE FOR /H
WHYMS2:	ASCIZ	/Type first word which applies (abbreviations ok) followed by
any comment:
OPR operator error
PARITY memory parity stop
POWER power failure
NXM non-existent memory stop
STATIC static electric
HARDWARE hardware malfunction
HALT program stop

LOOP loop in exec mode
HUNG no response

PM preventative maint
CM corrective maint
SA stand alone

NEW new monitor
SCHED scheduled reload

OTHER you don't know why or not any of the above
/
BUFLEN==.-WHYMS2		;LENGTH OF ONCE TTY BUFFER
				; MAKE IT LONG ENOUGH FOR THIS BIG MESSAGE
OTHMSG:	ASCIZ	/%OTHER requires a comment
/
;ASK FOR TODAY'S DATE AND CONVERT
;DATE STORED AS ((Y-64)*12.+M-1)*31.+D-1


DATLOP:	SKIPA	T1,[[ASCIZ /Date: /]]
DATHLP:	MOVEI	T1,[ASCIZ /Please type today's date as MON-DD(-YY)
/]
	SETZM	LOCSEC##	;NO TIME KNOWN YET
	SETOM	CRSDAY		;FAR FAR DISTANT PAST
	PUSHJ	P,CHKDCS
	  JRST	GOASK
	MOVE	T2,T4		;COPY DATE
	ANDI	T2,17		;MASK OUT MONTH
	MOVEM	T2,LOCMON##	;STORE
	MOVE	T1,T4
	LSH	T1,-4		;SHIFT OFF MONTH
	MOVE	T2,T1		;COPY DATE
	ANDI	T2,37		;MASK OUT DAY
	MOVEM	T2,LOCDAY##	;STORE IN COMMON
	LSH	T1,-5		;SHIFT OFF DAY
	ADDI	T1,^D1970	;ADD IN BASE
	MOVEM	T1,LOCYER##	;STORE
	HRRZ	T1,CRSDTM##	;GET TIME
	IDIVI	T1,^D60*^D60	;GET HOURS
	IDIVI	T2,^D60		;GET MIN
	MOVEM	T1,LOCHOR##	;STORE HOURS
	MOVEM	T2,LOCMIN##	;STORE MIN
	CAIN	T3,^D60		;OVERFLOW?
	SUBI	T3,1		;YES
	MOVEM	T3,LOCSEC##	;STORE SECONDS
	PUSHJ	P,CHKMNT##	;SEE IF PASSED THROUGH MIDNIGHT WHILE RELOADING
ifn stupid,<skipn locsec##>	;Don't increment 59. to 60.
	AOS	LOCSEC##	;MAKE NON-ZERO
	PUSHJ	P,THSDA##
DATLP2:	MOVE	T1,THSDAT##
	MOVEM	T1,CRSDAY
	MOVE	T1,DEFSP	;GET DEFAULT STRING POINTER
	MOVEM	T1,DEFPTR	;STORE AS POINTER
	MOVE	T1,LOCMON##	;GET MONTH
	PUSHJ	P,DECDEF	;DO THE DEFAULT STUFF
	MOVEI	T1,"-"		;ADD A DASH
	IDPB	T1,DEFPTR	; ..
	MOVE	T1,LOCDAY##	;GET THE DAY
	PUSHJ	P,DECDEF	;STORE AS PART OF DEFAULT
	MOVEI	T1,"-"		;ADD 1 MORE DASH
	IDPB	T1,DEFPTR	; ..
	MOVE	T1,LOCYER##	;GET THE YEAR
	PUSHJ	P,DECDEF	;ADD THAT ON
	MOVEI	T1,0		;MAKE ASCIZ
	IDPB	T1,DEFPTR	;STORE
	MOVEI	T1,[ASCIZ /Date: /]
	MOVEI	T2,DEFBUF
	PUSHJ	P,ASKDEF	;ASK QUESTION
	  JRST	DATLO2
	JRST	GOASK1		;GO PARSE THE ANSWER
GOASK:	PUSHJ	P,ASKGET
	  JRST	DATHLP
GOASK1:	MOVEI	T1,LOCYER##
	PUSHJ	P,GTDATE##	;GET DATE
	  JRST	DATHLP		;ERROR
	MOVE	T2,LOCYER##
	SUBI	T2,^D1900
	CAIGE	T2,M.YEAR##
	JRST	DATHLP
	MOVE	T1,LOCMON##	;NOW CHECK DAY ARG.
	SOS	T1
	LDB	T2,PMONTB##
	AOS	T2
	SOJN	T1,DATLO1	;JUMP IF NOT FEB
	MOVE	T1,LOCYER##	;LEAP YEAR?
	TRNN	T1,3
	AOS	T2		;YES - 29 DAYS
DATLO1:	CAML	T2,LOCDAY##	;CHECK DAY ARG.
	JRST	DATLO2		;OK
	MOVEI	T1,[ASCIZ/?Illegal day
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	JRST	DATLOP

;ROUTINE TO CHECK DATE/TIME CHECKSUM
;RETURNS CRASH DATE IN T4
CHKDCS:	HLRZ	T4,CRSDTM##
	HRRZ	T2,CRSDTM##
	ADD	T2,T4		;ADD DATE AND TIME
	HRRZ	T3,CRSWHY##
	ADD	T2,T3		;PLUS STOPCD NAME
	HRRZ	T3,CRSSTS##	
	ADD	T2,T3
	ADDI	T2,507601	;PLUS MAGIC CONSTANT
	HLRZ	T3,CRSWHY##	;GET CHECKSUM COMPUTED BY COMMON
	CAIN	T3,(T2)		;MATCH?
	AOS	(P)
	POPJ	P,
DATLO2:	PUSHJ	P,THSDA##	;COMPUTE & STORE THSDAT
	MOVE	T1,THSDAT##
	CAML	T1,CRSDAY
	JRST	VALID
	MOVEI	T1,[ASCIZ /
%Specified date is prior to last crash.
Last crash date:  /]
	PUSHJ	P,ICONM
	MOVEI	T1,DEFBUF
	JRST	VALID1

;CODE TO VALIDATE THE DATE JUST TYPED IN

VALID:	MOVE	T1,ONCMON	;FORM 12 BIT DATE FOR COMPARISON
	IMULI	T1,^D31
	MOVEM	T1,CHKDAT
	MOVE	T1,ONCDAY
	SUBI	T1,1+^D31
	ADDM	T1,CHKDAT
	MOVE	T1,ONCYER
	SUBI	T1,^D64		;ADJUST TO T=0
	IMULI	T1,^D12*^D31
	ADD	T1,CHKDAT
	CAMG	T1,THSDAT##
	JRST	TIMLOP		;OK IF TODAY .GE. CREATION DAY

	MOVEI	T1,[ASCIZ /
%Specified date is prior to monitor creation date.
Creation date:  /]
	PUSHJ	P,ICONM		;QUESTION EARLY DATE
	MOVEI	T1,SYSDAT##
VALID1:	PUSHJ	P,CONMES##
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /
Specified date:   /]
	PUSHJ	P,ICONM
	MOVE	T1,LOCMON##
	PUSHJ	P,RADX10##
	PUSHJ	P,DASH
	MOVE	T1,LOCDAY##
	PUSHJ	P,RADX10##
	PUSHJ	P,DASH
	MOVE	T1,LOCYER##
	SUBI	T1,^D1900
	PUSHJ	P,RADX10##
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /
Is this correct? (Y or N)/]
	PUSHJ	P,YESNO
	  JRST	DATHLP		;NO, TRY AGAIN
	JRST	TIMLOP		;HE LIKES IT ANYWAY

DASH:	MOVEI	T1,[ASCIZ /-/]
	PJRST	CONMES##

;CONSTANTS, MONTH,DAY,YEAR FROM MONGEN

ONCMON:	M.MON##
ONCDAY:	M.DAY##
ONCYER:	M.YEAR##
CHKDAT:	Z			;LOCAL STORAGE FOR DATE (12 BIT)
CRSDAY: Z
;GET TIME OF DAY


TIMLOP:	SKIPA	T1,[[ASCIZ /Time: /]]
TIMHLP:	MOVEI	T1,[ASCIZ /Please type time as HHMMSS or HH:MM:SS
/]
	SKIPN	LOCSEC##	;DO WE KNOW TIME
	JRST	ASKTIM		;NO--GO ASK FOR IT
	MOVE	T1,DEFSP
	MOVEM	T1,DEFPTR
	MOVE	T1,LOCHOR##	;SETUP DEFAULT
	PUSHJ	P,DECDEF	; ..
	MOVEI	T1,":"
	IDPB	T1,DEFPTR
	MOVE	T1,LOCMIN##	; ..
	PUSHJ	P,DECDEF	; ..
	MOVEI	T1,":"
	IDPB	T1,DEFPTR
	MOVE	T1,LOCSEC##
	PUSHJ	P,DECDEF
	MOVEI	T1,0		; ..
	IDPB	T1,DEFPTR	; ..
	MOVEI	T1,[ASCIZ /Time: /]
	MOVEI	T2,DEFBUF
	PUSHJ 	P,ASKDEF	;GO ASK ABOUT TIME
	  JRST	HAVTIM		;JUST A CR
	JRST	ASKTM1
ASKTIM:	PUSHJ	P,ASKGET
	  JRST	TIMHLP		;JUST A CR
ASKTM1:	PUSHJ	P,RDTIM##	;GET TIME OF DAY
	  JRST	[PUSHJ	P,SVOSET## ;SETUP FOR OUTPUT
		 PUSHJ	P,ERRCRL## ;ISSUE CRLF AND ERROR MESSAGE
		 PUSHJ	P,OPOUT	;FORCE OUTPUT
		 JRST	TIMHLP]	;LOOP BACK AND TRY AGAIN
	IDIVI	T1,^D60*^D60	;T1:= HOURS
	IDIVI	T2,^D60		;T2:= MINUTES, T3:= SECONDS
	MOVEM	T1,LOCHOR##	;SAVE HOURS
	MOVEM	T2,LOCMIN##	;SAVE MINUTES
	MOVEM	T3,LOCSEC##	;SAVE SECONDS
;	PJRST	HAVTIM		;GO COMPARE AGAINST LAST CRASH TIME
HAVTIM:
IFN STUPID,<
	PUSHJ	P,SUDATE##	;Set up correct weekday.
	SETO	T1,		;Don't know about daylight savings.
	PUSHJ	P,DSTTMZ##	;Try to set up TMZWRD.
	 JRST	HAVDST
	JUMPN	T1,HAVASK
	MOVEI	T1,[		;Non-existent hour, complain and try again.
		ASCIZ	/?Non-existent hour.
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	JRST	DATLP2
HAVASK:	MOVEI	T1,[		;Ambigous, must ask about daylight savings.
		ASCIZ	/%Ambigous hour./]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[
		ASCIZ	/
Daylight savings (Y or N)/]
	PUSHJ	P,YESNO
	 TDZA	T1,T1
	  MOVEI	T1,1
	PUSHJ	P,DSTTMZ##	;Set up TMZWRD.
HAVDST:				;GMTDIF successfully set up.
>;IFN STUPID
	MOVE	T1,LOCHOR##
	MOVE	T2,LOCMIN##
	IMULI	T1,^D60		;CONVERT TO MINUTES
	ADD	T1,T2		;MINUTES SINCE MIDNIGHT
	IMUL	T1,TICMIN##	;JIFFIES SINCE MIDNIGHT
	MOVEM	T1,TIME		;TIME=JIFFIES SINCE MIDNIGHT
	MOVE	T1,LOCSEC##	;SECONDS INTO THIS MINUTE
	IMUL	T1,TICSEC##	;JIFFIES INTO THIS MINUTE
	ADDB	T1,TIME##	;TIME=JIFFIES SINCE MIDNIGHT
	HRRZ	T2,CRSDTM##
	SUBI	T2,RLDTIM##
	IMUL	T2,TICSEC##
	MOVE	T3,THSDAT##
	CAMGE	T1,T2
	CAME	T3,CRSDAY
	JRST	HAVTI1
	MOVEI	T1,[ASCIZ /
%Specified time is prior to last crash.
Specified time:  /]
	PUSHJ	P,ICONM
	PUSHJ	P,PRDTIM##
	MOVEI	T1,[ASCIZ /Last crash time:  /]
	PUSHJ	P,CONMES##
	HRRZ	T1,CRSDTM##
	SUBI	T1,RLDTIM##
	IMUL	T1,TICSEC##
	PUSHJ	P,PRTIME##
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /
Is this correct (Y or N)/]
	PUSHJ	P,YESNO
	  JRST	DATLP2
HAVTI1:	HRRZ	T1,CRSSTS##	;STATES BEFORE THE RELOAD
	TRO	T1,ST.NOP	;ASSUME NO OPR IN ATTENDANCE
	SKIPGE	DEFALW		;DID THE OPR ANSWER?
	HRRM	T1,STATES##	;NO, STORE STATES AS PREVIOUSLY SET BY OPR
	PUSH	P,J		;SAVE ALT-MODE TYPED FLAG


;MOVE SYMBOL TABLE UP IN MEMORY
;FIRST FIND THE FIRST LOCATION OF NON-EXISTENT MEMORY


	TDZA	P2,P2
BYPSY0:	TLO	P2,400000	;FOR CALLS TO A SUBROUTINE IN SYSINI
	SETZB	U,P4
	MOVEI	P1,CORBLK##	;IN CASE MEMORY HAS NO NON-EXISTANT BANKS
BYPSY1:
IFN FTKI10,<
	CONO	APR,NXM##	;CLEAR NON-EX MEM FLAG
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM ;CLEAR NXM FLAG ON A KL
>
IFN FTKS10,<
	WRAPR	SP.CSF+SP.NXM
>
BYPSY2:	ADDI	U,PAGSIZ##	;TRY NEXT 1K BLOCK
	SETZB	T2,P3
BYPS2A:	PUSH	P,U
	ADDI	U,(P3)
	PUSHJ	P,REFMEM##	;REFERENCE THIS LOCATION
	POP	P,U
	CONSO	APR,NXM##	;NON:EXISTANT?
	TLOA	T2,200000	;NO, REMEMBER EXISTANT MEMORY SEEN
	TLO	T2,400000	;YES, REMEMBER THAT
	CAIE	P3,MEMITL##-1	;LOOKED AT ENOUGH WORDS IN THIS PAGE
	AOJA	P3,BYPS2A	; TO DETECT INTERLEAVING ERROR?
	JUMPG	T2,BYPS2B	;JUMP IF NO NXM SEEN
	TLNN	T2,200000	;NXM, SOME EXISTANT ALSO?
	JRST	BYPS2C		;NO, NOT AN INTERLEAVING PROBLEM
	MOVEI	T1,[ASCIZ  /?Memory interleaving error
/]
	PUSHJ	P,ICONM		;TELL THE OPR ABOUT THE PROBLEM
	PUSHJ	P,OPOUT
	STOPCD	.,STOP,MIW,	;++MEMORY INTERLEAVING IS WRONG
BYPS2B:	SOJG	P1,BYPSY2	;NO, KEEP LOOKING AS LONG AS NOT TOP OF MEMORY
BYPS2C:	SKIPN	P4		;FIRST TIME THROUGH?
	MOVE	P4,U		;YES, REMEMBER LOCATION OF LOWEST NON-EX MEM
	SOJL	P1,BYPSY4	;ACCOUNT FOR MISSED SOJ AND SEE IF FINISHED
	MOVE	P3,U		;NOW SEE IF ANY MEMORY EXISTS HIGHER UP
BYPSY3:	;CLEAR THE NON-EX-MEM FLAG
IFN FTKI10,<
	CONO	APR,NXM##
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM
>
IFN FTKS10,<
	WRAPR	SP.CSF+SP.NXM
>
	ADDI	P3,PAGSIZ##	;TRY NEXT 1K BLOCK
	PUSH	P,U		;SAVE U
	MOVE	U,P3		;SET ARG FOR REFMEM
	PUSHJ	P,REFMEM##	;REFERENCE IT
	POP	P,U		;RESTORE U
	CONSZ	APR,NXM##	;IS IT THERE?
	SOJG	P1,BYPSY3	;NO, LOOP THROUGH ALL 256K
	SOJLE	P1,BYPSY4	;JUMP IF NO MORE EXISTANT MEMORY
	PUSHJ	P,MEMBAD	;TELL THE OPERATOR HE HAS HOLES IN MEMORY
	  JRST	BYPSY0		;HE SAID HE FIXED IT. GO SEE IF HE DID.
IFN FTMONL,<
	  JFCL			;OFF-LINE
>
	  MOVE	U,P3		;HE SAID ITS BROKEN
	JRST	BYPSY1		;GO SEE IF THERE ARE ANY MORE HOLES
BYPSY4:	SKIPL	DEBUGF##	;SYS PROG DEBUGGING MONITOR?
				; NOTE - ALREADY TOLD HIM IF HOLE IN MIDDLE
;PATCH TO NO. OF WORDS OF CORE TO BE CHECKED FOR ALL-ON-LINE
PATNWC::CAML	U,NWCORE##	;NOW SEE IF THERE IS AT LEAST AS MUCH MEMORY AS THERE
				; WAS AT MONGEN TIME
	JRST	BYPSY5		;THERE IS SO NO REASON TO COMPLAIN
	MOVE	P3,NWCORE##	;REMIND HIM OF HOW MUCH MEMORY HE HAD AT MONGEN TIME
	PUSHJ	P,MEMBAD	;TELL THE OPERATOR THERE'S NOT THAT MUCH THERE
	  JRST	BYPSY0		;HE SAID HE FIXED IT. SEE IF HE REALLY DID.
IFN FTMONL,<
	  MOVEM	U,NWCORE##	;HE SAID DOWN, DON'T ALLOCATE EXTRA CORE FOR
				; PAGTAB AND MEMTAB
				;HERE IF HE SAID OFF LINE
>

;OK, HE'S WILLING TO BRING IT UP WITHOUT ALL THE MEMORY ON LINE (LET'S HOPE ITS DOWN)
BYPSY5:
	CAMG	U,[XWD 1,0]	;MORE THAN 256K?
	SETZ	U,		;NO
	MOVEM	U,FLG256##	;SET GTR THAN 256K FLAG

	SKIPE	P2		;IF WE COMPLAINED,
	PUSHJ	P,SUNXMT
	MOVEI	U,^D112*^D1024	;NO, PUT SYMBOLS AT 112K
OLDSYM:	SKIPL	DEBUGF##	;ARE WE DEBUGGING (JFCL THIS TO USE OLD DDT)
	JRST	BYPSY7		;NO, JUST MOVE SYMBOL TABLE OUT OF HARMS WAY
	HLRE	P1,.JBSYM##	;GET LENGTH OF SYMBOL TABLE
	JUMPE	P1,STULPT	;NONE TO WORRY ABOUT
	MOVMS	P1		;GET REAL LENGTH
	HRRZ	P2,.JBSYM##	;ADDRESS OF SYMBOL TABLE
	ADDI	P1,(P2)		;FIRST ADDRESS OUTSIDE OF THE SYMBOL TABLE
	SKIPN	P2,.JBUSY##	;IN CASE ANY UNDEF'S STILL LYING AROUND
	HRRZ	P2,.JBSYM##	;NONE, GET SYMBOL TABLE AGAIN
	ANDI	P2,777777-PG.BDY## ;MOVING WHOLE PAGES, ADJUST
	SUBI	P1,(P2)		;NOW KNOW NUMBER OF WORDS TO MOVE
	ADDI	P1,PG.BDY##	;BUT STILL HAVE TO ROUND IT UP
	LSH	P1,W2PLSH##	;NOW HAVE THE NUMBER OF PAGES
	MOVEI	T1,1(P1)	;COMPUTE NUMBER OF MAP SLOTS TO BLAST
IFE FTKLP,<
	LSH	T1,-1		;FOR EDDT TO COPY
>
	CAILE	T1,200		;ENOUGH SPACE (SYMBK1 IN COMMON.MAC)
	JRST	BYPSY7		;SIGH
	MOVEM	T1,.CPSYB##+1	;STORE IT
	MOVE	P3,[POINT 18+<IFN FTKLP,<18>>,SYMBK1##] ;WHERE TO STORE NEW CONTENTS
	PUSH	P,MONVFF##	;GOING TO FAKE OUT ONCMAP, SAVE REAL ORIGIN
BYPSY6:	MOVE	T1,P2		;PAGE OF SYMBOLS
	LSH	T1,W2PLSH##	;TO PHYSICAL PAGE NUMBER
	MOVE	T2,.CPMAP##	;MAP ADDRESS
IFE FTKLP,<
	TRO	T1,PM.ACC+PM.WRT ;ALLOW ACCESS
	HRRM	T1,.MECKS(T2)	;MAKE ADDRESSABLE (ONCMAP  CLEARS HARDWARE A.M.)
>
IFN FTKLP,<
	HRLI	T1,(<PM.DCD>B2+PM.WRT) ;ALLOW ACCESS
	MOVEM	T1,.ECKSM/PAGSIZ##(T2) ;MAKE ADDRESSABLE
>
	MOVEI	T1,.EUPMP	;WHERE WE WANT IT TO BE MAPPED
	MOVEM	T1,MONVFF##	;SO WE DON'T CHEW UP LOTS OF VIRTUAL SPACE
	MOVEI	T1,PAGSIZ##	;ONLY ALLOCATE ONE PAGE AT A TIME
IFE FTKLP,<
	MOVEI	T2,PM.ACC+PM.WRT ;ALLOW DDT TO WRITE IN IT
>
IFN FTKLP,<
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.CSH)
>
IFN FTKL10!FTKS10,<
	SKIPN	[CPUN##-1]
	TDO	T2,[PM.CSH]
>
	PUSHJ	P,ONCMAP##	;ALLOCATE A PAGE FROM SOMEWHERE
	HRLI	T1,.ECKSM	;OLD SYMBOL TABLE LOCATION (RE-MAPPED)
	HRRI	T1,.EUPMP	;NEW, SAFER, LOCATION
	BLT	T1,.EUPMP+PAGSIZ##-1 ;MOVE PART OF THE SYMBOL TABLE
	MOVE	T1,.CPMAP##	;GET MAP ADDRESS
IFE FTKLP,<
	HLRZ	T1,.MEUPM(T1)	;FETCH MAP CONTENTS
>
IFN FTKLP,<
	MOVE	T1,.EUPMP/PAGSIZ##(T1) ;GET MAP CONTENTS
>
	IDPB	T1,P3		;STORE SO DDT CAN RE-MAP IT IN
	ANDI	T1,17777	;ISOLATE PAGE NUMBER
	IDIVI	T1,^D36		;COMPUTE POSITION IN NXMTAB
	MOVE	T2,BITTBL##(T2)	;GET BIT FOR PAGE
	IORM	T2,NXMTAB##(T1)	;MARK THE PAGE SO IT DOESN'T GET RE-USED
	ADDI	P2,PAGSIZ##	;TO NEXT PART OF THE SYMBOL TABLE
	SOJG	P1,BYPSY6	;MOVE THE WHOLE THING
	POP	P,MONVFF##	;BACK TO NORMAL ALLOCATION NOW
	SETZ	T2,		;PREPARE TO CLEAR
	EXCH	T2,.JBSYM##	;GET OLD POINTER
	TRZ	T2,777000	;STRIP OF OLD VIRTUAL ADDRESS
	TRO	T2,MONORG+IFE FTKLP,<IFN MONORG&1000,<1000>> ;TO NEW VIRTUAL ADDRESS
	SETZ	T3,		;PREPARE TO CLEAR
	EXCH	T3,.JBUSY##	;GET OLD POINTER
	TRZ	T3,777000	;STRIP OF OLD VIRTUAL ADDRESS
	TRO	T3,MONORG+IFE FTKLP,<IFN MONORG&1000,<1000>> ;TO NEW VIRTUAL ADDRESS
	MOVEI	T1,[		;SUBROUTINE TO CALL
		MOVEM T2,.CPEDV##-.CPCDB##+2(P1) ;STORE RELOCATED .JBSYM
		MOVEM T3,.CPEDV##-.CPCDB##+3(P1) ;STORE RELOCATED .JBUSY
		MOVEI T4,.CPSYB## ;WHERE ADDRESS SWAPPING BLOCK LIVES
		MOVEM T4,.CPEDV##-.CPCDB##+1(P1) ;STORE
		MOVE T4,.CPSYB##+1 ;COUNT OF MAP WORDS TO REPLACE
		MOVEM T4,.CPSYB##-.CPCDB##+1(P1) ;STORE
		POPJ P,]
	PUSHJ	P,CPUAPP##	;FILL IN ALL CPU'S EDV'S
	PUSHJ	P,SETEDV##	;SETUP REMAINDER OF THE EDV
	JRST	STULPT		;SKIP OLD WAY NOW THAT .JBSYM IS ZERO
BYPSY7:	SKIPL	DEBUGF##	;DEBUGGING?
	JRST	STULPT		;NO, DON'T MAKE CORE CONTAINING
				; SYMBOLS LOOK LIKE NXM
	HLRE	T3,.JBSYM##	;-LENGTH OF SYMBOL TABLE
	JUMPE	T3,STULPT	;NOTHING TO DO IF NO S.T.
	MOVMS	T3		;+ SIZZ OF S.T.
	ADD	T3,.JBSYM##	;RH=FIRST ADDRESS OF S.T.
	SUBI	T3,(U)		;HOW MUCH ROOM LEFT
	TRNE	T3,400000	;NEGATIVE (IN 18 BITS)
	JRST	BYPSY8		;ROOM LEFT, MARK PAGES
	HRLZS	T3		;S.T. GOES ABOVE 112K
	ADDM	T3,.JBSYM##	;ADJUST
BYPSY8:	HLRE	T3,.JBSYM##	; - LENGTH OF S.T.
	MOVNS	T1,T3		;T1=T3=LENGTH OF S.T.
	LSH	T3,W2PLSH##	;T3=# OF PAGES REQUIRED FOR S.T.
	TRNE	T1,PG.BDY##
	ADDI	T3,1		;ROUND UP
	SUBM	U,T1		;T1=WHERE S.T. WILL START
	JUMPL	T1,STULPT	;MUST BE MOVING S.T. UP
	LSH	T1,W2PLSH##	;T1=FIRST PAGE WHICH WILL
				; CONTAIN THE SYMBOL TABLE
	IDIVI	T1,^D36		;BIT POSITION AND REL LOC IN NXMTAB
	MOVNI	T2,-^D36(T2)	;BIT 0=36, BIT 1=35,...
	HRLM	T2,T4		;CSETOS WANTS THAT IN LH(T4)
	HRRI	T4,NXMTAB##(T1)	;POINT TO WORD IN NXMTAB
	PUSHJ	P,CSETOS##	;MARK THE PAGES WHERE
				; THE S.T. WILL BE MOVED AS
				; NON-EXISTANT

;STILL IN FTKI CONDITIONAL
;HERE TO INITIALIZE LOWTAB (CORE BLOCKS FOR IOWD'S)
STULPT:
IFE FTKS10,<
	MOVE	T1,LOWPTR##	;ABOJN POINTER TO LOWTAB
	SETOM	(T1)		;SET IT TO ALL ONES
	AOBJN	T1,.-1		; ..
	MOVEI	P1,LTINIT##	;ADDRESS OF TABLE CONTAINING ADDRESSES OF
				;  LOWER CORE FOUR WORD BLOCKS
	HRRZ	P2,LTINIT##	;ADDRESS OF FIRST FOUR WORD BLOCK
	MOVEM	P2,LOWLOC##	;STORE THAT AS ORIGIN OF FOUR WORD IOWD SPACE
STULP1:	SKIPN	T2,(P1)		;NEXT CHUNK OF FOUR WORD SPACE
	JRST	STO0		;ALL DONE
	HLRZ	T1,(P1)		;NUMBER OF FOUR WORD BLOCKS IN THIS CHUNK
	HRRZS	T2		;0,,STARTING ADDRESS OF THIS CHUNK
	SUBI	T2,(P2)		;RELATIVE ADDRESS WITHIN IOWD SPACE
	LSH	T2,-2		;FOUR WORDS PER BLOCK
	IDIVI	T2,^D36		;NUMBER OF BITS REPRESENTING FOUR WORD BLOCKS
	HRLS	T2		;WHERE THEY START IN THE TABLE
	ADD	T2,LOWPTR##	;MAKE AN AOBJN POINTER TO THE TABLE
	PUSHJ	P,SETZRS##	;INDICATE THAT THOSE BLOCKS ARE AVAILABLE
	AOJA	P1,STULP1	;LOOP UNTIL ALL CHUNKS ARE MARKED IN THE BIT TABLE
>
STO0:	HLRE	T2,.JBSYM##	;-LENGTH OF S. T.
	JUMPE	T2,STO2		;0 IF NO S. T. TO MOVE UP
	MOVNS	T2		;+LENGTH
	HRRZ	T1,.JBSYM##	;FIRST ADDRESS
	ADDI	T1,(T2)		;LENGTH+FIRST ADDRESS
	HRL	T1,T2		;XWD LENGTH,LENGTH+FIRST ADDRESS
	SUBI	U,1(T1)		;NEW LAST+1-OLD LAST+1
	JUMPL	U,[AOJE U,STO2	;SYMBOL TABLE GOES ABOVE 112K
		   MOVMS U	;DISCARD SOME SYMBOLS
		   HRLZS U
		   ADDM U,.JBSYM## ;ADJUST S.T. LENGTH
		   JRST STO2]	;AND SKIP MOVING
	HRRM	U,STO1		;DIST. TO MOVE
	MOVE	T2,.JBSYM##	;-N,FIRST ADD.
	ADDI	T2,1(U)		;FORM NEW S.T. POINTER
	MOVEM	T2,.JBSYM##
	SKIPE	T2,.JBUSY##	;GET UNDEFINED SYMBOLS
	ADDI	T2,1(U)		;INCREMENT POINTER IF ANY
	MOVEM	T2,.JBUSY##
	SKIPE	T2,.JBUSY##	;SEE IF SOME UND. SYM.
	MOVE	T2,.JBSYM##	;GET START OF S.T.
	SUB	T2,.JBUSY##	;GET LEN. U.S.T.
	HRLZ	T2,T2		;POSITION
	ADD	T1,T2		;ADVANCE COPY COUNT

	MOVE	T2,-1(T1)
STO1:	MOVEM	T2,.-.(T1)
	SUB	T1,[XWD 1,1]
	JUMPGE	T1,.-3
STO2:	JSR	JRSTI1		;SETUP LOCS 40 THRU 61 & TEST FOR 2 RELOC. HARDWARE
	MOVE	T1,[JRST LOADMS] ;ONLY MOVE SYMBOLS ONCE
	MOVEM	T1,BYPSY5
LOADMS:	SKIPGE	(P)		;SKIP IF ALTMODE TERMINATED DATE
	JRST	LONGD		;DO THE LONG DIALOGUE IF THE LAST LINE
				; TYPED IN (NAMELY TIME OF DAY) WAS TERMINATED BY
				; AN "ALT MODE".  (PUSH-DOWN LIST IS SET UP
				; IN THE "GETLIN" SUBROUTINE CALLED ABOVE.)
;TYPING ESCAPE DURING ONCE WILL BRING YOU BACK HERE TO TRY AGAIN.

SHORTD::SETZB	P1,SHUTUP##	;CLEAR SHORT FLAG
	SETOM	OPTQIK##
	SETOM	OFFLOK##	;NO VERBOSITY
	SKIPGE	DEBUGF##
	JRST	QUICK
	SETZM	ERROK##		;TYPE REAL ERRORS
	MOVEI	T1,[ASCIZ/
Startup option: /]
	MOVEI	T2,[ASCIZ /QUICK	;Default/]
	PUSHJ	P,ASKDEF	;ASK QUESTION
	JRST	ONCHLP		;GIVE SOME HELP
	PUSHJ	P,CTEXT##	;GET FIRST WORD
SWTEST:	CAIE	T3,"/"
	JRST	LNG1
	PUSH	P,T2
	PUSHJ	P,CTEXT##
	PUSH	P,T3
	MOVE	T1,[-SWTLEN,,SWTTAB]
	PUSHJ	P,FNDNAM##
	  JRST	ONCHLS
	MOVSI	T2,(ST%ACV)
	MOVEI	T3,ST.NRT
	XCT	SWTXCT(T1)
	POP	P,T3
	POP	P,T2
	JRST	SWTEST
LNG1:	MOVE	T1,[-OPTLEN,,OPTTAB]
	PUSHJ	P,FNDNAM##	;LOOKUP NAME
	  JRST	ONCHLP		;GIVE SOME HELP
	XCT	OPTXCT(T1)	;DO YOUR THING

	JRST	SHORTD

;DONE BY XCT ABOVE

OPTXCT:	PUSHJ	P,SHRTPM##	;CHANGE
	PUSHJ	P,SHRTST##	;DESTROY
	JRST	QUICK		;GO
	PUSHJ	P,FILOPL##	;LONG
	JRST	PVQCK		;QUICK
	JRST	QUICKN		;NOINITIA
	PUSHJ	P,SHRTRF##	;REFRESH
	PUSHJ	P,SHRTID##	;UNITID

SWTXCT:	JRST	LNGHLP		;/HELP
	SETZM	OFFLOK##	;/OFFLINE
	SETOM	ERROK##		;/NOERROR
	IORM	T3,STATES##	;/STAND
	SETZM	OPTQIK		;/ASK
	ANDCAM	T2,CNFST2##	;/NOVALIDATE
IFN	FTKL10,<
	PUSHJ	P,NOPPC		;NOPRIMARY
>
	PUSHJ	P,NOCOPY	;/NOCOPY
IFN FTKL10,<
	PUSHJ	P,NODXLD	;/NODXLD
>

IFN	FTKL10,<
NOPPC:	MOVSI	T1,(JFCL)
	MOVEM	T1,PPCPAT##
IFN	FTMP,<
	MOVE	T2,[CPUN##]
	SOJE	T2,CPOPJ
>
	MOVEM	T1,PPCPT1##
	POPJ	P,
>
NOCOPY:	MOVSI	T1,(DF.DCC)	;DISABLE INVOCATION OF
	IORM	T1,DEBUGF##	; CRSCPY AT STARTUP
	POPJ	P,		;RETURN
IFN FTKL10,<
NODXLD:	MOVEI	T1,[SETOM .CPNLD##-.CPCDB##(P1) ;SUBROUTINE TO CALL
		    POPJ  P,]
	PJRST	CPUAPP##	;DISABLE LOADING ON ALL CPUS
>
;SHORT HELP
ONCHLS:	POP	P,(P)
	POP	P,(P)
ONCHLP:	MOVEI	T1,[ASCIZ "
CHANGE,DESTROY,GO,LONG,QUICK,NOINITIA,REFRESH,UNITID
/H for help
"]
	JRST	ONCHL1		;TYPE THAT OUT
LNGMSG:	ASCIZ	"
CHANGE      - Change disk parameters.
DESTROY     - Rebuild all disks.  Deletes all files, sets all defaults.
GO          - Start the system if all is OK.
LONG        - Enters long dialogue.
QUICK       - Same as GO.
NOINITIA    - GO, but don't bring up OPSER, etc.
REFRESH     - Refresh selected structures.
UNITID      - Change unit IDs.

Switches typed after option are:
/HELP       - Type this text.
/OFFLINE    - Tell operator about off-line units.
/NOERROR    - Don't tell about non-serious errors.
/STAND      - Set SCHED 10.
/ASK        - Ask about off-line units.
/NOVALIDATE - Don't require project validation.
/NOPRIMARY  - Come up in secondary protocal.
/NOCOPY     - Don't start CRSCPY.
/NODXLD     - Don't auto reload DX20s.
"
IFNDEF	BUFLEN,<BUFLEN==.-LNGMSG>
IFL	BUFLEN-<.-LNGMSG>,<BUFLEN==.-LNGMSG>
LNGHLP:	MOVEI	T1,LNGMSG
ONCHL1:	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	JRST	SHORTD


OPTTAB:	SIXBIT	/CHANGE/
	SIXBIT	/DESTRO/
	SIXBIT	/GO/
	SIXBIT	/LONG/
	SIXBIT	/QUICK/
	SIXBIT	/NOINIT/
	SIXBIT	/REFRES/
	SIXBIT	/UNITID/

OPTLEN==.-OPTTAB
SWTTAB:	SIXBIT	/HELP/
	SIXBIT	/OFF/
	SIXBIT	/NOERRO/
	SIXBIT	/STAND/
	SIXBIT	/ASK/
	SIXBIT	/NOVALI/
IFN FTKL10,<
	SIXBIT	/NOPRIM/
>
	SIXBIT	/NOCOPY/
IFN FTKL10,<
	SIXBIT	/NODXLD/
>
SWTLEN==.-SWTTAB
;THE LONG DIALOGUE BEGINNETH HERE.....

LONGD:	SETOM	(P)		;SET "ALTMOD"-TYPED FLAG

	PUSHJ	P,FILOPT##	;GO THROUGH THE REFRESH DIALOGUE(S) [LEVEL C]
				; TYPE STATE OF WHOLE DISK SYSTEM, THEN
				; ACCEPT CHANGES TO UNITS AND STR'S & REFRESH [LEVEL D]

REPEAT	0,<	;HISTORIC FEATURES
;PRINT I/O CONFIGURATION


	MOVEI	T1,[ASCIZ /LIST CONFIGURATION ? (Y OR <CR>)
/]
	PUSHJ	P,YESNO
	  JRST ONCEOP		;BYPASS CONFIGURATION TYPE-OUT
	MOVEI	T1,CRLFMS	;PRINT CRLF
	PUSHJ	P,ICONM
	MOVE	T1,TICSEC##	;GET # OF CLOCK TICKS PER SECOND
	PUSHJ	P,RADX10##	;PRINT IT
	PUSHJ	P,INLMES##
	ASCIZ	/ HZ. LINE FREQ.
/
	PUSHJ	P,OPOUT

	MOVEI	T1,CRLFMS	;PRINT CRLF
	PUSHJ	P,ICONM
	MOVEI	T1,1		;ASSUME 1
	SKIPE	TWOREG##
	MOVEI	T1,2
	PUSHJ	P,RADX10##	;NO, SECOND REG EXISTS
	PUSHJ	P,INLMES##
	ASCIZ	/ RELOC. REG.
/
	PUSHJ	P,OPOUT

;UNDER REPEAT 0
	MOVEI	T1,[ASCIZ #I/O CONFIGURATION
#]
	PUSHJ	P,ICONM
	HLRZ	P1,DEVLST##
	JUMPN	P1,ALRLNK	;DEVICE DATA BLOCKS ALREADY LINKED ?
	MOVSI	R,INTNUM##	;NO, NOT LOADED BY BUILD, -NUMBER OF DEVICES*2
CONFLP:	SKIPN	P1,.JDAT+INTTB1## ;INT LOC HAVE DEV DATA BLOCK ?
	JRST	NODDB		;NO, GO GET NEXT DEVICE DATA BLOCK
	LDB	M,[POINT 8,.JDAT+INTTAB##,8]	;YES, NUMBER OF DEVICE DATA BLOCKS
	JUMPE	M,TLDD		;SEE IF LEVEL D DISK
NLDD:	HRRZ	T1,M		;PRINT
	PUSHJ	P,RADX10##	;IN DECIMAL
	PUSHJ	P,INLMES##	;PRINT 1 SPACE
	ASCIZ	/ /
	HLLZ	T2,DEVNAM(P1)	;DEVICE NAME
	PUSHJ	P,PRNAME##	;PRINT IT
	SOJLE	M,SINGLE	;IS THIS JUST A SINGLE DEVICE ?
	PUSHJ	P,INLMES##	;NO, APPEND 'S TO DEVICE NAME
	ASCIZ	/'S/
SINGLE:	PUSHJ	P,CRLF##	;PRINT CR LF
	PUSHJ	P,OPOUTX	;TYPE OUT UNLESS ^O IS IN FORCE
	PUSHJ	P,OTSET		;REINITIALIZE BUFFER
NODDB:	AOBJN	R,.+1		;
	AOBJN	R,CONFLP	;FINISHED ALL DEVICES ?
	JRST	PRSCLN		;YES
;UNDER REPEAT 0
;UNDER REPEAT 0
TLDD:	HRRZ	P1,.JDAT+INTTB1## ;ADDR OF DDB
	HLRZ	P1,DEVNAM(P1)	;LH OF DEVICE NAME
	CAIE	P1,(SIXBIT .DSK.)
	JRST	NLDD		;NOT REALLY DISK
	MOVNI	M,KONINT##	;OFFSET FOR INT. LOCS
	ADD	M,.JDAT+INTTAB## ;ADDR OF KONT DB
	MOVEI	M,KONTAB##(M)	;ADDR OF ADDR OF 1ST UNIT
	HRLI	M,T1		;ALLOW FOR INDEXING ON INDIRECT
	MOVE	P1,(M)		;P1=ADDR OF 1ST UNIT
	MOVEI	P1,UNINAM##-DEVNAM(P1)	;POINT P1 TO UNIT NAME
	MOVSI	T1,MKNMXU##	;-MAX NUMBER OF UNITS ON KONTROLLER
	SKIPE	@M		;SKIP IF NO MORE UNITS
	AOBJN	T1,.-1		;LOOP FOR MAX UNITS ON KONTROLLER
	HRRZ	M,T1		;M=NUMBER OF UNITS ON KONTROLLER
	JUMPE	M,NODDB		;JUMP IF NO UNITS
	JRST	NLDD		;OK, PRINT KONTROLLER

;UNDER REPEAT 0
ALRLNK:	MOVEI	T1,1
	HLLZ	J,DEVNAM(P1)
ALRLK2:	HLRZ	P1,DEVSER(P1)
	JUMPE	P1,ALRLK4
	HLLZ	T2,DEVNAM(P1)
	CAMN	T2,J
	AOJA	T1,ALRLK2
ALRLK4:	MOVE	R,T1		;SAVE NUMBER
	PUSHJ	P,RADX10##
	PUSHJ	P,INLMES##
	ASCIZ	/ /
	MOVEI	M,3
	MOVE	T1,[POINT 6,J]
ALRLK6:	ILDB	T3,T1
	ADDI	T3,40
	TYPE
	SOJG	M,ALRLK6
	MOVEI	T1,[ASCIZ /'S/]
	CAILE	R,1
	PUSHJ	P,CONMES##
	PUSHJ	P,CRLF##
	PUSHJ	P,OPOUTX	;TYPE OUT EACH LINE
	JUMPN	P1,ALRLNK
PRSCLN:	MOVEI	T1,CRLFMS
	PUSHJ	P,ICONM
	MOVEI	T1,TCONLN##	;PRINT NUMBER OF TTY SCANNER LINES
	PUSHJ	P,OCTPNT##
	PUSHJ	P,INLMES##
	ASCIZ	/ (OCTAL) TTY SCANNER LINES
/
	PUSHJ	P,OPOUTX
	JRST	ONCEOP		;GO GET OPR CONSOLE
;UNDER REPEAT 0
;ASK FOR OPERATORS CONSOLE TO BE SPECIFIED

ONCEO2:	POP	P,T1		;GET RID OF LAST ANSWER WHICH WAS FAULTY

ONCEOP:	MOVEI	T1,[ASCIZ /TYPE NAME OF OPR CONSOLE
/]
	PUSHJ	P,ASKGET
	  JRST ONCDDT		;JUST CR
	PUSHJ	P,CTEXT##
	MOVE	T1,T2
	PUSH	P,T1		;SAVE ANSWER
	CAMN	T1,[SIXBIT /CTY/] ;CTY ?
	JRST	ONCEO1		;YES. JUST STORE IT.
	CAMN	T1,[SIXBIT /OPR/] ;IGNORE CUTE ANSWERS
	JRST	ONCEO2
	CAMN	T1,[SIXBIT /TTY/]
	JRST	ONCEO2
	CAMN	T1,[SIXBIT /SYS/]
	JRST	ONCEO2
	PUSHJ	P,DEVPHY##
	  JRST ONCEO2		;PHYSICAL NAME NOT FOUND
	MOVE	T2,DEVMOD(F)
	TLNN	T2,DVTTY	;IS SPECIFIED DEVICE A TELETYPE?
	JRST	ONCEO2		;NO, TRY AGAIN, WISE GUY.
	LDB	T2,PUNIT##
	CAIL	T2,TCONLN##	;A REAL TELETYPE?
	JRST	ONCEO2		;NO, PTY'S MAY NOT BE OPR...
ONCEO1:	POP	P,DEVOPR##	;STORE NEW NAME
;UNDER REPEAT 0

;IS EXEC DDT WANTED ?

ONCDDT:	MOVEI	T1,[ASCIZ /DO YOU WANT EXEC DDT ? (Y OR <CR>)
/]
	PUSHJ	P,YESNO
	  JRST ONCSI		;NO
	MOVEI	T1,DDTEND##	;FIRST FREE LOCATION ABOVE EXEC DDT
	MOVEM	T1,SYSSIZ##	;SET NEW MONITOR SIZE

ONCSI:	MOVEI	T1,ENDSYS##	;END OF SYSINI
	CAMG	T1,SYSSIZ##	;SKIP IF SYSINI WILL BE OVERLAYED
	JRST	ONCCOR		;NO, NO NEED TO ASK ABOUT IT
	MOVEI	T1,[ASCIZ /SYSINI?
/]
	PUSHJ	P,YESNO		;ASK IF WANT TO KEEP SYSINI
	  JRST	ONCCOR		;NO
	MOVEI	T1,ENDSYS##	;FIRST FREE LOCATION ABOVE SYSINI
	MOVEM	T1,SYSSIZ##	;SET NEW MONITOR SIZE

ONCCOR:	MOVEI	T1,[ASCIZ /MAX. K CORE FOR SINGLE USER IS /]
	PUSHJ	P,ICONM
	MOVEI	T1,USRLIM##
	PUSHJ	P,RADX10##
	PUSHJ	P,CRLF##
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /TYPE DESIRED MAX. (DECIMAL), TYPE <CR> IF OK AS IS
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX
	PUSHJ	P,GETLIN
	  JRST ONCLOK		;LEAVE LIMIT AS SET BY MONGEN QUESTION.
	PUSHJ	P,DECIN##
	JRST	ONCLOK
	JRST	ONCLOK
	SKIPE	T2		;UNLESS HE SAID 0 LIKE IN MONGEN,
	HRRM	T2,CORLIM##	; PATCH CORLIM FOR USER CORE SIZE LIMIT.
				; IF NOT PATCHED, LEAVE COMMON'S VALUE.
;UNDER REPEAT 0
ONCLOK:


IFN FTLOCK,<
	MOVEI	T1,LOKASK##	;LOCK UUO INCLUDED AT MONGEN TIME?
	JUMPE	T1,ONCLK6	;JUMP IF NO
	MOVEI	T1,[ASCIZ /MINIMUM AMOUNT OF CORE GUARANTEED TO SWAPPABLE JOBS IS /]
	PUSHJ	P,ICONM
	HRREI	T1,LOKMAX##
	SKIPG	T1
	HRRZ	T1,CORLIM##
	PUSHJ	P,RADX10##
	PUSHJ	P,INLMES##
	ASCIZ	/K
/
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ /TYPE DESIRED MIN. DECIMAL, CR IF OK AS IS
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX
	PUSHJ	P,GETLIN
	JRST	ONCLK2		;SET IT TO CORMAX
	PUSHJ	P,DECIN##
	JRST	ONCLK2
	JRST	ONCLOK
	JRST	ONCLK4
ONCLK2:	HRREI	T2,LOKMAX##
	SKIPG	T2
	HRRZ	T2,CORLIM##
ONCLK4:	HRRM	T2,LOKLIM##
ONCLK6:
>
;UNDER REPEAT 0
;SET TIME ACCOUNTING OPTIONS

;	STATES WORD BITS SELECT OPTIONS (INITIALIZED BY MONGEN)

	MOVE	P1,STATES##

;	SAY WHAT PRECISION IS

	MOVEI	T1,[ASCIZ/Runtime accounting is /]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ/high precision(DK10)
/]
	TLNN	P1,(ST.HPT)
	MOVEI	T1,[ASCIZ/low precision(APR clock)
/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX

;	LET HIM CHANGE IT IF HE HAS A DK10

	XCT	CKDK10##	;CK FOR DK10S ON ALL CPUS
	JRST	ONCTI2		;NO DK10-NO HIGH PRECISION
	MOVEI	T1,[ASCIZ/Is this OK(Y,N): /]
	PUSHJ	P,NOYES
	  JRST	ONCTI2		;YES - DOESN'T WANT TO CHANGE
	MOVEI	T1,[ASCIZ/High precision(=DK10, Low=APR clock)(Y,N): /]
	PUSHJ	P,NOYES
	  TLOA	P1,(ST.HPT)	;YES - SET BIT FOR HIGH PRECISION
	TLZ	P1,(ST.HPT)	;NO - CLEAR BIT FOR LOW
ONCTI2:

;UNDER REPEAT 0
;	SAY WHETHER MONITOR OVERHEAD INCLUDED OR NOT
;	AND LET HIM CHANGE IT IF HE WANTS

	MOVEI	T1,[ASCIZ/Monitor overhead is /]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUT
	MOVEI	T1,[ASCIZ/excluded from/]
	TLNN	P1,(ST.EMO)
	MOVEI	T1,[ASCIZ/included in/]
	PUSHJ	P,ICONM
	PUSHJ	P,OPOUTX
	MOVEI	T1,[ASCIZ/ user runtime
Is this OK(Y,N): /]
	PUSHJ	P,NOYES
	  JRST	ONCTI4		;YES - IT'S OK
	MOVEI	T1,[ASCIZ/Exclude overhead(Y,N): /]
	PUSHJ	P,NOYES
	  TLOA	P1,(ST.EMO)	;YES - SET BIT TO EXCLUDE OVERHEAD
	TLZ	P1,(ST.EMO)	;NO - CLEAR BIT TO INCLUDE
ONCTI4:

;	STORE (POSSIBLY) MODIFIED STATES WORD
;	SYSINI WILL INITIALIZE TIME ACCOUNTING (GETIME) ACCORDING TO STATES

	MOVEM	P1,STATES##
>	;END REPEAT 0
;FIND CORE TO BE USED FOR MULTIPLE DEVICE DATA BLOCKS
; INCLUDING DISK


;GO, BUT NO INITIA
QUICKN:
	MOVEI	T1,TTFCXI##	;INDEX OF INITIA
	SETZM	TTFCOM##(T1)	;CLEAR ENTRY FROM FORCED COMMAND TABLE
				;AND FALL INTO QUICK

PVQCK::
QUICK:			;THIS IS THE SHORT-CUT EXIT TO BY-PASS MOST OF THE DIALOGUE.
	SKIPN	HICORE##	;HICORE BEEN UPDATED?
	PUSHJ	P,REDHOM##	;NO, DO SO NOW
	  JFCL

	PUSH	P,SYSSIZ##	;SAVE CURRENT SIZE
	JSP	T1,CNTDB##	;UPDATE SYSSIZ BY SPACE USED
				; FOR DEVICE DATA BLOCKS FOR DSK,DTA,MTA,TTY,PTY)

	POP	P,T1		;POP OFF CURRENT SYSTEM SIZE
	EXCH	T1,(P)		;EXCH WITH ALTMODE TYPED FLAG
	JUMPGE	T1,QUICK1	;JUMP IF QUICK DIALOGUE - DONT TYPE MONITOR SIZE

;PRINT OCTAL SIZE OF MONITOR

	MOVEI	T1,[ASCIZ /
Exec is /]
	PUSHJ	P,ICONM
	MOVE	T1,SYSSIZ##
	PUSHJ	P,OCTPNT##
	MOVEI	T1,[ASCIZ / octal locations long.
/]
	PUSHJ	P,CONMES##
	PUSHJ	P,CRLF##
	PUSHJ	P,OPOUT
QUICK1:			;THIS IS THE SHORT-CUT EXIT TO BY-PASS MOST OF THE DIALOGUE.
	POP	P,SYSSIZ##	;RESTORE SYSSIZ PRIOR TO ACTUAL CREATION
				; OF DEVICE DATA BLOCKS


	JRST	@ONCE		;***EXIT FROM THE "ONCE-ONLY CODE"***...........



;ROUTINE TO FIND THE EXEC DDT SYMBOL TABLE POINTER AND MOVE IT TO THE PLACE
;WHERE EXEC DDT EXPECTS IT (DDTSYM=36)

;CALL:	JSR MOVSTP
;CALLED FROM MANDATORY ONCE ONLY CODE AND 141 START CODE (WHICHEVER OCCURS FIRST)


MOVSTP:	0			;JSR HERE FROM MANDATORY ONCE ONLY CODE AND
				; FIRST JUMP TO EXEC DDT IF BEFORE MONITOR STARTED
MOVJMP:	JRST	.+1		;PATCHED TO SETUUO AFTER FIRST EXECUTION
	MOVEI	T1,DDTX##	;MAKE SYSTEM STARTUP LOC(141) GO DIRECTLY  TO EXEC
				; DDT AND BY PASS THIS FOOLISHNESS 
	HRRM	T1,SYSDDT##
	MOVEI	T1,SETUUO	;MAKE SURE THIS IS DONE ONLY ONCE
	HRRM	T1,MOVJMP
SETUUO:	JRST	@MOVSTP		;RETURN

;HERE IF EXEC DDT IS STARTED UP BEFORE MONITOR (TO MAKE A PATCH FOR EXAMPLE)

PATSYM::JSR	MOVSTP		;MOVE DDT SYMBOL TABLE POINTER SO EXEC DDT WILL
				; FIND IT AND PATCH 141 TO GO DIRECTLY TO EXEC DDT
	JRST	DDTX##		;AND GO DIRECTLY TO EXEC DDT
JRSTI1:	0

;SET LOC TWOREG TO -1 IF MACHINE HAS TWO RELOC REG, TO 0 IF ONLY ONE RELOC REG


	MOVE	P3,.CPMAP##
IFE FTKLP,<
	PUSH	P,.EPPM##-.EPMP##(P3)	;SAVE FIRST ENTRY IN EXEC MAP
>
IFN FTKLP,<
	PUSH	P,400000/PAGSIZ##(P3)
>
IFN FTKL10,<
	SKIPE	[CPUN##-1]	;IF MORE THAN 1 CPU,
	SKIPA	T1,[JRST SYSTOP##] ;LET WARM RESTART=J407
	MOVE	T1,[JRST APRWRS##] ;WARM RESTART INSTRUCTION
	MOVEM	T1,WRSINS##	;STORE IN WARM RESTART LOCATION
>
IFN FTMP,<
	MOVE	T1,[JRST APRRES##] ;POWER FAIL-AUTO-RESTART INSTR.	
>
IFE FTMP,<
	MOVE	T1,[HALT APRRES##] ;HALT IF NOTHING SAVED
>
	MOVEM	T1,ARSLOC##	;STORE IN AUTO-RESTART LOCATION
IFN FTKS10!FTKL10,<
IFE FTKLP,<
	MOVE	T1,[JSR @.CPKAF##] ;KEEP ALIVE FAILURE INSTRUCTION
>
IFN FTKLP,<
	MOVE	T1,[XPCW@.CPKAF##]
>
	MOVEM	T1,KAFLOC##	;STORE IT IN RIGHT SPOT
>
IFE FTKLP,<
	MOVEI	T1,PM.ACC+PM.WRT+0 ;SETUP EXEC MAP
	HRLM	T1,.EPPM##-.EPMP##(P3)	; SO THAT SHADOW ACS
>
IFN FTKLP,<
	MOVSI	T1,(<PM.DCD>B2+PM.WRT)
	MOVEM	T1,400000/PAGSIZ##(P3)
>
	MOVE	P3,.CPTYP##	;GET CPU TYPE
	CAIN	P3,CT.KI
	DATAO	PAG,.CPEBR##	; PARITY ERRORS AND DDT
	CAIN	P3,CT.KL
	CONO	PAG,@.CPEBR##
IFN FTKS10,<
	CAIN	P3,CT.KS
	WREBR	@.CPEBR##
>
	MOVEI	17,400000	;MOVE HARDWARE AC'S INTO SHADOW AC'S TO CLEAR PARITY
				;IF HARDWARE AC'S TURNED OFF, AC'S WILL BE PRESERVED
	BLT	17,400017	;STOP WITH SHADOW AC 17
	SETZ	T2,		;ZERO AC T2
	SETOM	400000+T2	;SET SHADOW AC T2
	CONO	PI,10000	;CLEAR PI SYSTEM
	MOVE	P3,.CPMAP##
IFE FTKLP,<
	POP	P,.EPPM##-.EPMP##(P3)	;RESTORE EXEC MAP
>
IFN FTKLP,<
	POP	P,400000/PAGSIZ##(P3)
>
IFE FTKL10,<
;SETUP LOCATIONS 40 THRU 61

	MOVE	T1,[XWD LOC40,.EPIL##]	;SETUP LOWER CORE PI LOCATIONS
	BLT	T1,.EPIL##+LOC40E-1
>
;LINK DEVICE SERVICE ROUTINES TOGETHER


	SKIPE	DEVLST##	;HAVE SERVICE ROUTINES BEEN CHAINED TOGETHER YET ?
	JRST	@JRSTI1		;YES, MUST HAVE BEEN LOADED WITH BUILD
	MOVSI	T1,INTNUM##	;NO, NEGATIVE NUMBER OF SERVICE ROUTINES*2
INTLOP:	LDB	U,PINTCH##	;GET NEXT PI NUMBER

	LDB	J,DDBNUM##	;NUMBER OF DDBS
	JUMPN	J,NTLVDD	;JUMP IF NOT LEVEL D DISK
	HRRZ	J,INTTB1##(T1)	;ADDRESS OF DDB
	JUMPE	J,NTLVDD	;JUMP IF REALLY NO DDBS
	HLRZ	J,(J)		;IS LEVEL D DISK, GET LH OF DEVICE NAME
	CAIE	J,(SIXBIT .DSK.) ;SKIP IF IS REALLY A DISK
	JRST	NTLVDD		;NO
	MOVNI	J,KONINT##	;YES, GET OFFSET FOR INTERRUP LOCS
	ADD	J,INTTAB##(T1)	;PLUS INTERRUPT LOC=KONT DB
	DPB	U,KOYPI##	;STORE PI CHANNEL
IFN FTAUTC,<
	JRST	NOPICH		;AUTCON WILL SET UP NEEDED INTERRUPT CHAINS
>

NTLVDD:	LSH	U,1		;SHIFT LEFT ONE SO MATCH PI LOCATIONS
	JUMPE	U,NOPICH	;DOES THIS DEVICE HAVE A PI CHANNEL (PTY) ?
	LDB	J,PINTCP##
	LSH	J,.CPSOF##
	MOVE	J,.C0EPT##(J)
	ADDI	J,(U)
	MOVE	J,.EPIL##-.EPMP##(J)
IFN FTKLP,<
	ADDI	J,3
>
INTLP1:	MOVE	U,J		;SAVE IT IN U (EITHER A JRST DEV'INT OR
				; JEN @CH'N
	MOVE	J,1(U)		;PICK UP INSTR. FOLLOWING INTERRUPT CONSO
	TLNN	J,000740	;IS IT A JEN ?
	JRST	INTLP1		;NO, KEEP LOOKING
	HRRZ	T2,INTTAB(T1)	;YES, LAST DEVICE SO FAR, GET DEV'NT
IFN FTAUTC,<
	CAIE	T2,MT0INT##	;AUTCON WILL DO IT
>
	SKIPN	(T2)		;DEV'INT=0?
	JRST	NOPICH		;YES, MUST BE VECTORRED INTERRUPT DEVICE
	HRLI	T2,(JRST)	;MAKE JRST INSTR.
	MOVEM	T2,1(U)		;CHANGE JEN @CH'N TO JRST DEV'NT
	MOVEM	J,1(T2)		;MAKE DEV'NT+1 BE JEN @CH'N
NOPICH:	AOBJN	T1,.+1		;PICKUP EVERY OTHER WORD
	AOBJN	T1,INTLOP	;ANY MORE INTERRUPT SERVICE ROUTINES ?
	JRST	@JRSTI1		;NO, EXIT

IFE FTKL10,<
LOC40:	0			;UUO PC
UUOTRP::JSR	LUUOPC##	;TO UUO HANDLER
	JSR	CH1##
	JSR	PIERR##
	JSR	CH2##
	JSR	PIERR##
	JSR	CH3##
	JSR	PIERR##
	JSR	CH4##
	JSR	PIERR##
	JSR	CH5##
	JSR	PIERR##
	JSR	CH6##
	JSR	PIERR##
	JSR	CH7##
	JSR	PIERR##
LOC40E==.-LOC40
>
;ROUTINE TO READ A LINE FROM OPERATORS CONSOLE
;CALL:	PUSHJ P,GETLIN
;	JUST A CR TYPED IN
;	NORMAL RETURN (NOT A BLANK LINE)


GETLIN::HRLOI	T1,377777	;DO NOT ALLOW A DEFAULT
	MOVEM	T1,DEFLAG	;STORE FLAG
GETLI0:	MOVE	T1,LINEP
	MOVEM	T1,ONCTIP	;INITIAL STORAGE POINTER
	MOVEI	T3,40		;PRIME COMMAND ROUTINES WITH A SPACE
	MOVEM	T3,ONCTCH	; ..
	MOVEI	J,0		;FLAG NO ALTMODE SEEN, ZERO CHARACTER COUNT (RH
				; OF J), CLEAR DELETE FLAG (LH OF J)
GET1:	PUSHJ	P,XTYI		;WAIT FOR A CHARACTER
	SKIPGE	DEFLAG		;NEED A DEFAULT?
	ILDB	T3,DEFPTR	;YES--GET BYTE
	SKIPL	DEFLAG		;NEED A DEFAULT?
IFN FTKI10,<
	DATAI	TTY,T3		;GET IT
>
				;STRIP PARITY
IFN FTKL10!FTKS10,<
	MOVE	T3,FROMFE	;GET CHAR FROM WHERE IT WAS SAVED
>
	ANDI	T3,177
	CAIN	T3,177		;RUBOUT?
	JRST	DELETE		;YES
	TLZE	J,1
	PUSHJ	P,BKSLSH	;TERMINAL BACKSLASH IF WE HAD BEEN DELETING
	CAIE	T3,"$"		;ACCEPT DOLLAR-SIGN AS AN ALT-MODE
	CAIN	T3,33		;ALTMODE/ESCAPE?
	JRST	GETLN1		;YES
	CAIE	T3,175		;OTHER ALTS?
	CAIN	T3,176		; ..
	JRST	GETLN1		;YES
GET2:	PUSHJ	P,XTYO		;ECHO
	CAIL	T3,140		;LOWER CASE?
	TRZ	T3,40		;YES. MAKE UPPER
	IDPB	T3,T1		;STORE IN INPUT BUFFER
	CAIE	T3,15		;CAR RET?
	AOJA	J,GET1		;NO. LOOP TILL BREAK
	MOVEI	T3,12		;YES. ADD LF
	PUSHJ	P,XTYO		;OUTPUT LF
	MOVEI	T3,0		;TERMINATE INPUT STRING IN BUFFER
	IDPB	T3,T1		; ..
	JUMPN	J,CPOPJ1	;IF NON-NULL LINE, SKIP RET
	POPJ	P,0		;NULL. NON-SKIP RET
DELETE:	TRNN	J,-1		;AT BEGINNING OF LINE ?
	JRST	DELET1		;YES
	TLON	J,1		;SET DELETE FLAG
	PUSHJ	P,BKSLSH	;TYPE BACKSLASH IF JUST STARTING TO DELETE
	LDB	T3,T1		;GET PREVIOUS CHARACTER
	PUSHJ	P,XTYO		;ECHO IT AS WE DELETE IT
	ADD	T1,[XWD 070000,0] ;BACK UP BYTE POINTER
	TLNE	T1,400000	;FINISHED THIS WORD YET ?
	ADD	T1,[XWD 347777,-1] ;YES, BACK UP ADDRESS
	SOJA	J,GET1

DELET1:	TLZE	J,1
	PUSHJ	P,BKSLSH	;TERMINAL BACKSLASH IF DELETED ANY CHARS
	MOVEI	T3,15
	PUSHJ	P,XTYO
	MOVEI	T3,12
	PUSHJ	P,XTYO
	JRST	GETLIN

BKSLSH:	PUSH	P,T3
	MOVEI	T3,134		;TYPE BACKSLASH
	PUSHJ	P,XTYO
	POP	P,T3
	POPJ	P,0

GETLN1:	MOVEI	T3,"$"		;OUTPUT DOLLAR SIGN IF ALT-MODE TYPED
	PUSHJ	P,XTYO
	HRROS	J		;MECHANISM USED TO BY-PASS PART OF DIALOGUE
	MOVEI	T3,15		; WHEN ALTMODE IS TYPED (J NEGATIVE ON
	JRST	GET2		; RETURN FROM GETLIN).
;ROUTINE TO TYPE A LINE ON OPERATOR CONSOLE
;ECHO CHECK STOPS LINE AND RETURNS
;CALL:	ONCTOP SET TO END OF MESSAGE


;CALL OPOUTX FOR MESSAGE CONTINUATIONS TO BE SUPPRESSED IF
; THE PREVIOUS PART OF THE MESSAGE WAS ^O'D
OPOUTX:	SKIPE	CNTRLO		;^O IN EFFECT ?
	PJRST	OTSET		;YES, JUST CLEAR BUFFER AND GO AWAY

OPOUT::	SETZM	CNTRLO		;CLEAR ^O FLAG
	MOVEI	T3,0		;MAKE SURE STRING ENDS
	IDPB	T3,ONCTOP	;WITH A NULL
	MOVE	T1,LINEP	;AND RESTART AT BEGINNING
	MOVEM	T1,ONCTOP	; ..
IFN FTKI10,<
	CONO	TTY,1000	;CLEAR INPUT FLAG
OPOUT1:	CONSZ	TTY,40		;MAKE SURE NOT BEING INTERRUPTED
	JRST	OPOUT2		;INPUT FLAG
>
IFN FTKL10,<
OPOUT1:	PUSHJ	P,SPCGTI##	;WAIT FOR INPUT, SKIP WITH CHAR IN T3
	  JRST	.+2		;NOT READY YET
	JRST	OPOUT2		;YES
>
IFN FTKS10,<
OPOUT1:	SKIPN	T3,CTYIWD	;SKIP IF CHAR IS THERE
	  JRST	.+3		;NONE THERE
	SETZM	CTYIWD		;CLEAR CTYIWD
	JRST	OPOUT2		;GO DO CTRL-O
>
	ILDB	T3,ONCTOP	;GET CHAR TO TYPE
	JUMPE	T3,CPOPJ	;QUIT ON NULL
	PUSHJ	P,XTYO		;TYPE CHAR
	JRST	OPOUT1		;LOOP

;HERE WHEN KEY STRUCK DURING TYPEOUT
OPOUT2:	SETOM	CNTRLO		;SET ^O FLAG
	MOVEI	T3,"^"
	PUSHJ	P,XTYO
	MOVEI	T3,"O"
	PUSHJ	P,XTYO
	MOVEI	T3,15
	PUSHJ	P,XTYO		;TYPE OUT CRLF
	MOVEI	T3,12
	PUSHJ	P,XTYO
IFN FTKI10,<
	CONO	TTY,1000	;CLEAR INPUT FLAG
>
	JRST	OTSET		;RESET OUTPUT BUFFER, RETURN FROM OPOUT

CNTRLO:	0			;SUPPRESS TYPE-OUT WHEN -1
IFN FTKI10,<
;WAIT TILL OUTPUT BUSY OFF BEFORE TYPING OUT CHAR.


XTYO:	PUSH	P,T1		;SAVE A WORKING AC
XTYO1:	PUSHJ	P,APRCHK	;CHECK CLOCK
	CONSZ	TTY,20
	JRST	XTYO1
	PUSHJ	P,PEVEN8##
	DATAO	TTY,T3
	TRZ	T3,200
	PUSHJ	P,OPRFIL##	;ADD FILLERS
	JRST	TPOPJ##
>
IFN FTKL10,<
XTYO:	PUSHJ	P,PEVEN8##	;GET GOOD PARITY FOR CHAR
	PUSHJ	P,SPCTYO##	;TYPE OUT
	PUSHJ	P,OPRFIL##	;DO FILLERS
XTYO1:	PUSHJ	P,APRCHK	;UPDATE TIME
	PUSHJ	P,SPCWTO##	;WAIT FOR OUTPUT DONE
	  JRST	XTYO1		;NOT DONE, WAIT SOME MORE
	ANDI	T3,177		;TAKE AWAY PARITY FOR COMPARES IN GETLIN
	POPJ	P,		;RETURN
>
IFN FTKS10,<
XTYO:	PUSHJ	P,PEVEN8##	;GET GOOD PARITY FOR CHAR
	PUSHJ	P,APRCHK	;UPDATE TIME
	SKIPE	CTYOWD		;CAN WE TYPE YET?
	JRST	.-2		;NO, WAIT
	TRO	T3,CTYOVL	;SET VALID FLAG
	MOVEM	T3,CTYOWD	;PUT IT IN 8080'S WORD
	WRAPR	SP.SSF+SP.IFE	;INTERRUPT THE 8080
	PUSHJ	P,APRCHK	;UPDATE TIME
	SKIPE	CTYOWD		;CHAR TAKEN YET?
	JRST	.-2		;NO, WAIT
	ANDI	T3,177		;ONLY CHAR FOR COMPARES IN GETLIN
	POPJ	P,		;RETURN
>

;WAIT TIL INPUT DONE ON BEFORE RETURNING WITH NEXT CHAR.

XTYI:	PUSH	P,T1		;SAVE AN AC
XTYI1:	PUSHJ	P,APRCHK
	SKIPGE	DEFLAG
	JRST	XTYI2
IFN FTKI10,<
	CONSO	TTY,40
>
IFN FTKL10,<
	PUSHJ	P,SPCGTI##	;SKIP IF CHAR PRESENT, WITH IT IN T3
>
IFN FTKS10,<
	SKIPN	T3,CTYIWD	;SKIP IF CHAR PRESENT WITH IT IN T3
>
	JRST	XTYI1
IFN FTKS10,<
	SETZM	CTYIWD		;CLEAR CTYIWD FOR NEXT INPUT CHAR
>
IFN FTKL10!FTKS10,<
	MOVEM	T3,FROMFE	;SAVE CHARACTER FOR USE LATER
>
	HRLOI	T1,777		;RESET THE TIMER
	MOVEM	T1,DEFLAG	; SO WE DON'T START UP
	MOVEM	T1,OPRCNT
	SETZM	DEFALW
	JRST	TPOPJ##		;RETURN AND RESTORE T1
;CHECK APR FOR CLOCK FLAG SO TIME USER TYPES IN WILL BE ACCURATE

APRCHK:
IFN FTKI10,<
	CONSO	APR,XP.CLK	;IS CLOCK FLAG ON?
>
IFN FTKL10,<
	CONSO	TIM,TI.ITD	;TIMER ON KL10 FINISHED WITH ITS TICK?
>
IFN FTKS10,<
	CONSO	APR,SP.ITI
>
	POPJ	P,		;NO
IFN FTMP,<
	PUSH	P,T1
	MOVEI	T1,.C0CDB##	;INCREMENT .CPOK FOR ALL CPUS
APRCH1:	AOS	.CPOK##-.CPCDB##(T1)
	HLRZ	T1,.CPCDB##-.CPCDB##(T1) ;STEP TO NEXT CPU
	JUMPN	T1,APRCH1
	POP	P,T1
>
IFN FTKI10,<
	CONO	APR,XP.CCF	;YES, CLEAR CLOCK FLAG
>
IFN FTKL10,<
	CONO	TIM,@ONCKLT	;YES, CLEAR INTERNAL TIMER DONE AND START UP AGAIN
>
IFN FTKS10,<
	WRAPR	SP.CSF!SP.ITI
>
	AOS	TIME##		;INCREMENT TIME
	SOS	DEFLAG		;SEE IF TIME FOR DEFAULT
	POPJ	P,
XTYI2:	SETOM	DEFALW
	JRST	TPOPJ##

IFN FTKL10!FTKS10,<
ONCKLT::BLOCK	1		;PLACE TO KEEP BITS FOR KL10 INTERVAL TIMER
FROMFE:BLOCK	1		;PLACE TO KEEP CHAR AFTER XTYO GETS IT
>
;ONCTIV	ONCE TTY INPUT VECTOR.

ONCTIV::PUSHJ	P,ONCTYI	;(0 = CTIGNC) GET NEXT CHAR
	MOVE	T3,ONCTCH	;(1 = CTIGLC) GET LAST CHAR
	MOVEM	T3,ONCTCH	;(2 = CTISLC) SET LAST CHAR
	MOVE	T1,ONCTIP	;(3 = CTIGBP) GET BYTE POINTER
	MOVEM	T1,ONCTIP	;(4 = CTISBP) SET BYTE POINTER

;HERE TO READ THE NEXT CHAR FOR COMCON.

ONCTYI:	ILDB	T3,ONCTIP	;GET INPUT CHARACTER
	MOVEM	T3,ONCTCH	;STORE FOR RE-READS
	POPJ	P,0		;AND RETURN TO CALLING ROUTINE


ONCTYO:	SOSLE	ONCCNT		;COUNT CHARACTERS
	IDPB	T3,ONCTOP	;PUT IN BUFFER
	POPJ	P,0		;AND RETURN
ICONM::	SETTYO			;INITIALIZE LINE BUFFER
	JRST	CONMES##	;OUTPUT MESSAGE


OTSET::	MOVEI	T3,ONCTSZ	;SIZE OF BUFFER
	MOVEM	T3,ONCCNT	;SO CANT OVERFLOW
	MOVEI	T3,ONCTIV	;ADDRESS FOR READ ROUTINES TO USE
	MOVEM	T3,.CPTIV##	; ..
	MOVEI	T3,ONCTYO	;ADDRESS FOR TYPEOUT ROUTINES TO GO TO
	MOVEM	T3,.CPTOA##	; ..
	MOVE	T3,LINEP	;INITIAL OUTPUT POINTER
	MOVEM	T3,ONCTOP
	POPJ	P,0

YESNO::	PUSHJ	P,ASKGET	;ASK QUESTION, GET ANSWER
	  POPJ P,0		;JUST C-R
YESN:	PUSHJ	P,ALTM##
	NEXTC
	TRZ	T3,40		;FIRST CHAR OF RESPONSE (U.C.)
	CAIN	T3,"Y"		;WAS IT A Y ?
	AOS	0(P)		;YES. SKIP
	POPJ	P,		;NO, MAYBE IT WAS "N". SO DON'T SKIP


	REPEAT	0,<
;SAME AS YESNO EXCEPT RETURN IS INVERTED (SKIP IF NO, NONSKP IF YES OR CR)
NOYES::	PUSHJ	P,ASKGET
	  POPJ	P,
	PUSHJ	P,YESN
	  AOS	(P)
	POPJ	P,
>	;END OF REPEAT 0

PPNERR:	MOVEI	T1,[ASCIZ \Bad [P,PN] typed try again: \]
GTPPN::	PUSHJ	P,ASKGET	;ASK QUESTION, GET ANSWER
	  POPJ	P,
	PUSHJ	P,ALTM##	;DID HE TYPE ESC
GTPPN1:	NEXTC			;GET THE NEXT CHARACTER
	CAIN	T3," "		;SPACE
	  JRST	GTPPN1		;NO, TRY AGAIN
	CAIE	T3,"["		;BEGINNING OF PPN
	  JRST	PPNERR		;NO, TRY AGAIN
	PUSHJ	P,GETOCT	;GET THE FIRST OCTAL NUMBER
	JUMPE	T2,PPNERR	;NULL PROJECT NUMBER IS BAD
	TLNN	T2,777777	;TOO BIG?
	CAIE	T3,","		;OR A BAD P,PN SEPARATER
	  JRST	PPNERR		;YEP
	PUSH	P,T2		;SAVE IT
	PUSHJ	P,GETOCT	;GET THE PROGRAMMER NUMBER
	POP	P,T1		;GET PROJECT NUMBER BACK
	JUMPE	T2,PPNERR	;NULL PROGRAMMER NUMBER IS BAD
	CAIE	T3,"]"		;CHECK FOR LEGAL TERMINATER
	CAIN	T3,0		;CRLF IS OK TOO
	TLNE	T2,777777	;TOO BIG?
	  JRST	PPNERR		;YEP
	HRL	T1,T2		;GET PROGRAMMER NUMBER
	MOVSS	T1		;SET IT UP AS [PROJ,PROG]
	AOS	(P)		;GIVE A SKIP 
	POPJ	P,		;AND RETURN


GETOCT:	MOVEI	T2,777777	;ASSUME WILD
	NEXTC			;GET FIRST CHARACTER
	CAIE	T3,"*"		;WILD?
	TDZA	T2,T2		;NO - CLEAR RESULT
GETOC1:	NEXTC			;NEXT CHAR
	CAIL	T3,"0"		;IN RANGE?
	CAILE	T3,"7"
	POPJ	P,
	LSH	T2,3		;CLEAR NULL DIGIT
	SUBI	T3,"0"		;CONVERT TO BINARY
	ADDI	T2,(T3)		;ADD TO TOTAL
	JRST	GETOC1		;LOOP UNTIL DONE

ASKGET:	PUSHJ	P,ICONM		;OUTPUT THE QUESTION
	PUSHJ	P,OPOUT
	PJRST	GETLIN		;GET ANSWER





TTYWNZ::SETTYO
	POPJ	P,0

SKPWNZ::POPJ	P,0

;CONSTANTS AND PUSHDOWN LIST

ONCEPN=20
	BLOCK	ONCEPN		;PUSHDOWN LIST
ONCTIP:	0			;TYPE-IN POINTER
ONCTCH:	0			;LAST CHAR TYPED IN.
ONCTOP:	0			;TYPE-OUT POINTER
ONCCNT:	0			;COUNTER FOR TYO
LINEP:	POINT	7,LINBUF	;INPUT AND OUTPUT LINE BUFFER
LINBUF:	BLOCK	BUFLEN		;LINE BUFFER (LONG ENOUGH FOR WHY RELOAD /H MESSAGE)
ONCTSZ=<BUFLEN*5>-1		;CHARACTERS WHICH FIT IN OUTPUT BUFFER

CRLFMS:	ASCIZ	/
/

;ASK A QUESTION WITH A DEFAULT ANSWER
;CALL WITH:
;	MOVEI	T1,[ASCIZ /QUESTION/]
;	MOVEI	T2,[ASCIZ /ANSWER/]
;	PUSHJ	P,ASKDEF
;	  RETURN HERE ON CRLF
;	ELSE RETURN HERE
;
ASKDEF::PUSH	P,T2		;SAVE T2
	PUSHJ	P,ICONM		;OUTPUT QUESTION
	PUSHJ	P,OPOUT		; ..
	POP	P,T1		;RESTORE ANSWER
	MOVE	T2,DEFSP	;GET BYTE POINTER
	HLL	T1,T2		; ..
ASKDF1:	ILDB	T3,T1		;COPY STRING
	IDPB	T3,T2		; ..
	JUMPN	T3,ASKDF1	; ..
	MOVEI	T3,15		;ADD ON A CR
	IDPB	T3,T2		; ..
	MOVE	T1,OPRCNT	;ALLOW 60 SEC.
	IMULI	T1,JIFSEC##	; ..
	MOVEM	T1,DEFLAG	;STORE AS A FLAG
	MOVEI	T1,1
	SKIPGE	DEFALW
	MOVEM	T1,DEFLAG
	MOVE	T1,DEFSP	;SETUP POINTER
	MOVEM	T1,DEFPTR	; ..
	JRST	GETLI0
DEFSP:	POINT	7,DEFBUF
DEFLAG:	-1
DEFPTR:	POINT	7,DEFBUF
DEFBUF:	BLOCK	24
OPRCNT:	EXP	^D60

DEFALW:	0			;-1 TO TAKE DEFAULT ALWAYS
;SUBROUTINE TO PUT A DECIMAL STRING INTO THE DEFAULT BUFFER
DECDEF:	MOVEI	T2,"0"		;ALWAYS FORCE 2 DIGITS
	CAIGE	T1,^D10		;WILL WE GET MORE THAN ONE ANYWAY?
	IDPB	T2,DEFPTR	;NO--ADD IN LEADING DIGIT
DCDFLP:	IDIVI	T1,12
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,DCDFLP
	HLRZ	T1,(P)
	ADDI	T1,"0"
	IDPB	T1,DEFPTR
	POPJ	P,0
REFLOG::SETTYO
	PUSHJ	P,INLMES##	;CALLED BY DSKWNZ ROUTINE IN COMMON WHEN
				; ONE OR MORE DISKS HAVE BEEN REFRESHED.
	ASCIZ	/To automatically log-in under [1,2] type "LOGIN"

/
	JRST	OPOUT


CPUBAD:	HALT	.		;AND END THE NONSENSE


MEMBAD:	MOVEI	T1,[ASCIZ /%Memory from /]
	PUSHJ	P,ICONM
	MOVE	T1,U
	PUSHJ	P,PRT22A##
	MOVEI	T1,[ASCIZ / to /]
	PUSHJ	P,CONMES##
	MOVE	T1,P3
	SUBI	T1,1
	PUSHJ	P,PRT22A##
	MOVEI	T1,[ASCIZ / is OFF-LINE
/]
	PUSHJ	P,CONMES##
	PUSHJ	P,OPOUT
IFE FTMONL,<
	MOVEI	T1,[ASCIZ /Do you want it to be 1) ON-LINE, or 2) Down? (Type #)
/]
>
IFN FTMONL,<
	MOVEI	T1,[ASCIZ/Do you want it to be 1) ON-LINE, 2) OFF-LINE, or 3) Down? (Type #)
/]
>
	MOVEI	T2,[ASCIZ /2	;Default/]
	PUSHJ	P,ASKDEF
	  JRST	MEMBAD
	PUSHJ	P,DECIN##
	  JRST	MEMBAD
	  JRST	MEMBAD
	SOJE	T2,CPOPJ
IFN FTMONL,<
	SOJE	T2,CPOPJ2##
>
	SOSE	T2
	JRST	MEMBAD
CPOPJ1:	AOS	(P)
	POPJ	P,
SUNXMT::PUSH	P,P1		;SAVE WORKING ACS
	PUSH	P,P2
	PUSH	P,P3
	SETZB	T4,NXMTAB##	;ZERO HIGHEST EXISTANT ADDRESS SEEN, AND NXMTAB
	MOVE	T1,[NXMTAB##,,NXMTAB##+1]
	MOVEI	T2,NXMTAB##	; ..
	BLT	T1,NXMTBL##-1(T2)
	MOVEI	P1,CORBLK##	;NUMBER OF PAGES OF CORE POSSIBLE
	MOVE	T2,[POINT 1,NXMTAB##]
	MOVEI	T3,1		;TO MARK A PAGE AS NON-EXISTANT
	SETZB	P2,U		;ZERO P2 TO CALL A ROUTINE IN SYSINI,
				; START LOOKING FOR NXM AT 0
SUNXM0:
IFN FTKI10,<
	CONO	APR,NXM##	;CLEAR NXM FLAG
>
IFN FTKL10,<
	CONO	APR,LP.CSF+LP.NXM	;CLEAR NXM FLAG
>
IFN FTKS10,<
	WRAPR	SP.CSF+SP.NXM
>
			
	IBP	T2		;NEXT BYTE IN NXMTAB
	MOVEI	P3,MEMITL##	;NUMBER OF WAYS THE MEMORY CAN BE INTERLEAVED
SUNXM1:	PUSH	P,U		;SAVE THE CURRENT ADDRESS
	ADDI	U,-1(P3)	;CHECK PAGE PLUS INTERLEAVE OFFSET
	PUSHJ	P,REFMEM##	;REFERENCE TIS ADDRESS
	POP	P,U		;RESTORE THE CURRENT ADDRESS
	SOJG	P3,SUNXM1	;LOOK AT NEXT ADDRESS WITHIN THIS PAGE
	CONSO	APR,NXM##	;NON-EXISTANT MEMORY SEEN?
	JRST	SUNXM2		;NO
	DPB	T3,T2		;YES, MARK THE PAGE AS NON-EXISTANT
	JUMPN	T4,SUNXM3	;JUMP IF THE LAST PAGE LOOKED AT WAS NXM
	SKIPA	T4,U		;NOT SO, SO REMEMBER THE ADDRESS OF HIGHEST
				; EXISTANT PAGE SEEN SO FAR
SUNXM2:	MOVEI	T4,0		;MEMORY EXISTS, HAVEN'T SEEN THE HIGHEST EXISTANT PAGE YET
SUNXM3:	ADDI	U,PAGSIZ##	;GO ON TO THE NEXT PAGE OF MEMORY
	SOJG	P1,SUNXM0	; PROVIDED ALL POSSIBLE MEMORY HASN'T BEEN CHECKED
SUNXM4:	IDPB	T3,T2		;ONES TO THE END OF THIS WORD IN NXMTAB
	TLNE	T2,770000	; ..
	JRST	SUNXM4		; ..
	SKIPN	T4		;SKIP IF THE HIGHEST POSSIBLE PAGE OF MEMORY DIDNT EXIST
	MOVE	T4,U		;IT DID, SO U CONTAINS THE ADDRESS OF THE HIGHEST PAGE
	POP	P,P3		;RESTORE ACS
	POP	P,P2
	POP	P,P1
	POPJ	P,

IFN FTKLP,<
;SUBROUTINE TO ALLOCATE A MAP FOR A NON-ZERO SECTION
;CALL WITH:
;	T1 = SECTION NUMBER,,0
;RETURNS WITH A MAP ALLOCATED AND ITS ADDRESS STORED IN THIS CPUS
; EXEC SECTION MAP

ALCSMP:	PUSH	P,MONVFF##
	PUSH	P,T1
	MOVEI	T1,.EUPMP
	MOVEM	T1,MONVFF##
	MOVEI	T1,PAGSIZ##
	MOVSI	T2,(<PM.DCD>B2+PM.WRT+PM.CSH+PM.SWB)
	PUSHJ	P,ONCMAP##
	MOVE	T1,[.EUPMP,,.EUPMP+1]
	SETZM	.EUPMP
	BLT	T1,.EUPMP+PAGSIZ##-1
	POP	P,T1
	LSH	T1,-^D18
	MOVE	T2,.CPMAP##
	MOVE	T3,.EUPMP/PAGSIZ##(T2)
	MOVE	T2,.CPEPT##
	ADDI	T2,(T1)
	MOVEM	T3,SECTAB(T2)
	POP	P,MONVFF##
	POPJ	P,

FFMD1::	0
RELMD1::0
>

;SUBROUTINE TO ALLOCATE PHYSICAL PAGES (NOT IN ANY MAP)
;CALL WITH:
;	T1 = NUMBER OF PAGES TO ALLOCATE
;RETURNS CPOPJ IF NONE AVAILABLE, CPOPJ1 T1 = WHERE ALLOCATED
GETPPG:	PUSH	P,P1
	PUSH	P,P2
	MOVE	P1,T1
	MOVE	P2,MONPFF##
	LSH	P2,W2PLSH##
GETPP1:	MOVE	T2,P2
	IDIVI	T2,^D36
	MOVNS	T3
	MOVSI	T4,400000
	LSH	T4,(T3)
	IORM	T4,NXMTAB##(T2)
	AOS	P2
	SOJG	T1,GETPP1
	MOVE	T1,MONPFF##
	LSH	P1,P2WLSH##
	ADDM	P1,MONPFF##
	POP	P,P2
	POP	P,P1
	JRST	CPOPJ1
IFE FTEXE,<
BOOTWD=22			;DF-10 LOCS IN LOWER CORE
				; (LEVEL C RP-10 DF-10 LOCS)
LOWCMD=BOOTWD			;USE LOC 22 AND 23 FOR THE DF10

;I/O DEVICE PARAMETERS

DPC=250				;DEVICE KONTROLLER NUMBER FOR RP10
DPC2=254			;SECOND RP10
O.SEEK==4			;DISK OP FOR SEEK FOR RP10
O.READ==0			;DISK OP FOR READ FOR RP10
O.WRIT==1			;DISK OP FOR WRITE FOR RP10

FHD=170				;DEVICE NUMBER FOR RC10 KONTROLLER
FHD2=174			;SECOND RC10
FH.WRT==1000			;BIT IN DATAO FOR WRITE ON RC10

DHX==270			;FIRST RH10/RP04 DEVICE CODE
DHX2==274			;SECOND RH10/RP04
DH.RED==71			;READ
;FLAGS, RIGHT HALF OF S

R.KDEV=177			;BITS 29-35=KONTROLLER DEVICE CODE
R.TYPE==200			;TYPE OF UNIT ON KONTROLLER
R.DSKW==400			;WILD DISK NAME. TRY ALL.
R.SRIB==1000			;NEED TO SKIP A BLOCK (RIB AT START)
R.STRT==2000			;ON IF LOAD AND GO. OFF IF JUST LOAD


;SYSTEM PARAMETERS WHICH MUST AGREE WITH COMMOD

HOMBK1==1			;ADDRESSES OF HOME BLOCKS
HOMBK2==12			; ..
CODHOM=707070			;VERIFICATION CODE OF HOME BLOCK
CODRIB=777777			;VERIF CODE OF A RIB BLOCK
BLKCOD==176			;WORD ADDRESS OF VERIF CODE
BLKSLF==177			;WORD ADDRESS OF SELF POINTER
RIBFIR==0			;WORD ADDRESS OF RIB AOBJN PTR
RIBNAM==2			;W A OF NAME OF FILE IN THE RIB
RIBEXT==3			;W A OF EXT OF FILE IN THE RIB
RIBSIZ==5			;LENGTH OF FILE IN WORDS

HOMSNM==4			;STRUCTURE NAME IN SIXBIT
HOMLUN==10			;LOGICAL UNIT NUMBER (OCT) IN STR
HOMBSC==14			;BLOCKS PER SUPERCLUSTER IN HOME BLOCK
HOMSCU==15			;SUPERCLUSTERS PER UNIT
HOMCNP==16			;POINTER TO CLUSTER COUNT IN A RET PTR
HOMCKP==17			;POINTER TO CHECKSUM IN A RET PTR
HOMCLP==20			;POINTER TO CLUSTER ADDRESS IN A RET PTR
HOMBPC==21			;BLOCKS PER CLUSTER
HOMREF==23			;NEED TO REFRESH IF NON-ZERO
HOMCRS==41			;LBN IN STR OF CRASH.SAV RIB
HOMMFD==46			;LBN IN STR OF MFD RIB
;HERE WHEN FILE FOUND. FIRST RIB FOR FILE IS IN CORE.

RFILE:	MOVEI	P4,MONORG
RFILE1:	PUSHJ	P,RWORD
	  POPJ	P,
	MOVEM	W,(P4)
	AOJA	P4,RFILE1


;SUBROUTINE TO READ A DATA WORD FROM THE FILE.

RWORD1:	MOVE	P1,DBUFP	;PREPARE TO COUNT DATA WORDS
RWORD:	JUMPGE	P1,RWNXTB	;NEED ANOTHER BLOCK?
	MOVE	W,0(P1)		;NO. GET A WORD.
	AOBJN	P1,.+1		;COUNT IT.
	JRST	CPOPJ1		;RETURN FROM RWORD
RWNXTB:	PUSHJ	P,RDDATA	;NO. READ NEXT DATA BLOCK, IF ANY
	  POPJ	P,		;END OF FILE
	JRST	RWORD1		;READ FROM THIS BLOCK
;SUBROUTINE TO LOOK FOR FILE

LOOK:	MOVS	T1,DEVICE	;GET DEVICE NAME
	SKIPE	T1		;BLANK?
	CAIN	T1,(SIXBIT /DSK/) ;OR JUST DSK?
	TROA	S,R.DSKW	;YES. FLAG WILD DISK NAME
	JRST	LOOK1		;NO. USE SUPPLIED NAME
	MOVE	T1,[SIXBIT /DSK@/]	;START AT DSKA
	MOVEM	T1,DEVICE	;STORE NAME AWAY

LOOK2:	MOVEI	T1,010000	;INCREMENT WILD DSK NAME
	ADDB	T1,DEVICE	; ..
	TRNE	T1,200000	;TRIED UP TO DSKO?
	POPJ	P,		;YES. GIVE UP, IT AINT THERE.

LOOK1:	MOVE	T1,DEVICE	;DEVICE NAME TO LOOK FOR
	MOVEM	T1,STRUCT	;TO ARG OF SEARCH ROUTINE
	SETZM	SLUNIT		;CLEAR LOGICAL UNIT NUMBER
	PUSHJ	P,FNDUNI	;TRY TO FIND SUCH A UNIT
	  JRST NOTFND		;NOT THERE.
	SKIPN	F,PPN		;FIRST SEARCH FOR THE UFD
	MOVE	F,SYSPPN	;IF NONE, ASSUME 1,4
	MOVSI	U,(SIXBIT /UFD/) ;EXTENSION IS UFD FOR FILE DIR
	MOVE	T1,HBUF+HOMMFD	;LBN IN STR OF MFD RIB
	PUSHJ	P,SRCHFD	;SEARCH FOR THE REQUESTED UFD
	  JRST NOTFND		;NOT THERE.
	MOVE	F,FNAME		;NAME OF FILE TO SEARCH FOR
	MOVSI	U,(SIXBIT /SAV/) ;ASSUME SAV EXTENSION
	SKIPE	FEXT		;UNLESS ONE SUPPLIED
	HLLZ	U,FEXT		;IN WHICH CASE, USE IT.
	HRRZ	T1,1(T1)	;SUPERCLUSTER ADDRESS OF THE UFD
	IMUL	T1,HBUF+HOMBSC	;MAKE IT A BLOCK NUMBER
	PUSHJ	P,SRCHFD	;SEARCH FOR THE FILE IN THE UFD
	  JRST NOTFND		;NO SUCH FILE.
	HRRZ	M,1(T1)		;SUPERCLUSTER OF START OF THE FILE
	IMUL	M,HBUF+HOMBSC	;CONVERT TO LOGICAL BLOCK NUMBER
	PUSHJ	P,SETRIB	;GET THE RIB, CHECK IT
	  JRST NOTFND		;NO LUCK. ASSUME FILE NOT THERE.
	HLLZ	T1,RBUF+RIBEXT	;GET THE EXTENSION FROM RIB
	CAMN	T1,U		;DESIRED EXTENSION?
	CAME	F,RBUF+RIBNAM	;AND NAME?
	  PUSHJ P,ERROR		;NO. QUIT, RIB BAD.
	JRST	CPOPJ1		;SUCCESS RETURN

NOTFND:	TRNE	S,R.DSKW	;WILD DEVICE ARGUMENT?
	JRST	LOOK2		;YES. INCREMENT IT
	POPJ	P,
;SUBROUTINE TO SET UP A RIB BLOCK AND CHECK IT.

SETRIB:	PUSHJ	P,LBNSEL	;MAKE SURE ON RIGHT UNIT
	  POPJ P,0		;NOT THERE
	MOVEI	T1,RBUF-1	;ADDRESS OF THE RIB BUFFER
	PUSHJ	P,RDBLK		;READ THE FILE'S RIB
	  POPJ P,0		;COULDN'T READ IT
	SETZM	CLUCNT		;NO CLUSTERS LEFT
	SETZM	BLKCNT		;NO BLOCKS LEFT IN CLUSTER
	MOVE	T1,RBUF+RIBSIZ	;LENGTH OF FILE
	MOVEM	T1,LENGTH	;SAVE FOR EOF TEST
	TRO	S,R.SRIB	;WANT TO SKIP THE RIB WHEN READING
	MOVE	P2,RBUF+RIBFIR	;POINTER TO REAL RIB DATA
	JRST	CPOPJ1		;SUCCESSFUL RETURN
;SUBR TO SEARCH T1 UFD OR MFD FOR FILE & EXT.
; RIB M IN STR OF THE FD IN T1

SRCHFD:	SKIPG	M,T1		;STORE BLOCK TO READ RIB FROM.
	PUSHJ	P,ERROR		;SHOULDNT BE EOF
	PUSHJ	P,SETRIB	;SET UP THE RIB
	  POPJ P,0		;CAN'T READ IT
SCHL1:	PUSHJ	P,RDDATA	;READ THE FILE DIR DATA FROM THIS FD
	  POPJ P,0		;ERROR RETURN
	MOVE	T1,DBUFP	;POINTER TO THE DATA BUFFER
SCHL2:	MOVE	T2,0(T1)	;GET A FILE NAME
	CAME	T2,F		;IS NAME RIGHT?
	JRST	SCHN2		;NO. MOVE ON.
	HLLZ	T2,1(T1)	;CHECK THE EXTENSION
	CAMN	T2,U		;IS IT RIGHT TOO?
	JRST	CPOPJ1		;YES. GOOD RETURN, ANSWER AT (T1)
SCHN2:	AOBJN	T1,.+1		;MOVE ON TO NEXT FILE IN FD
	AOBJN	T1,SCHL2	;COUNT FILE, EXT. CHECK NEXT FILE IN FD
	JRST	SCHL1		;READ ON.

;SUBR TO SELECT CORRECT UNIT FROM M

LBNSEL:	MOVE	T1,M		;GET DESIRED BLOCK NUMBER
	MOVE	T2,HBUF+HOMBSC	;COMPUTE SIZE OF UNIT
	IMUL	T2,HBUF+HOMSCU	; ..
	IDIV	T1,T2		;SCALE LBN INTO A UNIT AND LOCAL LBN
	MOVE	M,T2		;LBN WITHIN THE UNIT
	CAMN	T1,HBUF+HOMLUN	;ALREADY AT THIS UNIT?
	JRST	CPOPJ1		;YES. NO NEED TO CHANGE UNITS
	MOVEM	T1,SLUNIT	;NO. NEED TO FIND IT.
	PUSH	P,M		;SAVE THE LBN WITHIN DESIRED UNIT
	PUSHJ	P,FNDUNI	;FIND THE UNIT
	  SOS -1(P)		;NOT THERE. SET FOR NON-SKIP RETURN.
	POP	P,M		;RESTORE UNIT LBN
	JRST	CPOPJ1		;AND SKIP RETURN.

;SUBROUTINE TO READ NEXT BLOCK OF DATA INTO DBUF

RDDATA:	SKIPGE	LENGTH		;ANY DATA LEFT?
	POPJ	P,0		;NO.
	MOVNI	T1,200		;SEE IF ANY LEFT
	ADDB	T1,LENGTH	;COUNT FILE SIZE DOWN
	PUSHJ	P,SELBLK	;SELECT NEXT DATA BLOCK OF FILE
	  POPJ P,0		;NONE LEFT.
	MOVEI	T1,DBUF-1	;SELECT DATA BUFFER
	PJRST	RDBLK		;READ THE BLOCK AND RETURN
				; SKIP RETURN IF NO ERROR
;SUBROUTINE TO SELECT NEXT BLOCK OF DATA
; THE DATA IS FOUND USING RIB'S STARTING AT 0(P2), OR
; IF STUFF LEFT OVER FROM CURRENT RIB, VIA CLUCNT, BLKCNT, CLBN

SELBLK:
SEL5:	AOS	M,CLBN		;ASSUME WILL USE NEXT BLOCK
	SOSL	BLKCNT		;ANY BLOCKS LEFT IN CURRENT CLUSTER?
	JRST	SEL1		;YES. GO PICK ONE.
	SOSL	CLUCNT		;ANY CLUSTERS LEFT IN CURRENT RET PTR?
	JRST	SEL2		;YES. PICK ONE.
SEL4L:	SKIPGE	P2		;FAIL IF OUT OF POINTERS
	SKIPN	T1,RBUF(P2)	;NEED ANOTHER RET PTR. EOF YET?
	POPJ	P,0		;YES. FAIL RETURN.
	AOBJN	P2,.+1		;COUNT POINTER FOR NEXT RIB
	MOVE	T3,HBUF+HOMCNP	;GET THE COUNT POINTER
	PUSHJ	P,RIBBYT	;GET COUNT OF CURRENT RET PTR
	JUMPN	T2,SEL3		;IF NON-ZERO, GO GET CLUSTER
	MOVE	T3,HBUF+HOMCLP	;NEW UNIT. GET UNIT LOGICAL NUMBER
	PUSHJ	P,RIBBYT	; ..
	CAMN	T2,HBUF+HOMLUN	;IS THIS UNIT RIGHT ALREADY?
	JRST	SEL4		;YES. DON'T SEARCH
	MOVEM	T2,SLUNIT	;NO. SAVE LOG UNIT NUMBER FOR SEARCH
	PUSHJ	P,FNDUNI	;FIND THE UNIT
	  POPJ P,0		;NOT FOUND. ERROR.
SEL4:	JRST	SEL4L		;READ NEXT RIB ON NEW UNIT

SEL3:	SUBI	T2,1		;COUNT CLUSTER ABOUT TO BE USED.
	MOVEM	T2,CLUCNT	;AND SAVE REMAINDER.
	MOVE	T3,HBUF+HOMCLP	;GET THE CLUSTER ADDRESS
	PUSHJ	P,RIBBYT	; ..
	IMUL	T2,HBUF+HOMBPC	;CONVERT TO AN LBN
	MOVEM	T2,M		;PUT IN CORRECT AC
SEL2:	MOVE	T1,HBUF+HOMBPC	;BLOCKS IN A CLUSTER
	SUBI	T1,1		;MINUS THE ONE ABOUT TO BE READ
	MOVEM	T1,BLKCNT	;SAVE THIS COUNT
SEL1:	MOVEM	M,CLBN		;SAVE CURRENT LBN
	TRZE	S,R.SRIB	;SKIP RIB?
	JRST	SEL5		;YES. GO THROUGH THIS ROUTINE AGAIN
;CHECKSUM HERE?
	JRST	CPOPJ1		;SUCCESSFUL RETURN FROM SELBLK
;ROUTINE TO FIND A PARTICULAR LOGICAL UNIT IN THE SYSTEM
;ARGUMENTS ARE: STRUCTURE F (SIXBIT) IN STRUCT, AND
;UNIT NUMBER WITHIN STRUCTURE IN SLUNIT.
;SKIP RETURN IF FOUND.

FNDUNI:	SETZM	TTYPE		;CLEAR SEARCH TEMPS
FNDUL1:	SETZM	TUNIT		; ..
FNDUL2:	MOVE	J,TTYPE		;GET KONTROLLER TYPE
	MOVE	P3,TUNIT	;AND UNIT NUMBER
	PUSHJ	P,HOME		;TRY TO READ ITS HOME BLOCK
	  JRST FNDUNX		;NO GOOD. ON TO NEXT.
	MOVE	T1,HBUF+HOMSNM	;FOUND THIS UNIT. IS IT DESIRED ONE?
	MOVE	T2,HBUF+HOMLUN	; ..
	CAMN	T1,STRUCT	;CHECK AGAINST SUPPLIED ARGS
	CAME	T2,SLUNIT	; ..
FNDUNX:	AOSA	T1,TUNIT	;NO GOOD. ON TO NEXT.
	JRST	CPOPJ1		;CORRECT. SKIP RETURN.
	CAIG	T1,UNIMAX	;TOO BIG?
	JRST	FNDUL2		;NO. GO CHECK THIS ONE
	AOS	T1,TTYPE	;YES. COUNT TO NEXT TYPE OF KONTROLLER
	CAIG	T1,TYPEMX	;ALL OF THOSE GONE BY?
	JRST	FNDUL1		;NO. TRY THIS ONE.
	POPJ	P,0		;ALL TRIED. GIVE FAIL RETURN.

RIBBYT:	HRRI	T3,T1		;WHERE THE WORD IS
	LDB	T2,T3		;GET THE DESIRED BYTE
	POPJ	P,0		;AND RETURN
;ROUTINE TO DETERMINE WHETHER A UNIT EXISTS, AND IF SO, TO READ
;ITS HOME BLOCK INTO THE HOME BUFFER

;CALLING SEQUENCE:
;J/	KONTROLLER TYPE INDEX
;P3/	UNIT NUMBER, 0-7
;	PUSHJ P,HOME
;	  NOT THERE RETURN
;	OK RETURN

;AT THIS POINT, ANY NEEDED UNIT PARAMETERS ARE SAVED, SUCH AS R.TYPE
; AND THE HOME BLOCK IN HBUF
HOME:	TRZ	S,R.TYPE	;ASSUME UNIT TYPE IS RD10 OR RP02
	MOVEM	P3,CUNIT	;SAVE CURRENT UNIT NUMBER
	MOVEM	J,CTYPE		;AND KONTROLLER TYPE
	MOVE	T3,J
	LSH	T3,-1		;DF10C CONI BIT FOR APPROPRIATE CONTROLLER
	MOVE	T3,[40000,,0
		       20,,0
		     4000,,0](T3)
	MOVEM	T3,DFBIT	;STORE THE BIT IN CORE.
	MOVEI	T3,UNIINI	;ABS ADR OF INI TABLE BASE(ARG FOR SETCHN)
	TLO	T3,J		;SET INDEX FIELD FOR RELOCATION BY J(KONT. TYPE)
	LDB	T1,[POINT 7,@T3,9] ;KONTROLLER DEVICE CODE FROM INI TABLE
	TRZ	S,R.KDEV	;CLEAR KONTROLLER FIELD
	TRO	S,(T1)		;SET KONTROLLER FIELD
	MOVEI	M,HOMBK1	;WANT TO READ FIRST HOME BLOCK
	MOVEI	T1,DBUF-1	;BUFFER FOR TEST I/O
	PUSHJ	P,SETCHN	;SET UP CHANNEL COMMAND LIST
				; AND CALL INITIALIZE KONT. ROUTINE
	  POPJ P,0		;ERROR. NOT THERE.
HOM1:	MOVEI	T1,HBUF-1	;READ HOME BLOCK INTO ITS BUFFER
	PUSHJ	P,RDBLK		;TRY TO READ THE HOME BLOCK
	  JRST HOM2		;CAN'T READ THAT ONE
	MOVE	T1,HBUF+BLKCOD	;GET THE CODE WORD
	CAIN	T1,CODHOM	;IS IT RIGHT?
	SKIPE	HBUF+HOMREF	;AND NOT NEEDING REFRESHING?
	JRST	HOM2		;NO GOOD.
	JRST	CPOPJ1		;OK RETURN.

HOM2:	CAIN	M,HOMBK2	;TRIED BOTH BLOCKS?
	POPJ	P,0		;YES. GIVE FAIL RETURN
	MOVEI	M,HOMBK2	;NO TRY ANOTHER ONE.
	JRST	HOM1		;READ SECOND HOME BLOCK

;INITIALIZE KONTROLLER ROUTINES (CONSO IRRELEVANT - USED TO GET DEVICE CODE

UNIINI:	CONSO	FHD,FHDINI	;FIRST FHD
	CONSO	FHD2,FHDINI	;SECOND FHD
	CONSO	DPC,DPCINI	;FIRST DPC
	CONSO	DPC2,DPCINI	;SECOND DPC
	CONSO	DHX,DHXINI	;FIRST DHX
	CONSO	DHX2,DHXINI	;SECOND DHX
TYPEMX==.-UNIINI-1		;MAXIMUM KONTROLLER ROUTINE
UNIMAX==7			;MAX NUMBER OF UNITS ON A KONTROLLER
;INITIALIZATION FOR RC10 FIXED HEAD DISK/DRUM

FHDINI:	CAILE	P3,3		;ONLY 3 UNITS ON FHD KONTROLLER
	POPJ	P,0		;ASKED FOR UNIT OVER 3. ERROR RETURN.
	ROT	P3,-2		;INTO UNIT NUMBER FIELD
	TLO	P3,160		;TRACK 0, SECTOR 70 BCD. ILLEGAL ON RM10B
	HRRI	P3,LOWCMD	;CHANNEL COMMAND ADDRESS
	MOVE	T3,[DATAO P3]	;SET UP DATAO FROM P3
	PUSHJ	P,IOXCT		;PERFORM DATAO ON RIGHT DEVICE
	PUSHJ	P,IOWAIT	;WAIT FOR DONE OR TIMEOUT
	JUMPLE	T2,CPOPJ	;QUIT IF TIMED OUT
	MOVEI	T1,170220	;ERROR FLAGS?
	PUSHJ	P,IOCNSZ	;DO A CONSZ
	POPJ	P,0		;ERRORS OR NOT DONE. FAIL RETURN
	MOVEI	T1,200000	;SEARCH ERROR?
	PUSHJ	P,IOCNSZ	; ..
	TRO	S,R.TYPE	;YES. PROBABLY A DRUM.
	JRST	CPOPJ1		;GIVE GOOD RETURN

;INITIALIZATION FOR PACKS

DPCINI:	CAILE	P3,7		;LEGAL DRIVE NUMBER?
	POPJ	P,0		;NO. NON-EXISTENT RETURN.
	DPB	P3,PDRIVE	;SAVE FOR IO
	MOVEI	T1,37		;T1 BAD SURFACE FOR ALL PACKS
	DPB	T1,PSURF	;STORE FOR DATAO
	DPB	P3,PSEC		;STORE FOR DATAO
	MOVE	T3,[DATAO DATAOW] ;SET UP T1 DATAO TO PACKS
	PUSHJ	P,IOXCT		;DATAO ON RIGHT DEVICE
	PUSHJ	P,IOWAIT	;TIMEOUT OR DONE FLAG
	JUMPLE	T2,CPOPJ	;TIMED OUT?
	MOVEI	T1,2000		;DRIVE NOT THERE?
	PUSHJ	P,IOCNSZ	; ..
	POPJ	P,0		;NOT THERE. ERROR RETURN.
	MOVE	T3,[DATAI T1]	;SET UP TO GET UNIT TYPE
	PUSHJ	P,IOXCT		; ..
	TRNE	T1,2000		;SKIP IF NOT RP03
	TRO	S,R.TYPE	;FLAG AS RP03
	JRST	CPOPJ1		;SUCCESS RETURN
;INITIALIZATION FOR RH10/RP04

DHXINI:	CAILE	P3,7
	POPJ	P,
	MOVSI	T1,60000(P3)
	PUSHJ	P,IODTI		;READ DRIVE TYPE REGISTER
	LDB	T2,[POINT 9,T1,35]
	TLNN	T1,5000
	CAIE	T2,20
	POPJ	P,		;NO DEVICE OR NOT AN RP04
	MOVSI	T1,4000(P3)
	HRRI	T1,23		;DO A PACK ACKNOWLEDGE
	PUSHJ	P,IODTO		;JUST IN CASE
	JRST	CPOPJ1

IODTI:	MOVE	T3,[DATAO T1]
	PUSHJ	P,IOXCT
	TLZA	T3,100		;TURN IT INTO A DATAI
IODTO:	MOVE	T3,[DATAO T1]
	PJRST	IOXCT

IOWAIT:	SETOB	T1,T2		;LOOK FOR ALL FLAG BITS
	PUSHJ	P,IOCNSO	;ANYTHING THERE?
	  POPJ P,0		;NO SUCH DEVICE AT ALL
	MOVEI	T2,^D50000	;TIMEOUT
	MOVEI	T1,10		;DONE FLAG, ALL KONTROLLERS
	PUSHJ	P,IOCNSO	;LOOK FOR DONE
	SOJG	T2,.-2		;NOT YET. COUNT DOWN AND LOOP
	POPJ	P,0		;DONE OR TIMED OUT.
;ROUTINE TO READ T1 BLOCK FROM THE DEVICE KONTROLLER AND UNIT IN
;CTYPE AND CUNIT INTO THE BUFFER AT (T1)+1, FROM LOGICAL BLOCK NUMBER
;IN LBN. SKIP RETURN IF SUCCESSFUL, NON-SKIP IF ANY HARDWARE ERRORS

RDBLK:	PJSP	T3,SETCHN	;SETUP CHANNEL CONTROL WORD AND CALL
				; PROPER READ ROUTINE BELOW DEP. ON TYPE

	Z	FHDRED		;RC10
	Z	FHDRED		;SECOND FHD
	Z	DPCRED		;RP10
	Z	DPCRED		;SECOND RP10
	Z	DHXRED		;RH10/RP04
	Z	DHXRED		;SECOND RH10/RP04

;SUBROUTINE TO SETUP CHANNEL, THEN DISPATCH TO DEVICE DEP ROUTINE
;CALL:	MOVEI T1,ABS. ADR. OF FIRST DATA WORD-1
;	HRRI T3,ABS. ADR. OF FIRST WORD IN DISPATCH TABLE
;	PUSHJ P,SETCHN
;	ERROR RETURN
;	OK RETURN

SETCHN:	HRRM	T1,LOWCMD	;SAVE ADDRESS
	MOVE	J,CTYPE		;GET CONTROLLER TYPE
	ADD	J,T3		;ADDRESS OF TABLE ENTRY
	MOVE	T3,[CONI T3]	;READ THE CONI BITS
	PUSHJ	P,IOXCT		; ..
	MOVSI	T2,-200		;ASSUME 18 BIT DF10
	TDNE	T3,DFBIT	;SKIP IF NOT DF10-T3
	LSH	T2,4		;22-BIT DF10 MOVE WORD COUNT
	HLLM	T2,LOWCMD	;STORE COMMAND
	SETZM	LOWCMD+1	;ALSO CLEAR FINAL CONTROL WORD ADDR
	SKIPG	T1,M		;GET AND CHECK BLOCK NUMBER
	PUSHJ	P,ERROR		;SHOULD BE .GT. 0
	PJRST	@(J)		;CALL DISPATCH ENTRY AS A SUBROUTINE RETURN
;READ FROM RC10. LBN IS IN T1, CHANNEL IS SET UP FOR ONE BLOCK (128 WDS)
;R.TYPE=0 IF RD10, 1 IF RM10B. UNIT NUMBER IS IN CUNIT, AND IS
;ASSUMED LEGAL.
;NOTE:	AN RD10 DISK HAS 200. TRKS OF 80. SECT OF 32. WDS =4000.*128. WDS
;	AN RM10B DRUM HAS 90. TRKS OF 60. SECT OF 64. WDS =2700.*128. WDS

FHDRED:	PUSHJ	P,FHDCNV	;SET UP DATAO WORD WITH ITS BCD STUFF
	MOVE	T3,[DATAO P3]	;SET UP DATAO TO RC10
	PUSHJ	P,IOXCT		;DO THE DATAO TO RIGHT DEVICE
	PJRST	DPCWAT		;WAIT FOR IO AND CHECK ERRORS
				; SKIP RETURN IF NO ERRORS.

FHDCNV:	MOVEI	T3,^D20		;ASSUME RD10
	TRNE	S,R.TYPE	;WHICH IS IT?
	MOVEI	T3,^D30		;RM10B
	IDIVI	T1,0(T3)	;T1_TRACK, T2_#OF 128 WORD SECTOR ON TRK
	PUSH	P,T2		;SAVE SECTOR*P3
	IDIVI	T1,12		;CONVERT TO BCD
	CAIL	T1,12		;..
	ADDI	T1,6		; ..
	LSH	T1,4		;POSITION TRACK ADR
	IOR	T1,T2		;BOTH DIGITS
	ROT	T1,-13		;TO PLACE FOR DATAO
	EXCH	T1,0(P)		;SAVE ON STACK. GET SECTOR ADDR
	LSH	T1,1		;TO 64. WD "SECTORS"
	TRNN	S,R.TYPE	;RD10?
	LSH	T1,1		;YES. MAKE IT 32. WD SECTORS
	IDIVI	T1,12		;NOW CONVERT TO BCD
	LSH	T1,4		;SHIFT HIGH DIGIT LEFT
	IOR	T1,T2		;OR IN LOW DIGIT
	HRLZS	T1		;POSITION FOR DATAO
	IORM	T1,0(P)		;STORE SECTOR
	MOVE	T1,CUNIT	;GET UNIT NUMBER
	ROT	T1,-2		;POSITION FOR RC10 DATAO
	IORM	T1,0(P)		;COMPLETE WORD
	POP	P,P3		;RESTORE TO AN AC
	TRO	P3,LOWCMD	;PUT IN CHANNEL ADDRESS
	POPJ	P,0		;DONE AT LAST
;READ ROUTINES FOR THE DISK PACKS

DPCRED:	PUSHJ	P,DPCCNV	;CONVERT AND SEEK FOR BLOCK
	  POPJ P,0		;BAD BLOCK NUMBER
	MOVEI	T1,O.READ	;SET OPERATION TO READ BLOCK
	JRST	DPCOPR		;READ THE BLOCK (CHANNEL ALL SET)

DPCCNV:	IDIVI	T1,12		;GET SECTOR NUMBER
	DPB	T2,PSEC		;SAVE IT
	IDIVI	T1,24		;GET SURF AND CYL
	DPB	T2,PSURF	;STORE SURFACE
	DPB	T1,PCYL		;STORE CYLINDER
	HRRZI	T2,200000	;EXTENDED CYLINDER ADDRESS IF RP03
	TRZE	T1,400		;SKIP IF NOT EXTENDED CYLINDER
	IORM	T2,DATAOW	;IS EXTENDED, SET PROPER BIT
	MOVE	P3,CUNIT	;CURRENT UNIT
	DPB	P3,PDRIVE	;STORE THAT TOO.
	TRNN	S,R.TYPE	;SKIP IT RP03
	CAIG	T1,^D202	;NOT RP03, SKIP IF CYLINDER NOT ON DISK
	CAILE	T1,^D405	;RP03 - SKIP IF OK
	PUSHJ	P,ERROR		;TOO BIG A LBN
	MOVEI	T1,O.SEEK	;MAKE DISK SEEK TO THE CYLINDER
DPCOPR:	DPB	T1,OPPNT	;STORE THE OPERATION
	MOVE	T3,[DATAO CLRATN] ;SET UP DATAO
	PUSHJ	P,IOXCT		;DO DATAO WITH RIGHT DEVICE
	HRRI	T3,DATAOW	;NEW ADDRESS(R IN INDEX FIELD ALREADY)
	XCT	T3		;SEND THIS WORD TOO

;SUBROUTINE TO WAIT FOR IO AND CHECK ERRORS

DPCWAT:	PUSHJ	P,IOWAIT	;WAIT FOR DONE FLAG OR TIMEOUT
	JUMPLE	T2,CPOPJ	;IF TIMED OUT, GIVE UP.
	MOVEI	T1,177720	;ANY ERRORS?
				;FALL INTO IOCNSZ(SKIP RETURN IF GOOD)

IOCNSZ:	SKIPA	T3,[CONSZ 0(T1)] ;SET UP I/O INSTR.
IOCNSO:	MOVSI	T3,(CONSO (T1))	;SETUP IO INSTR.
IOXCT:	DPB	S,[POINT 7,T3,9] ;PUT IN I/O DEVICE FIELD
	XCT	T3		;DO THE IO
	POPJ	P,		;NO SKIP RETURN
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;NO SKIP RETURN
;READ ROUTINES FOR RH10/RP04

DHXRED:	HRLI	P3,DH.RED
	IDIVI	T1,^D380
	HRLI	T1,124000(P3)
	PUSHJ	P,IODTO		;DESIRED CYLINDER
	IDIVI	T2,^D20
	DPB	T2,[POINT 5,T3,27]
	MOVSI	T1,54000(P3)
	HRR	T1,T3
	PUSHJ	P,IODTO		;DESIRED SECTOR, SURFACE
	MOVS	T1,P3
	TDO	T1,[404000,,200000!LOWCMD_6]
	PUSHJ	P,IODTO		;START THE IO
	PUSHJ	P,IOWAIT
	JUMPLE	T2,CPOPJ
	MOVSI	T1,10000(P3)
	PUSHJ	P,IODTI		;READ STATUS REGISTER
	TRNE	T1,40000
	POPJ	P,
	MOVEI	T1,736320
	PJRST	IOCNSZ


SYSPPN:	XWD	1,4		;DEFAULT PROJ-PROG
SYSTEM:	SIXBIT	/SYSTEM/	;DEFAULT FILENAME
CRASH:	SIXBIT	/CRASH/		;DEFAULT DUMP F
DBUFP:	XWD	-200,DBUF	;POINTER TO DATA BLOCK

PDRIVE:	POINT	3,DATAOW,5	;DRIVE NUMBER FOR DATAO
PCYL:	POINT	8,DATAOW,13	;CYLINDER NUMBER FOR DATAO
PSURF:	POINT	5,DATAOW,18	;SURFACE NUMBER FOR DATAO
PSEC:	POINT	5,DATAOW,23	;SECTOR NUMBER FOR DATAO
OPPNT:	POINT	3,DATAOW,2	;OPERATION FOR DATAO
CLRATN:	XWD	500000,776	;CLEAR ATTENTION FLAGS.
DATAOW:	EXP	LOWCMD		;LOW CORE ADR FOR DF10

CTYPE:	BLOCK	1
CUNIT:	BLOCK	1
TTYPE:	BLOCK	1
TUNIT:	BLOCK	1
STRUCT:	BLOCK	1
SLUNIT:	BLOCK	1
CLUCNT:	BLOCK	1
BLKCNT:	BLOCK	1
CLBN:	BLOCK	1
LENGTH:	BLOCK	1
DFBIT:	BLOCK	1

;BUFFERS FOR HOME BLOCK, DATA, AND RIB
HBUF:	BLOCK	200
RBUF:	BLOCK	200
DBUF:	BLOCK	200
ERROR:	STOPCD	.,HALT,HNF,	;++HI-SEG NOT FOUND
>;END IFE FTEXE
;MONITOR EXPECTS TO FIND DEVICE, FILE, U AND PPN HERE
DEVICE:	BLOCK	1
FNAME:	BLOCK	1
FEXT:	BLOCK	1
PPN:	BLOCK	1
SFDLST:	BLOCK	5


RADIX 8

XLIST	;LITERALS

LIT


LIST

VAR
	$HIGH
MONTOP==.
	$LOW
ONCEND::END
