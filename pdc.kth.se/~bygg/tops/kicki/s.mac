UNIVERSAL S - SYSTEM PARAMETER FILE FOR 7.02 MONITOR - V1237
.directive .nobinary

SUBTTL	/TH/AF/CHW/RCC/DAL/I/BGE/RLD/JBS	3 JAN 83

SEARCH	F

STUPID==-1			;This is SuperTOPS.

DEFINE	.CPYRT(ARG,SHOW),<>

DEFINE	XPP(A,B)	;SYSTEM PARAMETER WHICH WILL PRINT-OUT FROM DDT
<A=:B>

DEFINE	XPL(A,B)	;LOCAL PARAMETER WHICH WILL PRINT-OUT FROM DDT
<A=B>

DEFINE	XP(A,B)		;SYSTEM PARAMETER WHICH WILL NOT PRINT FROM DDT
<A==:B>

DEFINE	ND(A,B)		;DEFINE A IF NOT DEFINED
<IFNDEF A,<XP <A>,<B>>>

DEFINE	NDL(A,B)	;DEFINE A AS LOCAL IF NOT DEFINED
<IFNDEF A,<A==B>>
SALL			;SUPPRESS MACRO EXPANSIONS

;               TABLE OF CONTENTS FOR S
;
;
;                        SECTION                               PAGE
;    1. ACCUMULATOR ASSIGNMENTS...............................   4
;    2. CHANNEL DATA BLOCK....................................   7
;    3. DEVICE DATA BLOCK (DDB)...............................   9
;    4. FLAG BITS
;         4.1   S AND DEVIOS(F)...............................  16
;         4.2   UUOS..........................................  18
;	  4.3   JOBPEK........................................  19
;         4.4   PAGE ACCESSIBILITY UUO........................  20
;         4.5   PAGE. UUO.....................................  20
;    5. PAGE. UUO
;         5.1   FUNCTION CODES................................  20
;         5.2   ERROR CODES...................................  20
;    6. BITS FOR TESTING UUOS.................................  21
;    7. SCHED. UUO ERROR CODES................................  22
;    8. TRMOP. UUO ERROR CODES................................  22
;    9. DTE. UUO ERROR CODES..................................  22
;   10. SEARCH LIST PARAMETERS AND LIMITS.....................  23
;   11. BITS IN JOB TABLES
;        11.1   JOB STATUS WORD (JBTSTS)......................  27
;        11.2   JBTSCD........................................  31
;        11.3   JBTST2........................................  32
;        11.4   JBTSWP, JBTPPB AND PAGTAB.....................  33
;        11.5   MEMTAB AND SWPLST.............................  34
;        11.6   JBTSGN........................................  35
;        11.7   JBTPRV........................................  36
;        11.8   WORDS OF PROCESS DATA BLOCKS..................  36
;        11.9   JBTWCH AND JBTRSP.............................  37
;        11.10  JBTLIM, JBTSPL, .PDOBI........................  38
;        11.11  JBTSPS........................................  39
;        11.12  JBTPIA AND PSISER DEFINITIONS.................  40
;   12. ERROR CODES...........................................  42
;   13. EXTENDED I/O ERRORS...................................  43
;   14. JOB BUFFER HEADER.....................................  44
;   15. ARGUMENTS FOR EXTENDED LOOKUP/ENTER/RENAME............  45
;   16. MEM PARITY ERROR RECOVERY.............................  46
;   17. CODES FOR DAEMON ERROR REPORTING......................  48
;   18. BITS IN STATES AND DEBUGF.............................  49
;   19. TAPSER AND IORB BIT DEFINITIONS.......................  50
;   20. MTAPE AND TAPOP. DEFINITIONS..........................  53
;   21. TAPE LABEL DEFINITIONS................................  54
;   22. EVENT WAIT CODE DEFINITIONS...........................  55
;   23. CODES SENT TO THE FILE DAEMON.........................  55
;   24. BITS RETURNED TO THE MONITOR BY THE FILE DAEMON.......  55
;   25. BITS IN THE RH OF .CPSBR..............................  55
;   26. SAVE-FILE FORMAT DEFINITIONS..........................  56
;   27. BITS IN GETTAB TABLE (NUMTAB).........................  57
;   28. TELETYPE PARAMETERS...................................  58
;   29. DEFINITIONS FOR DC44, DC75, DC76, DN60 AND DAS85......  59
;   30. HARDWARE BITS
;        30.1   FOR BOTH KA10 AND KI10 PROCESSORS.............  67
;        30.2   FOR KA10 PROCESSOR (APR, PI, PC)..............  68
;        30.3   FOR KI10 PROCESSOR............................  71
;        30.4   FOR KL10 PROCESSOR............................  76
;        30.5   FOR KS10 PROCESSOR............................  81
;        30.6   FOR KS10 UBA AND DEVICES......................  84
;   31. KI10/KL10/KS10 PAGE MAP LAYOUT........................  86
;   32. FEATURE TEST SWITCHES WHICH MUST BE ON................  91
;   33. SYSTEM MACROS
;        33.1   GENERAL.......................................  92
;        33.2   NETSER INTERLOCK MANAGEMENT...................  94
;        33.3   STOPCD........................................  97
;        33.4   FRAME.........................................  99
;        33.5   TEXT CONCATENATION............................ 100
;        33.6   SOPDEF, GOPDEF, GSOPDEF....................... 102
;        33.7   METER POINT................................... 103
;        33.8   EXECUTIVE EXECUTE............................. 104
;        33.9   KL10 SPECIFIC................................. 105
;        33.10  SOFTWARE INTERRUPTS........................... 110
;        33.11  TWO SEGMENT MONITOR........................... 111
;        33.12  UUO ERROR CODE GENERATOR...................... 112
;        33.13  MULTI PROCESSING.............................. 113
;        33.14  DISK AND TAPE PI CONTROL...................... 114
;        33.15  QUEUE DEFINITIONS............................. 116
;   34. OPDEFS................................................ 117
;   35. MONITOR/USER SYMBOL PREFIXES.......................... 118
;   36. DEFINE THE SYMBOLS FOR THE LINK PSEUDO OPERATIONS..... 120
;   37. KLINIK DEFINITIONS.................................... 120
	SUBTTL	ACCUMULATOR ASSIGNMENTS

;* MEANS LOADED BY UUO HANDLER ON ALL UUOS

XPP S,0		;*I/O DEVICE STATUS WORD (SEE BELOW FOR BITS)
XPP P,1		;*PUSH DOWN POINTER (SEPARATE LIST FOR EACH PI
		; CHANNEL AND EACH USER JOB)
XPP J,2		;BUFFER ITEM COUNT, OR JOB NUMBER
		;IN LEVEL D FILSER ADR OF CONTROLLER
		;  DATA BLOCK - ONE PER CONTROLLER
		;IN REMOTE COMMUNICATIONS HANDLER ADR OF STATION DATA BLOCK
XPP R,3		;*LH=HIGHEST RELATIVE LOCATION IN USER AREA
XPP F,4		;*LH=UUOS DONE SO FAR FOR THIS DEVICE (SEE BELOW)
		; RH=ADDRESS OF DEVICE DATA BLOCK - ONE PER FILE
XPP U,5		;TTY OUTPUT BUFFER POINTER FOR COMMANDS, ERROR
		; MESSAGES, ETC.	;OR TEMPORARY
		;ADDRESS OF 3 WORD BUFFER HEADER IN USER AREA
		;IN LEVEL D FILSER ADR OF UNIT DATA BLOCK - ONE FOR EACH
		; DISK UNIT (POSITIONER) EVEN IF SAME TYPE
		;IN TERMINAL HANDLER ADR OF LINE DATA BLOCK OF THIS TTY
XPP T1,6	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
XPP T2,T1+1	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
		;IN TERMINAL HANDLER CHARACTER ADDRESS IN CHARACTER POOL
XPP T3,T2+1	;TEMPORARY
		;IN TERMINAL HANDLER CHARACTER (SEVEN BIT ASCII)

XPP T4,T3+1	;*ADDRESS OF DEVICE SERVICE ROUTINE'S DISPATCH TABLE

;0 THRU 11 SAVED FOR LEVEL D

XPP W,12	;*ADDRESS OF PDB
XPP M,13	;*CURRENT UUO IN PROGRESS
		; R IN INDEX FIELD FOR RELOCATION
XPP P1,14	;PERMANENT AC'S
		;*USER I/O CHANNEL NUMBER
XPP P2,P1+1	;
XPP P3,P2+1	;
XPP P4,P3+1	;CONTENTS OF 2ND WORD OF USER BUFFER ON UUOS
		;CONTAINS ADR. OF CDB ON APR AND CLK INTERRUPTS

XPP .FP,17	;FRAME POINTER AC FOR TRVAR - SEE .TRSET.
		;DEFINED HERE SO WE CAN MOVE IT AROUND.

	SUBTTL	CHANNEL DATA BLOCK


;	!=======================================================!
;	!               BUSY FLAG (-1 IF AVAIL.)                !
;	!=======================================================!
;	!       NEXT CHAN DB        !      UDB WITH ERROR       !
;	!=======================================================!
;	!                      INITIAL CCW                      !
;	!-------------------------------------------------------!
;	!                       FINAL CCW                       !
;	!=======================================================!
;	!                        CCW - 2                        !
;	!-------------------------------------------------------!
;	!                        CCW - 1                        !
;	!-------------------------------------------------------!
;	!                        CCW - 0                        !
;	!=======================================================!
;	!                     DATA WORD - 2                     !
;	!-------------------------------------------------------!
;	!                     DATA WORD - 1                     !
;	!-------------------------------------------------------!
;	!                     DATA WORD - 0                     !
;	!=======================================================!
;	!             NO. OF CHAN. MEM. PAR. ERRORS             !
;	!-------------------------------------------------------!
;	!                NO. OF DATA PAR. ERRORS                !
;	!-------------------------------------------------------!
;	!                   NO. OF NXM ERRORS                   !
;	!=======================================================!
;	!      FLAGS FOR SWEEP      !       DDB IN ERROR        !
;	!=======================================================!
;CHANNEL DATA BLOCK (DF10) FOR DISK AND MAGTAPE (TM10B)
; AC J IS USED AS INDEX TO THIS BLOCK. CONFLICTS WITH USE OF J FOR JOB NUMBER.
; HOWEVER CAN GET JOB NUMBER BY:   LDB     J, PJOBN##(F)

;SYMBOLIC NAME FOR ABS ADR OF FIRST WORD HAS FORM CHN'N'CB
	XP	.CHBSY,0	;(0) CHANNEL BUSY IF NON-NEGATIVE, IDLE IF -1
				;AOSGE SETS AND TESTS BUSY IN ONE INSTR.
	XP	.CHSYS,1	;(1) LH=ADR OF NEXT CHANNEL DATA BLOCK
	XP	.CHLUE,1	;(1) RH=ADR OF LAST UNIT WHICH HAD ERROR (AC U)
				; (DISK UNIT DATA BLOCK OR MAGTAPE CONTROLLER DATA BLOCK)
	XP	.CHICW,2	;(2) INITIAL CONTROL WORD ON LAST SOFT OR HARD ERROR
				; IE CONTENTS OF EVEN DF-10 LOWER CORE WORD
	XP	.CHFCW,3	;(3) FINAL CONTROL WORD ON LAST SOFT OR HARD ERROR
				; IE WHAT CHANNEL STORES IN ODD LOW CORE WORD
				;ON HARD ERRORS, CHANNEL STOPPED ON ERROR SO CAN SEE WHERE.
				;LH=PRESENT CONTENTS OF CONTROL WORD ADR COUNTER
				;RH=PRESENT CONTENTS OF DATA ADR COUNTER
				;BECAUSE EACH DEVICE HANDLES ERROR TERMINATION DIFFERENTLY
				; ON THE CHANNEL, THE SOFTWARE STORES 3 CONTROL WORDS.
				; AND 3 DATA WORDS 'AROUND' THE PROBLEM AREA AS INDICATED
				; BY WHAT CHANNEL STORES IN LH,RH OF .CHFCW.
				;ON THE LAST RETRY, THE MONITOR TELLS CONTROL TO
				; TELL CHANNEL TO STOP ON DATA OR MEMORY PARITY.
				;NO ATTEMPT IS MADE BY THE MONITOR OR DAEMON TO DETERMINE
				; WHICH OF 3 WORDS IS REALLY THE LAST CONTROL OR
				; DATA WORD. THAT MUST BE DONE BY THE INVESTIGATING
				; PERSONNEL.
	XP	.CHCW2,4	;(4) COMMAND WORD -2 ON LAST SOFT OR HARD ERROR
	XP	.CHCW1,5	;(5) COMMAND WORD -1 ON LAST SOFT OR HARD ERROR
	XP	.CHCW0,6	;(6) COMMAND WORD 0 ON LAST SOFT OR HARD ERROR
	XP	.CHDW2,7	;(7) DATA WORD -2 ON LAST SOFT OR HARD ERROR
	XP	.CHDW1,10	;(10) DATA WORD -1 ON LAST SOFT OR HARD ERROR
	XP	.CHDW0,11	;(11) DATA WORD 0 IN LAST SOFT OR HARD ERROR
	XP	.CHMPE,12	;(12) NO. OF CHANNEL MEMORY PARITY ERRORS
	XP	.CHDPE,13	;(13) NO. OF DATA PARITY ERRORS (FROM DEVICE)
	XP	.CHNXM,14	;(14) NO. OF CHANNEL NON-EX MEMORY REFERENCES
	XP	.CHCSR,15	;(15) LH=BITS TO REQUEST CPU TO SWEEP CORE
				; ON BEHALF OF THIS CHANNEL. STORED IN .CPAEF BY
				; CHNMPE ROUTINE. RH=SEE .CHLDE.
	XP	.CHLDE,15	;LH=SEE .CHCSR, RH=LAST DEVICE DATA BLOCK ADR
				; (CONTENTS OF F ON ERROR)
	XP	.CHTCW,16	;(16) EXPECTED TERMINATION CONTROL WORD OF LAST ERROR
	XP	.CHCBL,.CHTCW+1	;(PUBLISHED) COMMON (TO ALL DEVICES) BLOCK LENGTH
	XP	CHNCBL,.CHTCW+1	;(UNPUBLISHED) COMMON (TO ALL DEVICES) BLOCK LENGTH
	SUBTTL	DEVICE DATA BLOCK (DDB)




;;!=========================================================================!
;;!                          DEVICE NAME IN SIXBIT                          !
;;!-------------------------------------------------------------------------!
;;!LC!MD! !N!FREE !HTIME! HUNG TIMER  !F!            BUFFER SIZE          !
;;!-------------------------------------------------------------------------!
;;!                             IO STATUS WORD                              !
;;!-------------------------------------------------------------------------!
;;!              NEXT DDB              !       DEVICE SERVICE POINTER       !
;;!-------------------------------------------------------------------------!
;;!                   DEVICE CHARACTERISTICS (DEVCHR UUO)                   !
;;!-------------------------------------------------------------------------!
;;!                         LOGICAL NAME IN SIXBIT                          !
;;!-------------------------------------------------------------------------!
;;!        OUTPUT BUFFER HEADER        !        INPUT BUFFER HEADER         !
;;!-------------------------------------------------------------------------!
;;!          FLAGS           !   "R"    !       INPUT BUFFER TO FILL        !
;;!-------------------------------------------------------------------------!
;;!          FLAGS           !   "R"    !      OUTPUT BUFFER TO EMPTY       !
;;!-------------------------------------------------------------------------!
;;!                        DEVICE STATUS (LAST CONI)                        !
;;!-------------------------------------------------------------------------!
;;!SP!AV!L!R!  DEVTYP   !I! SPOOL BITS  !A!I!O!N!M!E!T!F!DSK PRI!U!-! STA # !
;;!-------------------------------------------------------------------------!
;;!                           EVM IN USE FOR I/O                            !
;;!-------------------------------------------------------------------------!
;;!IP!     IRF MASK     !    SPARE?     !   DEFER BITS    !   VECT. OFF.    !
;;!-------------------------------------------------------------------------!
;;!FO!FF!S! **FREE**  !   FOR FILSER    !     UNIT #      !      JOB #      !
;;!-------------------------------------------------------------------------!
;;!                           FILE NAME IN SIXBIT                           !
;;!-------------------------------------------------------------------------!
;;!             EXTENSION              !                                    !
;;!-------------------------------------------------------------------------!
;;!               PROJ #               !               PROG #               !
;;!=========================================================================!
	XP	DEVNAM,0	;NAME IN SIXBIT ASCII
				; C(LH)=DEVICE MNEMONIC
				; C(RH)=DEVICE NUMBER, LEFT JUSTIFIED
	XP	DEVCHR,1	;CHARACTERISTIC
	XP	DVLPTL,400000	;BIT 0=LOWER CASE LPT
	XP	DVCMDA,200000	;BIT 1-DEVICE IS CONTROLLED BY THE
				; MOUNTABLE DEVICE ALLOCATOR
				;BIT 2-***FREE***
	XP	DVDIBP,40000	;DEVICE IS A BATCH PTY
	XP	DVCNET,20000	;DEVICE CONTROLLED BY NETSER
	XP	DVOFLN,10000	;DEVICE WAS OFF-LINE THE LAST TIME THE
				; SERVICE ROUTINE WAS POLLED
	XP	DVC2IO,4000	;DEVICE CAN DO SIMULTANEOUS INPUT AND OUTPUT
	XP	HUNGST,400	;BITS 7-9 ARE A CODE FOR HUNG DEVICE
				; TIMEOUT. 0 MEANS DEVICE CANNOT BE HUNG
				; 1-7 MEANS HUNG TIME IS 2**N-1 SECONDS
				; POINTER = PDVTIM
				;BITS 10-16 ARE THE COUNTDOWN TIMER
				; FOR HUNG DEVICE. POINTER = PDVCNT
				; TRANSITION TO ZERO MEANS DEVICE HUNG
				; BITS 17-18 FREE
				; BITS 19-35=BUFFER SIZE

IFN FTCIMP,<			;[arpa]
	XP	DEPCBC,400000	;[arpa] CHECK THE BYTE COUNT
				;[arpa] (BIT 18 STOLEN FROM FREE BITS)
				;[arpa] (Was bit 23 before 7.02)
>				;[arpa]

	XP	DEVIOS,2	;STATUS WORD.  SEE BELOW
	XP	DEVSER,3	;C(LH)=NEXT DEVICE DATA BLOCK
				; C(RH)=DEVICE SERVICE DISPATCH TABLE
;  DEVICE SERVICE DISPATCH TABLE ASSIGNMENTS
	XP	DOFL,-5		;DEVICE OFF-LINE?
	XP	DDVO,-4		;DEVOP UUO
	XP	DSZ,-3		;RETURN BUFFER SIZE
	XP	DINI,-2		;DEVICE INITILIZATION
	XP	DHNG,-1		;DEVICE IS HUNG
	XP	DRL,0		;RELEASE
	XP	DCL,1		;CLOSE
	XP	DCLO,DCL	;CLOSE OUTPUT
	;IMMEDIATE ADDRESS PART OF CLOSE UUO
		XP CLSOUT,1	;INHIBIT CLOSING OUTPUT
		XP CLSIN,2	;INHIBIT CLOSING INPUT
		XP CLSDLL,4	;INHIBIT DEALLOCATION ON CLOSE OUTPUT
		XP CLSACC,10	;INHIBIT UPDATE OF ACCESS DATE ON READS (AND BAT BLOCK ON ERR)
		XP CLSNMB,20	;INHIBIT DELETING NMB ON CLOSE WITH ONLY LOOKUP
		XP CLSRST,40	;RESET (INHIBIT SUPERSEDE/CREATE)
		XP CLSDAT,100	;DELETE ACCESS TABLE ON CLOSE
	XP	DOU,2		;OUTPUT
	XP	DIN,3		;INPUT.	SHORT DISPATCH TABLE
	XP	DEN,4		;ENTER
	XP	DLK,5		;LOOKUP
	XP	DDO,6		;DUMP MODE OUTPUT
	XP	DDI,7		;DUMP MODE INPUT
	XP	DSO,10		;SETO
	XP	DSI,11		;SETI
	XP	DGF,12		;GETF UUO
	XP	DRN,13		;RENAME
	XP	DCLI,14		;CLOSE INPUT
	XP	DCLR,15		;CALL D,[SIXBIT /UTPCLR/]
	XP	DMT,16		;MTAPE
		; END OF LONG DISPATCH TABLE
	XP	DEVMOD,4	;BIT 35-J=1 IF MODE J IS LEGAL FOR THIS DEVICE
				; BIT 18 DEVICE ASSIGNED BY CONSOLE COMMAND
				; BIT 19 DEVICE ASSIGNED BY PROGRAM (INIT)
				; SEE I/O STATUS WORD ASSIGNMENTS

;RIGHT HALF OF DEVICE CHARACTERISTICS WORD (DEVCHR UUO)
	XP	ASSCON,400000	;ASSIGNED BY CONSOLE COMMAND ASSIGN
	XP	ASSPRG,200000	;ASSIGNED BY PROGRAM (INIT UUO)
;LEFT HALF DEVICE CHARACTERISTICS (DEVCHR UUO)
	XP	DVOUT,1		;OUTPUT DEVICE
	XP	DVIN,2		;INPUT DEVICE
	XP	DVDIR,4		;HAS A DIRECTORY
	XP	DVTTY,10	;IS A TTY
	XP	DVMTA,20	;IS A MAG TAPE (REWIND)
	XP	DVAVAL,40	;1 IF DEVICE IS AVAILABLE TO THIS JOB
				; SET BY DEVCHR UUO

IFN FTCIMP,<			;[arpa]
	XP	DVSWPW,DVAVAL	;[arpa] JOB CAN BE SWAPPED EVEN IF DEVICE (IMP)
				;[arpa] IS ACTIVE.  USER DOES NOT SEE THIS BIT.
>				;[arpa]
	XP	DVDTA,100	;IT IS A DECTAPE
	XP	DVPTR,200	;IS A PAPER TAPE READER
	XP	DVPTP,400	;IS A PAPER TAPE PUNCH
	XP	DVLNG,1000	;DEVICE HAS LONG DISPATCH TABLE
				; (OTHER UUOS BESIDES INPUT,OUTPUT,CLOSE,RELEASE)
	XP	DVDIS,2000	;IS A DISPLAY
	XP	TTYBIU,4000	;TTY DDB IN USE (AS I/O DEVICE EVEN IF
				; NOT AS USER CONSOLE)
	XP	TTYUSE,10000	;TTY DDB IN USE FLAG
	XP	TTYATC,20000	;TTY ATTACHED TO JOB IF 1
	XP	DVLPT,40000	;IS A LPT (CARRIAGE CONTROL IN FORTRAN)
	XP	DVCDR,100000	;IS A CARD READER (TRAILING SPACES FOR MACRO)
	XP	DVDSK,200000	;IS A DISK
	XP	DVDIRIN,400000	;DECTAPE DIRECTORY IN CORE IF 1 (MUST BE SIGN BIT)
	XP	DVCHN,DVMTA!DVDSK ;I/O IS DONE DIRECTLY TO MEMORY (KI10)



	XP	DEVLOG,5	;LOGICAL NAME FOR JOB DEVICE
	XP	DEVBUF,6	;C(LH)=REL. ADDRESS OF 3 WORD OUTPUT BUFFER HEADER
				; C(RH)=REL. ADDRESS OF 3 WORD INPUT BUFFER HEADER
	XP	DEVIAD,7	;C(LH)=R IN INDEX FIELD
				;BITS 1 AND 2 CONTAIN THE COUNT OF NUMBER OF USER
				; CHANNELS INIT'ED ON THIS DEVICE (DECTAPE ONLY)
				; IADPTR-COMMON BYTE POINTER TO 2 BIT COUNT
				;C(RH)=RELATIVE ADDRESS OF INPUT BUFFER THE
				; SERVICE ROUTINE IS FILLING.
	XP	DEVADR,DEVIAD
	XP	DEVOAD,10	;C(LH)=R IN INDEX FIELD
				;C(RH)=RELATIVE ADDRESS OF OUTPUT BUFFER THE
				; SERVICE ROUTINE IS EMPTYING.
	XP	DEVPTR,DEVOAD
	XP	DEVSTS,11	;WORD FOR DEVICE CONI

	XP	DEVSTA,12	;STATION NUMBER IN RIGHT 6 BITS
	XP	DEVDPR,DEVSTA	;BITS 26-29 = DISK PRIORITY
	 XP	DEPUUO,10	;PRIORITY SET BY A UUO
	 XP	MINDPR,4	;BITS 28-29 ARE NEGATIVE
				;BITS 28-29 ARE ACTUAL PRIORITY
	  XP	DEPDEL,2000	;DISABLE ERROR LOGGING ON THIS DEVICE BIT 25
	  XP	DEPDER,4000	;DISABLE ERROR RECOVERY ON THIS DEVICE BIT 24
	  XP	DEPEVM,10000	;IF 1, DEVICE DOESN'T NEED EVM ON KI10 TO DO I/O
	XP	DEVAIO,DEVSTA	;ASYNCHRONOUS IO
	 XP	DEPAIO,400000	;DOING ASYNC. IO
	 XP	DEPIND,200000	;INPUT NOT YET DONE
	 XP	DEPOND,100000	;OUTPUT NOT YET DONE

	XP	DEVMSG,DEVSTA	;MSGSER FLAGS
	 XP	DEPECS,40000	;BIT 21 ON IF A NON-SUPERSEDE ENTER
	 XP	DEPMSG,20000	;THIS DEVICE IS CONTROLLED BY MSGSER
	  XP	DEVSPL,DEVSTA	;BITS 11-17=SPOOL BITS
	 XP .SPLPT,1		;LINE PRINTER SPOOL BIT
	 XP .SPPLT,2		;PLOTTER SPOOL BIT
	 XP .SPPTP,4		;PTP SPOOL BIT
	 XP .SPCDP,10		;CDP SPOOL BIT
	 XP .SPCDR,20		;CDR SPOOL BIT
	 XP .SPALL,37		;CHANGE SPALL IF ADD NEW SPOOLING DEVS
	XP DEPIBC,200		;INHIBIT CLEARING OUTPUT BUFFERS
	 XP DERRAS,100		;RIGHT ADJUSTED.
	 XP DERLEN,200		;RIGHT-ADJUSTED
	  XP	DEVTYP,DEVSTA	;BITS 4-9=CLASS (DEVTYP UUO)
	 XP .TYEST,400		;RIGHTMOST BIT OF CLASS-BYTE
	 XP .TYDSK,0		;DISK
	 XP .TYDTA,1*.TYEST	;DTA
	 XP .TYMTA,2*.TYEST	;MTA
	 XP .TYTTY,3*.TYEST	;TTY
	 XP .TYPTR,4*.TYEST	;PTR
	 XP .TYPTP,5*.TYEST	;PTP
	 XP .TYDIS,6*.TYEST	;DISPLAY
	 XP .TYLPT,7*.TYEST	;LPT
	 XP .TYCDR,10*.TYEST	;CDR
	 XP .TYCDP,11*.TYEST	;CDP
	 XP .TYPTY,12*.TYEST	;PTY
	 XP .TYPLT,13*.TYEST	;PLT
	 XP .TYXTC,14*.TYEST	;EXTERNAL TASK
	 XP .TYMPX,15*.TYEST	;MPX
	 XP .TYPAR,16*.TYEST	;PA611R READER
	 XP .TYPCR,17*.TYEST	;PC-11 READER ON DC44
	 XP .TYPAP,20*.TYEST	;PA611P PUNCH ON DC44
	 XP .TYLPC,21*.TYEST	;LPC-11 TYPESET INTERFACE ON DC44
	 XP .TYPCP,22*.TYEST	;PC-11 PUNCH ON DC44
	 XP .TYWTY,23*.TYEST	;WTY DEVICE ON DC44
	 XP .TYTSK,24*.TYEST	;REMOTE NETWORK TASK
	 XP .TYD78,25*.TYEST	;DAS78 DEVICE (NOW OBSOLETE)
	 XP .TYRDA,26*.TYEST	;REMOTE DATA ENTRY DEVICE
	 XP .TYMCR,27*.TYEST	;HOST COMMAND INTERPRETER
	 XP .TYDRA,30*.TYEST	;DRA
	 XP .TYKDP,31*.TYEST	;KMC/DUP COMM GEAR
	 XP .TYDTE,32*.TYEST	;DTE-20 COMM DEVICE
	 XP .TYDDP,33*.TYEST	;ANF-NETWORK DDCMP DEVICE
	 XP .TYDMR,34*.TYEST	;DMR11 AS A NETWORK DEVICE

IFN FTCIMP,<			;[arpa]
	 XP .TYIMP,77*.TYEST	;[arpa] IMP (PSEUDO DEVICE)
	XP TYPMAX,77		;[arpa] HIGHEST DEVICE TYPE
>				;[arpa]
ife FtCImp,<			;[arpa]
	XP TYPMAX,34		;HIGHEST DEVICE TYPE
>				;[arpa]
	 XP DEPRAS,40000		;BIT 3=1 IF DEVICE HAS RESTRICTED ASSIGNMENT
	 XP DEPLEN,100000	;BIT 2=1 IF VARIABLE LENGTH BUFFERS
				;BIT 1=1 IF A DSK IN 10/11 COMPATABILITY MODE
	XP	DEVADV,DEVSTA	;DON'T ADVANCE BUFFERS ON INTERCEPT
	 XP	DEPADV,200000	; IF DEPADV IS ON
	 XP DEPSPL,400000	;THIS DDB IS FOR A SPOOLED DEVICE
	XP	DEVXTR,13	;EXTRA WORD

;DEVXTR USEAGE BY MSGSER:
;	IF THIS IS AN MPX DDB:
;	LH = ADDRESS OF CONNECTED DEVICE TABLE
;	RH = NUMBER OF CONNECTED DEVICES
;	IF THIS IS A DDB CONTROLED BY MSGSER:
;	LH = FLAGS (SAME DEFS AS LH OF USRJDA)
;	RH = ADDRESS OF MPX DDB

;DEVXTR BITS USED BY FILSER (DEFINED IN COMMOD):

;DEVUVA=LH
;DEVPRI=BITS 18-20
;DEPWRT=BIT 21
;DEVBFN=BITS 22-30
;DEPPAL=BIT 31
;DEPALC=BIT 32

	XP	DEVEVM,14	;WORD TO KEEP TRACK OF EXEC VIRTUAL MEMORY
				; THIS DEVICE HAS

	XP	DEVPSI,15	;WORD TO KEEP TRACK OF SOFTWARE INTERRUPTS
				; FOR THIS DEVICE. LH-ENABLE COND. RH-PENDING INTS.
	XP	DEVESE,16	; 0-17 PSISER DEVICE LINK
				;18-26 PSISER VECTOR INTERRUPT
				;27-35 EXTENDED SOFTWARE ERROR STATUS
	XP	DEVHCW,17	;HARDWARE CHARACTERISTICS WORD
				;LINEPRINTER HARDWARE CHARACTERISTICS
	  XP	HC.LCP,1B0	;LOWER CASE PRINTER
	  XP	HC.PGC,1B1	;LPT HAS A PAGE COUNTER
	  XP	HC.VFT,7B5	;VFU TYPE
	    XP	  .HCVTO,0	;  OPTICAL (PAPER TAPE) VFU
	    XP	  .HCVTD,1	;  DIRECT ACCESS VFU (DAVFU)
	    XP	  .HCVTN,2	;  NO VFU (HDW HANDLES LF,FF,CR)
	  XP	HC.CST,7B8	;CHARACTER SET TYPE
	    XP	  .HCC64,0	;  64 CHARACTER SET
	    XP	  .HCC95,1	;  95 CHARACTER SET
	    XP	  .HCC28,2	;  128 CHARACTER SET
	    XP	  .HCCVR,3	;  VARIABLE CHARACTER SET
	  XP	HC.TYP,7B11	;LPT TYPE
	    XP	  .HCTUK,0	;UNKNOWN
	    XP	  .HCTBX,1	;BA10
	    XP	  .HCTLC,2	;LP100
	    XP	  .HCT20,3	;LP20
	  XP	HC.TYU,7B14	;LPT CLASS (UNIT TYPE)
	    XP	  .HCUUK,0	;UNKNOWN/UNSPECIFIED
	    XP	  .HCULP,1	;LP05/ETC.
	    XP	  .HCULN,2	;LN01/ETC.
	  XP	HC.CSN,<0,,-1>	;CHARACTER SET NAME (3 SIXBIT CHRS)

	XP	DEVCPU,20
				;BITS 0-2 CPU NUMBER FOR 1ST CPU OWNING DEVICE
				;BITS 3-5 CPU NUMBER FOR 2ND CPU OWNING DEVICE
				;BITS 6-8 QUEUE-PROTOCOL NO FOR DEVICE (=0 IF RESCHEDULE)
				;BITS 9-11 CPU ON WHICH IN OR OUT LAST DONE
	  XP	DEPCPS,40	;BIT 12=1 IF BITS 30-32 ARE VALID (DEV ON 2 CPUS)
				;BITS 13-17=0
				;RH=ADR OF INTERLOCK WORD (SET AT INTLOP)
	XP	DEVJOB,21	;JOB AND UNIT NUMBERS

;DEVLSD SHOULD ALWAYS BE EQUAL TO DEVJOB+1 USED BY SYSTAT
;ALSO, MANY PROGRAMS BELIEVE DEVJOB+1=DEVFIL SO NEW ENTRIES
; IN THE SHORT DDB SHOULD BE BEFORE DEVJOB
	XP	DEVLSD,DEVJOB+1	;LENGTH OF SHORT DDB
	  XP	DEPFOP,(1B0)	;BIT 0 = 1 IF FILOP. UUO IS IN PROGRESS
	  XP	DEPFFA,(1B1)	;INHIBIT FULL-FILE ACCESS
	  XP	DEPSIM,(1B2)	;DDB IS ENABLED FOR SIMULTANEOUS UPDATE
	  XP	DEPSIE,(1B3)	;SYNCHRONIZE I/O ERROR (SET ON OPEN)
	 XP	DEPALW,(1B4)	;ALLOCATION IS IN WORDS
				;***BITS 5 AND 6 ARE FREE***
				;BITS 7-17 ARE USED BY FILSER
				;BITS 18-26 ARE UNIT NUMBER (PUNIT)
				;BITS 27-35 ARE THE JOB NUMBER (PJOBN)
	XP	DEVCTR,22
	XP	DEVCID,DEVCTR	;CURRENT INPUT DEVICE (USED BY MSGSER
				; TO ROUND ROBIN INPUT DEVICES)
;FOR LONG DISPATCH TABLE DEVICES ONLY:
	XP	DEVFIL,22	;FILE NAME IN SIXBIT
	XP	DEVEXT,23	;LH=EXTENSION, RH=UNUSED
	XP	DEVPPN,24	;PROJECT,PROGRAMMER NUMBER (DISK ONLY)
				; OTHER DEVICES NEED NOT HAVE THIS LOCATION IN THEM.
	XP	DEVLLD,DEVPPN+1	;LENGTH OF LONG DDB
IFN FTKL10&FTMP,<
	XP	DEVNBF,25	;NO. OF BUFFERS SWEPT FOR (QUEUED PROTOCOL ONLY)
	XP	DEVSBF,26	;COPY OF DEVNBF WHEN SWITCHING INPUT/OUTPUT
	XP	DEVCSN,27	;CACHE SWEEP NO. (QUEUED PROTOCOL)
>
IFN FTKLP,<
	XP	DEVISN,DEVLLD+IFN FTKL10&FTMP,<3> ;SECTION NUMBER FOR CURRENT I/O OPERATION
>
	SUBTTL	FLAG BITS -- S AND DEVIOS(F)

; I/O STATUS WORD ASSIGNMENTS - THESE ARE THE "MODE" OF DEVMOD
;DATA MODES: BITS 32-35 (BYTE POINTER=PIOMOD)
	XP	A,0		;ASCII
	XP	AL,1		;ASCII LINE
	XP	PIMMOD,2	;PACKED IMAGE MODE
	XP	BYTMOD,3	;BYTE-MODE
	XP	I,10		;IMAGE
	XP	IB,13		;IMAGE BINARY
	XP	B,14		;BINARY
	XP	SD,15		;SCOPE DUMP MODE
	XP	DR,16		;DUMP BY RECORDS
	XP	D,17		;DUMP ACROSS RECORDS
; STATUS BITS
;RIGHT HALF (USER)
	XP	IOWC,20		;DON'T COMPUTE WORD COUNT
	XP	IOCON,40	;CONTINUOUS (CONT=0)
	XP	IONRCK,100	;READ WITH NO REREAD CHECK
;BITS 27,28	DENSITY OF MAG TAPE
;		00=INSTALLATION STANDARD
;		01=200 BPI
;		10=556 BPI
;		11=800 BPI
	XP	IOPAR,1000	;WRITE EVEN PARITY (BCD) IF 1 ON MAG TAPE
	  XP	IOHDER,1000	;ON IF SEARCH ERROR
				; NEVER STORED IN DDB, ONLY USED
				; IN CALLS BETWEEN CONTROLLER ROUTINES
	XP	IOTEND,2000	;END OF MAG TAPE
	  XP	IOVRUN,2000	;ON IF AN OVERRUN
				; NEVER STORED IN DDB, ONLY USED IN
				; CALLS BETWEEN CONTROLLER ROUTINES
	XP	IOBOT,4000	;BEGINNING OF MAG TAPE
	  XP	IOECCX,4000	;ECC RECOVERABLE ERROR
				; NOTE:NEVER STORED IN MEMORY IN DDB.
				; ONLY USED IN CALLS BETWEEN CONTROLLER
	XP	IOACT,10000	;DEVICE ACTIVE
	  XP	IOCHNX,10000	;CHANNEL DETECTED NON-EX MEM OR DATA LATE (OVER-RUN)
				; NOTE: NEVER STORED IN MEMORY IN DDB.
				; ONLY USED IN CALLS BETWEEN CONTROLLER ROUTINES
	XP	IODEND,20000	;DATA END ENCOUNTERED
	  XP	IOCHMP,20000	;CHANNEL DETECTED MEMORY PARITY ERROR
				; NOTE: NEVER STORED IN MEMORY IN DDB.
				; ONLY USED IN CALLS BETWEEN CONTROLLER ROUTINES.
	XP	IOBKTL,40000	;BLOCK TOO LARGE
	XP	IODTER,100000	;DATA ERROR-IE HARDWARE OR SOFTWARE PARITY AND/OR
				; CHECKSUM INDICATES DATA MAY BE BAD
	XP	IODERR,200000	;DEVICE ERROR-IE THE DEVICE IS BAD
				; THE DATA IS PROBABLY INTACT ON THE MEDIUM
				; IF READING (USUAL)
				; THE DATA IS PROBABLY INCORRECTLY WRITTEN
				; ON THE MEDIUM
				;  IF WRITING (UNUSUAL)
	XP	IOIMPM,400000	;IMPROPER MODE DETECTED BY UUOCON OR DEVICE
				; SERVICE ROUTINE
		IOERR=IOBKTL!IODTER!IODERR!IOIMPM  ;ALL ERROR BITS
; LEFT HALF (SYSTEM)
	XP	IOW,1		;I/O WAIT
	XP	IOBEG,2		;VIRGIN DEVICE
	XP	IOFST,4		;NEXT ITEM WILL BE THE FIRST ITEM OF A BUFFER
	XP	IOSTBL,10	;DEVICE ERROR FLAG
	XP	IO,20		;OUT=1, IN=0
	XP	IOEND,40	;SERVICE ROUTINE HAS TRANSMITTED LAST DATA
	XP	IOSDMR,100	;TSKSER ONLY. DISABLE MESSAGE RE-ASSEMBLY

;REST OF BITS IN LH ARE DEVICE DEPENDENT
;COMMAND DECODER USE OF AC S:

;RH=DISPATCH ADDRESS - SAVJOB,GETJOB,RUNJOB
;LH:
	XP	NSRBIT,400000	;HIGH SEG TO BE FLAGGED NON-SHARABLE (SAVE VS SSAVE
				; COMMAND) DO NOT CONFUSE WITH SIGN BIT OF JBTSTS
				; WHICH SAYS SEG IS SHARABLE
	SUBTTL	FLAG BITS -- UUOS

;BITS FOR DETERMINING IF UUO REFERS TO PHYSICAL DEVICES ONLY
	XP	UPHNLY,200000	;UPHNLY NOT= BIT 18 IF PHYS ONLY
	XP	PHONLY,400000	;BIT ON IN LH(W) IF PHYS ONLY


;BITS IN LH OF FIRST (0) ARG OF OPEN UUO
	XP	.OPPDO,400000	;PHYSICAL DEVICE ONLY (NO LOGICAL)
	XP	.OPDEL,200000	;DISABLE ERROR LOGGING (DAEMON
				; COUNTS NOT UPDATED - SYSERR NOT UPDATED)
				; USED BY USER MODE
	XP	.OPFSP,.OPDEL	;FULL SCNSER PTY
	XP	.OPDER,100000	;DISABLE ERROR RETRY
				; USED BY MODE DIAGNOSTIC
	XP	.OPBJP,.OPDER	;BATCH JOB PTY
	XP	.OPDMR,.OPBJP	;TSKSER ONLY. DISABLE MESSAGE RE-ASSEMBLY
	XP	.OPAIO,40000	;ASYNCHRONOUS (NON-BLOCKING) I/O
	XP	.OPIBC,20000	;INHIBIT OUTPUT BUFFER CLEARING
	XP	.OPSIE,10000	;SYNCHRONIZE I/O ERRORS
	XP	.OPRRC,4000	;REWRITE RIB ON CHANGE
	XP	.OPLBF,2000	;USE LARGE DISK BUFFERS
	XP	.OPCFS,1000	;CFP SUPPLIED ON LOOKUP
	XP	.OPALL,777000	;ALL THE ABOVE OPEN BITS. USED TO TEST
				; FOR UNDEFINED BITS BEING SET.
;BITS RETURNED BY DEVTYP UUO(LH)
	XP	.TYMAN,400000	;LOOKUP/ENTER MANDATORY
	XP	.TYAVL,DVAVAL
	XP	.TYSPL,20	;DEVICE BEING SPOOLED ONTO DISK
	XP	.TYINT,DVTTY
	XP	.TYVAR,4	;USER CAN SET VARIABLE-LENGTH BUFFERS
	XP	.TYIN,DVIN
	XP	.TYOU,DVOUT
	XP	TY.MPX,(1B11)	;RETURNED IF CNECT. WILL WORK
	XP	TY.LL,(1B10)	;IF LPT THEN LOWER CASE
	XP	TY.MDA,(1B9)	;DEVICE IS CONTROLLED BY MDA
	XP	TY.GEN,(1B8)	;DEVICE IS GENERIC
;BITS IN RH OF EXTENDED LOOKUP WORD 0
	XP	RB.NSE,1B18	;NON-SUPERSEDING ENTER
	XP	RB.DSL,1B19	;DON'T SEARCH LIB
	XP	RB.AUL,1B20	;ALLOW UPDATE/RENAME IN LIB
	XP	RB.NLB,1B21	;NO LOAD BALANCING
	XP	RB.BIT,RB.NSE!RB.DSL!RB.AUL!RB.NLB

;BIT IN LH (UUO) - FOR LOCAL (TEMPORARY USE) ONLY
	XP	GENSRC,400000	;BIT SET IF DVASRC SUCCESS
				;FROM UUOCON INIT CALL
;UNIVERSAL I/O INDEX VALUES, FOR STANDARDIZED I/O UUO'S
;PREFIX .UX
	XP	.UXCHN,0	;I/O CALLED BY CHANNEL NUMBER (AC OF UUO'S)
	XP	.UXTRM,200000	;I/O CALLED BY TERMINAL INDEX
;LEFT HALF USRJDA (JOB DEVICE ASSIGNMENTS) UUO'S FOR THIS CHANNEL SINCE LAST INIT
;SET IN LH OF F AT BEGINNING OF UUO,STORED IN MEMORY(USRJDA) IF UUO IS SUCCESSFUL
	XP	INITB,400000	;INIT-SAVEGET DEPENDS ON THIS BEING SIGN BIT
	XP	IBUFB,200000	;INIT WITH INPUT BUFFER SPECIFIED
	XP	OBUFB,100000	;INIT WITH OUTPUT BUFFER SPECIFIED
	XP	LOOKB,40000	;LOOKUP
	XP	ENTRB,20000	;ENTER
	XP	INPB,10000	;INPUT
	XP	OUTPB,4000	;OUTPUT
	XP	ICLOSB,2000	;INPUT CLOSE
	XP	OCLOSB,1000	;OUTPUT CLOSE
	XP	INBFB,400	;INBUF
	XP	OUTBFB,200	;OUTBUF
	XP	SYSDEV,100	;THIS DEVICE IS SYSTEM TAPE OR SYSPPN ON DISK
	XP	RENMB,40	;RENAME UUO IN PROGRESS (NEVER STORED IN MEMORY)
	XP	DSKRLB,20	;TO DISTINGUISH RELEASE FROM RESET UUO IN DSKSER.
				; RELEASE CLEARS THEM ALL - LEVEL C
	XP	RESETB,20	;RESET UUO IN PROGRESS - LEVEL D (NEVER STORED IN MEMORY)

;MTAPE UUO BITS
	XP	SLICE,40	;SET SLICE LEVEL IF A 1 ACCORDING TO SLEVEL
	XP	SLEVEL,20	;VALUE OF SLICE LEVEL IF SLICE A 1

		SUBTTL	FLAG BITS -- ACCLG. UUO

AC.MAX==1B0	;CHECK LOGMAX
AC.BMX==1B1	;CHECK BATMAX
AC.DCR==1B2	;DECREMENT LOGNUM COUNT

;ERROR CODES
	ACLMX%==1		;LOGMAX CHECK FAILED
	ACLBM%==2		;BATMAX CHECK FAILED
	ACLIL%==3		;ACCLG. ARGUMENT ERROR
	ACLJL%==4		;ACCLG. GOT BAD DECREMENT WITH JLOG SET
	ACLDC%==5		;ACCLG. ERROR, DECR TRIED WITHOUT INCR DONE

		SUBTTL	FLAG BITS -- JOBPEK UUO

	XP	JK.WRT,1B0	;1=WRITE, 0=READ
	XP	JK.UPM,1B1	;READ UPMP OF SPECIFIED JOB
	XP	JK.EVA,1B2	;SOURCE ADDRESS IS BETWEEN 340000 AND
				;377777.  TREAT IT AS IF IT WERE AN
				;EXEC VIRTUAL ADDRESS MAPPED THROUGH THE
				;SPECIFIED JOB'S UPMP
	XP	JK.AIO,1B3	;DO NOT BLOCK IF DATA INACCESSIBLE
				; (ONLY IF JK.UPM OR JK.EVA)
	XP	JK.ALL,777B8	;ALL POSSIBLE FLAGS

;ERROR CODES
	JKNPV%==1		;JOB NOT PRIVILEGED
	JKIJN%==2		;ILLEGAL JOB NUMBER
	JKSWP%==3		;JOB SWAPPED OR IN TRANSIT
	JKIAD%==4		;ILLEGAL ADDRESS
	JKDNA%==5		;DATA NOT ADDRESSABLE
	JKPNC%==6		;PAGE NOT IN CORE
	JKIOE%==7		;I/O ERROR READING SWAPPING SPACE
	JKABZ%==10		;ALLOCATED BUT ZERO PAGE

	SUBTTL	FLAG BITS -- JOBSTS UUO

JB.UJA==1B0	;JOB NUMBER ASSIGNED
JB.ULI==1B1	;JOB IS LOGGED IN
JB.UML==1B2	;TTY IS AT MONITOR LEVEL
JB.UOA==1B3	;OUTPUT IS AVAILABLE
JB.UDI==1B4	;TTY IS DEMANDING INPUT
JB.UJC==1B5	;JACCT IS SET
JB.URN==1B6	;JOB IS RUNNING
JB.UFC==1B7	;TTY IN FULL CHARACTER SET
JB.UBK==1B8	;TTY IN BREAK ON ALL CHARACTERS MODE
;JB.UII==1B9	;TTY IS IN IMAGE INPUT MODE
;JB.UIO==1B10	;TTY IS IN IMAGE OUTPUT MODE
JB.UNE==1B11	;TTY IS NO ECHO (A LA LOGIN, INDEPENDENT OF LOCAL COPY)
JB.UTO==1B12	;TTY IS BLOCKED IN 'TO' STATE
JB.UCC==1B13	;TTY CHARACTERISTICS (WIDTH, LC, TABS, ETC.) CHANGED
JB.UNT==1B14	;TTY IS NETWORKED (.SET HOST) TO A REMOTE HOST
	SUBTTL  FLAG BITS -- PAGE ACCESSIBILITY UUO

PA.NXP==1B0		;NON-EXISTENT PAGE
PA.WRT==1B1		;WRITE ACCESS
PA.RED==1B2		;READ ACCESS (OFF IFF LIP=1 & JS.XO=0)
PA.AA==1B3		;ACCESS ALLOWED
PA.ZER==1B4		;ZERO PAGE (ALLOCATED ON DSK)
PA.CPO==1B5		;CAN'T BE PAGED OUT
PA.OUT==1B6		;PAGE IS PAGED OUT
PA.GHI==1B7		;PAGE IS PART OF HIGH SEG
PA.GSH==1B8		;PAGE IS SHARABLE
PA.GSP==1B9		;PAGE IS SPYING ON RUNNING MONITOR
PA.LCK==1B10		;PAGE IS LOCKED
PA.NCS==1B11		;PAGE IS NOT CACHED

	SUBTTL  FLAG BITS -- PAGE. UUO
PG.SLO==1B1		;ON IF PAGE ONTO SLOW SWAPPING SPACE
PG.DSK==1B1		;ON IF CREATE A PAGE ON DSK

	SUBTTL	PAGE. UUO -- FUNCTION CODES
.PAGIO==0			;SWAP A PAGE IN/OUT
.PAGCD==1			;CREATE/DESTROY A PAGE
.PAGEM==2			;MOVE/EXCHANGE A PAGE
.PAGAA==3			;CLEAR/SET ACCESS ALLOWED
.PAGWS==4			;GET THE WORKING SET
.PAGGA==5			;GET ACCESS ALLOWED
.PAGCA==6			;GET PAGE ACCESSIBILITY
.PAGRM==7			;GENERALIZED REMAP

	SUBTTL	PAGE. UUO -- ERROR CODES
PAGUF%==0			;UNIMPLEMENTED FUNCTION
PAGIA%==1			;ILLEGAL ARGUMENT
PAGIP%==2			;ILLEGAL PAGE NUMBER
PAGCE%==3			;PAGE CAN'T EXIST, BUT DOES
PAGME%==4			;PAGE MUST EXIST, BUT DOESN'T
PAGMI%==5			;PAGE MUST BE IN CORE, BUT ISN'T
PAGCI%==6			;PAGE CAN'T BE IN CORE, BUT IS
PAGSH%==7			;PAGE IS IN A SHARABLE HIGH SEGMENT
PAGIO%==10			;PAGING I/O ERROR
PAGNS%==11			;NO SWAPPING SPACE AVAILABLE
PAGLE%==12			;CORE LIMIT EXCEEDED
PAGIL%==13			;NOT ALLOWED IF LOCKED
PAGNV%==14			;ATTEMPT TO CREATE A VIRTUAL PAGE WITH CVPL=0
PAGNP%==15			;NOT PRIVILEGED

	SUBTTL	BITS FOR TESTING UUOS

XP	UU.CP1,400000		;UUO CAN BE EXECUTED ON CPU1

;BITS 30-35 = N,  CHECK FROM START (PC+1 OR EA) TO START+N-1

XP	UU.EA,100		;CHECK EFFECTIVE ADDRESS
XP	UU.CAC,200		;USE C(AC)
XP	UU.CEA,400		;USE C(EFECT.ADR)
XP	UU.MNS,1000		;MINUS
XP	UU.LER,2000		;LOOKUP/ENTER/RENAME
XP	UU.LFT,4000		;USE LEFT HALF
XP	UU.NAL,10000		;NOT ALLOWED IF LOCKED
XP	UU.WCC,20000		;WORKING SET CAN CHANGE
XP	UU.NCL,40000		;NEGATIVE ARGUMENT (REPEAT) COUNT IS LEGAL
XP	UU.MSK,7777		;ANY CHECK AT ALL

;COMPOSITE MASKS
XP	UU.LEA,UU.EA+UU.CAC+UU.LFT ;CHECK EA TO EA+C(LH(AC))
XP	UU.MEA,UU.LEA+UU.MNS	;CHECK EA TO EA-C(LH(AC))

	SUBTTL	SCHED. UUO ERROR CODES
SCHAC%==1			;ADDRESS CHECK
SCHUF%==2			;UNKNOWN FUNCTION
SCHUJ%==3			;UNKNOWN JOB
SCHNP%==4			;NOT PRIVILEGED
SCHUC%==5			;UNKNOWN CLASS
SCHUQ%==6			;UNKNOWN QUEUE
SCHNC%==7			;NON-EXISTANT CHANNEL
SCHEB%==10			;EXPONENTIAL FACTOR BAD
SCHMI%==11			;ATTEMPT TO SET PROT WHEN MCUINT NON-ZERO
;SCHNS%==12			;ATTEMPT TO USE SCHED. UUO WHEN
				; NON-CLASS SCHEDULER WAS RUNNING (OBSOLETE)
SCHNH%==13			;NOT 100%
SCHFN%==14			;FAIRNESS NOT POSITIVE
SCHIC%==15			;ILLEGAL CPU
SCHIS%==16			;ILLEGAL SCAN ORDER

	SUBTTL	TRMOP. UUO ERROR CODES
TRMNP%==1			;NOT PRIVILEGED
TRMBR%==2			;BAD RANGE
TRMIA%==3			;ILLEGAL ADDRESS
TRMCD%==4			;CANNOT DO SPECIFIED FUNCTION
TRMDO%==5			;DIALLER OPERATION ERROR
TRMND%==6			;CANNOT GET DDB
TRMNB%==7			;NOT IN BREAK SET MODE
TRMIB%==10			;ILLEGAL BYTE SIZE



	SUBTTL DTE. UUO ERROR CODES

DTENP%==1			;NOT PRIVILEGED
DTEUF%==2			;UNKNOWN FUNCTION CODE
DTEDC%==3			;UNKNOWN CPU NUMBER OR DTE NUMBER
DTEAP%==4			;ALREADY RUNNING PRIMARY PROTOCOL
DTEPT%==5			;POWER FAIL TIMEOUT ERROR
DTEDE%==6			;DEAD 11 - NO DOORBELL FROM 11 DURING BOOTSTRAP SEQUENCE
DTTTE%==7			;TO-10 ERROR AFTER BOOT SEQUENCE
DTEDD%==10			;NO RESPONSE FROM 11 AFTER BOOT SEQUENCE
DTEIJ%==11			;ILLEGAL JOB NUMBER SPECIFIED.
DTEIB%==12			;ILLEGAL BYTE COUNT TO FRONT END DEVICE
DTENI%==13			;FAILURE TO DO INITIALIZE FUNCTION ON FRONT END
				; DEVICE BEFORE USING IT
DTEFB%==14			;FRONT END DEVICE BUSY FOR ANOTHER JOB
DTENF%==15			;NON-EXISTANT FRONT END DEVICE
DTEFE%==16			;FATAL ERROR ON FRONT END DEVICE
DTESE%==17			;ERROR STARTING PRIMARY PROTOCOL
DTENC%==20			;NO FREE CORE FOR FRONT END DEVICE BUFFERS
DTETE%==21			;TIMER EXPIRED FOR KL ERROR DATA CORE
DTECM%==22			;DTE TO-11 QUEUE ROUTINE COULD NOT SEND
				; A MESSAGE FOR FRONT END DEVICE
DTEIU%==23			;TRIED TO SET LINE TO ILLEGAL USER VALUE
DTEWU%==24			;WRONG LINE USER FOR FUNCTION
DTEEV%==25			;NO EVM LEFT TO PERFORM FUNCTION
DTEIP%==26			;ILLEGAL BYTE POINTER
SUBTTL	SEARCH LIST PARAMETERS AND LIMITS

;PRIMARY CONSTANTS

XP	.SLMAX,^D36	;MAX.NUM.FS'S SIMULTANEOUSLY MOUNTED
XP	.SLMXJ,^D10;	;MAX.NUM.FS'S IN JOB SL.
XP	.SLMXS,.SLMAX;	;MAX.NUM.FS'S IN SYS.SL.
XP	.SDMAX,^D8	;MAX NUMBER OF STRS IN SYSTEM DUMP LIST

XP	.FSSIZ,^D9;	;SIZE OF BYTE CONTAINING FSN. & STATUS BITS
XP	.FSFSN,^D6;	;SIZE OF BYTE CONTAINING FSN. ONLY
XP	FS.MSK,777;	;MASK FOR .FSSIZ
XP	FS.NMK,077;	;MASK FOR FSN. ONLY
XP	FS.BMK,700;	;MASK FOR BITS ONLY
XP	FS.WLK,100;	;SOFTWARE WRITELOCK BIT
XP	FS.NCR,200;	;NO-CREATE BIT
;	FS.???,400;	;SPARE BIT


;SECONDARY PARAMETERS AND CONSTANTS

XP	.SLIPW,<^D36/.FSSIZ>;		;ITEMS (FSN'S, MARKERS) PER WORD
XP	.SLWDJ,<<.SLMXJ+2+.SLIPW-1>/.SLIPW>;	;WORDS PER JOB SL. (+2 FOR FNC AND STP)
XP	.SLWDS,<<.SLMXS+2+.SLIPW-1>/.SLIPW>;	;WORDS PER SYS SL.
XP	.SLPSB,<.FSSIZ-1>;		;POSITION OF FIRST BYTE IN A WORD
XP	.SLPSE,<.FSSIZ*.SLIPW-1>;	;POSITION OF LAST BYTE IN A WORD
;XP	SL.PT0,<POINT .FSSIZ,0>;		;POINTER (SANS ADDRESS) WHICH MUST IBP'D TO GET 1ST BYTE
;XP	SL.PTB,<POINT .FSSIZ,.SLPSB>;	;POINTER (SANS ADDRESS) TO 1ST BYTE IN WORD
;XP	SL.PTE,<POINT .FSSIZ,.SLPSE>;	;POINTER (SANS ADDRESS) TO LAST BYTE IN A WORD

;FILE STRUCTURE NUMBERS AND SEARCH LIST MARKERS

			;0 IS NOT USED AS A FSN. SO THERE WILL BE NO
			;  CONFUSION WITH ZEROED DATA BLOCKS
XP	.FSMIN,1	;.FSMIN TO .FSMAX ARE THE LEGAL FSN.S
XP	.FSMAX,<.FSMIN+.SLMAX-1>
XP	.FSFNC,.FSMAX+1	;FENCE MARKER (SEPERATE ACTIVE AND PASIVE LISTS)
XP	.FSEND,.FSFNC+1	;LOGICAL END MARKER
			;  ONLY FNC & FSN'S MUST BE .LT. END SO
			;  CAIL .FSEND CAN BE USED FOR END-TEST
XP	.FSTMP,.FSEND+1	;TEMPORARY SL. MARKER (PREFACED TO SL'S  WHICH
			;  MUST BE RETURNED TO FREE SORAGE)
XP	.FSXX1,.FSTMP+1	;GENERAL PURPOSE MARKER (E.G. FSNINC IN FNDFIL)
XP	.FSSTP,FS.NMK	;PHYSICAL END MARKER

E$$STS:	IFGE .FSXX1-.FSSTP,<PRINTX % S:E$$STS: .FSSIZ TOO SMALL>

;WELL FORMED SEARCH LISTS HAVE ONE OF THE FOLLOWING TWO FORMS:
;
;	(TMP) FNC ( END (?) ) STP		THE EMPTY SEARCH LIST
;	(TMP) (FSN) FNC (FSN) ( END (?) ) STP	NON-EMPTY SEARCH LIST
;
;		(X) MEANS 0 OR MORE OCCURANCES OF X
;		?  MEANS ANYTHING EXCEPT STP
;		FSN MEANS ANY F.S. NUMBER
;
;	0 IS NOT A LEGAL SEARCH LIST -- AND MEANS A SEARCH LIST
;	HAS NOT BEEN CREATED. IT WILL INVOKE DIFFERENT ACTIONS DEPENDING
;	ON CONTEXT (E.G. SUBSTITUTE SYS.SEARCH LIST, CREATE EMPTY
;	SEARCH LIST, ETC.)

;MACROS FOR DEFINING SEARCH LISTS

;AN EMPTY SEARCH LIST
;NUM=	MAX.NUM.FS'S TO ACCOMADATE (MUST BE .GE. 1)
;
DEFINE	SLEMPT (NUM)
	<XLIST
	BEGBYT(.FSSIZ)
	XBYT(.FSFNC)
	XBYT(.FSEND)
	REPEAT NUM-1,<XBYT(0)>
	XBYT(.FSSTP)
	ENDBYT;
	LIST>

;THE ALL: SEARCH LIST
;
DEFINE	SLALL
	<XLIST
	BEGBYT(.FSSIZ)
	$SLALL==.FSMIN
	REPEAT .SLMAX,<
		XBYT($SLALL)
		$SLALL==$SLALL+1
		>
	XBYT(.FSFNC)
	XBYT(.FSSTP)
	ENDBYT;
	LIST>

DEFINE	BEGBYT	(SIZ,POS)
	<XLIST
	IFB  <POS>,<$XBYP==<SIZ>-1>
	IFNB <POS>,<$XBYP==<POS>>
	$XBYS==<SIZ>
	$XBYT==0
	LIST>

DEFINE	XBYT (VAL)
	<XLIST
	$XBYT==$XBYT+<VAL>B<$XBYP>
	$XBYP==$XBYP+$XBYS
	IFG $XBYP-^D35,<
		EXP <$XBYT>
		$XBYP==$XBYS-1
		$XBYT==0
		>
	LIST>

DEFINE	ENDBYT
	<XLIST
	IFN $XBYP-$XBYS+1,<EXP <$XBYT>>
	PURGE $XBYT,$XBYP,$XBYS
	LIST>


;DIAGNOSTIC AND DEBUGGING MACROS ASSEMBLED IF FTSLCK=-1


IFE FTSLCK,<

DEFINE	SLCKFS (AC) <>
DEFINE	SLCKMK (AC) <>
DEFINE	SLCKPT (AC) <>

>;IFE FTSLCK
IFN FTSLCK,<

;EXTERN A SYMBOL IF NOT DEFINED
;
DEFINE	EXT(SYMBOL)
	<
	IRP SYMBOL,<
		IF2,<IFNDEF SYMBOL,<EXTERN SYMBOL>>
	>	>
;CHECK FOR VALID FSN. OR MARKER,  STOPCD BFS IF BAD
;	DEPENDS ON .FSTMP=.FSEND+1=.FSFNC+1=.FSMAX+1
;
DEFINE	SLCKMK	(AC,%L)
	<XLIST
	EXT	SLXBFS;
	PUSH	P,AC
	HRRZS	AC
	CAIN	AC,.FSSTP
	JRST	%L
	CAIL	AC,.FSMIN
	CAILE	AC,.FSTMP
	PUSHJ	P,SLXBFS	;STOPCD BFS
%L:	POP	P,AC
	LIST>


;CHECK FOR VALID FSN., STOPCD BFS IF BAD
;
DEFINE	SLCKFS	(AC)
	<XLIST
	EXT	SLXBFS;
	PUSH	P,AC
	HRRZS	AC
	CAIL	AC,.FSMIN
	CAILE	AC,.FSMAX
	PUSHJ	P,SLXBFS
	POP	P,AC
	LIST>

;CHECK FOR VALID SL.PTR.,  STOPCD BSL IF BAD
;
DEFINE	SLCKPT	(AC)
	<XLIST
	EXT	SLXBPT;
	PUSH	P,AC
	TLZ	AC,770000	;CK FOR ABS.PTR. WITH RIGHT BYTE SIZE
	TLC	AC,<.FSSIZ*100>
	TLZN	AC,-1
	CAMLE	AC,SYSSIZ##	;CK FOR WILD ADDRESS
	PUSHJ	P,SLXBPT
	POP	P,AC
	LIST>

>;IFN FTSLCK
	SUBTTL	BITS IN JOB TABLES -- JOB STATUS WORD (JBTSTS)

;JOB STATUS WORD (JBTSTS TABLE), ONE WORD FOR EACH JOB (SOME BITS ALSO
; APPEAR IN HIGH SEG STATUS WORD)


	XP	RUN,400000	;USER WANTS JOB TO RUN (MUST BE SIGN BIT)
	XP	SNA,400000	;HIGH SEG NUMBER ASSIGNED (ANALOGOUS TO JNA EXCEPT
				; MUST BE SIGN BIT)
	XP	CMWB,200000	;JOB TYPED A COMMAND WHICH NEEDS CORE
				; WHICH IS ON DISK.  SET BY COMMAND DECODER
				; CLEARED WHEN JOB IN CORE AGAIN.
	XP	SHRSEG,200000	;HIGH SEG IS SHARABLE (ALTHOUGH NAME MAY BE 0
				; IF IT HAS BEEN SUPERSEDED).  THIS BIT ALSO
				; APPEARS IN SAME PLACE IN LH OF JBTSGN FOR
				; EACH USER TO INDICATE USER IS USING A SHARABLE
				; HIGH SEG (ALSO APPEARS IN LH OF AC J WHEN
				; RH IS SEG NUMBER FOR A PARTICULAR JOB)
	XP	JXPN,100000	; LOW OR HI SEG MUST BE SWAPPED OUT BECAUSE
				; IT IS EXPANDING SIZE
				; OF CORE AND THERE WASN'T ROOM IN CORE
	XP	JNA,40000	;THIS JOB NUMBER IS ASSIGNED (JOB INITIALIZED)
	XP	SS.SYS,40000	;SEGMENT CAME FROM SYS
	XP	JERR,20000	;A MONITOR DETECTED ERROR HAS OCCURRED
				; JOB CAN NOT CONTINUE
	XP	SERR,20000	;A SWAP READ ERROR HAS OCCURRED FOR THIS HIGH SEG
	XP	NSWP,10000	;JOB OR HIGH SEG IS NOT TO BE SWAPPED
				; (REALTIME OR DISPLAY)
				; (CAN BE SHUFFLED OR NOT ACCORDING TO NSHF)
	XP	SHF,4000	;MONITOR IS WAITING FOR DEVICES FOR THIS
				; JOB TO STOP AFTER CURRENT BUFFERFULL
				; SO JOB CAN BE SHUFFLED IN CORE OR SWAPPED OUT
				; IF JOB ONLY HAS LOW SEG
	XP	SWP,2000	;0 IF JOB IN CORE, 1 IF SWAPPED OUT OR ON WAY
				; IN OR OUT.  SAME FOR LOW AND HIGH SEGMENTS
	XP	NSHF,1000	;JOB IS NOT SHUFFLABLE
	XP	CNTRLC,400	;^C WAS TYPED WHILE JOB WAS IN MONITOR MODE
				; AND NOT IN TTY WAIT - DELAY STOPPING JOB
	XP	STOPIO,SWP+CMWB+SHF	;FORCE JOB TO STOP TO EXECUTE
				; SWAP, COMMAND OR SHUFFLE

	;BITS 10-14 USED TO INDICATE JOB IN WAIT FOR A SHARABLE DEVICE
	;0 MEANS JOB NOT WAITING FOR SHARABLE DEVICE

	XP	JWSIZ,5		;SIZE OF WAIT CODE
	XP	JWPOS,^D14	;RIGHT MOST BIT POS. OF WAIT CODE
	XP	WTMASK,370	;MASK FOR CLEARING WAIT CODES

	XP	JLOG,4		;JOB SUCCESSFULLY LOGGED IN
	XP	JRQ,2		;JOB HAS CHANGED STATE AND MUST BE REQUEUED AT CLOCK
				; LEVEL BEFORE RESCHEDULING CAN TAKE PLACE
	XP	JACCT,1		;PRIVILEGED SYSTEM CUSP IS BEING RUN WHICH CANNOT
				; BE STOPPED (E.G., LOGIN
				; OR LOGOUT).  PROTECT IT FROM CURIOUS EYES.
				; DISABLE CONTROL C, MADE IT ACT LIKE ALT-MODE

;BITS IN RIGHT HALF OF JBTSTS
	XP	CLKR,400000	;JOB HAS A CLOCK REQUEST IN.
				; NEEDED SO ONLY ONE REQUEST PER JOB
	XP	LOK,200000	;JOB IS BEING LOCKED IN CORE
	XP	JDC,100000	;JOB HAS TYPED "DCORE"

	XP	UTRP,40000	;TRAP TO USER ON UUO EXIT (REENTER DDT)
				; TRAP ADR. STORED IN JOBFDV BY COMMAND
	XP	JDCON,20000	;JOB IN ^C STATE WAITING FOR DEVICE
				;TO CONTINUE FROM ERROR
	XP	JS.DEP,10000	;DAEMON ERROR PAUSE.  SET WHEN JOB
				; GETS AN ERROR.  JOB PAUSES UNTIL
				; DAEMON CAN ENTER ERROR INFO INTO LOG FILE
				; DAEMON CLEARS BIT
	XP	JS.XXX,4000	;***AVAILABLE
	XP	JS.XO,2000	;EXECUTE ONLY CORE IMAGE
	XP	JS.SFE,400000	;ON IF HIGH SEGMENT CAME FROM AN EXE FILE
	XP	JS.RUU,1000	;RUN UUO OR COMMAND IN PROGRESS
	XP	JS.MPE,400	;MEM PAR ERROR FOR JOB (LOW OR HIGH SEG)
				; BEHAVES LIKE CNTRLC. JOB RUNS TO UUO EXIT
				; IF PARITY IN UUO LEVEL CODE IN USER AREA
				; DOES NOT STOP A JOB FROM BEING RUN

	XP	JS.BPT,200	;SET DDT BREAKPOINT BIT
	XP	JS.DPM,100	;DAEMON PROBLEM MESSAGE NEEDED FOR JOB
				; PRINT ONCE A MINUTE PRINT %PROBLEM WITH DAEMON ON JOB
				; THEN SET EVERY MIN JOB IS WAITING FOR DAEMON
	  XP	JS.DEM,JDC!JS.DEP	;JOB BITS TO CHECK FOR EVERY MINUTE.
				; SET JS.DPM IF ON
	XP	JS.ASA,40	;FETCH AND STORE UUO ARGUMENTS INTO/FROM USER ADDRESSES
				; WHICH ARE LESS THAN 20 IN SHADOW AC AREA RATHER
				; THAN USERS ACS. CSET ON SAVE, GET, RUN, AND GETSEG
	XP	JS.XOR,20	; LIT IF RUN UUO OR COMMANDS IN PROGRESS A FILE IS XO.

	XP	JS.RQR,10	; RESET QUANTUM RUN-TIME. THIS BIT IS SET
				;  IF WE WANT TO ALTER QUANTUM RUNTIME.
				;  WHILE THE PDB IS ON THE DISK.

	XP	JS.SFL,4	;STOP JOB IF DISK FULL. SET (CLEARED)
				; BY SET FULL STOP (NOSTOP) COMMAND, UUO. IF OFF
				; AN ERROR BIT IS SET ON DISK FULL OR QUOTA
				; EXCEEDED.  IF ON JOB IS STOPPED, ".CONT" RETRIES
	XP	JS.NXM,2	;SOME PAGE IN THIS JOB'S ADDRESS SPACE
				; IS CONTAINED IN NON-EXISTENT MEMORY

	XP	JS.NTO,1	;THIS JOB HAS DONE SOME NON-BLOCKING
				; TTY OUTPUT.

;***********************************************************************
;ADD NEW BITS IN JOB STATUS WORD ABOVE HERE
;***********************************************************************
;BITS 9-17 ARE USED FOR ACCESS PRIVILEGE BITS FOR SHARABLE HIGH SEGMENTS
; SAME FORMAT AS ACCESS BITS FOR DISK

	XP	HSASIZ,^D9	;SIZE OF HIGH SEG ACCESS BITS
	XP	HSAPOS,^D17	;RIGHT MOST POSITION OF HIGH SEG ACCESS BITS
	XP	HSAMSK,777	;MASK TO CLEAR ACCESS PRIVILEGES
	XP	ICCSIZ,^D12	;SIZE OF HIGH SEG IN CORE COUNT FIELD
	XP	ICCPOS,^D35	;RIGHT MOST POSITION OF HIGH SEG IN
				; CORE COUNT FIELD MUST BE RIGHT MOST
				; BITS OF WORD SINCE COUNT IS AOSED
				; AND SOSED
	XP	ICCMSK,7777	;MASK FOR TESTING IN CORE COUNT


;MASKS USED TO TEST STATUS CONDITIONS:

	XP	RUNABLE,RUN+JNA	;STATUS BIT PATTERN FOR JOB TO BE RUNABLE
	XP	RUNMSK,JLOG+NSHF+JACCT+NSWP+CNTRLC
				; BITS WHICH DO NOT MATTER FOR RUNABILITY
	SUBTTL	BITS IN JOB TABLES -- JBTSCD

;BITS IN RIGHT HALF OF JBTSCD

	XP JS.TYP,777B35	;JOB'S SCHEDULER TYPE

;BITS IN LEFT HALF OF JBTSCD

	XP JS.PQ2,1B0		;JOB IS IN PQ2, THEREFORE SUBCLASS
				; (MUST BE SIGN BIT)
	XP JS.CLS,37B17		;JOB'S SCHEDULER CLASS
	SUBTTL	BITS IN JOB TABLES -- JBTST2


;;!=========================================================================!
;;!IP! ! ! ! ! !X!NN!BB!C!H!BP!FX!CF!SL!N!EX!M!A!EW.CODE!W!R!QUEUE #!O!Q!S!
;;!=========================================================================!

;BITS IN RH OF JBTST2

	XP	JS.MIG,1B18	;JOB HAS MIGRATED TO ANOTHER SWAPPING U NIT
				; WHEN A DISK CONTROLLER IS BEING TAKEN
				; OFF-LINE (FTDHIA)
	XP	JS.ABP,1B19	;AN ADDRESS BREAK PAGE FAULT OCCURRED
				; BECAUSE OF A REFERENCE TO THIS USER'S
				; VIRTUAL ADDRESS SPACE DURING UUO
				; PROCESSING
	XP	ESLPSZ,5	;ESLEEP REASON BYTE SIZE
	XP	ESLPBP,^D24	;ESLEEP REASON BYTE POSITION
	XP	EWAKEB,1B25	;EWAKE CALLED (WAKEUP WAITING)
	XP	JS.RPC,1B26	;IF=1 RUN PROGRAM IN .PDPGM ON CONTROL-C
	XP	JS.SIZ,6	;NUMBER OF BITS FOR QUEUE NUMBER
	XP	JS.POS,^D32	; RIGHTMOST BIT IN QUEUE NUMBER
	XP	JS.MSK,770	;MASK FOR STATE CODE. USED AT CLRJBT
	XP	JS.OOO,4	;USER RAN OUT OF ORDER. STOP WHEN GIVES UP
				; LAST RESOURCE.
	XP	JS.TFO,2	;JOB FORCED OUT BY TIMER
	XP	JS.SCN,1	;JOB WAS SCANNED TO RUN BY AT LEAST ONE
				; CPU DURING LAST TICK

;BITS IN THE LEFT HALF OF JBTST2

	XP	JS.EXE,1B17	;A NEW SAVE (EXE FILE) IS UNDERWAY
				; OR, ON A "GET", THIS BIT MEANS THAT A LOOKUP
				; ON THE EXE FILE FAILED. IF SO, THE
				; EXE FILE WILL NOT BE LOOKUP'ED AGAIN
				; FOR THE LOW SEGMENT
	XP	JS.NCS,1B16	;ON IF CACHE BITS ARE NOT TO BE TURNED
				; ON IN THIS JOBS MAP
	XP	JS.HIB,1B15	;THIS JOB IS HIBERNATING
	XP	JS.CFX,1B14	;CALL FILE DAEMON ON "PROGRAM EXIT"
	XP	JS.FXO,1B13	;FILE DAEMON MADE THIS CORE IMAGE EXECUTE ONLY
	XP	JS.BPR,1B12	;BYPASS PROGRAM TO RUN CHECKING IF THIS
				; FLAG IS SET THE CURRENT RUN COMMAND IS
				; ALLOWED DESPITE .PDPGM (USED FOR KJOB)
	XP	JS.HNG,1B11	;JOB STAYED IN FORCE TOO LONG, CAUSING TEMPORARY
				; OR PERMANENT SYSTEM HANG,  CLEARED WHEN SWAPPED IN
	XP	JS.IGS,1B10	;IN GETSEG (DOING A GETSEG UUO)
	XP	JS.CSQ,1B9	;IF JOB CHANGING SUBQUEUE DO TO SCHED UUO
	XP	JS.BBJ,1B8	;IF JOB IS BACKGROUND BATCH
	XP	JS.NNQ,1B7	;IF NOT TO ASSIGN NEW QUANTA ON SWAP IN.
				; SET WHEN DOING A GETSEG TO A SWAPPED HIGH SEGMENT
	XP	JS.FPS,1B6	;ON IF LONG KA10 FLOATING POINT INSTRUCTIONS SHOULD BE
				; SIMULATED
	XP	JS.SIP,1B5	;ON IF SWAPPING I/O IS IN PROGRESS FOR THIS JOB
	XP	JS.OLS,1B4	;JOB OWNS LOCKED STRUCTURE(S)
	XP	JS.SAC,1B3	;THE JOB'S CURRENT CORE IMAGE IS AN ALTERNATE
				; CONTEXT. RESTORE PREVIOUS CONTEXT WHEN THE
				; TERMINAL IS RETURNED TO MONITOR LEVEL
	XP	JS.DEB,3B2	;DEFERRED ECHO BITS
	XP	JS.IPQ,1B0	;ON IF JOB IS IN A PROCESSOR QUEUE (MUST BE SIGN BIT)
	SUBTTL	BITS IN JOB TABLES -- JBTSWP, JBTPPB AND PAGTAB

;BITS IN JBTSWP TABLE

	XP	FRGSEG,400000	;LH - 1 IF LOW OR HIGH SEG IS FRAGMENTED ON SWP DEV


;BITS IN LH JBTPPN TABLE

	XP	JBPWLK,400000	;LEFTMOST BIT OF WRITELOCK FIELD (STR # 0)
	XP	JBPNCR,400	;LEFTMOST BIT OF NO-CREATE FIELD (STR # 0)
	XP	JBLWLK,1000	;RIGHTMOST BIT OF WRITELOCK FIELD (STR # 8)
	XP	JBLNCR,1	;RIGHTMOST BIT OF NO-CREATE FILED (STR # 8)
	XP	NCRMSK,777	;ALL NO-CREATE BITS

;BITS IN LEFT HALF OF JBTPDB
	XP	MCPSIZ,6	;SIZE OF BYTE POINTER FIELD FOR THE NUMBER
				; OF PAGES OF MONITOR FREE CORE ALLOCATED
				; TO THIS USER
	XP	MCPBPP,^D17	;POSITION
	XP	IMCPBP,^D11	;POSITION FOR NUMBER OF PAGES TO SWAP IN
	XP	MCPCNT,1B17	; FOR INCREMENTING/DECREMENTING COUNT

;BITS IN PAGTAB
	XP	FREPAG,400000	;ON IF PAGE IS NOT IN SOME JOBS ADDRESSING SPACE
	XP	LOKPHB,200000	;ON IF THIS PAGE IS CONTAINED IN A SEGMENT
				; WHICH IS LOCKED IN PHYSICALLY CONTIGUOUS MEMORY
	XP	LOKEVB,100000	;ON IF THIS PAGE IS CONTAINED IN A SEGMENT WHICH
				; IS LOCKED VIRTUALLY CONTIGUOUS IN THE
				; EXEC ADDRESSING SPACE
	XP	LOKIPB,40000	;ON IF THIS PAGE IS CONTAINED IN A SEGMENT
				; WHICH IS LOCKED IN PLACE
	XP	NXMBIT,20000	;ON IF THIS PAGE IS BELOW MEMSIZ BUT IS
				; NON-EXISTANT
	XP	MONTRB,10000	;ON IF THIS PAGE IS CONTAINED IN THE MONITOR
	XP	IPCBIT,4000	;ON IF THIS PAGE IS OWNED BY IPCF
	XP	TNCSHB,2000	;ON IF THIS PAGE IS TEMPORARILY UNCACHED
				; (MONITOR LOW PAGES ONLY ON 1099)
	XP	LKBITS,LOKPHB!LOKEVB!LOKIPB!NXMBIT!MONTRB
	SUBTTL	BITS IN JOB TABLES --  MEMTAB AND SWPLST

;BITS IN MEMTAB
MT.LEF==1B0		;LAST ENTRY IN FRAGMENT-CHAIN

HLGPNO==777
IFN FTKLP,<
HLGSNO==37
>
PA.PME==1B35
PA.PMI==1B34
PA.PCE==1B33
PA.PCI==1B32
PA.IHB==1B31


;BITS IN SWPLST
SL.FRG==1B0		;FRAGMENTED ENTRY
SL.DIO==1B1		;DIRECTION OF IO (1=OUT)
SL.SIO==1B2		;SWAPPING/PAGING (1=SWAPPING)
SL.IOP==1B3		;IO IN PROGRESS
SL.IOD==1B4		;IO DONE (THIS SWPLST ENTRY IS DONE)
SL.IPC==1B5		;ON IF AN IPCF PAGE
SL.DFM==1B6		;KEEPS FNDSLE FROM FINDING THE SWPLST ENTRY.
SL.CHK==1B11		;SWAPPING CHECKSUM ERROR
SL.ERR==1B12		;IO ERROR (IODTER,IODERR, OR IOIMPM)
SL.CHN==1B13		;CHANNEL ERROR (IOCHMP OR IOCHNX)

;BITS IN THE PDB
PD.IPV==1B1		;JOB IS IN PQV
PD.PLS==1B18		;JOB HAS A PHYSICAL LIMIT (AS OPPOSED TO GUIDELINE) SET
PD.DPS==1B9		;JOB HAS A DEFAULT PROTECTION SET
PD.FSP==1B10		;FILE DAEMON SPECIFIED THE PROTECTION FOR THIS CREATE
PD.UDS==1B11		;USE DEFAULT FILE SPEC ON RUN, GET
PD.DAD==1B12		;DON'T ASK ABOUT DETACHED JOBS AT LOGIN TIME
PD.LGN==1B13		;LOGIN BIT, IF SET DO INCR AND CLEAR,
			;IF CLEAR DO DECR AND SET, THIS IS FOR ACCLG. UUO
	SUBTTL	BITS IN JOB TABLES -- JBTSGN

;VIRTUAL ADDRESSING SPACE DESCRIPTOR WORD (JBTSGN) ONE WORD FOR EACH JOB
;THIS WORD APPEARS IN AC J
;LH BITS
	XP	SPYSEG,400000	;THE HIGH SEG IS PHYSICAL CORE (SEE SPYUUO)
				; MUST BE SIGN BIT SO TEST FOR JOB HAVING A
				; REAL HIGH SEG IS SKIPG JBTSGN(J)
				;THIS BIT CAN ALSO BE SET IN AN AC (AS IN J),
				;SO THAT MODULES LIKE LOKCON CAN USE A COPY
				;OF JBTSGN AS AN INDEX. THIS WILL NEVER BE
				;STORED BACK IN JBTSGN, IT WILL JUST BE USED
				;IN THE AC.
	XP	SHRSEG,SHRSEG	;THE HIGH SEG THIS JOB IS USING IS SHARABLE
				; THIS BIT ALSO APPEARS IN JBTSTS FOR HIGH SEGS
	XP	UWPOFF,100000	;IF 1, USER-MODE WRITE PROTECT IS OFF FOR THIS JOB
	XP	MEDDLE,40000	;IF 1, USER HAS MEDDLED WITH SHARABLE PROGRAM SUCH
				; THAT PROGRAM CANNOT TRUST ITSELF
				; TO TURN UWP OFF OR CHANGE HIGH SEG CORE ASSIGNMENT
				; MEDDLING MEANS:
				;   1. START N, OR D COMMAND
				;   2. RUN UUO WITH GREATER THAN 1 STARTING INCREMENT
				;   3. GETSEG UUO
				;   4. HIGH SEG IS PHYSICAL CORE (SPY UUO)
	XP	CORCNT,20000	;IF 1, THE HIGH SEG IN CORE COUNT FOR THIS
				; JOB HAS BEEN INCREMENTED.  IF 0, IT HAS NOT.
				; SET AND CLEARED BY INCCNT AND DECCNT ROUTINES.
	XP	LOKSEG,10000	;THE HIGH SEGMENT THIS JOB IS SHARING IS LOCKED
				; IN CORE. THE HIGH SEGMENT WILL ONLY BE UNLOCKED
				; WHEN THIS BIT IS OFF EVERY JOB SHARING
				; THE HIGH SEGMENT.
	XP	NCSH,4000	;THE HIGH SEGMENT THIS JOB IS USING
				; IS TO HAVE THE CACHE BITS OFF IN
				; THIS JOB'S MAP
	XP	SEGMB,2000	;SET BY KILOCK TO INDICATE THAT SOMEONE HAS
				; LOCKED THIS SEGMENT AND THIS JOB'S PAGE MAP
				; MUST BE RECOMPUTED.  USED BY CLOCK ROUTING
				; ONLY IF NEXT JOB = LAST JOB.
	XP	NOCSH,1000	;ON IF THIS JOB'S HIGH SEGMENT IS NOT TO
				; BE CACHED SINCE IT IS SHARABLE, WRITABLE
				; BY SOME JOB IN A MULTIPROCESSING MONITOR
	XP	REDOMP,400	;ON IF THE HIGH SEGMENT PART OF THIS
				; JOB'S MAP MUST BE REDONE
	XP	GTSSEG,200	;ON IF THIS JOB'S HIGH SEGMENT WAS
				; OBTAINED VIA A GETSEG UUO
;BITS 13-17=0 SO CAN DO CAI @JBTSGN TO COMPARE RH.
;RH IS HIGH SEG NUMBER (NUMBER GREATER THAN JOB MAX AND LESS THAN OR EQUAL TO JBTMAX)
; OR IF SPYSEG IS SET, RH IS HIGHEST PHYSICAL ADR USER MAY SPY INTO
; BITS 26-35 ALWAYS=1777 SO CANNOT WORK LIKE A SEGMENT NUMBER
	SUBTTL	BITS IN JOB TABLES -- JBTPRV

;JOB PRIVILEGE BITS - JBTPRV TABLE
;SET BY LOGIN FROM ACCT.SYS FILE AS MODIFIED BY CUSTOMER FOR
; HIS PARTICULAR INSTALLATION
;RH RESERVED FOR SPECIAL CUSTOMER DEFINED PRIVILEGES (PLEASE START
; AT BIT 35 AND WORK TO THE LEFT)
;LH RESERVED FOR DIGITAL STANDARD PRIVILEGES

;BITS IN LEFT HALF
	XP	PVSPYM,1	;JOB ALLOWED TO SPY AT MONITOR USING PEEK/SPY UUOS
	XP	PVSPYA,2	;JOB ALLOWED TO SPY AT ALL OF CORE USING PEEK/SPY UUOS
	XP	PVTRPS,4	;JOB ALLOWED TO USE TRPSET UUO
	XP	PVLOCK,10	;JOB ALLOWED TO USE LOCK UUO
	XP	PVRTT,20	;JOB IS ALLOWED TO USE RTTRP (REAL-TIME TRAPPING) UUO
	XP	JP.ENQ,100	;JOB HAS ENQ PRIVILEGES
	XP	PVNSPL,200	;JOB IS ALLOWED TO UNSPOOL DEVICES
	XP	PVHPQ,7400	;LARGEST HPQ RUN QUEUE
	XP	JP.CCC,10000	;JOB IS ALLOWED TO CHANGE CPU SPECIFICATION
				; VIA COMMAND AND UUO
	XP	JP.POK,20000	;POKE AT MONITOR
	XP	JP.MET,40000	;JOB IS ALLOWED TO USE METER. UUO
	XP	JP.DPR,300000	;LARGEST DISK PRIORITY ALLOWED
	XP	JP.IPC,400000	;IPCF PRIV. FUNCTIONS

;BITS IN RIGHT HALF - CUSTOMER BITS

IFN FTCIMP,<			;[arpa]
	XP	JP.IMP,1B35	;[arpa] SUPER IMP PRIVS
	XP	JP.NET,1B34	;[arpa] NETWORK ACCESS PRIVS
>				;[arpa]
IFN STUPID,<
	XP	JP.DCN,1B33	;DECnet access privileges.
>;IFN STUPID
	SUBTTL	BITS IN JOB TABLES -- WORDS OF PROCESS DATA BLOCKS


	XP	PDMQNT,7777	;MASK FOR QUANTUM RUN TIME
				;MUST BE LOW ORDER BITS FOR SOS

	XP	PDSQNT,^D12	;SIZE OF QNT BYTE
	XP	PDNQNT,^D35	;BYTE PTR POSITION

	XP	PDSIPT,^D17	;BYTE SIZE OF INCORE PROTECT TIME
	XP	PDNIPT,^D17	;BYTE POSITION.
	XP	PDMSWP,400000	;BIT ZERO FOR SKIPS ON .PDIPT
				;IF ON, INCORE-PROTECT TIME HAS EXPIRED
	XP	NWSCTX,^D22	;NUMBER OF WORDS OF MONITOR FREE CORE
				; REQUIRED TO SAVE A JOBS CONTEXT
	SUBTTL	BITS IN JOB TABLES -- JBTWCH AND JBTRSP

;BITS IN JBTWCH    -	WATCH SYSTEM RESPONSE COMMAND
;LH BITS:	(BITS 13-35 = TIME OF DAY IN JIFFIES USER STARTS TO WAIT)
;MUST BE IN FOLLOWING ORDER WITH JW.WDJ AS LEFT MOST BIT OF ALL OF THEM
	XP	JW.WDY,200000	;WATCH TIME OF DAY STARTED TO WAIT
	XP	JW.WRN,100000	;WATCH RUN TIME WHEN RETURN TO COMMAND LEVEL
	XP	JW.WWT,40000	;WATCH WAITING TIME RETURN TO COMMAND LEVEL
	XP	JW.WDR,20000	;WATCH NO. 128 WORD DISK BLOCKS READ
	XP	JW.WDW,10000	;WATCH NO. 128 WORD DISK BLOCKS WRITTEN
	XP	JW.WVR,4000	;WATCH VERSIONS
	XP	JW.WMT,2000	;WATCH MTA PERFORMANCE STATISTICS
	XP	JW.WFL,1000	;WATCH FILE ACTIVITY
	XP	JW.WLM,400	;LONG ERROR MESSAGES
	XP	JW.WNM,200	;NORMAL ERROR MESSAGES
	XP	JW.WPM,100	;PREFIX ERROR MESSAGES
				; IF ABOVE 3-BITS=0, ASSUME =3.
		;ADD NEW DATA HERE (ALSO INCLUDE IN WCHALL)
	XP	WCHALL,JW.WDY!JW.WRN!JW.WWT!JW.WDR!JW.WDW!JW.WVR!JW.WMT!JW.WFL	;ALL WATCH BITS


;BITS IN JBTRSP - RESPONSE TIME MEASURE
;LH BITS - REST OF WORD IS UPTIME IN JIFFIES WHEN USER
; TYPED IN COMMAND WHICH STARTED JOB OR BREAK CHAR
; WHICH TOOK JOB OUT OF IO WAIT

;BITS SET TO 1 WHEN TYPE OF RESPONSE IS RECORDED. SET TO 0 WHEN USER TYPES IN
	XP	JR.RCR,1B0	;RECORDED FIRST CPU USE
	XP	JR.ROR,1B1	;RECORDED TTY OUTPUT UUO
	XP	JR.RIR,1B2	;RECORDED TTY INPUT UUO
	XP	JR.RRR,1B3	;RECORDED CPU QUANTUM EXCEEDED REQUEUE
	XP	JR.RXR,1B4	;RECORDED FIRST OF ABOVE THREE RESPONSES
				; (NOT JR.RCR)
	XP	JR.RXX,JR.RCR!JR.ROR!JR.RIR!JR.RRR!JR.RXR

;BITS IN C(JOBERR+2) (ERROR INTERCEPTING)
;LEFT HAND BITS:
	XP	.ERMSG,400000	;DONT TYPE ERROR MESSAGE IF BIT=1

;RIGHT HAND BITS:
	XP	.ERIDV,1	;INTERCEPT "DEV OK?" ERRORS (HNGSTP)
	XP	.ERICC,2	;CONTROL-C INTERCEPT
	XP	.EROFL,4	;UNIT DROPPED OFF-LINE
	XP	.ERFUL,10	;FILE STRUCTURE IS FULL
	XP	.ERQEX,20	;QUOTA EXHAUSTED
	XP	.ERTLX,40	;TIME LIMIT EXCEEDED
	XP	.EREIJ,100	;ERROR IN JOB

	SUBTTL	BITS IN JOB TABLES -- JBTLIM, JBTSPL, .PDOBI

;BITS, FIELDS IN JBTLIM
	XP	JB.LTL,1B0	;0--TIME LIMIT SET FROM FORCED DETACH
	XP	JB.LCR,777B9	;1-9--CORE LIMIT
	XP	JB.LBT,1B10	;10-BATCH JOB
	XP	JB.LSY,1B11	;11--GOTTEN FROM SYS:
	XP	JB.LTM,77777777	;12-35--TIME LIM TO GO IN JIF. (0=INF.)

;BITS, FIELDS IN JBTSPL
	XP	JB.SIN,777777B17  ;0-17 SPOOLED INPUT NAME
	XP	JB.DPR,7B26	;24-26 DISK PRIORITY
				; DEFINED IN COMMOD,JBXPRI
	XP	JB.SPL,777	;SPOOLING BITS
	XP	JBSSIZ,^D9	;SIZE OF BYTE
	XP	JB.DFR,1B27	;27 DEFFERRED SPOOLING
				;28-30 RESERVED FOR MORE SPOOLING DEVICES
	XP	JB.CDR,.SPCDR	;31 SPOOLED CDR
	XP	JB.CDP,.SPCDP	;32 SPOOLED CDP
	XP	JB.PTP,.SPPTP	;33 SPOOLED PTP
	XP	JB.PLT,.SPPLT	;34 SPOOLED PLT
	XP	JB.LPT,.SPLPT	;35 SPOOLED LPT

;BITS, FIELDS IN .PDOBI
	XP	JB.WTO,3B1	;WRITE TO OPERATOR VALUES
		XP	JB.WRA,0 ;WTO/WTOR ALLOWED
		XP	JB.WRO,1 ;WTO ALLOWED
		XP	JB.WNA,2 ;NEITHER WTO OR WTOR ALLOWED
	XP	JBPWTO,<<POINT 2,.PDOBI##(W),1>>
;DEFINITIONS FOR QUEUE. UUO
	XP	QU.FLG,777777B17;QUEUE UUO FLAGS
	XP	QU.RSR,1B0	;USER IS REQUESTING A RESPONSE
	XP	QU.PRP,1B1	;USER IS PRIVILIGED AND IS REQUESTING PRIVS
	XP	QU.NBR,1B2	;USER IS REQUESTING NON-BLOCKING
;ADD NEW LEGAL QUEUE UUO FLAG BITS TO THE DEFINITION BELOW (QU.LFB)
	XP	QU.LFB,QU.RSR+QU.PRP+QU.NBR
;DEFINITIONS FOR WTO/WTOR UUO
	XP	.WTORR,200012	;WTOR RESPONSE
	XP	.OMACK,700000	;OPERATOR MESSAGE ACK
	XP	WT.WTR,1B0	;WTOR AS OPPOSED TO WTO
	XP	WT.SND,1B10	;WTO AS A RESULT OF A SEND COMMAND
	XP	WT.RWT,1B18	;WTOR TEXT WAS TRUNCATED
	XP	WT.RBR,1B19	;RESPONSE BLOCK RETURNED
	XP	WT.NRW,777B35	;LENGTH OF WTOR RESPONSE MESSAGE
	XP	.WTTXT,40	;WTO TEXT
	XP	.WTDES,25	;NODE NAME OF WTO OPERATOR
	XP	.WTACT,23	;ACCOUNT STRING
	XP	.WTUFC,24	;QUEUE UUO FUNCTION
	XP	.WTNAM,26	;USER'S NAME
	XP	.CMTXT,17	;OPERATOR RESPONSE TO WTOR
	XP	WT.NOR,1B2	;NORMAL RESPONSE FROM ORION
	XP	JP.OPP,7B4	;OPER PRIVS
	XP	JBPOPP,<<POINT 3,.PDOBI##(W),4>>
	XP	JB.BSS,1B10	;BATCH STREAM NUMBER SET
	XP	JB.BSN,177B17	;BATCH STREAM NUMBER
	XP	JBPBSN,<<POINT 7,.PDOBI##(W),17>> ;POINTER TO BSN
;QUEUE. UUO OFFSETS (FIXED)
;GALAXY HEADER

QUELNH==0		;LENGTH,,FUNCTION
QUEFLG==1		;FLAGS
QUEJOB==2		;ACK CODE,,JOB NUMBER
QUEMBZ==3		;0
QUEARC==4		;ARGUMENT COUNT

;QUEUE. UUO OFFSETS (MAY CHANGE)
;MONITOR SUPPLIED DATA

QUEONH==5		;OPR NODE NAME HEADER
QUEONN==QUEONH+1	;OPR NODE NAME
  QUEONL==2		;LENGTH OF OPR NODE NAME
QUEUNH==QUEONH+QUEONL	;USER NAME HEADER
QUEUSN==QUEUNH+1	;USERS NAME
  QUEUNL==3		;LENGTH OF USERS NAME
QUEACH==QUEUNH+QUEUNL	;ACCOUNT STRING HEADER
QUEACS==QUEACH+1	;ACCOUNT STRING
IFNDEF ACTSTL,<EXTERN ACTSTL>
  QUEACL==ACTSTL+1	;LENGTH OF ACCOUNT STRING


;***QUEFCH MUST BE LAST, ADD MONITOR GENERATED ARGUMENTS ABOVE HERE
QUEFCH==QUEACH+QUEACL	;FUNCTION BLOCK HEADER
QUEFCN==QUEFCH+1	;FUNCTION
  QUEFCL==2		;LENGTH OF FUNCTION BLOCK

;***NUMBER OF MONITOR GENERATED ARGUMENTS, MUST BE UPDATED IF ANOTHER
; BLOCK IS ADDED TO THE OUTPUT OF THE QUEUE. UUO
QUEIGL==4

;LENGTH OF STATIC DATA
QUESDL==5+QUEONL+QUEUNL+QUEACL+QUEFCL
	SUBTTL	BITS IN JOB TABLES -- JBTSPS

;BITS IN JBTSPS - SECOND PROCESSOR STATUS TABLE.  INDEXED BY JOB NO.
;BITS DEFINED AS 36 BIT MASKS USING NEW SP.XXX CONVENTION
;NOT DEFINED FOR USERS (YET):
	XP	SP.NR0,1B5	;NOT RUNABLE ON CPU0
	XP	SP.NR1,1B4	;NOT RUNABLE ON CPU1
	XP	SP.NRA,77B5	;NOT RUNABLE ANYWHERE
;BITS 3-0 RESERVED FOR FUTURE CPUS
	XP	SP.CJ0,1B11	;CURRENT JOB ON CPU 0
	XP	SP.CJ1,1B10	;CURRENT JOB ON CPU 1
	XP	SP.CJA,77B11	;CURRENT JOB SOMEWHERE
;BITS 6-9 RESERVED FOR FUTURE CPUS
	XP	SP.ROP,1B12	;JOB FORCED TO POLICY CPU
				; FIX SP.NR? BITS WHEN POLICY CPU DIES
	XP	SP.CC1,1B14	;CONTROL C ON CPU 1, STOP RUNNING JOB
				;ON SLAVE

;DEFINED FOR USERS:
	XP	SP.CR0,1B35	;CAN RUN ON CPU 0.  SET BY SETUUO, RESET, EXIT
				; IE CURRENT JOB CPU SPECIFICATION BIT.
	XP	SP.CR1,1B34	;CAN RUN ON CPU 1. SET BY SETUUO, RESET, EXIT
				; IE CURRENT JOB CPU SPECIFICATION BIT.
	XP	SP.CRA,77B35	;CAN RUN ANYWHERE
;BITS 33-30 RESERVED FOR FUTURE CPUS
	XP	SP.SC0,1B29	;"SET CPU COMMAND" BIT FOR CPU 0
				; 1 MEANS OK AS FAR AS USER IS CONCERNED
				; TO RUN JOB ON THIS CPU (EVEN IF CPU HAS
				; BEEN STOPPED OR IS NOT SCHEDULING).
	XP	SP.SC1,1B28	;"SET CPU COMMAND" BIT FOR CPU 1
				; 1 MEANS OK AS FAR AS USER IS CONCERNED
				; TO RUN JOB ON THIS CPU (EVEN IF CPU HAS
				; BEEN STOPPED OR IS NOT SCHEDULING).
	XP	SP.SCA,77B29	;"SET CPU ALL"
;BITS 27-24 RESERVED FOR FUTURE CPUS
SP.CP0==1B35			;CPU0'S BIT IS RIGHTMOST IN ALL FIELDS
SP.CPA==77B35			;BITS FOR ALL CPUS

	SUBTTL	BITS IN JOB TABLES --  JBTPIA AND PSISER DEFINITIONS

;BITS IN JBTPIA -- PROGRAMMED SOFTWARE INTERRUPT POINTER TABLE
	XP	SI.ON,1B0	;PI SYSTEM IS TURNED ON
	XP	SI.DBK,1B1	;PI SYSTEM IS OFF UNTIL DEBRK OF CURRENT

;BITS IN AC OF PISYS. UUO
	XP	PS.OFF,1B1	;TURN SYSTEM OFF
	XP	PS.ON,1B2	;TURN SYSTEM ON
	XP	PS.CPI,1B3	;CLEAR ALL PENDING INTERRUPTS
	XP	PS.CSI,1B4	;CLEAR SELECTED INTERRUPT
	XP	PS.RDV,1B5	;REMOVE DEVICE OR CONDITION
	XP	PS.ADV,1B6	;ADD DEVICE OR CONDITION
	XP	PS.ALL,77B6	;ALL VALID BITS

;BITS IN THE INTERRUPT REASON WORD
;*** 1B18 IS RESERVED TO PSISER AND NOT AVAILABLE ***
	XP	IR.IND,1B19	;INPUT DONE
	XP	IR.OUD,1B20	;OUTPUT DONE
	XP	IR.EOF,1B21	;END OF FILE
	XP	IR.IER,1B22	;INPUT ERROR
	XP	IR.OER,1B23	;OUTPUT ERROR
	XP	IR.DOL,1B24	;DEVICE OFF LINE
	XP	IR.DFL,1B25	;DEVICE IS FULL
	XP	IR.QTE,1B26	;QUOTA EXCEEDED
	XP	IR.IOW,1B27	;I/O WAIT
	XP	IR.ONL,1B28	;DEVICE ON LINE
	XP	IR.RHC,1B29	;RIB HAS CHANGED
	XP	IR.HNG,1B30	;HUNG DEVICE
	XP	IR.ALL,7777B30
;BITS IN THE DECNET EVENT INTERRUPT REASON WORD
	XP	DR.EVT,1B35	;A DECNET EVENT IS WAITING FOR NETWORK MGMT
;TABLE OF CONDITION CODES THAT CAN CAUSE INTERRUPTS

	DEFINE	COND(COD),<
	XP	C$MIN,C$MIN-1		;DECREMENT MINIMUM CODE
	IFNB	<COD>,<XP COD,C$MIN>	;SET NEW CODE = NEW MIN
>


	XP	C$MIN,0		;INITIAL VALUE OF MOST NEGATIVE CONDITION.


	COND	C$TLE,		;(-1) TIME LIMIT EXCEEDED
	COND	C$TMR,		;(-2) TIMER REQUEST
	COND	C$CTLC,		;(-3) CONTROL-C INTERCEPT
	COND	C$AUUO,		;(-4) ANY MUUO
	COND	C$IUUO,		;(-5) ILLEGAL UUO
	COND	C$IMR,		;(-6) ILL MEM REF
	COND	C$ADCK,		;(-7) ADDRESS CHECK
	COND	C$ARIT,		;(-10) ARITHMETIC EXCEPTION
	COND	C$PLOV,		;(-11) PDL OV
	COND	C$NSP,		;(-12) DECNET NSP. INTERRUPTS
	COND	C$NXM,		;(-13) NON-EX MEM
	COND	C$APRC,		;(-14) APR CLOCK
	COND	C$UEIJ,		;(-15) USER INDUCED ERROR IN JOB
	COND	C$XEIJ,		;(-16) EXTERNAL ERROR IN JOB
	COND	C$KSYS,		;(-17) KSYS WARNING
	COND	C$DSET,		;(-20) DATASET STATUS CHANGE
	COND	C$DATT,		;(-21) DETACH/ATTACH
	COND	C$WAKE,		;(-22) WAKE UUO
	COND	C$ADRB,		;(-23) ADDRESS BREAK
	COND	C$IPC,		;(-24) IPCF (MESSAGE AVAILABLE)
	COND	C$DEVT		;(-25) DECNET EVENT
	COND	C$QUE,		;(-26) ENQ/DEQ (RESOURCE AVAILABLE)
	COND	C$NTC,		;(-27) NETWORK TOPOLOGY CHANGE
	COND	C$JBI,		;(-30) CROSS JOB INTERRUPTS
	COND	C$DTC,		;(-31) DATE/TIME CHANGE
	SUBTTL	FILE (FILOP./OPEN/LOOKUP/ENTER/RENAME) ERROR CODES

;ERROR CODES RETURNED TO USERS ON FILOP./LOOKUP/ENTER/RENAME FAILURES
;ERROR CODE RETURNED IN AC FOR FILOP.; IN RH OF EXTENSION WORD FOR OTHERS.

	XP	FNFERR,0	;FILE NOT FOUND OR 0 FILE NAME
	XP	IPPERR,1	;INCORRECT PROJECT,PROGRAMMER NUMBERS
	XP	PRTERR,2	;PROTECTION FAILURE (OR DIRECTORY FULL ON DTA)
	XP	FBMERR,3	;FILE BEING MODIFIED
	XP	AEFERR,4	;ALREADY EXISTING FILE ON ENTER/RENAME
				; OR DIFFERENT FILE NAME ON UPDATE ENTER
	XP	ISUERR,5	;ILLEGAL SEQUENCING OF UUOS
				; (RENAME WITHOUT LOOKUP OR ENTER; LOOKUP AFTER ENTER)
	XP	TRNERR,6	;TRANSMISSION ERROR OR BAD UFD
	XP	NSFERR,7	;NOT A SAVE FILE (RUN,GETSEG UUO ONLY)
	XP	NECERR,10	;NOT ENOUGH CORE (RUN,GETSEG UUO ONLY)
	XP	DNAERR,11	;DEVICE NOT AVAILABLE
	XP	NSDERR,12	;NO SUCH DEVICE
	XP	ILUERR,13	;ILLEGAL UUO (GETSEG ONLY)
	XP	NRMERR,14	;NO ROOM ON THIS FILE STRUCTURE ON ENTER
				; OR ALLOCATION OR USER QUOTA EXCEEDED
				; (OVERDRAW DOESN'T COUNT ON ENTER)
	XP	WLKERR,15	;WRITE LOCK ERROR - CAN'T WRITE
				; ON FILE STRUCTURE. EITHER HARDWARE
				; OR SOFTWARE WRITE PROTECTED.
	XP	NETERR,16	;NOT ENOUGH MONITOR TABLE SPACE
	XP	PAOERR,17	;PARTIAL ALLOCATION ONLY
	XP	BNFERR,20	;BLOCK NOT FREE ON ALLOCATION WHERE STARTING
				; LOGICAL BLOCK NUMBER OF FILE STRUCTURE SPECIFIED.
	XP	CSDERR,21	;CAN'T SUPERCEDE A DIRECTORY
	XP	DNEERR,22	;CAN'T DELETE A NON-EMPTY DIRECTORY
	XP	SNFERR,23	;SFD NOT FOUND
	XP	SLEERR,24	;SEARCH LIST EMPTY
	XP	LVLERR,25	;NESTING TO TOO DEEP A LEVEL
	XP	NCEERR,26	;NO-CREATE OR READ-ONLY ON FOR ALL STR'S IN LIST
	XP	SNSERR,27	;SEGMENT NOT ON SWAPPING SPACE (GETSEG ONLY)
	XP	FCUERR,30	;FILE CAN'T BE UPDATED
	XP	LOHERR,31	;LOW SEGMENT OVERLAPS HIGH SEGMENT (GETSEG ONLY)
	XP	NLIERR,32	;NOT LOGGED IN (RUN UUO ONLY)
	XP	ENQERR,33	;FILE STILL HAS OUTSTANDING LOCKS ON IT
	XP	BEDERR,34	;BAD EXE FILE DIRECTORY (GETSEG, RUN UUO)
	XP	BEEERR,35	;BAD EXTENSION FOR EXE FILE
				; ".EXE" ISN'T AN EXE FILE,
				;  OR ".ANYTHING ELSE"
				; IS (GETSEG, RUN UUO)
	XP	DTBERR,36	;EXE DIRECTORY IS TOO BIG (GETSEG, RUN UUO)
	XP	ENCERR,37	;TSK - EXCEEDED NETWORK CAPACITY
	XP	TNAERR,40	;TSK - TASK NOT AVAILABLE
	XP	UNNERR,41	;TSK - UNKNOWN NETWORK NODE (WENT DOWN DURING LOOKUP/ENTER)
	XP	SIUERR,42	;RENAME - SFD IS IN USE BY ANOTHER JOB
	XP	NDRERR,43	;DELETE - FILE HAS AN NDR LOCK
	XP	TMYERR,44	;TOO MANY READERS
	XP	SLLERR,45	;RENAME - SFD TO LOWER LEVEL
	XP	CNOERR,46	;CHANNEL NOT OPEN (FILOP.)
	XP	DDUERR,47	;DEVICE DOWN AND UNUSEABLE (DETACHED)
	XP	DRSERR,50	;DEVICE IS RESTRICTED
	XP	DCMERR,51	;DEVICE IS CONTROLLED BY THE MDA
	XP	DAJERR,52	;DEVICE BELONGS TO ANOTHER JOB
	XP	IDMERR,53	;ILLEGAL DATA MODE
	XP	UOBERR,54	;UNDEFINED/UNKNOWN OPEN BITS SET
	XP	DUMERR,55	;DEVICE IN USE ON MPX CHANNEL
	XP	NPCERR,56	;NO (NOT ENOUGH) PER PROCESS SPACE FOR
				; THE EXTENDED I/O CHANNEL TABLE
	XP	NFCERR,57	;NO FREE CHANNELS AVAILABLE
	XP	UFFERR,60	;UNKNOWN FILOP. FUNCTION
	XP	CTBERR,61	;CHANNEL NUMBER TOO BIG
	XP	CIFERR,62	;CHANNEL ILLEGAL FOR OPERATION
	XP	ACRERR,63	;ADDRESS CHECK READING ARGUMENTS
	XP	ACSERR,64	;ADDRESS CHECK STORING ANSWER
	XP	NZAERR,65	;NEGATIVE OR ZERO ARGUMENT COUNT
	XP	ATSERR,66	;ARGUMENT BLOCK TOO SHORT
	XP	LBLERR,67	;MAGTAPE LABELING ERROR
	SUBTTL	EXTENDED I/O ERRORS

;CODES RETURNED BY DEVOP. FUNCTION 3
	IOPLE%==1		;PAGE LIMIT EXCEEDED (LPT)
	IOVFE%==2		;VFU FORMAT ERROR (LPT)
	IOLTE%==3		;LABEL TYPE ERROR (MTA)
	IOHLE%==4		;HEADER LABEL ERROR (MTA)
	IOTLE%==5		;TRAILER LABEL ERROR (MTA)
	IOVLE%==6		;VOLUME LABEL ERROR (MTA)
	IODER%==7		;HARD DEVICE ERROR
	IOPAR%==10		;PARITY ERROR
	IOWLE%==11		;WRITE LOCK ERROR
	IOIPO%==12		;ILLEGAL POSITIONING OPERATION (MTA)
	IOBOT%==13		;BEGINING OF TAPE (MTA)
	IOIOP%==14		;ILLEGAL OPERATION (MTA
	IOFNF%==15		;FILE NOT FOUND (MTA)
	IOCAN%==16		;OPR CANCELLED REEL SWITCH (MTA)
	IOTMV%==17		;TOO MANY VOLUMES IN VOLUME-SET (MTA)
	IONND%==20		;NETWORK NODE DOWN
	IOUNC%==21		;UNDEFINED CHARACTER INTERRUPT (LP20)
	IORPE%==22		;RAM PARITY ERROR (LP20)
	IOLRA%==23		;LABELER REQUEST ABORTED BY RESET UUO (MTA)
	IOMAX%==23		;HIGHEST LEGAL EXTENDED ERROR CODE

;BITS RETURNED BY DEVOP. FUNCTION 5
	XP	DV.OFL,1B0	;DEVICE IS OFF-LINE
	XP	DV.VLE,1B34	;VFU LOAD ENABLED
	XP	DV.VFE,1B35	;VFU ERROR
	SUBTTL	JOB BUFFER HEADER

; JOB BUFFER AREA HEADER
	XP	JBFADR,0	;BIT 0=1 IF THIS BUFFER RING HAS NEVER BEEN
				; REFERENCED FROM THE USER'S PROGRAM BY
				; AN INPUT OR OUTPUT COMMAND.
				; BITS 1-17=UNUSED
				; BITS 18-35=CURRENT BUFFER ADDRESS
	XP	JBFPTR,1	;BYTE POINTER TO NEXT BYTE -1
	XP	JBFCTR,2	;POSITIVE ITEM COUNT
	XP	JBFUDX,3	;UDX FOR MSGSER
; JOB BUFFER HEADER
	XP	IOUSE,400000	;1 IF BUFFER IS FULL (OR BEING EMPTIED)
				; 0 IF BUFFER IS EMPTY (OR BEING FILLED)
				; BITS 1-17=BUFFER SIZE
				; BITS 18-35=NEXT BUFFER ADDRESS
	XP	IOIBC,200000	;INHIBIT CLEARING OUTPUT BUFFERS BEFORE
				; GIVING THEM TO THE USER IF .OPIBC WAS
				; SPECIFIED IN THE OPEN STATEMENT FOR THIS CHANNEL
	XP	IONER,700000	;PRESENTLY ONLY USED BY TSK DEVICE. SET MEANS
	XP	IOSIZ,177777	; MASK OF BUFFER SIZE OF THIS BUFFER
				; THE DATA IN THE BUFFER DOES NOT INCLUDE END OF RECORD.

; DEFINITIONS FOR TRANSPOSING EXTRA DATA BIT IN CLOCK QUEUE DATA ITEMS
	XP	CLKEXB,400000	;EXTRA DATA BIT IN LH OF REQUEST WORD
	XP	CLKDB7,100	;DATA BIT 7 OF DATA ITEM RH

	SUBTTL	ARGUMENTS FOR EXTENDED LOOKUP/ENTER/RENAME

;SYMBOLS FOR MAKING PARTS OF WORDS BE A CONSTANT OF ZERO
; SO THAT FUTURE PROGRAMMERS WILL KNOW THAT THAT BYTE MUST BE ZERO.

	XP	ZERO36,0	;36 BITS OF ALWAYS ZERO
	XP	ZERO18,0	;18 BITS (LH OR RH DEPENDING ON WHICH FIELD OF XWD.
	XP	ZERO13,0	;INDIRECT BIT
	XP	ZERO5,0		;5 BITS (USUALLY LH BITS 13 THRU 17, I.E., @ AND INDEX FIELD
			; OF POINTERS WHICH WANT TO BE REFERENCED USING INDIRECTION

	XP	UUNNAM,0
	XP	UUNEXT,1
	XP	UUNATT,2
	XP	UUNPPN,3
	XP	UUXNUM,0
	XP	UUXPPN,1
	XP	UUXNAM,2
	XP	UUXEXT,3
	XP	UUXPRV,4
	XP	UUXSIZ,5
	XP	UUXVER,6
	XP	UUXFUT,7
	XP	UUXEST,10
	XP	UUXALC,11
	XP	UUXPOS,12
	XP	UUXFT1,13
	XP	UUXNCA,14
	XP	UUXLNA,UUXNCA
	XP	UUXMTA,15
	XP	UUXDEV,16
	XP	UUXSTS,17
	XP	UUXELB,20
	XP	UUXEUN,21
	XP	UUXQTF,22
	XP	UUXQTO,23
	XP	UUXQTR,24
	XP	UUXUSD,25
	XP	UUXAUT,26
	XP	UUXNXT,27
	XP	UUXPRD,30
	XP	UUXPCA,31
	XP	UUXUFD,32
	XP	UUXFLR,33
	XP	UUXXRA,34
	XP	UUXTIM,35
	XP	UUXLAD,36
	XP	UUXDED,37
	XP	UUXENX,UUXDED	;LAST "REGULAR VALUE"
	XP	UUXACT,40
	XP	UUXENT,UUXACT	;LAST ARG OR VALUE FOR EXTENDED UUOS
	SUBTTL	MEM PARITY ERROR RECOVERY

;MEM PARITY COMMUNICATION BITS BETWEEN CPUS AND INTERRUPT LEVELS
;THE FOLLOWING BITS ARE DEFINED HERE AND ARE STORED IN LH OF VARIABLE .CPAEF
; AND CONSTANT .CPMPS
	XP	CP.PXX,1B0	;SOME CPU OR CHANNEL REQUESTED A MEMORY SCAN FOR
				; PARITY OR NXM TO BE DONE ON THIS CPU
	XP	CP.PS0,1B1	;CPU0 REQUESTED THIS CPU TO SCAN
	XP	CP.PS1,1B2	;CPU1
	XP	CP.PS2,1B3	;CPU2
	XP	CP.PS3,1B4	;CPU3
	XP	CP.PS4,1B5	;CPU4
	XP	CP.PS5,1B6	;CPU5
	XP	CP.PSX,CP.PS0!CP.PS1!CP.PS2!CP.PS3!CP.PS4!CP.PS5 ;ANY CPU REQ SCAN
	XP	CP.CS0,1B7	;CHANNEL 0 REQUESTED THIS CPU TO SCAN
	XP	CP.CS1,1B8	;CHN 1
	XP	CP.CS2,1B9	;CHN 2
	XP	CP.CS3,1B10	;CHN 3
	XP	CP.CS4,1B11	;CHN 4
	XP	CP.CS5,1B12	;CHN 5
	XP	CP.CS6,1B13	;CHN 6
	XP	CP.CS7,1B14	;CHN 7
	XP	CP.CSX,CP.CS0!CP.CS1!CP.CS2!CP.CS3!CP.CS4!CP.CS5!CP.CS6!CP.CS7  ;ANY CHAN REQ SCAN
	 SUBTTL CPU UP/DOWN BITS
;BITS IN .CPRUN DETERMINING RUNNABILITY STATE OF A CPU
	XP CR.NRN,1B0	;NO RUN (NOT RUNNING), MUST BE THE SIGN BIT
	XP CR.RMV,1B1	;REMOVE(D)
	XP CR.DET,1B2	;DETACH(ED)
	XP CR.SPD,1B3	;SUSPEND(ED)
	XP CR.TSS,1B4	;TAKE A SNAP SHOT/SNAP SHOT FAILED
;THE FOLLOWING DEFINITIONS ARE USED AS LOCAL SYMBOLS
; IN KLSER FOR AR-ARX PARITY ERROR RECOVERY
	TRPTRY==4	;# OF RETRIES BEFORE FAILURES ARE NON-RECOVERABLE
	CCHEMX==3	;# OF HARD CACHE ORIENTED FAILURES TO ALLOW
			; DURING A MONITOR LOAD PERIOD BEFORE TURNING
			; THE CACHE OFF AND TELLING OPERATOR

;LOCAL FLAG WORD DEFINITIONS
	PFCPF0==1B18	;A LOCAL RETRY TEST REFERENCE IS IN PROGRESS
	PFCPF1==1B19	;ERROR IS NON-RECOVERABLE
	PFCPF2==1B20	;ERROR DURING RETRY TEST REFERENCE
	PFCPF3==1B21	;CACHE WAS ENABLED WHEN TRAP OCCURRED
	PFCPF4==1B22	;ERROR OCCURRED DURING CACHE SWEEP TO CORE
	PFCPF5==1B23	;CACHE WAS TURNED OFF (DISABLED) BECAUSE
			; .GT. CCHEMX FAILURES HAVE OCCURED
DMACLR==110000		;LEFT HALF VALUE TO CLEAR ERROR BITS IN
			; DMA20 WITH SBDIAG.

.SBNMC==21		;NUMBER OF MEMORY CONTROLLERS FOR SBDIAG
			; (0-3 ARE MA20 OR MB20, 4 IS DMA20, 5-7 UNUSED, 10-20 ARE MF20)
.SBFNC==2		;NUMBER OF SBDIAG FUNCTIONS (0 AND 1)
SB.CLR==(1B5)		;LEFT-HALF BIT TO CLEAR ERROR FLAGS IN SBDIAG
			; FUNCTION 0
.PMMER==1		;CODE SENT TO TGHA INDICATING SINGLE BIT MOS ERROR
	SUBTTL  CODES FOR DAEMON ERROR REPORTING

;ERROR CODES FOR DAEMON ERROR REPORTING
;PASSED IN LH OF AC RETURNED ON ERRPT. UUO


.ERWHY==1	;RELOAD MONITOR ERROR
.ERMSE==2	;NON-RELOAD MONITOR ERROR
.ERMPE==3	;CPU MEMORY PARITY ERROR
.ERNXM==4	;NON-EXISTENT MEMORY ERROR
.ERCPE==6	;CHANNEL ERROR
.ERDPE==10	;DISK ERROR
.ERDXE==12	;DX20 DEVICE ERROR
.ERSWE==14	;SOFTWARE EVENT OF INTEREST
	.SWEPK==1	;EVENT WAS A POKE
	.SWESN==2	;EVENT WAS A SNOOP.
	.SWETP==3	;EVENT WAS A TRPSET
	.SWERT==4	;EVENT WAS A RTTRAP
	.SWMS1==5	;MISC EVENT 1 (FOR DEBUGGING)
	.SWMS2==6	;MISC EVENT 2 (FOR DEBUGGING)
.ERCSC==15	;CONFIGURATION STATUS CHANGE
	.CSCAT==0	;ATTACH
	.CSCDT==1	;DETATCH
	.CSCXC==2	;EXCHANGE
	.CSCTC==3	;DATE/TIME CHANGE
	.CSCCF==4	;SET CPU OFF-LINE
	.CSCCO==5	;SET CPU ON-LINE
	.CSCNF==6	;NODE OFF-LINE
	.CSCNO==7	;NODE ON-LINE
	.CSCMO==10	;SET MEMORY ON-LINE
	.CSCMF==11	;SET MEMORY OFF-LINE
	.CSCPO==12	;MONITOR (PARITY RECOVERY) SET MEM OFF-LINE
.ERMAG==20	;MAGTAPE ERROR
.ERTAP==21	;TAPSER MAGTAPE ERROR
.ERKLE==30	;KL CPU ERROR INFO FROM FRONT END
.ERMSC==41	;MAGTAPE STATISTICS
.ERTPS==42	;TAPSER MAGTAPE STATISTICS
.ERDSC==45	;DISK STATISTICS (USUALLY FROM A CRASH)
.ERDLE==50	;DL10 HARDWARE ERROR
.ERKIP==51	;KI PARITY/NXM INTERRUPT (7.01)
.ERKLP==52	;KL PARITY/NXM INTERRUPT (7.01)
.ERKSN==54	;KS NXM TRAP (7.01)
.ERKPT==55	;KL/KS PARITY TRAP (7.01)
.ERSNX==56	;NXM MEMORY SCAN (7.01)
.ERSPR==57	;PARITY MEMORY SCAN (7.01)
.ERKDT==61	;KL10 DATA PARITY TRAP
.ERCSB==63	;CPU STATUS BLOCK
.ERDSB==64	;DEVICE STATUS BLOCK
.ERLPT==71	;LPT ERROR
.ERHCC==72	;HARD COPY CONTROLLER ERROR
.ERDTC==100	;DATE/TIME CHANGE
	SUBTTL	WARM RESTART

;WARM RESTART REASON CODES


.WRCES==1	;CLOCK ERROR STOP
.WREPE==2	;EBUS PARITY ERROR
.WRDEX==3	;DEX FAILURE
.WRKAC==4	;KEEP ALIVE CEASED
.WRPTO==5	;PROTOCOL TIMEOUT
.WRFMP==6	;FAST MEMORY PARITY ERROR
.WRCRP==7	;CRAM PARITY ERROR
.WRDRP==10	;DRAM PARITY ERROR


WRSINS==72	;LOCATION OF INSTRUCTION EXECUTED BY RSX20F ON A WARM RESTART
WRSLOC==100	;LOCATION WHERE RSX20F STORES PC AND CODE ON A WARM RESTART
	SUBTTL	BITS IN STATES AND DEBUGF

;SYSTEM STATE WORD (STATE)
;  LH CHANGED ONLY BY ONCE
;  RH CHANGED BY SCHED COMMAND

ST.DSK==1B0			;DISK SYSTEM
ST.SWP==1B1			;SWAPPING SYSTEM
ST.LOG==1B2			;LOGIN
ST.FTT==1B3			;FULL DUPLEX TTY SOFTWARE
ST.PRV==1B4			;PRIVILEGES
ST.TWR==1B5			;DUAL SEGMENT SOFTWARE
ST.CYC==1B6			;50 HERTZ CLOCK
ST.TDS==7B9			;TYPE OF DISK SYSTEM
ST.IND==1B10			;IND. PPNS ON DISK
ST.IMG==1B11			;IMAGE MODE TTYS
ST.DUL==1B12			;DUAL PROCESSOR SYSTEM
ST.MRB==1B13			;MULTIPLE RIBS SUPPORTED
ST.HPT==1B14			;HIGH PRECISION TIME ACCOUNTING (DK10)
ST.EMO==1B15			;EXCLUDE MONITOR OVERHEAD FROM RUN TIMES
ST.RTC==1B16			;REAL TIME CLOCK (DK10)
ST.MBF==1B17			;MONITOR BUILT FOR FOROTS
				; (5.06 AND AFTER, 504B, 505A)
ST.DDL==1B26			;NO AUTO DOWN LINE DC72,DC71,DAS 80 SERIES
ST.NOP==1B27			;NO OPERATOR IN ATTENDANCE
ST.NSP==1B28			;UNSPOOL DEVICES
ST.ASS==1B29			;ASSIGN/INIT DEVICES
ST.NRT==1B32			;NO REMOTE TTY'S
ST.BON==1B33			;BATCH ONLY
ST.NRL==1B34			;NO REMOTE LOGINS
ST.NLG==1B35			;NO LOGINS EXCEPT CTY/OPR

;BITS IN CNFST2

ST%EMR==1B20			;EBOX/MBOX RUNTIME IN EFFECT
ST%XPI==1B19			;EXCLUDE PI TIME IN USER RUNTIME
ST%ITA==1B17			;INTERVAL TIMER AVAILABLE (ON KL10 ONLY)
ST%NCS==1B16			;IF SET, SCHEDULER IS NOT CLASS SYSTEM
				; SCHEDULER.
ST%NER==1B15			;MONITOR SUPPORTS 6.03 ERROR REPORTING
ST%ACV==1B14			;SYSTEM DOES ACCOUNT-STRING VERIFICATION
ST%LSC==1B13			;MONITOR LOW SEGMANT IS CACHED
ST%MDA==1B12			;MOUNTABLE DEVICE ALLOCATOR WILL RUN

ST%END==1B6			;RUNNING AS DECNET ENDNODE

;BITS IN DEBUGGING WORD
DF.SBD==1B0			;SYSTEM BEING DEBUGGED
DF.RDC==1B1			;RELOAD ON DEBUG STOPCD'S
DF.RJE==1B2			;RELOAD ON JOB ERRORS
DF.NAR==1B3			;NO AUTO RELOADS
DF.CP1==1B4			;STOP SYSTEM ON CPU STOPCD ON ANY CPU
DF.DDC==1B5			;DON'T DO CONTINUABLE STOPCD DUMP ON DEBUG STOPCDS
DF.DJE==1B6			;DON'T DO CONTINUABLE STOPCD DUMP ON JOB STOPCDS
DF.DCP==1B7			;DON'T DO CONTINUABLE STOPCD DUMP ON CPU STOPCDS
DF.RQC==1B8			;CALL CRSCPY ON NEXT CLOCK TICK ON BOOT CPU
DF.RQK==1B9			;CALL KDPLDR ON NEXT CLOCK TICK
DF.WFL==1B10			;COPY OUTPUT TO FRCLIN TO SYSTEM CTY
DF.DCC==1B11			;DISABLE NEXT CRSCPY REQUEST
DF.RIP==1B12			;RELOAD IN PROGRESS (RECON. FUNCTION .RCRLD)
IFN STUPID,<
DF.DST==1B16			;Start or end daylight savings.
>;IFN STUPID
ifn stupid,<
DF.RQB==1B17			;Call cuckoo clock at next tick.
>;rather stupid.
DF.BP0==1B18			;CAN ENTER EDDT ON CPU0 USING XCT .C0DDT
DF.BP1==1B19			;CAN ENTER EDDT ON CPU1 USING XCT .C1DDT
DF.BP2==1B20			;CAN ENTER EDDT ON CPU2 USING XCT .C2DDT
DF.BP3==1B21			;CAN ENTER EDDT ON CPU3 USING XCT .C3DDT
DF.BP4==1B22			;CAN ENTER EDDT ON CPU4 USING XCT .C4DDT
DF.BP5==1B23			;CAN ENTER EDDT ON CPU5 USING XCT .C5DDT
DF.BPT==DF.BP0!DF.BP1!DF.BP2!DF.BP3!DF.BP4!DF.BP5 ;MASK OF CPU BPT BITS


	SUBTTL	TAPSER AND IORB BIT DEFINITIONS


;;!=========================================================================!
;;!EX!AY!E!DENSITY! MODE  !STS!FUNCTION !         LINK TO NEXT IORB         !
;;!-------------------------------------------------------------------------!
;;!ER!DE!E!T!B!D!L!W!N!O!R!V!I! *FREE*  !    PTR TO EVA OF COMMAND LIST     !
;;!-------------------------------------------------------------------------!
;;!                               BYTE COUNT                                !
;;!-------------------------------------------------------------------------!
;;!       PTR TO END OF XFR LIST       !         INTERRUPT ROUTINE          !
;;!=========================================================================!
;IORB 4 WORD BLOCK FOR GENERAL TAPSER I/O REQUEST

XP TRBLNK,0		;LINK TO NEXT (RH)
  XP RB.EXC,(1B0)	;SIGN BIT - UNIT EXCEPTION (TRBSTS NON-ZERO)
			;FCN INFO (LH)
  XP RB.AIO,(1B1)	;THIS REQUEST IS ASYNC
  XP RB.PCL,(1B2)	;FROM QUEUED PROTOCOL
  XP RB.PAR,(1B3)	;PARITY THIS REQUEST (1=EVEN)

  XP RB.DNS,4		;DENSITY BYTE SIZE
  XP RB.DNP,^D7		;BYTE POSITION OF DENSITY BYTE
    XP RB.D2,1		;200 BPI
    XP RB.D5,2		;556 BPI
    XP RB.D8,3		;800 BPI
    XP RB.D16,4		;1600 BPI
    XP RB.D62,5		;6250 BPI

  XP RB.MDS,3		;MODE BYTE SIZE
  XP RB.MDP,^D10	;RIGHT MOST BIT OF MODE BYTE
    XP RB.MCD,1		;CORE DUMP (9 TRK)
    XP RB.MBY,2		;BYTE MODE (4 8 BIT BYTES/WD - 9 TRK)
    XP RB.M6B,3		;SIXBIT  (9 TRK SPCL)
    XP RB.M7B,4		;7 BIT MODE ("MARVELOUS ASCII")
    XP RB.M7T,5		;7-TRK CORE DUMP (SIXBIT)

  XP RB.BYS,RB.MDS+RB.DNS+1 ;PARITY/DENSITY/MODE BYTE
  XP RB.BYP,RB.MDP
  XP RB.RQS,2		;REQUEST STATUS BYTE SIZE
  XP RB.RQP,^D12	;RIGHT MOST BIT POSITION OF STATUS
    XP RB.RPN,1		;REQUEST PENDING
    XP RB.ACT,2		;REQUEST ACTIVE
    XP RB.DUN,3		;REQUEST DONE

  XP RB.FNS,5		;FUNCTION BYTE SIZE
  XP RB.FNP,^D17	;RIGHT MOST BIT OF FCN BYTE
    XP RB.FRD,1		;READ FORWARD
    XP RB.FWT,2		;WRITE
    XP RB.FRB,3		;READ BACKWARDS
    XP RB.FSR,4		;SPACE FORWARD RECORD
    XP RB.FBR,5		;SPACE BACKWARD RECORD
    XP RB.FSF,6		;SPACE FORWARD FILE
    XP RB.FBF,7		;SPACE BACKWARD FILE
    XP RB.FLG,10	;WRITE LONG GAP (3")
    XP RB.FSE,11	;DATA SECURITY ERASE
    XP RB.FRW,12	;REWIND
    XP RB.FRU,13	;REWIND AND UNLOAD
    XP RB.FTM,14	;WRITE TAPE MARK
    XP RB.FYB,15	;WAIT FOR KONTROLLER IDLE (YELLOW BALL)
    XP RB.FCR,16	;PERFORM CORRECTION READ
    XP RB.FRL,17	;READ AT LOW THRESHOLD
XP TRBSTS,1		;TERMINATION STATUS (LH)
  XP RB.SER,(1B0)	;NON REC ERROR
  XP RB.SDE,(1B1)	;0 = CHN/DEV ERR, 1 = DATA ERR
  XP RB.SED,(1B2)	;SOME ERROR ENCOUNTERED
  XP RB.STM,(1B3)	;TAPE MARK ENCOUNTERED
  XP RB.SBT,(1B4)	;HIT BOT
  XP RB.SET,(1B5)	;HIT EOT
  XP RB.STL,(1B6)	;RECORD TOO LONG (READ)
  XP RB.SLK,(1B7)	;WRITE ATTEMPTED ON W.L. TAPE
  XP RB.SNM,(1B8)	;TAPE DIDN'T MOVE
  XP RB.SOL,(1B9)	;UNIT OFF LINE
  XP RB.SRW,(1B10)	;UNIT REWINDING
  XP RB.SRE,(1B11)	;RECOVERED ERROR (OLD INFO STILL VALID)
  XP RB.SIL,(1B12)	;ILLEGAL OP
  XP RB.SEN,(1B13)	;ERROR ON NEXT RECORD (THIS ONE OK)
  XP RB.SMO,(1B14)	;MONITOR-DIRECTED OFF-LINE
  XP RB.SAP,(1B15)	;TAPE ALREADY REPOSITIONED FOR ERROR RECIVERY

XP TRBXCW,1		;PNTR TO EVA OF COMMAND LIST (RH)

XP TRBRCT,2		;BYTE COUNT OF XFER IF DATA READ

XP TRBIVA,3		;(RH) ADDRS OF INTERUPT ROUTINE
XP TRBEXL,3		;(LH) PNTR TO END OF XFER LIST
	SUBTTL	MTAPE AND TAPOP. DEFINITIONS

XP MT.DEC,100		;DEC COMPATIBLE
XP MT.IND,101		;WORLD COMPATIBLE
XP MT.STL,200		;SET TO LOW THRESHOLD (TM10 ONLY)

XP MT.MAX,17		;MAXIMUM MTAPE OPERATION CODE

XP MT.WAT,0		;WAIT
XP MT.REW,1		;REWIND
XP MT.WTM,3		;WRITE TAPE MARK
XP MT.FSR,6		;FORWARD SKIP RECORD
XP MT.BSR,7		;BACK SKIP RECORD
XP MT.SET,10		;SKIP TO LEOT
XP MT.UNL,11		;REWIND & UNLOAD
XP MT.WLG,13		;WRITE LONG GAP (3" BLANK TAPE)
XP MT.FSF,16		;FORWARD SKIP FILE
XP MT.BSF,17		;BACK SPACE FILE

;KONTROLLER TYPE CODES
XP K.TMA,0		;TM10A
XP K.TMB,1		;TM10B
XP K.TC1,2		;TC10C
XP K.TX1,3		;TX01
XP K.TM2,4		;TM02
XP K.TM2H,5		;TM02 ON RH11
XP K.DX2,6		;DX20
XP K.T78,7		;TM78
XP K.MAX,7		;MAXIMUM KONTROLLER TYPE

;TD2KON TUBIEP/TUBFEP BLOCK SIZES
XP .TD2MC,25		;# WORDS CONTAINING MISC VALUES
XP .TD2ES,24		;# WORDS CONTAINING DX20 EXTENDED STATUS REGISTERS
XP .TD2MR,27		;# WORDS CONTAINING MASSBUS REGISTERS
SUBTTL TAPE LABEL DEFINITIONS

IFN FTTLAB,<
;LABEL TYPE CODES

XP LT.BLP,0		;BYPASS LABEL PROCESSING
XP LT.SL,1		;STANDARD DEC (ANSI) LABELS
XP LT.SUL,2		;STANDARD WITH USER LABELS
XP LT.IL,3		;IBM STANDARD LABELS
XP LT.IUL,4		;IBM STANDARD WITH USER LABELS
XP LT.LTM,5		;LEADING TAPE MARK
XP LT.NSL,6		;NON-STANDARD LABELS
XP LT.NL,7		;NO LABELS
XP LT.CBA,10		;DEC COBOL ASCII LABELS
XP LT.CBS,11		;DEC COBOL SIXBIT LABELS
XP LT.NLV,12		;NO-LABELS, USER SEES EOT
XP LT.MAX,12		;MAXIMUM LABEL TYPE DEFINED

;REASON CODES FOR LABEL PROCESSING

XP LR.FIN,1		;FIRST INPUT
XP LR.FOU,2		;FIRST OUTPUT
XP LR.POS,3		;POSITIONING REQUEST
XP LR.TM,4		;TAPE MARK SEEN
XP LR.EOT,5		;EOT SEEN
XP LR.CLI,6		;CLOSE INPUT
XP LR.CLO,7		;CLOSE OUTPUT
XP LR.EOV,10		;FORCE END OF VOLUME
XP LR.URQ,11		;USER REQUEST SERVICE
XP LR.ABO,12		;ABORT OPERATION (RELEASE DONE)

;ERROR CODES RETURNED BY LABEL PROCESS

XP LE.CON,1		;DIDN'T DO POSITIONING REQUEST
XP LE.EOF,2		;RETURN END OF FILE
XP LE.LTE,3		;LABEL TYPE ERROR
XP LE.HDE,4		;HEADER LABEL ERROR
XP LE.TRE,5		;TRAILER LABEL ERROR
XP LE.VLE,6		;VOLUME LABEL ERROR
XP LE.DER,7		;DEVICE ERROR
XP LE.DTE,10		;DATA ERROR
XP LE.WLK,11		;WRITE LOCKED
XP LE.PSE,12		;POSITIONING ERROR
XP LE.BOT,13		;BEGINNING OF TAPE
XP LE.IOP,14		;ILLEGAL I/O OPERATION
XP LE.FNF,15		;FILE NOT FOUND
XP LE.CAN,16		;OPR CANCELLED VOLUME SWITCH
XP LE.TMV,17		;TOO MANY VOLUMES IN VOLUME SET
XP LE.LRA,23		;LABELER REQUEST ABORTED BY RESET UUO

>
SUBTTL EVENT WAIT CODE DEFINITIONS

;TYPES OF EVENTS

DEFINE EWCODE,<
	X	EV.TKW,SJ	;TAPE KONTROLLER WAIT
	X	EV.REW,SJ	;REWIND WAIT
	X	EV.LBL,SJ	;LABEL PROCESSING WAIT
	X	EV.NET,SJ	;NETWORK DEVICE WAIT
	X	EV.NTC,DJ	;NETWORK TERMINAL CONNECT WAIT
	X	EV.STC,DJ	;NETWORK STATION CONTROL WAIT
	X	EV.DTE,SJ	;DTE IO WAIT
	X	EV.KDP,SJ	;KDP IO WAIT
	X	EV.IPC,SJ	;IPCF SYSTEM PROCESS RECEIVE WAIT
	X	EV.FEI,SJ	;FRONT END DEVICE INPUT WAIT
	X	EV.FEO,SJ	;FRONT END DEVICE OUTPUT WAIT
	X	EV.D60,DJ	;DN60 DEVICE WAIT (WAITING FOR THE PDP11)
	X	EV.DCN,SJ	;DECNET CONNECT/IO WAIT.
	X	EV.DMR,SJ	;DMR IO WAIT
    IFN FTHISTORY,<
	X	EV.CMD,SJ	;Command editor wait.
    >
>	;END DEFINE EWCODE
DEFINE X(SYM,CNTLC),<
	XP	SYM,XX
	XX==XX+1
	IFG	<XX>-<-1_<-<^D36-ESLPSZ>>>,<PRINTX	?TOO MANY EVENT WAIT STATE CODES.>
>	;END DEFINE X

;NOW GENERATE THE EVENT WAIT CODES
;
	XX==1			;START EVENT WAIT CODES AT 1
	EWCODE

SUBTTL CODES SENT TO THE FILE DAEMON

IFN FTFDAE,<
XP .FDCAC,1		;CHECK IF ACCESS IS ALLOWED
XP .FDCLI,2		;CLOSE INPUT
XP .FDCLO,3		;CLOSE OUTPUT
XP .FDXIT,4		;PROGRAM EXECUTION TERMINATED
XP .FDCPA,5		;CHECK IF PROGRAM ACCESS IS ALLOWED
XP .FDCAD,6		;CHECK DIRECTORY ACCESS ALLOWED
>

SUBTTL BITS RETURNED TO THE MONITOR BY THE FILE DAEMON

IFN FTFDAE,<
XP FD.CAA,1B0		;CALL THE FILE DAEMON ON EVERY ACCESS TO THE FILE
XP FD.COC,1B1		;CALL THE FILE DAEMON WHEN THE FILE IS CLOSED
XP FD.COX,1B2		;CALL THE FILE DAEMON WHEN PROGRAM EXECUTION TERMINATES
XP FD.SCP,1B3		;FILE DAEMON SPECIFIED CREATE PROTECTION
>

SUBTTL BITS IN THE RH OF .CPSBR

XP SR.CSB,1B35		;CPU STATUS BLOCK READ AT SOME POINT ON THIS CPU
XP SR.DSB,1B34		;DEVICE STATUS BLOCK READ AT SOME POINT ON THIS CPU
XP SR.STS,1B33		;MACHINE STATUS SAVED ON THIS CPU.  USED TO AVOID SAVING
			; STATUS ON SECOND AND SUBSEQUENT 407 STARTS
XP SR.DIE,1B32		;LAST STOPCD WAS CPU.  OPERATOR MUST RESTART PROCESSOR
			;MANUALY
XP SR.ACL,1B31		;THIS CPU IS LOOPING IN THE AC'S. DON'T
			;SAVE THIS AC BLOCK IN SYSTOP
XP SR.LBH,1B30		;LOAD BOOT (OR GO TO MONBTS) ON THIS CPU
			;REGARDLESS OF WHO IS THE BOOT CPU
	SUBTTL	SAVE-FILE FORMAT DEFINITIONS

IFN FTEXE,<

;DEFINITIONS OF BLOCK TYPES IN SAVE-FILE DIRECTORY
SV.END==1777		;END BLOCK CODE
SV.DIR==1776		;DIRECTORY BLOCK CODE

;LENGTHS OF VARIOUS END BLOCKS
LN.END==1		;END BLOCK IS ONLY 1 WORD LONG


;BITS IN THE LEFT HALF OF 1ST WORD OF EACH DIRECTORY ENTRY
SV%HIS==(1B0)		;THIS PAGE IS PART OF THE HIGH SEGMENT
SV%SHR==(1B1)		;THIS PAGE IS SHARABLE
SV%WRT==(1B2)		;THIS PAGE IS WRITABLE
SV%CON==(1B3)		;THIS PAGE IS CONCEALED
SV%SYM==(1B4)		;THIS PAGE IS PART OF SYMBOL TABLE (NOT IMPLEMENTED)
SV%ABZ==(1B5)		;THIS PAGE IS ALLOCATED BUT ZERO (INTERNAL FLAG)

;MISCELLANEOUS DEFINITIONS
NTRYSZ==2		;SIZE OF EACH DIRECTORY ENTRY
DIRSIZ==6		;SIZE OF THE DIRECTORY ON NON-VM SYSTEMS
EXESIZ==^D512		;SIZE OF EXE FILE PAGES
PXWLSH==11		;PAGES TO WORDS
WXPLSH==-PXWLSH		;WORDS TO PAGES
PAGNUM==777000		;MASK FOR CHECKING WHETHER DIRECTORY IS IN PAGE ZERO (NON-VM)


>;END OF IFN FTEXE CONDITIONAL
	SUBTTL	EXEC DATA VECTOR DEFINITIONS


; THESE QUANTITIES ARE POINTED TO BY .JBEDV IN JOBDAT

.EDCNT==0	;'EDV',,COUNT (INCLUDES THIS WORD)
.EDHSB==1	;POINTER TO HIDDEN SYMBOL MAP SWITCHING BLOCK
.EDSYM==2	;.JBSYM IN SYMBOL SPACE
.EDUSY==3	;.JBUSY IN SYMBOL SPACE
.EDHSF==4	;POINTER TO SYMBOLS HIDDEN FLAG WORD
.EDDAT==5	;CPU/PAGING/HARDWARE DATA
   ED.KLP==1B0	   ;KL PAGING
   ED.XKL==1B1	   ;EXTENDED KL10
   ED.CPU==0,,-1   ;CPU TYPE CODE (KI10=3, KL10=4, KS10=5, ETC.)
.EDEPT==6	;PHYSICAL ADDRESS OF THE BOOT CPU'S EPT
.EDSPT==7	;PHYSICAL ADDRESS OF THE BOOT CPU'S SPT
.EDCST==10	;PHYSICAL ADDRESS OF THE BOOT CPU'S CST
.EDLEN==11	;LENGTH THE EXEC DATA VECTOR
	SUBTTL	BITS IN GETTAB TABLE (NUMTAB)

;BITS 0-8 = MAXIMUM SIZE OF TABLE IF REGULAR TABLE
XP	GT.COD,7B11	;TYPE OF GETTAB TABLE
	XP GT.UND,0	;UNDEFINED IN THIS MONITOR
	XP GT.ITM,1	;INDEX BY ITEM TYPE
	XP GT.JOB,2	;INDEX BY JOB NUMBER
	XP GT.SEG,3	;INDEX BY JOB OR SEGMENT
	XP GT.PDB,4	;INDEX BY JOB DATA IS IN PDB
	XP GT.RNG,5	;INDEX BY NEGATIVE AND POSITIVE OFFSETS
	SUBTTL	TELETYPE PARAMETERS

	XP	STTYBF,20	;SIZE OF TTY BUFFER
	XP	STTYB1,STTYBF+1	;LENGTH+1
IFN FTLINK,<			;[link]

;[link] BIT DEFINITIONS FOR LINK WORD IN TTY LDB.

;[link] PLACED IN S FOR EASE OF USE BY SCNSER, COMCON AND LNKSER. THE ACTUAL
;[link]  WORDS WHERE THE BITS ARE USED ARE DEFINED IN THE PROTOTYPE LDB IN
;[link]  SCNSER.

;[link] BITS IN LH OF LDBLNK(U):

XP	LNKXMT,400000	;[link] TTY IS ABOUT TO TRANSMIT BECAUSE OF LINK
XP	LNKACV,200000	;[link] TTY HAS ACTIVE LINKS
XP	LNKREF,100000	;[link] TTY IS REFUSING FURTHER LINKS
XP	LNKECH,40	;[link] SENDING ECHO CHAR (SET BY SCNSER FOR LNKSER)
XP	LNKFLP,20	;[link] SENDING FILL POINTER (SET BY SCNSER FOR LNKSER)
XP	LNKOPD,10	;[link] ON CLOCK TICK, START OUTPUT IF NOT IN PROGRESS

> ;[link] END IFN FTLINK
	SUBTTL FEK FRONT END KONTROLLER DATA BLOCKS

;MACRO FOR DEFINING THE FIELDS OF THE VARIOUS NETWORK DATA BLOCKS

DEFINE	X(NAME,SIZE)<			;;DEFINE A MACRO TO MAKE THINGS EASY
  IFNB <NAME>,<NAME==:%%%OFF>		;;DEFINE THE SYMBOL
  IFNB <SIZE>,<%%%OFF==%%%OFF+SIZE>	;;INCREMENT THE SIZE
  IFB  <SIZE>,<%%%OFF==%%%OFF+1>	;;  BY ONE IF "SIZE" NOT SPECIFIED
>

;FEK BLOCK OFFSETS

	%%%OFF==0		;INITIALIZE FOR X MACRO

	X	FEKBLK		;XWD FLAGS,LINK TO NEXT FEK
	X	FEKDSP		;"JRST DSP(T1)" DSP == FEK'S DISPATCH VECTOR.
	X	FEKNNM		;NUMBER OF NODE ON OTHER SIDE OF FEK (IF UP)
	X	FEKHTM		;HUNG TIMER
	X	FEKUNI		;XWD CPU,"FEK SPECIFIC UNIT ID"

	X	FEKIAD		;HEAD OF LIST OF PCBS FOR FEK TO FILL
	X	FEKBSI		;FLAG FOR THE FEK TO INTERLOCK ITSELF

	X	FEKOAD		;HEAD OF LIST OF OUTPUT PCBS
	X	FEKOCT		;LENGTH OF "FEKOAD"
	X	FEKODN		;"SENT" PCBS GO HERE FOR NETSER
	X	FEKBSO		;INTERLOCK FOR FEK TO USE
	X	FEKBJN		;XWD TIMER,BOOT-JOB-NUMBER (FOR STC)
	X	FEKICT		;XWD TIMER,STC-MSG (FOR INCOMING STC)

IFN FTKL10,<			;TWO DTE-20 SPECIFIC LOCATIONS
	X	FEKAKC		;COUNT OF QPR-ACK'S TO SEND
	X	FEKIBP		;"INPUT" BYTE POINTER FOR DTE-20 FEK'S
>
	X	FEKLEN,0	;LENGTH OF A FEK


;BITS IN LEFT HALF OF FEKBLK

	XP	FK.ONL,(1B0)	;ONLINE SAME AS NOT DOWN
				;MUST BE THE SIGN BIT
	XP	FK.NID,(1B1)	;NODE ID HAS BEEN SENT
	XP	FK.STI,(1B2)	;THIS FEK WANTS INPUT STARTED NEXT TICK
	XP	FK.STO,(1B3)	;THIS FEK WANTS OUTPUT STARTED NEXT TICK
	XP	FK.NUL,(1B4)	;THIS IS A NULL (LOCAL LOOP BACK) FEK
	XP	FK.IAC,(1B5)	;INPUT ACTIVE (USED BY D85INT)
	XP	FK.OAC,(1B6)	;OUTPUT ACTIVE (")
	XP	FK.CPD,(1B7)	;CPU WENT DOWN. (CLEAN UP IN 1/SEC CODE)
	XP	FK.MAI,(1B8)	;THIS FEK IS IN DDCMP MAINT MODE
	XP	FK.LUB,FK.MAI	;LOWEST USED BIT.

;OFFSETS INTO EACH FEK'S DISPATCH VECTOR. (NETSER CALLING THE FEK)

	XP	FF.ONC,0	;ONCE-ONLY CODE
	XP	FF.SEC,1	;ONCE/SECOND CODE
	XP	FF.RDD,2	;ENTRY TO POST A READ REQUEST
	XP	FF.WRT,3	;ENTRY TO POST A WRITE REQUEST
	XP	FF.CRS,4	;ENTRY TO REQUEST A FEK TO CRASH
	XP	FF.DWN,5	;ENTRY CALLED WHEN FE DIES
	XP	FF.UP,6		;ENTRY CALLED WHEN FE COMES UP
	XP	FF.STC,7	;ENTRY CALLED WITH "U" := STC TO SEND
	XP	FF.CPS,10	;ENTRY CALLED WHEN CPU IS GOING TO SLEEP
	XP	FF.CPW,11	;ENTRY CALLED WHEN CUP WAKES UP

;OFFSETS INTO FEKINT (FEKS CALLING NETSER)

	XP	FI.RDD,0	;READ DONE. PCB AT FEKIAD HAS BEEN FILLED
	XP	FI.ODN,1	;OUTPUT DONE, PCB AT FEKODN HAS BEEN SENT
	XP	FI.STC,2	;INCOMING STATION CONTROL MSG (STC IN "U")
	XP	FI.DWN,3	;THIS FEK JUST CRASHED
;	XP	FI.DAE,4	;DAEMON ERROR REPORT?

	SUBTTL	DEFINITIONS FOR SYNC LINE TYPES (INCLUDING DTE)

;THESE SYMBOLS ARE USED IN COMNET.MAC TO SET UP THE LINE'S "USER"
;TABLES FOR ANY NETWORK LINE.

	XP	DD.NOB,0	;NOBODY (DEFAULT)
	XP	DD.ANF,1	;ANF-10
	XP	DD.DEC,2	;DECNET-10
	XP	DD.PRO,3	;PROGRAM MODE (FOR KDP: OR DTE:)
	XP	DD.IBM,4	;IBM COMM
		DD.MAX==DD.IBM	;MAX USER TYPE
IFN FTCIMP,<
	XP	DD.IP,5		;IP packets.
		DD.MAX==DD.IP	;New max user type.
>;FTCIMP
	SUBTTL	DEFINITIONS FOR DC44, DC75, DC76, DAS78, DN60 AND DAS85
;MACRO .DLTYP GENERATES SYMBOL TP.DL'PORT FOR PORT PORT
;WHERE TP.DL'PORT REPRESENTS THE SYSTEM FOR WHICH THE PORT
;WAS MONGENED. IN ADDITION IT GENERATES WARNINGS TO NOTIFY
;FOR INADVERTENTLY CREATED CONFLICTS. MOREOVER XXICHN IS REDEFINED
;IF NON DAS78/DN60 PORTS ARE PRESENT TO EQUAL SCNCHN

DEFINE	.DLTYP(PORT,ZZZ,CH),<
	IFNDEF	M0'PORT'D85,<M0'PORT'D85==0>	;;DC75 FOR THIS PORT
	IFNDEF	M0'PORT'D78,<M0'PORT'D60==0>	;;DAS78 FOR THIS PORT
	IFNDEF	M0'PORT'D60,<M0'PORT'D60==0>	;;DN60 FOR THIS PORT
	IFNDEF	TYPNU'PORT,<TYPNU'PORT==0>	;;DC44 FOR THIS PORT
	IFNDEF	M.D7'PORT'N,<M.D7'PORT'N==0>	;;DC76 FOR THIS PORT
ZZZ=TYPNU'PORT+M.D7'PORT'N+M0'PORT'D85+M0'PORT'D78 ;;DC44 DC76 DC75 & DAS78
IFN CH,< IFN	ZZZ,<XXICHN==SCNCHN>>	;;GET OPTIONS ON THE SAME CHANNEL
TP.DL'PORT==0			;;ASSUME NO USE FOR THIS PORT
ZZZ==0
IFN TYPNU'PORT,<ZZZ==ZZZ+1>
IFE TYPNU'PORT,<IFN M.D7'PORT'N,<ZZZ==ZZZ+1>>
IFN M0'PORT'D85,<ZZZ==ZZZ+1>
IFN M0'PORT'D78,<ZZZ==ZZZ+1>
IFN M0'PORT'D60,<ZZZ==ZZZ+1>
IFG ZZZ,<
ZZZ=ZZZ-1
IFG ZZZ,<
	IF1,	<
	PRINTX	WARNING: DL10 PDP-11 NUMBER PORT HAS MORE THAN ONE OPTION
	PRINTX	FROM THE SET: DC44, DC76, DAS85 (OR DC75), DAS78, AND DN60.
	> ;;END OF IF1
> ;END OF IFG ZZZ
IFN M0'PORT'D85,<
	TP.DL'PORT==TP.D85
	DLX.75==DLX.75+1
> ;;END IFN M0'PORT'D85
IFE TP.DL'PORT,<
	IFN	TYPNU'PORT,<TP.DL'PORT==TP.DL'PORT+TP.D44
	DLX.44=DLX.44+1>
	IFN	M.D7'PORT'N,<TP.DL'PORT==TP.DL'PORT+TP.D76
DLX.76=DLX.76+1>
> ;END OF IFE TP.DL'PORT
IFE TP.DL'PORT,<
	IFN FTDAS78,<
		IFN M0'PORT'D78,<
			TP.DL'PORT=TP.D78
			DLX.78==DLX.78+1
		> ;;END IFN M0'PORT'D78
	> ;; END IFN FTDAS78
> ;;END IFE TP.DL'PORT
IFE TP.DL'PORT,<
	IFN FTDN60,<
		IFN	M0'PORT'D60,<
			TP.DL'PORT==TP.D60
			DLX.60==DLX.60+1
		> ;;END OF IFN M.'PORT'D60
	> ;;END IFN FTDN60
> ;END OF IFE TP.DL'PORT
IFN TP.DL'PORT,<PDP11N=PDP11N+1>
> ;END OF IFG ZZZ
>	;END OF .DLTYP

;MACRO DLX.CK WHEN CALLED WILL GENERATE THE FOLLOWING SET OF SYMBOLS
;DLX.44 = NUMBER OF 44 OPTIONS ON DL10
;DLX.60 = NUMBER OF DN60 OPTIONS ON DL10
;DLX.75 = NUMBER OF 75 OPTIONS ON DL10
;DLX.76 = NUMBER OF 76 OPTIONS ON DL10
;DLX.78 = NUMBER OF 78 OPTIONS ON DL10
;MOREOVER A CONSISTENCY CHECK OF THE PORT USAGE WILL BE DONE
;FOR EACH PORT A SYMBOL "P.DL'PORT WILL BE GENERATED ITS
;VALUE DEFINES THE OPTION ON THIS PORT.

	DEFINE	DLX.CK(CH),<

	XLIST

DLX.44=0		;;ASSUME NOTHING THERE
DLX.60=0
DLX.75=0
DLX.76=0
DLX.78=0
PDP11N=0
ZZ=0
	REPEAT	10,<
	.DLTYP(\ZZ,ZZZ,CH)
ZZ=ZZ+1
>
DL10XI==PDP11N		;;DL10XI IS NUMBER OF PDP11'S ON DL10'S
	LIST
	XP	DLX.44,DLX.44	;;SO VALUE IS LISTED
	XP	DLX.60,DLX.60	;;VALUES DEFINED BY .DLTYP
	XP	DLX.75,DLX.75	;;AND SHOWS UP IN GLOBS
	XP	DLX.76,DLX.76
	XP	DLX.78,DLX.78
>	;END OF DLX.CK
DEFINE	MAP76(CPU,PORT),<

;;THIS MACRO IS USED IS SEVERAL PLACES. THEY ARE:
;;
;;	1. COMMON.MAC CALLS IT TO BUILD THE REAL DL10 MEMORY
;;	    MAP.
;;
;;	2. TEST76 CALLS IT TO BUILD A DL10 MAP TO RUN THE DC76
;;	    WITHOUT THE HELP OF THE MONITOR.
;;
;;	3. IT IS CALLED BY THE PDP-11 CODE TO BUILD THE MATCHING
;;	    SYMBOL DEFINITIONS.
;;
;;	4. IT IS CALLED BY D76INT TO BUILD SYMBOL DEFS.
;;
;;MAP76 HAS 1 ARGUMENT WHICH IS THE DL10 PORT NUMBER IT WILL BE
;; USED WITH. THIS IS USED IS BUILDING SOME OF THE SYMBOLS
;;
;;
;;THIS MACRO CONTAINS ONLY MACRO CALLS. THE MACROS IT
;; CALLS ARE:
;;
;;	WORD	SYM,	;;DEFINE SYM AS A 1 WORD QUANTITY. SYM
;;			;; SHOULD BE NO MORE THAN 3 LETTERS. THE
;;			;; WORD IS SET TO ZERO IN THE MAP.
;;
;;	DATA	SYM,THING
;;			;;SAME AS WORD EXECPT THING IS PLACED IN
;;			;; THE WORD.
;;
;;	PNTR	SYM,PLACE
;;			;;SAME AS WORD EXCEPT A 16 BIT READ ONLY
;;			;; INDIRECT POINTER IS PLACED IN THE MAP. THE
;;			;; POINTER POINTS TO PLACE.
;;
;;	BLK	SYM,SIZE
;;			;;SAME AS WORD EXCEPT IT LEAVES SIZE WORD
;;
	..P==PORT	;;USED SO MACRO DOES NOT PRODUCE AN 'A' ERROR
			;; ON IFNDEF THING

IFE FTKLP,<
	DATA	KII,<JSR D70'PORT'KI>;;KI10 AUTOMATIC PRIORITY
>
IFN FTKLP,<
	DATA	KII,<XPCW D70'PORT'KI>;;EXETNDED KL10 VECTORS HERE
>
					;; INTERUPT SYSTEM EXECUTES
					;; THIS INSTRUCTION.
	WORD	ESA,	;;ELEVEN STARTING ADDRESS. USED TO FORCE
			;; THE ELEVEN TO START AT A GIVEN PLACE.

	WORD	WNU,	;;WORD NOT USED


	WORD	NAM,	;;6-BIT DL10 BYTE POINTER TO NAME OF PROGRAM
			;; IN THE ELEVEN. TELL DC75 FROM DC76.
	DATA	EPN,<..P>;;ELEVEN PORT NUMBER. THIS IS USED BY THE
			;; 10 TO MAKE CONI/CONO INSTRUCTIONS FOR
			;; THE DL10. IT IS USED TO HELP DEBUG THE -11
	WORD	OK,	;;FLAG SET TO ZERO BY THE DC76 AND COUNTED
			;; UP ONCE A SECOND BY THE -10. IF THE FLAG
			;; IS .GE. 2 THE DC76 IS DEAD.

	WORD	HLT,	;;WHEN THE DC76 HALTS IT PLACES THE HALT
			;; ADDRESS HERE.

	WORD	DWN,	;;A FLAG WHICH INDICATES THE UPNESS OF THE -11
			;; -1 DOWN , NO MESSAGES
			;; 0  DOWN , COMPLAIN ONCE A MIN
			;; +1 UP

	PNTR	UPT,.C0UPT,	;;NUMBER IN THE TEN WHICH COUNTS UP
				;; ONCE A JIFFY.
	IFDEF	M'CPU'PORT'D85,<
	IFE	M'CPU'PORT'D85+M'CPU'PORT'D60,<  ;;NOT AN 85 OR DN60
	WORD	TTP,	;;POINTER TO LAST ITEM PLACED IN THE TO -10
			;; QUEUE.

	WORD	TTG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -10
			;; QUEUE

	WORD	TEP,	;;POINTER TO LAST ITEM PLACED IN THE TO -11
			;; QUEUE

	WORD	TEG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -11
			;; QUEUE

	DATA	EBS,<TEBS'PORT'> ;;SIZE OF TO ELEVEN QUEUE

	DATA	TBS,<TTBS'PORT'> ;;SIZE OF TO TEN QUEUE

	DATA	LTO,<D7'PORT'OFS> ;;THE NUMBER ONE ADDS TO DC76 LINE
			;; ZERO TO GET A LINTAB INDEX

	DATA	DTO,<D7'PORT'DSO> ;;OFFSET TO DSCTAB
	PNTR	STS,STATES,	;;WORD WHICH HAS THE BIT WHICH SAYS
				;; IF WE SHOULD ANSWER DATASETS

	PNTR	FRN,TTFREN,	;;NUMBER OF FREE TTY CHUNKS. USED
				;; TO ALLOW THE DC76 TO COOL IT
				;; INSTEAD OF GETTING A DING.

	DATA	AOM,<M7'PORT'KII>;;ADDRESS OF THE FIRST WORD OF THE
				;; MAP. USED SO THAT THE -11 CAN UNDERSTAND
				;; TTA AND TEA.

	DATA	TEA,<M7'PORT'TEQ>;;ADDRESS OF THE TO -11 QUEUE
				;; USED ONLY BY D76INT

	DATA	TTA,<M7'PORT'TTQ>;;ADDRESS OF THE TO -10 QUEUE

	DATA	MAX,<M.D7'PORT'N+TYPNU'PORT> ;;TOTAL NUMBEER OF FRONT END LINES
	DATA	NTT,<M.D7'PORT'N> ;;NUMBER OF LINES ON THIS DC76
	DATA	PIO,<M7'PORT'NIP>	;;AREA OF NON IMMEDIATE BYTE POINTERS
;;ALL BLK MACROS SHOULD COME AT THE END OF THE MAP SO THAT OFFSETS
;; CAN BE COMPUTED WITHOUT KNOWING ANY MONGEN SYMBOLS.

	BLK	TTQ,<TTBS'PORT>,;;THE TO TEN QUEUE

	BLK	TEQ,<TEBS'PORT>,;;THE TO ELEVEN QUEUE

	BLK	NIP,<TYPNU'PORT>	;;POOL OF NONIMMEDIATE BYTE POINTERS
>	;;END OF IFE M'CPU'PORT'D85+M'CPU'PORT'D60
	IFN	M'CPU'PORT'D85+M'CPU'PORT'D60,<  ;;I.E., 85 OR DN60 MAP
	WORD	SWD,	;GLOBAL STATUS WORD
			;1=DEPOSIT
			;2=EXAMINE
			;4=ADDRESS IS GARBAGE
			;10=HOLD EVERYTHING
	WORD	ADR,	;EXAMINE/DEPOSIT ADDRESS
	WORD	DAT,	;EXAMINE/DEPOSIT DATA
	WORD	REC,	;MAXIMUM RECORD LENGTH
	WORD	MOD,	;VERSION OF SOFTWARE
	WORD	TA,	;10 ALIVE IF .LE. 1 (11 INCREMENTS, 10 SETS TO -1)
	WORD	TS,	;10 STATUS (0=INITIAL,1=STARTED INIT,-1=RUNNING)
	WORD	ES,	;11 STATUS (0=INITIAL,1=STARTED INIT,-1=RUNNING)
IFN M'CPU'PORT'D60,< ;;THIS IS A DN60 PORT
	XP	D60WVR,3	;DN60 WINDOW VERSON
	WORD	MXL,	;MAX LINES ON THIS CPU
	WORD	LT1,	;FIRST LIGHTS WORD
	WORD	LT2,	;SECOND LIGHTS WORD
	WORD	OPE,	;11-OPERATION:
			; 0 = IDLE
			; 1 = REQUEST TO READ DATA
			; 2 = REQUEST TO WRITE DATA
			; 3 = REQUEST TO READ DEVICE STATUS
			; 4 = REQUEST TO WRITE DEVICE STATUS
			; 5 = REQUEST TO READ LINE STATUS
			; 6 = REQUEST TO WRITE LINE STATUS
	WORD	LNE,	;LINE NUMBER OF ABOVE OPERATION
	WORD	DVE,	;DEVICE NUMBER OF ABOVE OPERATION
	WORD	OPX,	;10-OPERATION CODE
			; 0 = IDLE
			; 1 = READ DATA INTO 10
			; 2 = WRITE DATA FROM 10
			; 3 = READ DEVICE STATUS
			; 4 = WRITE DEVICE STATUS
			; 5 = READ LINE STATUS
			; 6 = WRITE LINE STATUS
	WORD	LNX,	;LINE NUMBER OF ABOVE OPERATION
	WORD	DVX,	;DEVICE NUMBER OF ABOVE OPERATION (1-4)
	WORD	RST,	;RESULT CODE
	WORD	XFR,	;NUMBER OF BYTES TRANSFERRED
	BLK	CBP,40,	;COUNTS AND BYTE POINTERS (16 OF EACH)
> ;IFN M'CPU'PORT'D60
IFE M'CPU'PORT'D60,<  ;;THIS IS A DN85 PORT
	WORD	IFL,	;INPUT FLAGS
	WORD	IC1,	;INPUT COUNT (PART 1)
	WORD	ID1,	;INPTA POINTER (PART 1)
	WORD	IC2,	;INPUT COUNT
	WORD	ID2,	;INPUT DATA BYTE POINTER
	WORD	OFL,	;OUTPUT FLAGS
			;1=HEADER THERE
			;2=FIRST HALF THERE
			;4=SECOND HALF THERE
	WORD	OC1,	;OUTPUT HEADER COUNT
	WORD	OD1,	;OUTPUT HEADER POINTER
	WORD	OC2,	;OUTPUT DATA COUNT
	WORD	OD2,	;OUTPUT DATA POINTER
	WORD	OC3,	;OUTPUT DATA COUNT (PART 2)
	WORD	OD3,	;OUTPUT DATA POINTER (PART 2)
>	;IFE M'CPU'PORT'D60
>	;IFN	M'CPU'PORT'D85+M'CPU'PORT'D60
>	;;END OF IFDEF M'CPU'PORT'D85
	IFNDEF	M'CPU'PORT'D85,<
	WORD	TTP,	;;POINTER TO LAST ITEM PLACED IN THE TO -10
			;; QUEUE.

	WORD	TTG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -10
			;; QUEUE

	WORD	TEP,	;;POINTER TO LAST ITEM PLACED IN THE TO -11
			;; QUEUE

	WORD	TEG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -11
			;; QUEUE

	DATA	EBS,<TEBS'PORT'> ;;SIZE OF TO ELEVEN QUEUE

	DATA	TBS,<TTBS'PORT'> ;;SIZE OF TO TEN QUEUE

	DATA	LTO,<D7'PORT'OFS> ;;THE NUMBER ONE ADDS TO DC76 LINE
			;; ZERO TO GET A LINTAB INDEX

	DATA	DTO,<D7'PORT'DSO> ;;OFFSET TO DSCTAB
	PNTR	STS,STATES,	;;WORD WHICH HAS THE BIT WHICH SAYS
				;; IF WE SHOULD ANSWER DATASETS

	PNTR	FRN,TTFREN,	;;NUMBER OF FREE TTY CHUNKS. USED
				;; TO ALLOW THE DC76 TO COOL IT
				;; INSTEAD OF GETTING A DING.

	DATA	AOM,<M7'PORT'KII>;;ADDRESS OF THE FIRST WORD OF THE
				;; MAP. USED SO THAT THE -11 CAN UNDERSTAND
				;; TTA AND TEA.

	DATA	TEA,<M7'PORT'TEQ>;;ADDRESS OF THE TO -11 QUEUE
				;; USED ONLY BY D76INT

	DATA	TTA,<M7'PORT'TTQ>;;ADDRESS OF THE TO -10 QUEUE

	DATA	MAX,<M.D7'PORT'N+TYPNU'PORT> ;;TOTAL NUMBEER OF FRONT END LINES
	DATA	NTT,<M.D7'PORT'N> ;;NUMBER OF LINES ON THIS DC76

	IFNB	<PORT>,<ZZZZ==PAR'PORT'N>
	IFB	<PORT>,<ZZZZ==0>
	DATA	PAR,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PA611R READERS
	IFNB	<PORT>,<ZZZZ==ZZZZ+PCR'PORT'N>

	DATA	PCR,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PC-11 READERS
	IFNB	<PORT>,<ZZZZ==ZZZZ+PAP'PORT'N>
	DATA	PAP,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PA611P PUNCHES
	IFNB	<PORT>,<ZZZZ==ZZZZ+LPC'PORT'N>
	DATA	LPC,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF LPC 11 DEVICES
	IFNB	<PORT>,<ZZZZ==ZZZZ+PCP'PORT'N>
	DATA	PCP,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PC-11 PUNCHES
	DATA	PIO,<M7'PORT'NIP>	;;AREA OF NON IMMEDIATE BYTE POINTERS
;;ALL BLK MACROS SHOULD COME AT THE END OF THE MAP SO THAT OFFSETS
;; CAN BE COMPUTED WITHOUT KNOWING ANY MONGEN SYMBOLS.

	BLK	TTQ,<TTBS'PORT>,;;THE TO TEN QUEUE

	BLK	TEQ,<TEBS'PORT>,;;THE TO ELEVEN QUEUE

	BLK	NIP,<TYPNU'PORT>	;;POOL OF NONIMMEDIATE BYTE POINTERS
>	;;END OF IFNDEF M'CPU'PORT'D85
>;;END OF THE MAP76 MACRO
;MACRO DLMAP WILL GENERATE VALUES FOR THE MNEMONICS USED
; TO ADDRESS THE DL10 MAP
;WE NOW WANT TO EXPAND MAP76 TO DEFINE OFFSETS IN THE MAPPED AREA.
;OFFSETS ARE DEFINED ONLY FOR "DATA" OR "WORD" SYMBOLS. THIS IS DONE
; SO THAT ONE CAN NOT REFERENCE A DL10 INDIRECT POINTER OR A MONGEN
; DEPENDANT VARIABLE IN THIS MODULE.
	DEFINE	DLMAP
<	XLIST

DEFINE	WORD(SYMBOL)<SYMBOL==.I	;;DEFINE OFFSET
			.I==.I+1>

DEFINE	DATA(SYMBOL,DATUM)<SYMBOL==.I
			.I==.I+1>

DEFINE	PNTR(SYMBOL,WORD),<.I==.I+1>

DEFINE	BLK(SYMBOL,SIZE),<IFDEF SIZE,<.I==.I+SIZE>
			  IFNDEF SIZE,<PURGE .I>>

	.I==0
	MAP76		;DEFINE PARAMETERS
	LIST
>


;LINE PARAMETER CONTROL MESSAGES FOR THE DC76
XP	LPCSPD,2	;SET LINE SPEED (RECEIVE*10+TRANSMIT)
XP	LPCABR,4	;ENABLE AUTO BAUD RATE DETECT
XP	LPCELE,6	;SET TYPE ELEMENT
XP	LPCAPL,10	;SET/CLEAR APL MODE
XP	LPCRVB,12	;SET/CLEAR REVERSE BREAK
XP	LPCUKB,14	;UNLOCK KEYBOARD
XP	LPCTDY,16	;SET/CLEAR TIDY BIT

;TYPES OF DL-10 FRONT ENDS
XP	TP.D76,1	;FRONT END IS A DC76
XP	TP.D44,2	;FRONT END IS A DC44
XP	TP.D47,3	;FRONT END COMBINES DC44 AND DC76
XP	TP.D75,4	;OLD DECSYNC PROTOCOL
XP	TP.D60,5	;DN60 FRONT END
XP	TP.D85,6	;NEW DDCMP FRONT END
XP	TP.D78,7	;FRONT END IS A DAS78

;TYPES OF DTE-20 FRONT ENDS
XP	DT.RSX,1	;RSX20F
XP	DT.ANF,2	;ANF10
XP	DT.IBM,3	;IBM (DN60)
XP	DT.DNT,4	;DECNET

;TYPES OF KMC/DUP FRONT ENDS
XP	KD.ANF,1	;ANF10
XP	KD.DNT,2	;DECNET
XP	KD.USR,3	;USER
XP	KD.IBM,4	;IBM (DN60)

;TYPES OF DMR FRONT ENDS
XP	RD.ANF,1	;ANF10
XP	RD.DNT,2	;DECNET
XP	RD.USR,3	;USER
XP	RD.IBM,4	;IBM (DN60)


;DN60 CALL11 ENTRY VECTOR OFFSETS (FOR COMMUNICATION BETWEEN D60SER AND
;D6?INT MODULES
XP	D6F.UD,0	;SEE IF PDP11 IS UP OR DOWN
XP	D6F.QU,1	;THE CALL11 QUEUE DATA FUNCTION
XP	D6F.ED,2	;THE CALL11 EXAMINE/DEPOSIT FUNCTION
;THIS MACRO DEFINES THE INTERPROCESSER
;WINDOW USED BETWEEN THE PDP10 AND THE PDP11.
;
DEFINE MAP78	(CPU,PORT),<

	Q78SYM	<.DL'PORT'BS>;			;;FOR WINDOW MAP TABLE
	Q78SYM	<M8'PORT'KII>;			;BEGINNING WINDOW ADDRESS

	PHASE	0

IFN FTKI10!FTKL10,<
	Q78DAT	M78KII,<IFE FTKLP,<JSR D80'PORT'KI>	;KI PAGING STYLE INTERRUPT
IFN FTKLP,<XPCW D80'PORT'KI>>			;KL PAGING STYLE INTERUUPT

>;END IFN FTKI10!FTKL10
	Q78WRD	<M78ESA>,			;
	Q78WRD	<M78WNU>,			;
	Q78WRD	<M78NAM>,			;PROGRAM NAME (DAS78 IN SIXBIT)
	Q78WRD	<M78EPN>,			;
	Q78WRD	<M78OK>,			;PDP11 ALIVE INDICATOR.  INCREMENTED
						; BY 10 ONCE A SECOND. SET 0 BY 11.
						;  IF .LT. 2, 11 IS ALIVE
	Q78WRD	<M78HLT>,			;11 TO 10 STOP CODE
	Q78WRD	<M78DWN>,			;1=UP, 0=DOWN & TELL OPR, -1=DOWN
						; AND QUITE
	Q78WRD	<M78UPT>,			;
	Q78WRD	<M78GLB>,			;GLOBAL STATUS WORD
	Q78WRD	<M78MOD>,			;MODIFICATION NUMBER
	Q78WRD	<M78XXI>,			;10 TO 11 ACTIVTY INDICATOR
	Q78WRD	<M78XIX>,			;11 TO 10 ACTIVITY INDICATOR
	Q78WRD	<M78ALI>,			;PDP10 ALIVE INDICATOR.  INCREMENTED
						; BY 11 ONCE A SECOND.  SET -1 BY 10.
						;  IF .LE.1, 10 IS ALIVE.
	Q78WRD	<M7810S>,			;STATUS OF 10.	0 INITIALLY
						;1 STARTED INITIALIZATION
						;-1 RUNNING
	Q78WRD	<M7811S>,			;STATUS OF 11.	0 INITIALLY
						;1 STARTED INITIALIZATION
						;-1 RUNNING
	Q78WRD	<M78ADR>,			;ADDRESS FOR LOAD/STORE IN 11 CORE
	Q78WRD	<M78DTA>,			;CONTENTS OF CONTENTS OF M78ADR.
	Q78DAT	M78NLI,<M'CPU'PORT'D78>		;NUMBER OF LINES ON THIS PORT

	Q78SYM	<M78WIN>;			;BEGINNING OF WINDOW FOR EACH LINE
	DEPHASE
;THIS IS THE BEGINNING OF THE WINDOW SLOTS AND
;THERE IS ONE FOR EACH LINE
;
REPEAT	<M'CPU'PORT'D78>,<
	Q78SYM	<WS8L>,\<ZZD78L>;		;BEGINNING OF WINDOW SLOT
	PHASE	0
	Q78SYM	<SUBW78>;	;FIRST ADDR IN SUB WINDOW
	Q78WRD	<WS8LS0>,	;GENERAL LINE STATUS (OWNED BY 10 FOR CALL78 UUO)
	Q78WRD	<WS8LS1>,	;2ND LINE STATUS WORD
	Q78WRD	<WS8MSZ>,	;MESSAGE SIZE
	Q78WRD	<WS8RSZ>,	;RECORD SIZE
	WS8SET==:<.-SUBW78>	;NUMBER OF WORDS WE ALLOW
				; THE CALL78 TO SET
	Q78WRD	<WS810S>,	;STATUS OWNED BY THE PDP10
	Q78WRD	<WS811S>,	;STATUS OWNED BY THE PDP11
	Q78WRD	<WS8ICC>,	;INPUT TO 10 CHARACTER COUNT
	Q78WRD	<WS8IBP>,	;INPUT TO 10 BYTE POINTER
	Q78WRD	<WS8OCC>,	;OUTPUT FROM 10 CHARACTER COUNT
	Q78WRD	<WS8OBP>,	;OUTPUT FROM 10 BYTE POINTER
	M78SIZ==:<.-SUBW78>	;WINDOW SLOT SIZE
	Q78INC	<ZZD78L>,<1>;	;NEXT LINE NUMBER
	DEPHASE

>	;END REPEAT
>;END MAP78
	SUBTTL	CAL11. UUO DEFINITIONS


.C11FC==0	;FUNCTION WORD
;	C1.1NO==777B17  ;(OLD FORMAT) WHICH -11
;	C1.1NT==77B14	;(OLD FORMAT) TYPE
;	C1.1NN==7B17	;(OLD FORMAT) NUMBER

	C1.1NF==1B0	;NEW FORMAT ARGUMENTS
	C1.1XX==377B8	;RESERVED FOR DEC
	C1.1TY==7B11	;TYPE
		.C11DL==0	;DL-10
		.C11DT==1	;DTE-20
		.C11KD==2	;KMC/DUP
		.C11DR==3	;DMR
	C1.1CN==7B14	;CPU NUMBER
	C1.1PN==7B17	;PORT NUMBER
	C1.1FC==777777	;WHICH FUNCTION
		.C11DP==0	;DEPOSIT FUNCTION
		.C11EX==1	;EXAMINE FUNCTION
		.C11QU==2	;QUEUE A REQUEST
		.C11NM==3	;RETURN NAME OF FRONT END PROG
		.C11UP==4	;RETURN 0 IF DOWN, 1 IF UP
		.C11SM==5	;SEND MESSAGE
		.C11RM==6	;RECEIVE MESSAGE
		.C11TY==7	;RETURN TYPE/NODE NUMBER
			.C1D76==1	;DC76
			.C1D75==2	;DC75/DN87
			.C1D60==3	;DN60
			.C1D8S==4	;DN87S
			.C1CFE==5	;CONSOLE FRONT END
			.C1MCB==6	;DECNET MCB
			.C1D22==7	;DN22 ON A KMC/DUP
.C11AD==1	;ADDRESS OF EXAMINE/DEPOSIT
.C11CN==2	;CONTENTS TO DEPOSIT
.C11EN==1	;START OF QUEUE ENTRY


;CAL11.	ERROR CODES
C11NP%==1	;NOT PRIVILEGED
C11UF%==2	;UNKNOWN FUNCTION
C11ND%==3	;NOT DC76
C11IU%==4	;EXAM/DEP IN USE
C11NA%==5	;NO ANSWER TO EXAM/DEP
C11TS%==6	;QUEUE ENTRY TOO SHORT
C11NE%==7	;NOT ENOUGH ARGS
C11IA%==10	;INVALID EXAMINE/DEPOSIT ADDRESS
C11IQ%==11	;INVALID QUEUE FUNCTION ARGUMENT
C11IC%==12	;INSUFFICIENT CORE
C11RP%==13	;DTE RELOAD BIT SET OR PRIMARY PROTOCOL NOT RUNNING
C11IE%==14	;INSUFFICIENT EVM
C11NC%==16	;CPU NOT RUNNING
C11IT%==17	;ILLEGAL TYPE CODE
C11IP%==20	;ILLEGAL PORT NUMBER
C11DL%==21	;NO DL10 SUPPORT IN THIS MONITOR
C11DT%==22	;NO DTE SUPPORT IN THIS MONITOR
C11KD%==23	;NO KDP SUPPORT IN THIS MONITOR
C11DM%==24	;NO DMR SUPPORT IN THIS MONITOR
	SUBTTL	HARDWARE BITS --  FOR BOTH KA10 AND KI10 PROCESSORS
;OLD NAMES FOR SEVERAL RANDOM BITS:

	XP	UWP,1		;IN LH OF DATAO APR TO TURN ON
				; USER-MODE WRITE-PROTECT OF HIGH SEG
	XP	USRMOD,10000	;LH PC WORD, MACHINE WAS IN USER MODE WHEN
				; PC WAS STORED
	XP	UIOMOD,4000	;LH PC WORD, MACHINE WAS IN USER I/O MODE WHEN
				; PC WAS STORED, I.E., ALL INSTRUCTIONS WERE LEGAL.
	XP	POV,200000	;PUSH DOWN OVERFLOW
	XP	ILM,20000	;ILLEGAL MEMORY
;RIGHT HALF APR CONI BITS

XP.LTH==1B18		;LOOP DETECTED IN TRAP HANDLER
			; USED TO PREVENT SAC STOPCDS IN APRLIM
			; THIS IS A SOFTWARE BIT NOT A HARDWARE ONE
XP.CLK==1B26		;CLOCK (HAS INTERRUPTED)

;RIGHT HALF APR CONO BITS

XP.DDU==1B18		;DON'T DISABLE USER ENABLED INTERRUPTS WHEN
			; THEY OCCUR.  THIS IS A SOFTWARE BIT, NOT A HARDWARE
			; ONE.
XP.CCF==1B26		;CLEAR CLOCK FLAG

;PI CONO BITS

XI.CPE==1B19		;CLEAR PARITY ERROR

;LEFT HALF PC FLAG BITS

XC.OVF==1B0		;OVERFLOW
XC.FOV==1B3		;FLOATING OVER FLOW
XC.USR==1B5		;USER MODE
XC.UIO==1B6		;USER IOT MODE
IFN FTKI10!FTKL10,<
XC.PUB==1B7		;LAST INSTRUCTION PUBLIC
>
XC.TRP==3B10		;TRAPS 1 AND 2
	XC.ARI==1		;ARITHMETIC TRAP
	XC.PDL==2		;PUSHDOWN LIST OVERFLOW
	XC.TT3==3		;RESERVED FOR DEC
XC.FUF==1B11		;FLOATING UNDER FLOW
XC.NDV==1B12		;NO DIVIDE

;OTHER RANDOM PC DEFINITIONS

IFN FTKLP,<
SECMSK==37,,0		;PC SECTION NUMBER
MCSEC0==0,,0		;MONITOR CODE SECTION
MDSEC0==0,,0		;MONITOR DATA SECTION
MCSEC1==1,,0		;1ST NON-ZERO MONITOR CODE SECTION
MDSEC1==2,,0		;1ST NON-ZERO MONITOR DATA SECTION
MDSEC2==3,,0		;2ND NON-ZERO MONITOR DATA SECTION (PAGTAB, MEMTAB)
>


;RIGHT HALF BITS FOR USER ENABLING AND TESTING VIA APRENB UUO
UE.NXM==1B23		;NXM ERROR ENABLE AND INTERRUPT (SAME AS KA10 NXM FLAG)
UE.PEF==1B24		;PARITY ERROR ENABLE AND INTERRUPT
			;(SAME AS DISABLE CLOCK WHICH MONITOR NEVER USES
	SUBTTL	HARDWARE BITS --  FOR KA10 PROCESSOR (APR, PI, PC)

;APR CONI BITS:

AP.POV==1B19		;PUSH DOWN OVERFLOW
AP.UIO==1B20		;USER IN-OUT
AP.ABK==1B21		;ADDRESS BREAK
AP.ILM==1B22		;ILLEGAL MEMORY
AP.NXM==1B23		;NON-EXIST. MEMORY
;UE.PEF==1B24		;PARITY ENABLE (AND INTERRUPT) FOR APRENB UUO
			; MONITOR MAKES PARITY BIT APPEAR HERE FOR USER
AP.CIE==1B25		;CLOCK INTERRUPT ENABLED
;AP.CLK==1B26		;CLOCK (HAS INTERRUPTED)
AP.PPV==1B27		;FLAG FOR PROPRITARY PAGE VIOLATION NOT REALLY
			; A CONI BIT.  USED FOR IMPROVED ERROR MESSAGE
AP.FOE==1B28		;FLOATING OVERFLOW ENABLED
AP.FOV==1B29		;FLOATING OVERFLOW (HAS INTERRUPTED)
AP.TOS==1B30		;TRAP OFF SET - MASTER VS. SLAVE
AP.AOE==1B31		;ARITHMETIC OVERFLOW ENABLED
AP.AOV==1B32		;ARITHMETIC OVERFLOW

;APR CONO BITS:
;(DIFFERENT NAMES FROM CONI ONLY BECAUSE SOME HAVE DIFFERENT FUNCTIONS)
AP.CPO==1B18		;CLEAR PDL OVF
;AP.DDU==1B18		;DON'T DISABLE USER ENABLED INTERRUPTS WHEN
			; THEY OCCUR.  THIS IS A SOFTWARE BIT, NOT A HARDWARE
			; ONE.
AP.IOR==1B19		;IO RESET (CLEAR ALL DEVICES)
AP.CAB==1B21		;CLEAR ADDRESS BREAK
AP.CMP==1B22		;CLEAR MEMORY PROTECTION
AP.CNM==1B23		;CLEAR NON-EXISTENT MEMORY
AP.DCI==1B24		;DISABLE CLOCK INTERRUPT
AP.ECI==1B25		;ENABLE CLOCK INTERRUPT
;AP.CCF==1B26		;CLEAR CLOCK FLAG
AP.DFO==1B27		;DISABLE FLOAT. OVERFLOW
AP.EFO==1B28		;ENABLE FLOAT. OVERFLOW
AP.CFO==1B29		;CLEAR FLOATING OVERFLOW
AP.DAO==1B30		;DISABLE ARITH. OVERFLOW
AP.EAO==1B31		;ENABLE ARITH. OVERFLOW
AP.CAO==1B32		;CLEAR ARITH. OVERFLOW
;AP.PI0==7B35		;PI CHANNEL FOR CPU 0 (REDEFINED IN COMMON)
;AP.PI1==7B35		;PI CHANNEL FOR CPU 1 (REDEFINED IN COMMON)

;APR DATAO BITS:
AP.UWP==1B17		;USER MODE WRITE PROTECT FOR HIGH SEGMENT
;PC FLAGS

;PC.OVF==1B0		;OVERFLOW
PC.CY0==1B1		;CARRY 0
PC.CY1==1B2		;CARRY 1
;PC.FOV==1B3		;FLOATING OVER FLOW
PC.BIS==1B4		;BYTE INCREMENT SUPPRESSION
;PC.USR==1B5		;USER MODE
;PC.UIO==1B6		;USER IO MODE
;PC.FUF==1B11		;FLOATING UNDER FLOW
;PC.NDV==1B12		;NO DIVIDE

;PI CONI BITS:

PI.PWF==1B18		;POWER FAILURE
PI.PAR==1B19		;PARITY ERROR IN MEMORY
PI.PEE==1B20		;PARITY ERROR ENABLED
PI.IP1==1B21		;INTERRUPT IN PROGRESS ON CHANNEL 1
PI.IP2==1B22		;     "           "               2
PI.IP3==1B23		;     "           "               3
PI.IP4==1B24		;     "           "               4
PI.IP5==1B25		;     "           "               5
PI.IP6==1B26		;     "           "               6
PI.IP7==1B27		;     "           "               7
PI.IPA==PI.IP1+PI.IP2+PI.IP3+PI.IP4+PI.IP5+PI.IP6+PI.IP7 ;INTERRUPTING PROG ON ALL
PI.PIA==1B28		;PI ACTIVE
PI.CO1==1B29		;CHANNEL ON 1
PI.CO2==1B30		;    "    " 2
PI.CO3==1B31		;    "    " 3
PI.CO4==1B32		;    "    " 4
PI.CO5==1B33		;    "    " 5
PI.CO6==1B34		;    "    " 6
PI.CO7==1B35		;    "    " 7
;PI CONO BITS:
;(DIFFERENT NAMES FROM CONI ONLY BECAUSE SOME HAVE DIFF FUNCTIONS)
PI.CPF==1B18		;CLEAR POWER FAILURE
PI.CPE==1B19		;CLEAR PARITY ERROR
PI.DPE==1B20		;DISABLE PARITY ERROR
PI.EPE==1B21		;ENABLE PARITY ERROR
PI.CPI==1B23		;CLEAR PI SYSTEM
PI.IIO==1B24		;INITIATE INTERRUPT ON (SELECTED PIS)
PI.TNP==1B25		;TURN ON SELECTED PIS
PI.TFP==1B26		;TURN OFF SELECTED PIS
PI.OFF==1B27		;TURN PI SYSTEM OFF
PI.ON==1B28		;TURN PI SYSTEM ON
PI.SC1==1B29		;SELECT CHANNELS 1
PI.SC2==1B30		;   "       "    2
PI.SC3==1B31		;   "       "    3
PI.SC4==1B32		;   "       "    4
PI.SC5==1B33		;   "       "    5
PI.SC6==1B34		;   "       "    6
PI.SC7==1B35		;   "       "    7

;CPU TYPE CODES (RH OF .CPTYP)(LH FOR CUSTOMERS)
CT.P6==1		;PDP-6 TYPE PROCESSOR
CT.KA==2		;KA-10 TYPE PROCESSOR
CT.KI==3		;KI-10 TYPE PROCESSOR
CT.KL==4		;KL-10 TYPE PROCESSOR
CT.KS==5		;KS-10 TYPE PROCESSOR
	SUBTTL	HARDWARE BITS -- FOR KI10 PROCESSOR

;LEFT HALF APR CONI BITS.

IP.MOD==1B1			;MEMORY OVERLAP DISABLE
IP.FMS==1B2			;FAST MEMORY SELECT
IP.MID==1B3			;MI PROGRAM DISABLE
IP.CRO==1B4			;CONSOLE READ ONLY
IP.CLC==1B5			;CONSOLE LOCKED
IP.50H==1B6			;50 HERTZ POWER LINE FREQUENCY
IP.MNM==1B7			;MANUAL MARGINS
IP.MNT==1B8			;MAINTAINANCE MODE
IP.PWL==1B9			;POWER LOW
IP.MCL==1B10			;MARGIN COMPARE LOW
IP.SS1==1B12			;SENSE SWITCH 1
IP.SS2==1B13			;SENSE SWITCH 2
IP.SS3==1B14			;SENSE SWITCH 3
IP.SS4==1B15			;SENSE SWITCH 4
IP.SS5==1B16			;SENSE SWITCH 5
IP.SS6==1B17			;SENSE SWITCH 6

;RIGHT HALF APR CONI BITS.  THOSE MARKED WITH "*" CAUSE INTERRUPTS.

IP.TTO==1B18			;*TIMER TIMED OUT
IP.PAR==1B19			;*PARITY ERROR IN MEMORY
IP.PEE==1B20			;PARITY ERROR ENABLED
IP.TOE==1B21			;TIME-OUT ENABLED
IP.PWF==1B22			;*POWER FAILURE
IP.ARE==1B23			;AUTO-RESTART ENABLED
;UE.PEF==1B24			;PARITY ERROR ENABLE (AND INTERRUPT) FOR APRENB UUO
				; MONITOR MAKES IT APPEAR AS IF PARITY IS HERE FOR USER
IP.CIE==1B25			;CLOCK INTERRUPT ENABLED
;IP.CLK==1B26			;*CLOCK (HAS INTERRUPTED)
IP.ABK==1B27			;*ADDRESS BREAK
IP.IOF==1B28			;*I/O PAGE FAIL FLAG
IP.NXM==1B29			;*NON-EXISTANT MEMORY

;BITS 30-35 ARE APR ERROR AND CLOCK PI ASSIGNMENTS
;RIGHT HALF APR CONO BITS.

IP.SWT==1B18			;SET WATCH-DOG TIMER
IP.IOR==1B19			;I/O RESET (CLEAR ALL DEVICES)
IP.CTE==1B20			;CLEAR TIME-OUT ENABLE
IP.STE==1B21			;SET TIME-OUT ENABLE
IP.CAE==1B22			;CLEAR AUTO-RESTART ENABLE
IP.SAE==1B23			;SET AUTO-RESTART ENABLE
IP.DCI==1B24			;DISABLE CLOCK INTERRUPTS
IP.ECI==1B25			;ENABLE CLOCK INTERRUPTS
;IP.CCF==1B26			;CLEAR CLOCK FLAG
IP.CAB==1B27			;CLEAR ADDRESS BREAK
IP.CIO==1B28			;CLEAR I/O PAGE FAIL
IP.CNM==1B29			;CLEAR NON-EXISTANT MEMORY

;BITS 30-35 ARE APR ERROR AND CLOCK PI ASSIGNMENTS

;LEFT HALF PI CONI BITS. NONE CAUSE INTERUPTS.

II.AIF==1B0	;ADDRESS BREAK ON INSTRUCTION FETCH SWITCH IS ON
II.ADF==1B1	;   "      "    "    DATA       "      "    "  "
II.ABW==1B2	;   "      "    " WRITE SWITCH
II.ASS==1B3	;ADDRESS STOP SWITCH
II.ABS==1B4	;ADDRESS BREAK SWITCH
II.EPS==1B5	;EXEC PAGING SWITCH
II.UPS==1B6	;USER PAGING SWITCH
II.PSS==1B7	;PARITY STOP SWITCH
II.NSS==1B8	;NXM STOP SWITCH
II.PR1==1B11	;PROGRAM PI REQUESTED FOR CHANNEL 1
II.PR2==1B12	;   "    "      "      "     "    2
II.PR3==1B13	;   "    "      "      "     "    3
II.PR4==1B14	;   "    "      "      "     "    4
II.PR5==1B15	;   "    "      "      "     "    5
II.PR6==1B16	;   "    "      "      "     "    6
II.PR7==1B17    ;   "    "      "      "     "    7
;RIGHT HALF PI CONO BITS.

II.CPF==1B18			;CLEAR POWER FAIL FLAG
;II.CPE==1B19			;CLEAR PARITY ERROR FLAG
II.EPE==1B21			;ENABLE PARITY ERROR
II.CPP==1B22			;CLEAR PROGRAM PI N
II.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
II.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
II.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
II.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
II.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
II.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
II.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
II.IPA==II.IP1+II.IP2+II.IP3+II.IP4+II.IP5+II.IP6+II.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
II.PIA==1B28			;PI ACTIVE
II.CO1==1B29			;PI CHANNEL 1 ON
II.CO2==1B30			;PI CHANNEL 2 ON
II.CO3==1B31			;PI CHANNEL 3 ON
II.CO4==1B32			;PI CHANNEL 4 ON
II.CO5==1B33			;PI CHANNEL 5 ON
II.CO6==1B34			;PI CHANNEL 6 ON
II.CO7==1B35			;PI CHANNEL 7 ON
II.ACO==II.CO1+II.CO2+II.CO3+II.CO4+II.CO5+II.CO6+II.CO7
				;ANY OR ALL PI CHANNELS ON
;LEFT HALF PC FLAG BITS.

IC.000==1B0			;(EXEC)
;IC.OVF==1B0			;(USER) ARITHMETIC OVERFLOW
IC.CY0==1B1			;CARRY 0
IC.CY1==1B2			;CARRY 1
;IC.FOV==1B3			;FLOATING OVERFLOW
IC.BIS==1B4			;BYTE INCREMENT SUPPRESSION
;IC.USR==1B5			;USER MODE
IC.UOU==1B6			;(EXEC) UUO OLD USER
;IC.UIO==1B6			;(USER) USER IOT MODE
IC.LIP==1B7			;LAST INSTRUCTION PUBLIC
IC.AFI==1B8			;ADDRESS FAILURE INHIBIT
IC.ATN==3B10			;APR TRAP NUMBER
IC.TN0==1B9			;TRAP BIT 0
IC.TN1==1B10			;TRAP BIT 1
;IC.FUF==1B11			;FLOATING POINT UNDERFLOW
;IC.NDV==1B12			;NO DIVIDE
;PAGE MAP WORD FORMAT.

IFE FTKLP,<
PM.ACC==400000			;ACCESS ALLOWED
PM.PUB==200000			;PUBLIC
PM.WRT==100000			;WRITE ALLOWED
PM.XTR==20000			;EXTRA
IFN FTKL10!FTKS10,<
PM.CSH==20000			;CACHE (KL10 AND KS10 ONLY)
>
>
PM.SWB==40000			;SOFTWARE BIT
IFN FTKLP,<
PM.PUB==1B3
PM.WRT==1B4
PM.SWB==1B5
PM.CSH==1B6

PM.NCD==0
PM.DCD==1
PM.SCD==2
PM.ICD==3
PM.ACD==7
>

PM.ZER==40000			;CORE ALLOCATED BUT 0 IF ONLY
				; THIS BIT IS ON IN THE MAP SLOT

;BITS IN CONO PAGE WORD.

PG.LUB==1B0			;LOAD USER BASE REGISTER
PG.ACE==1B4			;USER ADDRESS COMPARE ENABLE
PG.LEB==1B18			;LOAD EXEC BASE REGISTER
PG.EAT==1B22			;ENABLE TRAPS
PG.AC0==0B2			;USE AC SET 0 IN USER MODE
PG.AC1==1B2			;USE AC SET 1 IN USER MODE
PG.AC2==2B2			;USE AC SET 2 IN USER MODE
PG.AC3==3B2			;USE AC SET 3 IN USER MODE
PG.EPT==17777			;ADDRESS OF EPT
PG.UPT==17777B17		;ADDRESS OF UPT


;BITS RETURNED AS PAGE-FAIL CODE ON PAGE FAULTS
PC.PNA==1			;PAGE NOT ACCESSABLE
PC.PNC==2			;PAGE NOT IN CORE
PC.UUO==3			;PAGE FAULT WHILE IN UUO PROCESSING
PC.TIM==4			;TIME-CAUSE FAULT DISPATCH
PC.AZU==5			;FAULT ON AN ALLOCATED-BUT-ZERO PAGE
				; (NON MONITOR-CALL)
PC.AZM==6			;FAULT ON A  MONITOR CALL PAGE ALLOCATED BUT 0

;BITS RETURNED IN PAGE-FAIL WORD
PC.WHC==1B0			;WORKING SET HAS CHANGED
PC.WSS==1B1			;WORKING SET IS SCRAMBLED
;EXEC VIRTUAL MEMORY ADDRESSES (MAPPED THROUGH THE PER PROCESS MAP)

.MCFV==1000000			;VIRTUAL PAGE NUMBER OF FIRST PAGE OF MONITOR
				; FREE CORE
.FPPP==340000			;EXEC VIRTUAL ADDRESS OF FIRST PAGE OF
				; "PER PROCESS" DATA
.FPMC==340000			;EXEC VIRTUAL ADDRESS OF FIRST PAGE OF MONITOR
				; FREE CORE
.LPMC==370000-IFN FTKLP,<1000> 	;EXEC VIRTUAL ADDRESS OF FIRST PAGE AFTER
				; MONITOR FREE CORE
NWMCP==.LPMC-.FPMC		;NUMBER OF WORDS OF MONITOR FREE CORE
.UPMP==370000			;EXEC VIRTUAL ADDRESS OF THE CURRENT USER'S UPMP
.UPMVP==1030000			;VIRTUAL PAGE NUMBER OF THE UPMP
.JDAT==371000			;EXEC VIRTUAL ADDRESS OF THE CURRENT USER'S JOBDAT
.VJDT==372000			;EXEC VIRTUAL ADDRESS OF THE CURRENT USER'S
				; VESTIGUAL JOBDAT
.TEMP==373000			;EXEC VIRTUAL ADDRESS OF TEMP
.JBPK==374000			;EXEC VIRTUAL ADDRESSES USED FOR JOBPEK UUO
.JBPK1==375000			; "
.JBPK2==376000			; "
IFN FTKI10!FTKS10,<
.UUPMP==.UPMP
>
IFN FTKL10,<
.UUPMP==377000			;ADDRESS USED TO REFERENCE CACHED ITEMS
				; IN THE UPMP
.UPMAP==367000
>
.LPPP==400000			;EXEC VIRTUAL ADDRESS OF FIRST PAGE AFTER
				; "PER PROCESS" DATA
	SUBTTL	HARDWARE BITS -- FOR KL10 PROCESSOR

;LEFT HALF APR CONI BITS.

LP.SEE==1B6		;SBUS ERROR ENABLED
LP.NEE==1B7		;NXM ERROR ENABLED
LP.IFE==1B8		;I/O PAGE FAIL ERROR ENABLED
LP.PEE==1B9		;PARITY ERROR ENABLED
LP.CDE==1B10		;CACHE DIRECTORY PARITY ERROR ENABLED
LP.PDE==1B11		;PAGE TABLE DIRECTORY PARITY ERROR ENABLED
LP.PFE==1B12		;POWER FAIL ENABLED
LP.SDE==1B13		;SWEEP DONE ENABLED

;RIGHT HALF APR CONI BITS

LP.CSB==1B19		;CACHE SWEEP BUSY
LP.SBE==1B24		;S-BUSS ERROR
LP.NXM==1B25		;NXM
LP.IOF==1B26		;I/O PAGE FAIL
LP.PAR==1B27		;PARITY ERROR
LP.CDP==1B28		;CACHE DIRECTORY PARITY ERROR
LP.ADP==1B29		;ADDRESS PARITY ERROR
LP.PWF==1B30		;POWER FAIL
LP.CSD==1B31		;CACHE SWEEP DONE
LP.INT==1B32		;INTERRUPT REQUEST
LP.PIA==7B35		;PIA

;CONO APR BITS
LP.IOR==1B19		;IO RESET
LP.ESF==1B20		;ENABLE SELECTED FLAGS (BITS 24-31)
LP.DSF==1B21		;DISABLE SELECTED FLAGS (BITS 24-31)
LP.CSF==1B22		;CLEAR SELECTED FLAGS (BITS 24-31)
LP.SSF==1B23		;SET SELECTED FLAGS (BITS 24-31)
LP.SBE==1B24		;S-BUSS ERROR
LP.NXM==1B25		;NXM
LP.IOF==1B26		;I/O PAGE FAIL
LP.PAR==1B27		;PARITY ERROR
LP.CDP==1B28		;CACHE DIRECTORY PARITY
LP.ADP==1B29		;ADDRESS PARITY
LP.PWF==1B30		;POWER FAIL
LP.CSD==1B31		;CACHE SWEEP DONE
LP.PIA==7B35		;PIA

;LEFT HALF CONI PI BITS
LI.PR1==1B11		;PROGRAM P1 REQUEST FOR CHANNEL 1
LI.PR2==1B12		;PROGRAM PI REQUEST FOR CHANNEL 2
LI.PR3==1B13		;PROGRAM PI REQUEST FOR CHANNEL 3
LI.PR4==1B14		;PROGRAM PI REQUEST FOR CHANNEL 4
LI.PR56=1B15		;PROGRAM PI REQUEST FOR CHANNEL 5
LI.PR6==1B16		;PROGRAM PI REQUEST FOR CHANNEL 6
LI.PR7==1B17		;PROGRAM PI REQUEST FOR CHANNEL 7

;RIGHT HALF PI CONO BITS.

LI.EPA==1B18			;EVEN PARITY ADDRESSES
LI.EPD==1B19			;EVEN PARITY DATA
LI.CPP==1B22			;CLEAR PROGRAM PI N
LI.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
LI.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
LI.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
LI.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
LI.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
LI.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
LI.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
LI.IPA==LI.IP1+LI.IP2+LI.IP3+LI.IP4+LI.IP5+LI.IP6+LI.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
LI.PIA==1B28			;PI ACTIVE
LI.CO1==1B29			;PI CHANNEL 1 ON
LI.CO2==1B30			;PI CHANNEL 2 ON
LI.CO3==1B31			;PI CHANNEL 3 ON
LI.CO4==1B32			;PI CHANNEL 4 ON
LI.CO5==1B33			;PI CHANNEL 5 ON
LI.CO6==1B34			;PI CHANNEL 6 ON
LI.CO7==1B35			;PI CH7NNEL 7 ON
LI.ACO==LI.CO1+LI.CO2+LI.CO3+LI.CO4+LI.CO5+LI.CO6+LI.CO7
;BITS FOR KL10 PROGRAM CLOCKS


;BITS IN CONO TIM,

TO.CIT==1B18		;CLEAR INTERVAL TIMER
TO.SIT==1B21		;START INTERVAL TIMER
TO.CTD==1B22		;CLEAR TIMER DONE
TO.PRP==1B35		;POSITION OF PERIOD FIELD
TO.PRS==^D12		;SIZE OF PERIOD FIELD
TO.PRF==7777B35		;THE FIELD ITSELF


;BITS IN CONI TIM,

TI.INP==1B17		;POSITION OF INTERVAL TIMER FIELD
TI.INS==^D12		;SIZE OF IT
TI.INF==7777B17		;THE FIELD ITSELF
TI.TIO==1B21		;INTERVAL TIMER ON
TI.ITD==1B22		;INTERVAL TIMER DONE
TI.TOV==1B23		;TIMER OVERFLOW
TI.PRP==1B35		;PERIOD REGISTER POSITION
TI.PRS==^D12		;SIZE
TI.PRF==7777B35		;FIELD


;BITS IN CONO MTR,

MO.LAC==1B18		;LOAD ACCOUNTING CONTROL
MO.AIP==1B21		;ACCT INCLUDE PI
MO.AEN==1B22		;ACCT INCLUDE EXEC NO PI
MO.AO==1B23		;ACCT ON
MO.TOF==1B24		;TIME BASE OFF
MO.TON==1B25		;TIME BASE ON
MO.CTB==1B26		;CLEAR TIME BASE
MO.IPI==7B35		;INTERVAL TIMER PI

;BITS IN CONI MTR,

MI.AIP==1B21		;ACCT INCLUDE PI
MI.AEN=1B22		;ACCT INCLUDE EXEC NO PI
MI.AO==1B23		;ACCT ON
MI.TON==1B25		;TIME BASE ON
MI.IPI==7B35		;INTERVAL TIMER PI
;LEFT HALF WRPAE BITS

PE.CP0==1B0		;CHANNEL 0 PERFORMANCE ENABLE
PE.CP1==1B1		; CHANNEL 1
PE.CP2==1B2
PE.CP3==1B3
PE.CP4==1B4
PE.CP5==1B5
PE.CP6==1B6
PE.CP7==1B7
PE.CPI==1B8		;CHANNEL PERFORMANCE IGNORE

PE.UCI==1B9		;MICROCODE STATE IGNORE

PE.PRL==1B10		;PROBE LOW ENABLE
PE.PRI==1B11		;PROBE STATE IGNORE

PE.CCR==1B12		;CACHE REFILL ENABLE
PE.CCF==1B13		;CACHE FILL ENABLE
PE.EWB==1B14		;EBOX WRITE BACK
PE.SWB==1B15		;SWEEP WRITE BACK ENABLE
PE.CCI==1B16		;CACHE CONDITION IGNORE

;RIGHT HALF WRPAE BITS

PE.PP0==1B18		;PI 0 PERFORMANCE ENABLE
PE.PP1==1B19
PE.PP2==1B20
PE.PP3==1B21
PE.PP4==1B22
PE.PP5==1B23
PE.PP6==1B24
PE.PP7==1B25
PE.NPI==1B26		;NO PI
PE.PPI==777B26		;PI CONDITION IGNORE

PE.PCU==1B27		;PC USER ENABLE
PE.PCI==1B28		;PC IGNORE
PE.EVM==1B29		;EVENT MODE (RATHER THAN DURATION MODE)
PE.CLR==1B30		;CLEAR PERFORMANCE METER



;VALUES FOR THE CLOCKS

.EBCPT==10000		;EBOX COUNTS/EBOX TICK
.MBCPT==10000		;MBOX COUNTS/MBOX TICK
.TBCPT==10000		;TIME BASE COUNTS/TIME BASE TICK

TB.LTP==^L<.TBCPT>	;POSITION THAT TIME BASE STARTS COUNTING IN
;BITS IN CONO PAG
LG.CSL==1B18		;CACHE STRATEGY LOOK
LG.CSW==1B19		;CACHE STRATEGY WRITE
LG.KIP==0B21		;KI PAGING (INVERTED IN BREADBOARD)
LG.KLP==1B21		;KL PAGING
LG.TEN==1B22		;TRAP ENABLE
LG.EPT==17777		;ADDRESS OF EPT

;BITS IN DATAO PAG
LG.LAB==1B0		;LOAD AC BLOCKS
LG.LPC==1B1		;LOAD PREV CONTEXT
LG.LUB==1B2		;LOAD USER BASE REGISTER
LG.CAC==7B8		;CURRENT AC BLOCK #
LG.PAC==7B11		;PREV. AC BLOCK #
LG.CSX==1B12		;CSWX
LG.PCS==37B17		;PREVIOUS CONTEXT SECTION
LG.IAM==1B18		;INHIBIT STORING ACCOUNTING METER
LG.UPT==17777		;ADDRESS OF UBR

;BITS IN RDERA
EA.SWP==1B2		;CACHE SWEEP REFERENCE
EA.CHN==1B3		;CHANNEL REFERENCE
EA.DAT==1B4		;DATA SOURCE FIELD (2 BIT ENCODING)
EA.SRC==1B5		;...
EA.WRT==1B6		;MEMORY WRITE

;BITS IN APRID
ID.T2P==1B0		;TOPS20 PAGING
ID.XAD==1B1		;EXTENDED ADDRESSING
ID.XUC==1B2		;EXOTIC MICROCODE
ID.UVN==777B17		;MICROCODE VERSION NUMBER
ID.50H==1B18		;50 HZ EXTENAL POWER
ID.CSH==1B19		;PROCESSOR HAS CACHE
ID.CHL==1B20		;CHANNEL
ID.XKL==1B21		;EXTENDED KL
ID.PSN==7777B35		;PROCESSOR SERIAL NUMBER
	SUBTTL	HARDWARE BITS -- FOR KS10 PROCESSOR

IFN FTKS10,<

;WRAPR BITS

SP.IOR==1B19		;IO RESET
SP.ESF==1B20		;ENABLE SELECTED FLAGS (BITS 24-31)
SP.DSF==1B21		;DISABLE SELECTED FLAGS (BITS 24-31)
SP.CSF==1B22		;CLEAR SELECTED FLAGS (BITS 24-31)
SP.SSF==1B23		;SET SELECTED FLAGS (BITS 24-31)
SP.IFE==1B25		;INTERRUPT FRONT END
SP.PWF==1B26		;POWER FAIL
SP.NXM==1B27		;NXM
SP.HMP==1B28		;HARD MEMORY PARITY ERROR
SP.SMP==1B29		;SOFT MEMORY PARITY ERROR
SP.ITI==1B30		;INTERVAL TIMER
SP.PIA==7B35		;PIA

;RDAPR BITS, LEFT HALF

SP.PFE==1B8		;POWER FAIL ENABLED
SP.NEE==1B9		;NXM ERROR ENABLED
SP.HPE==1B10		;HARD MEM PAR ERROR ENABLED
SP.SPE==1B11		;SOFT MEM PAR ERROR ENABLED
SP.ITE==1B12		;INTERVAL TIMER ENABLED

;RDAPR BITS, RIGHT HALF

SP.PWF==1B26		;POWER FAIL
SP.NXM==1B27		;NXM
SP.HMP==1B28		;HARD MEMORY PARITY ERROR
SP.SMP==1B29		;SOFT MEMORY PARITY ERROR
SP.ITI==1B30		;INTERVAL TIMER INTERRUPT
SP.FEI==1B31		;INTERRUPT FROM 8080 FRONT END
SP.INT==1B32		;INTERRUPT REQUESTED
SP.PIA==7B35		;PIA

;WRUBR BITS

SG.LAB==1B0		;LOAD AC BLOCKS
SG.LUB==1B2		;LOAD USER BASE REGISTER
SG.CAC==7B8		;CURRENT AC BLOCK NUMBER
SG.PAC==7B11		;PREVIOUS AC BLOCK NUMBER
SG.UPT==3777B35		;ADDRESS OF UBR

;WREBR BITS

SG.KIP==0B21		;KI PAGING
SG.TEN==1B22		;TRAP AND PAGING ENABLED
SG.EPT==3777B35		;ADDRESS OF EPT
;LEFT HALF RDPI BITS
SI.PR1==1B11		;PROGRAM P1 REQUEST FOR CHANNEL 1
SI.PR2==1B12		;PROGRAM PI REQUEST FOR CHANNEL 2
SI.PR3==1B13		;PROGRAM PI REQUEST FOR CHANNEL 3
SI.PR4==1B14		;PROGRAM PI REQUEST FOR CHANNEL 4
SI.PR56=1B15		;PROGRAM PI REQUEST FOR CHANNEL 5
SI.PR6==1B16		;PROGRAM PI REQUEST FOR CHANNEL 6
SI.PR7==1B17		;PROGRAM PI REQUEST FOR CHANNEL 7

;RIGHT HALF WRPI BITS.

SI.CPP==1B22			;CLEAR PROGRAM PI N
SI.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
SI.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
SI.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
SI.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
SI.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
SI.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
SI.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
SI.IPA==SI.IP1+SI.IP2+SI.IP3+SI.IP4+SI.IP5+SI.IP6+SI.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
SI.PIA==1B28			;PI ACTIVE
SI.CO1==1B29			;PI CHANNEL 1 ON
SI.CO2==1B30			;PI CHANNEL 2 ON
SI.CO3==1B31			;PI CHANNEL 3 ON
SI.CO4==1B32			;PI CHANNEL 4 ON
SI.CO5==1B33			;PI CHANNEL 5 ON
SI.CO6==1B34			;PI CHANNEL 6 ON
SI.CO7==1B35			;PI CH7NNEL 7 ON
SI.ACO==SI.CO1+SI.CO2+SI.CO3+SI.CO4+SI.CO5+SI.CO6+SI.CO7
;PHYSICAL CORE DEFINITIONS FOR KS10 CTY, KLINIK SERVICE
; AND OTHER FRONT-END FUNCTIONS

RLWORD==31			;RELOAD WORD
	KSRLD==1B4		;RELOAD REQUEST
	KPACT==1B5		;KEEP ALIVE ACTIVE
	KLACT==1B6		;KLINIK ACTIVE
	PAREN==1B7		;PARITY ERROR DETECT ENABLED
	CRMPAR==1B8	;CRAM PAR ERR DETECT ENABLED
	DRMPAR==1B9	;DRAM PAR ERR DETECT ENABLED
	CASHEN==1B10	;CACHE ENABLED
	MILSEN==1B11	;1MSEC ENABLED
	KPALIV==377B28	;KEEP ALIVE WORD
	AUTOBT==1B32	;BOOT SWITCH OR POWER UP CONDITION
	PWRFAL==1B33	;POWER FAIL
	FORREL==1B34	;FORCED RELOAD
	KEPFAL==1B35	;KEEP ALIVE FAILURE


CTYIWD==32			;CTY INPUT WORD
	CTYICH==377B35	;CTY INPUT CHARACTER
	CTYIVL==1B27	;INPUT VALID BIT

CTYOWD==33			;CTY OUTPUT WORD
	CTYOCH==377B35	;CTY OUTPUT CHARACTER
	CTYOVL==1B27	;OUTPUT VALID FLAG

KLIIWD==34			;KLINIK INPUT WORD
	KLIICH==377B35	;KLINIK INPUT CHARACTER
	KLIIVL==1B27	;KLINIK INPUT VALID
KLICHR==1B27			;KLINIK CHARACTER
KLIINI==2B27			;KLINIK INITED
KLICAR==3B27			;CARRIER LOST


KLIOWD==35			;KLINIK OUTPUT WORD
	KLIOCH==377B35	;KLINIK OUTPUT CHARACTER
	KLIOVL==1B27	;KLINIK OUTPUT VALID
KLOCHR==1B27			;KLINIK CHARACTER AVAILABLE
KLIHUP==2B27			;KLINIK HANGUP REQUEST
SUBTTL	HARDWARE BITS -- FOR KS10 UBA AND DEVICES

; EXTERNAL PAGE DEFINITIONS FOR UNIBUS ADAPTER

UBAEXP==763000			;ADDRESS OF UNIBUS ADAPTER (FIRST ADDRESS)
UNBSTW==763100			;BASIC UNIBUS STATUS REGISTER ADDRESS (MINUS UNIT NUMBER)
UNBSTS==100			;ADDRESS OF STATUS WORD (FIRST UNIBUS ADAPTER)

; BIT DEFINITIONS FOR STATUS WORD
UNBTMO==1B18			;NON EX DEVICE (TIMEOUT)
UNBBME==1B19			;BAD MEMORY
UNBBPE==1B20			;SM10 BUS PARITY
UNBNED==1B21			;NON EX CPU DEVICE
UNBACL==1B26			;AC OR DC LOW (POWER FAIL ON UNIBUS)
UNBENI==1B27			;ENABLE INTERNAL INTERRUPT
UNBDTR==1B28			;DISABLE TRANSFER ON UNCORRECTABLE DATA
UBINIT==1B29			;UNIBUS INIT

UBAMUL==4000			;MULTIPLIER FOR UNIBUS ADDRESSES / PAGE RAM
UBAPGS==100			;NUMBER OF MAPPING REGISTERS
MXUBWN==100			;MAX MAPPING REGISTER
MXSMCH==0			;MAX UNIBUS ADAPTER (ONLY ONE LEGAL FOR NOW)
UNBPAR==1B4			;UNIBUS ADAPT PARITY BIT
UNBRRV==1B18			;READ REVERSE BIT
UNBD18==1B19			;DISABLE 18 BIT MODE TRANSFER (16 BIT TRANSFERS)
UNB36B==1B20			;36 BIT MODE TRANSFERS
UNBVBT==1B21			;VALID TRANSFER BIT

;NOTE THE DEVICE ADDRESSES ARE A FULL-WORD QUANTITY IN THE FORMAT:
;	XWD	UBA NUMBER,,UNIBUS ADDRESS

;DUP11 DEFINITIONS

	DUP1BA==3760300		;DUP-11 BASE ADDRESS

;KMC11 DEFINTIONS

	KMC1BA==3760540		;KMC11 DEVICE ADDRESS
	KMC1IV==540		;INTERRUPT VECTOR FOR KMC11

;DMR11 DEFINITIONS

	DMR1BA==3764000		;DMR11 DEVICE ADDRESS
				;Temp in "user space" for ME
	DMR1IV==610		;DMR11 INTERRUPT VECTOR
				;Also a ME definition

;LP20 DEFINITIONS

	LP11CA==3775400			;LP20 DEVICE ADDRESS
	LP11IV==754			;INTERRUPT VECTOR FOR LP20

;RH11 DEFINITIONS

	RH11CA==1776700			;DEVICE ADDRESS OF FIRST RH11
	RH21CA==3772440			;DEVICE ADDRESS OF SECOND RH11
	RH11IV==254			;INTERRUPT VECTOR ADDRESS FOR 1ST RH11
	RH21IV==224			;INTERRUPT VECTOR ADDRESS OF 2ND RH11

;CD20 DEFINITIONS
	CD11BA==3777160			;CD20 DEVICE ADDRESS
	CDRIVT==230			;INTERRUPT VECTOR ADDRESS

;DZ11 DEFINITIONS
	DZ11BA==3760010			;BASE ADDRESS FOR FIRST DZ11
	DZ11IV==340			;INTERRUPT VECTOR ADDRESS FOR FIRST DZ11
;PROCESSOR INSTRUCTIONS

OPDEF APRID [700000,,0]		;GET PROCESSOR SERIAL NUMBER, ETC.
OPDEF WRAPR [700200,,0]		;WRITE APR
OPDEF RDAPR [700240,,0]		;READ APR
OPDEF WRPI [700600,,0]		;WRITE THE PI SYSTEM
OPDEF RDPI [700640,,0]		;READ THE PI SYSTEM
OPDEF WRUBR [701140,,0]		;WRITE THE USER BASE REGISTER
OPDEF CLRPT [701100,,0]		;CLEAR PAGE TABLE ENTRY FOR EFF ADR
OPDEF RDUBR [701040,,0]		;READ THE USER BASE REGISTER
OPDEF WREBR [701200,,0]		;WRITE THE EXEC BASE REGISTER
OPDEF RDEBR [701240,,0]		;READ THE EXEC BASE REGISTER

; OPDEFS FOR KS10 UNIBUS ADAPTER

OPDEF TIOE [710000,,0]		;TEST IO NO MOD SKIP IF EQUAL
OPDEF TIOEB [720000,,0]		;TEST IO BYTE NO MOD SKIP IF EQUAL
OPDEF TION [711000,,0]		;TEST IO NO MOD SKIP IF NOT EQUAL
OPDEF TIONB [721000,,0]		;TEST IO BYTE NO MOD SKIP IF NOT EQUAL
OPDEF RDIO [712000,,0]		;READ I/O
OPDEF RDIOB [722000,,0]		;READ I/O BYTE
OPDEF WRIO [713000,,0]		;WRITE I/O
OPDEF WRIOB [723000,,0]		;WRITE I/O BYTE
OPDEF BSIO [714000,,0]		;BIT SET I/O
OPDEF BSIOB [724000,,0]		;BIT SET I/O BYTE
OPDEF BCIO [715000,,0]		;BIT CLEAR I/O
OPDEF BCIOB [725000,,0]		;BIT CLEAR I/O BYTE
OPDEF WRSPB [702400,,0]		;WRITE SPT BASE REGISTER
OPDEF RDSPB [702000,,0]		;READ SPT BASE REGISTER
OPDEF WRCSB [702440,,0]		;WRITE CORE STATUS TABLE BASE EGISTER
OPDEF RDCSB [702040,,0]		;READ CORE STATUS TABLE BASE REGISTER
OPDEF WRPUR [702500,,0]		;WRITE PROCESS USE REGISTER
OPDEF RDPUR [702100,,0]		;READ PROCESS USE REGISTER
OPDEF WRCSTM [702540,,0]	;WRITE CST MASK REGISTER
OPDEF RDCSTM [702140,,0]	;READ CST MASK REGISTER
OPDEF WRTIME [702600,,0]	;WRITE TIME BASE
OPDEF RDTIME [702200,,0]	;READ TIME BASE
OPDEF WRINT [702640,,0]		;WRITE INTERVAL TIMER
OPDEF RDINT [702240,,0]		;READ INTERVAL TIMER
OPDEF RDHSB [702300,,0]		;READ HALT STATUS BLOCK ADDRESS
OPDEF WRHSB [702700,,0]		;WRITE HALT STATUS BLOCK ADDRESS

;OPDEFS FOR KL10 INSTRUCTIONS WHICH WORK ON THE KS10

	OPDEF	ADJSP	[105B8]	;ADJUST STACK POINTER
	SOPDEF	PXCT	[XCT]	;PREVIOUS CONTEXT EXECUTE
	OPDEF	DADD	[114B8]	;DOUBLE ADD
	OPDEF	DSUB	[115B8]	;DOUBLE SUB
	OPDEF	DMUL	[116B8]	;DOUBLE MUL
	OPDEF	DDIV	[117B8]	;DOUBLE DIV
	OPDEF	ADJBP	[IBP]	;ADJUST BYTE POINTER

>;END IFN FTKS10
	SUBTTL	KI10/KL10/KS10 PAGE MAP LAYOUT

SECTAB==540			;LOCATION OF THE SECTION TABLE
MXSECN==37			;MAXIMUM SECTION NUMBER
.UPTVC==420			;LOCATION OF TRAP VECTOR
.USTVC==.UPMP+.UPTVC
.UPPFT==420			;LOCATION OF USER PAGE FAULT TRAP INSTRUCTION
.USPFT==.UPMP+.UPPFT
.UPAOT==421			;LOCATION OF USER ARITHMETIC TRAP INSTRUCTION
.USAOT==.UPMP+.UPAOT
.UPPDT==422			;LOCATION OF USER PUSH DOWN LIST OVERFLOW TRAP
.USPDT==.UPMP+.UPPDT
				; INSTRUCTION
.UP03T==423			;LOCATION OF USER TRAP 3 INSTRUCTION
.US03T==.UPMP+.UP03T
	UP.PFT==0		;PAGE FAIL TRAP MUUO
	UP.AOT==1		;ARITHMETIC TRAP UO
	UP.PDT==2		;PUSJ DOWN LIST OVERFLOW TRAP MUUO
	UP.03T==3		;TRAP 3 TRAP UUO
	UE.PFT==4		;USER ENABLED PAGE FAIL TRAP MUUO
	UE.AOT==5		;USER ENABLED ARITHMETIC TRAP MUUO
	UE.PDT==6		;USER ENABLED PDL OVERFLOW TRAP MUUO
	UE.03T==7		;USER ENABLED TRAP 3 TRAP MUUO
	UI.PFT==10		;PSI PAGE FAULT TRAP MUUO
	UI.AOT==11		;PSI ARITHMETIC TRAP MUUO
	UI.PDT==12		;PSI PDL OVERFLOW TRAP MUUO
	UI.03T==13		;PSI TRAP 3 TRAP MUUO
	UP.MLT==11		;MAXIMUM LEGAL TRAP NUMBER
.UPMUO==424			;LOCATION OF MUUO
.USMUO==.UPMP+.UPMUO
.UPMUP==425			;LOCATION OF MUUO PC
.USMUP==.UPMP+.UPMUP
.UPMUE==426			;MUUO EFFECTIVE ADDRESS CALCULATION
.USMUE==.UPMP+.UPMUE
.UPEPF==426			;LOCATION OF EXEC PAGE FAIL WORD
.USEPF==.UPMP+.UPEPF
.UPUPF==427			;LOCATION OF USER PAGE FAIL WORD
.USUPF==.UPMP+.UPUPF
.UPMTS==430			;START OF MUUO TRAP VECTOR
.USMTS==.UPMP+.UPMTS
.UPMTE==437			;END OF MUUO TRAP VECTOR
.USMTE==.UPMP+.UPMTE
.LMPFW==500			;(KL10)PAGE FAIL WORD
.LMPFP==501			;(KL10)PAGE FAIL OLD PC WORD
.LMPFN==502			;(KL10)PAGE FAIL NEW PC WORD
WSBTAB==.UPMP+440		;BIT-TABLE FOR WORKING SET
WSBTBL==<^D512+^D35>/^D36	;LENGTH OF WORKING SET BIT TABLE
AABTAB==WSBTAB+WSBTBL		;BIT TABLE FOR ACCESS-ALLOWED BITS
AABTBL==WSBTBL			;LENGTH OF ACCESS ALLOWED BIT TABLE

.LMEBH==504			;(KL10)HIGH ORDER PART OF EBOX CYCLE METER
.LMEBL==505			;(KL10)LOW ORDER PART OF EBOX CYCLE METER
.LMMBH==506			;(KL10)HIGH ORDER PART OF MBOX CYCLE METER
.LMMBL==507			;(KL10)LOW ORDER PART OF MBOX CYCLE METER

JOBPDO=.UUPMP+IFE FTKLP,<510>	;ORIGIN OF THE PUSH DOWN LIST
PDLLEN==142+IFN FTKLP,<14>	;LENGTH OF THE PUSH DOWN LIST
				; **********
				; PDLLEN MUST BE DEFINED SO THAT
				; USRHCU AND USRPC DO NOT FALL IN THE
				; SAME 4 WORD CACHE BLOCK
				; IF PDLLEN IS INCREASED, INCREASE
				; IT BY A MULTIPLE OF 4 WORDS.
				; **********
JOBPRO==JOBPDO+PDLLEN-<.UUPMP-.UPMP> ;ORIGIN OF THE 'PROTECTED JOB DATA AREA'
PRTLEN==114-71+IFN FTKLP,<1>	;LENGTH OF THE 'PROTECTED JOB DATA AREA'
.UPLPS==JOBPRO+PRTLEN-.UPMP	;LOCATION OF SAVED POINTER TO CURRENT VIRTUAL
.USLPS==.UPMP+.UPLPS		; PAGE NUMBER ON A SWAP IN/OUT

.UPSLX==.UPLPS+1		;RH=SWPLST INDEX - USED WHEN STARTING PAGING
.USSLX==.UPMP+.UPSLX		; I/O AT UUO LEVEL

.UPTMP==.UPSLX+1		;6 LOCATIONS USED AS TEMPORARIES WHILE SWAPPING
.USTMP==.UPMP+.UPTMP		; (USED ON A FRAGMENTED SWAP)

.UPUAC==.UPTMP+6		;BLOCK OF 20 ACS USED TO SAVE JOBS ACS
.USUAC==.UPMP+.UPUAC		; WHILE GETTING PFH.EXE

.UPFFT==.UPUAC+20		;VIRTUAL TIME OF FIRST PAGE FAULT
.USFFT==.UPMP+.UPFFT
.UPLFT==.UPFFT+1		;VIRTUAL TIME OF LAST FAULT
.USLFT==.UPMP+.UPLFT
.UPVCT==.UPLFT+1		;COUNT OF TOTAL FAULTS FOR JOB
.USVCT==.UPMP+.UPVCT		;LH="REAL" FAULTS, RH= COUNT OF FAULTS WHEN
				; THE PAGE IS IN CORE, PM.ACC=0
.UPREL==.UPVCT+1		;HIGHEST LOC GOTTEN BY COR UUO OR COMMAND
.USREL==.UPMP+.UPREL		; IF JOB IS HOLEY

.UPTMI==.UPREL+1		;INTERVAL FOR VIRT-TIME INTERRUPTS
.USTMI==.UPMP+.UPTMI
.UPTMC==.UPTMI+1		;COUNT-DOWN COUNTER FOR VIRT-TIME INTERRUPTS
.USTMC==.UPMP+.UPTMC
.UPNXP==.UPTMC+1		;PAGE RANGE SPECIFIED IN PAGE UUO ARGUMENT LIST
.USNXP==.UPMP+.UPNXP
.UPJOB==.UPNXP+1		;JOB NUMBER
.USJOB==.UPMP+.UPJOB
.UPMEM==.UPJOB+1		;TOTAL VIRTUAL MEMORY A JOB HAS
.USMEM==.UPMP+.UPMEM		; (OR 0 IF NOT VIRTUAL)

;NOTE THAT THE 2 FOLLOWING WORDS MUST BE IN THIS ORDER
.UPHSE==.UPMEM+1		;VIRTUAL ADR OF THE END OF THE HI SEG
.USHSE==.UPMP+.UPHSE
.UPHSS==.UPHSE+1		;VIRTUAL ADR OF THE START OF THE HI SEG
.USHSS==.UPMP+.UPHSS
.UPVRT==.UPHSS+1		;NON-0 IF JOB IS VIRTUAL(HAS DSK ADDRESS IN MAP)
.USVRT==.UPMP+.UPVRT		;LH FOR HI-SEG, RH FOR LOW SEG

.UPBTS==.UPVRT+1		;RANDOM COLLECTION OF BITS
.USBTS==.UPMP+.UPBTS
	UP.WHC==1B1		;WORKING SET HAS CHANGED
	UP.MGP==1B2		;MONITOR GOT PFH
	UP.GET==1B3		;RUNNING GET TO GET A PROGRAM TOO BIG TO FIT IN CORE
	UP.SAA==1B4		;SET ACCESS ALLOWED AUTOMATICALLY
	UP.CSP==1B5		;CORE IMAGE (MAY) CONTAIN SPY PAGES
	UP.MPF==1B6		;MERGING PFH - ON SO PFH DOESN'T GET PAGED OUT
	UP.MMO==1B7		;THIS JOB OWNED AND GAVE UP THE MM RESOURCE
				; OVER A CALL TO THE SCHEDULAR
	UP.PGB==1B8		;ON IF PAGING I/O PAGES HAVE NOT BEEN GIVEN BACK
	UP.IYB==1B9		;IN YOUR BEHALF PPN SPECIFIED (FOR IPCSER)
	UP.WSS==1B10		;WORKING SET IS SCRAMBLED
	UP.DST==1B11		;DON'T PUT TERMINAL AT MONITOR LEVEL (HNGSTF)
	UP.CXO==1B12		;CORE IMAGE (AS OPPOSED TO HIGH SEGMENT) IS XO
	UP.FIP==1B13		;FILOP IN PROGRESS
	UP.DDW==1B14		;DON'T DIDDLE WORKING SET (MIGRAT)
	UP.MIP==1B15		;MIGRAT SET LOK FOR THIS JOB
	UP.SWS==777777B35	;ADDRESS OF SAVED COPY OF WORKING SET
.UPANA==.UPBTS+1		;COUNT OF NON-ACCESSABLE PAGES
.USANA==.UPMP+.UPANA
.UPICT==.UPANA+1		;INCREMENTAL COUNT OF PAGE FAULTS
.USICT==.UPMP+.UPICT
.UPPFH==.UPICT+1		;COPY OF .JBPFH ON SWAP OUT (USED IF FTDHIA=-1)
.USPFH==.UPMP+.UPPFH
.UPFOP==.UPPFH+1		;USED BY FILOP. TO RECOVER FROM A PAGE FAIL
.USFOP==.UPMP+.UPFOP
SPYTBL==WSBTBL			;LENGTH OF SPY PAGES TABLE
SPYTAB==.UPMP+.UPFOP+1		;TABLE TO KEEP TRACK OF PAGES IN A PROGRAMS
				; ADDRESS SPACE WHICH ARE SPY PAGES
.UPHVA==.UPFOP+SPYTBL+1		;USED FOR ADDRESS CHECKING AT INTERRUPT LEVEL
.USHVA==.UPMP+.UPHVA
.UPLST==.UPHVA+1		;LH POINTER TO SWAPPABLE DDBS
.USLST==.UPMP+.UPLST		;RH POINTER TO SAVED CONTEXT BLOCK IN FUNNY SPACE

.UPFCC==.UPLST+1		;HEADER FOR CACHED (KI TOO) FREE SPACE
.USFCC==.UPMP+.UPFCC		;LH USED FOR TMPCOR FILE POINTERS

.UPFCU==.UPFCC+1		;HEADER FOR UNCACHED (KL ONLY) FREE SPACE
.USFCU==.UPMP+.UPFCU		;LH KEEPS TRACK OF LARGEST HOLE

.UPFCD==.UPFCU+1		;HEADER FOR RESTRICTED FREE SPACE
.USFCD==.UPMP+.UPFCD
.UPSWI==.UPFCD			;LH IS POINTER TO CORE COPY OF SWITCH.INI
.USSWI==.UPMP+.UPSWI
.UPLNM==.UPFCD+1		;RH=POINTER TO LOGICAL NAME SPACE
.USLNM==.UPMP+.UPLNM		;LH=T4

.UPCTA==.UPLNM+1		;RH=POINTER TO EXTENDED CHANNEL TABLE
.USCTA==.UPMP+.UPCTA
.UPMBF==.UPCTA+1		;ADDRESS OF MONITOR BUFFER
.USMBF==.UPMP+.UPMBF

.UPLBF==.UPMBF+1		;FLAG FOR USE OF EXTRA PAGE FOR DIRECTORY
.USLBF==.UPMP+.UPLBF		;SEARCHES - 0=DONT GET, POSITIVE=CAN GET,
				;NEGATIVE=IOWD FOR IT

.UPSBF==.UPLBF+1		;SAVED .UPMBF WHEN DOING 4-BLOCK READ
.USSBF==.UPMP+.UPSBF
.UPEND==.UPSBF+1		;LAST WORD ALLOCATED IN THE UPMP
.USEND==.UPMP+.UPEND
				; NEW VARIABLES SHOULD GO BEFORE THIS

;LOCATIONS IN THE USER PER PROCESS MAP

.MUPMP==414			;LEFT HALF MAPS UNCACHED REFERENCES TO THE UPMP
.MJDAT==414			;RIGHT HALF WORD MAPS JOBDAT IN EXEC VIRTUAL MEMORY
.MVJDT==.MJDAT+1		;LEFT HALF WORD MAPS VESTIGIAL JOBDAT IN EXEC
				; VIRTUAL MEMORY
.MTEMP==.MVJDT			;RIGHT HALF WORD USED FOR TEMPORARY MAPPINGS IN EVM
.MJBPK==.MTEMP+1		;LEFT HALF WORD MAPS TEMPORARYS USED BY JOBPEK UUO
.MJBP1==.MJBPK			;RIGHT HALF WORD MAPS TEMPORARIES USED BY JOBPEK UUO
.MJBP2==.MJBP1+1		;LEFT HALF WORD MAPS TEMPORARIES USED BY JOBPEK UUO
.MUUPM==.MJBP2			;RIGHT HALF MAPS CACHED REFERENCES TO THE UPMP
;LOCATIONS IN THE EXEC MAP
.MEUPM==200			;LEFT HALF WORD MAPS THE UPMP TO SETUP .UPMP
.MERPL==.MEUPM		;RECLAIM LOCATIONS USED BY INTERRUPT LEVEL PROCESSING
.MECKS==200			;RIGHT HALF WORD USED FOR MAPPING SWAPPING CHECKSUM
REPEAT 0,<;OBSOLETE
;THE NEXT SEVEN HALF WORDS ARE RESERVED FOR TEMPORARY MAPPING AT
; INTERRUPT LEVEL (ONE FOR EACH PI LEVEL) SO THAT INTERRUPT
; LEVEL USAGE OF THE MAP CAN BE REENTRANT. THE LOCATIONS MUST
; BE CONTIGUOUS AND START ON A WORD BOUNDARY SO THAT A
; CONI PI TO GET PIS IN PROGRESS CAN BE USED TO DECIDE WHICH
; HALF WORD TO USE.
;NOTE: CHECK CODE AT SYSTRT FOR SETTING
; UP CDB MAPPING WHEN CHANGING .MSKPC
.MERPL==201	;START OF 7 HALF WORDS USED FOR MAPPING AT IRP LEVEL
.MERP1==201	;LEFT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 1 IN PROGRESS
.MERP2==201	;RIGHT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 2 IN PROGRESS
.MERP3==202	;LEFT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 3 IN PROGRESS
.MERP4==202	;RIGHT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 4 IN PROGRESS
.MERP5==203	;LEFT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 5 IN PROGRESS
.MERP6==203	;RIGHT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 6 IN PROGRESS
.MERP7==204	;LEFT HALF WORD USED FOR TEMPORARY MAPPING WHEN PI 7 IN PROGRESS
.MERUL==204	;RIGHT HALF WORD USED FOR MAPPING AT UUO LEVEL
.MSKPC==205	;LEFT HALF WORD USED FOR MAPPING SKPCPU
RHWEVM==^D11	;NUMBER OF RESERVED HALF WORDS OF EVM, THIS
		; NUMBER MUST BE INCREASED AS NEW RESERVED
		; HALF WORDS ARE ADDED
>;END REPEAT 0
.MSKPC==201	;USED FOR MAPPING SKPCPU
RHWEVM==^D3

;EXEC VIRTUAL MEMORY ADDRESSES (MAPPED THROUGH THE EXEC MAP)
.EAHUA==337777		;EXEC VIRTUAL ADDRESS OF HIGHEST "UNMAPPED" WORD
			; (I.E., MAPPED ONE-TO-ONE VIRTUAL-TO-PHYSICAL)
.EUPMP==400000		;EXEC VIRTUAL ADDRESS OF THE UPMP TO SETUP .UPMP
.ERPIL==.EUPMP	;EXEC VIRTUAL ADDRESS USED FOR MAKING PHYSICAL REFERENCES
.ECKSM==401000		;EXEC VIRTUAL ADDRESS OF THE SWAPPING CHECKSUM
REPEAT 0,<;OBSOLETED
.ERPIL==402000		;EXEC VIRTUAL ADDRESS OF RESERVED PI TEMPORARIES
.ESKPC==412000		;EXEC VIRTUAL ADDRESS OF PAGE CONTAINING SKPCPU
>;END REPEAT 0
.ESKPC==402000	;EXEC VIRTUAL ADDRESS OF THE CPU DATA BLOCK
.EPCDB==.ESKPC		;EXEC VIRTUAL ADDRESS OF THE CPU DATA BLOCK
IFN FTKL10!FTKS10,<
RHWEVM==RHWEVM+1	;THE CDB IS TWO PAGES LONG ON A KL10 AND KS10
>
IFE FTKLP,<
PAGTAB==400000+RHWEVM*1000
PAGTBL==^D16
ifn ftki10,pagtbl==^d7		;[JE] shrink to 1.5 megawords.
ifn ftks10,pagtbl==2		;[ROLL] shrink to .5 megawords.
MEMTAB==PAGTAB+PAGTBL*1000
MEMTBL=PAGTBL
MONORG==MEMTAB+MEMTBL*1000
HIORG==400000
>
IFN FTKLP,<
PAGTAB==0
PAGTBL==^D16
ifn ftks10,pagtbl==2		;[ROLL] shrink to .5 megawords.
MEMTAB==PAGTAB+PAGTBL*1000
MEMTBL=PAGTBL
MONORG==400000+RHWEVM*1000
HIORG==400000
>
;BITS IN THE DATAO PTR (OPERATING CONSOLE) WORD

OC.BCI==1B0			;BREAK CONDITION INSTRUCTION FETCH
OC.BCD==1B1			;BREAK CONDITION DATA FETCH
OC.BCW==1B2			;BREAK CONDITION WRITE
OC.BCM==1B3			;BREAK CONDITION MUUO (SOFTWARE BIT)
OC.ABE==1B4			;ADDRESS BREAK ENABLED
OC.FEP==1B5			;FOLLOW EXEC PAGING
OC.FUP==1B6			;FOLLOW USER PAGING
OC.BSU==1B7			;BREAK ADDRESS AND CONDITIONS SET BY UUO

;BITS 14-35 SET ADDRESS SWITCHES

;PAGE FAILURE NUMBERS (STORED IN THE PF WORD ON A PAGE FAILURE)

IFN FTKI10!FTKL10,<
PF.SUV==20			;SMALL USER VIOLATION
PF.PRV==21			;PROPRIETARY VIOLATION
PF.PRF==22			;PAGE REFILL FAILURE
PF.ABF==23			;ADDRESS BREAK FAILURE
PF.IID==24			;ILLEGAL INDIRECT (BITS 0 & 1 =1)
PF.PTP==25			;PAGE TABLE PARITY ERROR
PF.ISN==27			;ILLEGAL SECTION NUMBER
PF.ARP==36			;AR PARITY ERROR
PF.AXP==37			;ARX PARITY ERROR
>;IFN FTKI10!FTKL10

IFN FTKS10,<
PF.IOP==20			;UBA ADDRESS FAILURE (I/O PAGE FAILURE)
PF.PTP==25			;PAGE TABLE PARITY ERROR
PF.PAR==36			;UNCORRECTABLE (HARD) MEMORY PARITY ERROR
PF.NXM==37			;NXM
>;IFN FTKS10

;BITS IN THE PAGE FAIL WORD

IFN FTKI10,<
PF.USR==1B8			;PAGE FAILURE CAUSED BY A REFERENCE TO A PAGE
				; IN THE USER'S VIRTUAL ADDRESS SPACE
>
IFN FTKL10!FTKS10,<
PF.USR==1B0			;PAGE FAILURE CAUSED BY A REFERENCE TO A PAGE
				; IN THE USER'S VIRTUAL ADDRESS SPACE
PF.PHY==1B8			;PAGE FAILURE WAS CAUSED BY A PHYSICAL REFERENCE
>;IFN FTKL10!FTKS10
REPEAT 0,<
;NOTE THAT THE SOURCES HAVE BEEN EDITED SO THAT THESE TESTS NO LONGER APPEAR
	SUBTTL	FEATURE TEST SWITCHES WHICH MUST BE ON

;LIST OF INDEPENDENT MONITOR COMMAND FEATURES
;WILL BE FOUND IN FILE F.MAC. THOSE FEATURE TEST SWITHCES
;WHICH MUST BE ON ARE FOUND HERE.

; ( -1 MEANS INCLUDE THE ASSOCIATED FEATURE, 0 MEANS ELIMINATE IT )

XP FTSWAP,-1	;SWAPPING SYSTEM
		;IF FTSWAP=-1, THEN FTDISK MUST BE -1
		; APPEARS IN CLOCK1, COMCON, COMMON, CORE1, DPCINT, DPCREF,
		;  DPDINT, DPDREF, DSKSER, DTASRN, FHDINT, FHDREF, MDFINT,
		;  MDFREF, SCHED, SCNSRH, SEGCON, SYSINI, AND UUOCON.

XP FTDISK,-1	;DISK SYSTEM (MAY OR MAY NOT HAVE SWAPPING)
		;IF FTDISK=-1, THEN FTLOGIN MUST BE -1
		;IF FTSWAP=-1, THEN FTDISK MUST BE -1
		; APPEARS IN CLKCSS, COMCON, COMMON, ONCE, SCHED, SEGCON,
		;  SYSINI, AND UUOCON.

XP FTLOGIN,-1	;LOGIN-LOGOUT COMMAND AND UUOS
		;FTDISK=-1 IMPLIES FTLOGIN=-1
		; APPEARS IN CLOCK1, COMCON, SCNSRF, SCNSRH, AND UUOCON

XP FTCCL,-1	;CONCISE COMMAND LANGUAGE COMMANDS
		;SHOULD BE 0 IN NON-DISK SYSTEMS
		;SHOULD BE -1 IN DISK SYSTEMS, WHEN IMPLEMENTED
		; APPEARS IN COMCON
>;END REPEAT 0
XP FTVM,-1	;ONLY DEFINED SO THAT JOBDAT ASSEMBLES CORRECTLY
	SUBTTL	SYSTEM MACROS -- GENERAL

;MACROS TO CONVERT FROM DOUBLE WORD TO SINGLE WORD PCS AND VICE-VERSA

DEFINE	GETPC	(AC,LOC)<
	SALL
IFE FTKLP,<
	MOVE	AC,LOC
>
IFN FTKLP,<
	PUSHJ	P,[	MOVE	AC,LOC+1
;			TLNE	AC,7777
;			STOPCD	.+1,DEBUG,NZS,
			HLL	AC,LOC
			POPJ	P,]
>
>
DEFINE	GETPCS	(AC,LOC)<
	SALL
IFE FTKLP,<
	SKIPA	AC,LOC
>
IFN FTKLP,<
	PUSHJ	P,[	AOS	(P)
			MOVE	AC,LOC+1
;			TLNE	AC,7777
;			STOPCD	.+1,DEBUG,NZS,
			HLL	AC,LOC
			POPJ	P,]
>
>
DEFINE	PUTPC	(AC,LOC)<
	SALL
IFE FTKLP,<
	MOVEM	AC,LOC
>
IFN FTKLP,<
	PUSHJ	P,[	HLLZM	AC,LOC
			HRRZM	AC,LOC+1
			POPJ	P,]
>
>

;MACRO TO MAKE IT EASY TO USE "POPM" IF IT EVER GETS IMPLEMENTED
DEFINE	RETSKP,<
	IFNDEF	CPOPJ1,<EXTERNAL CPOPJ1>
	JRST	CPOPJ1
>

;MACRO TO PREVENT SCHEDULING, USED AT UUO LEVEL WHEN A
;REENTRANT ROUTINE IS CHANGING COMMON DATA NOT YET
;ASSIGNED TO A PARTICULAR JOB

DEFINE NOSCHED
<>

;MACRO TO ALLOW SCHEDULING ONCE MORE

DEFINE SCHEDULE
<>
;MACRO TO PREVENT INTERRUPTS ON A CPU-BASIS
DEFINE	SYSPIF<
IFE FTMP,<
	CONO	PI,PI.OFF
>
IFN FTMP,<IFNDEF LOKSPI,<EXTERN LOKSPI>
	PUSHJ	P,LOKSPI
>>

;MACRO TO REENABLE INTERRUPTS ON A CPU-BASIS
DEFINE	SYSPIN(A)<
IFN FTMP,<IFNDEF UNLSPI,<EXTERN UNLSPI,UNLSPT>
IFB <A><PUSHJ P,UNLSPI>
IFNB <A><PUSHJ P,UNLSPT
	CONO PI,PI.ON+A>
>
IFE FTMP,<
IFB <A><CONO PI,PI.ON>
IFNB <A><CONO PI,PI.ON+A>
>>

;MACRO TO PREVENT INTERRUPTS ON A DEVICE-BASIS
DEFINE PIOFF<
IFE FTMP,<
IFNDEF SYSOFF,<EXTERN SYSOFF>
	CONO	PI,SYSOFF
>
IFN FTMP,<
IFNDEF LOKDPI,<EXTERN LOKDPI>
	PUSHJ	P,LOKDPI
>>

;MACRO TO REENABLE INTERRUPTS ON A DEVICE-BASIS
DEFINE PION<
IFE FTMP,<
IFNDEF SYSON,<EXTERN SYSON>
	CONO	PI,SYSON
>
IFN FTMP,<
IFNDEF UNLDPI,<EXTERN UNLDPI>
	PUSHJ	P,UNLDPI
>>

;MACRO TO PREVENT INTERRUPTS FOR BIT DIDDLERS (SETOS,CLRBTS)
DEFINE	BTSOFF,<
IFE FTMP,<
	CONO	PI,PI.OFF
>
IFN FTMP,<
IFNDEF LOKBTI,<EXTERNAL LOKBTI>
	PUSHJ	P,LOKBTI
>>

;MACRO TO REENABLE INTERRUPTS FOR BIT DIDDLERS
DEFINE	BTSON,<
IFE FTMP,<
	CONO	PI,PI.ON
>
IFN FTMP,<
IFNDEF UNLBTI,<EXTERNAL UNLBTI>
	PUSHJ	P,UNLBTI
>>

;MACRO TO INTERLOCK BUFFER MANAGEMENT (CACHE)
DEFINE	NBFOFF,<
IFN FTMP & FTKL10,<
IFNDEF	LOKNBI,<EXTERNAL LOKNBI>
	PUSHJ	P,LOKNBI
>>

;MACRO TO FREE UP BUFFER MANAGEMENT INTERLOCK
DEFINE NBFON,<
IFN FTMP & FTKL10,<
IFNDEF	UNLNBI,<EXTERNAL UNLNBI>
	PUSHJ	P,UNLNBI
>>

ND	NLSTAL,5	;NUMBER OF LONG NOOPS TO EXECUTE IF A LOCK ISN'T AVAILABLE
	DEFINE	LSTALL,<
XLIST
	JRST	[REPEAT NLSTAL,<
		 IMULI P,1	;ALLOW OTHER PROCESSORS TO GET TO MEMORY
	>
		 JRST .-1]
LIST
>
IFN FTMP,<
;MACRO TO PREVENT DDB-SCAN RACES
DEFINE DDBSRL<
IFNDEF DSKPIF,<EXTERNAL DSKPIF>
	CONO	PI,DSKPIF
	AOSE	INTRDD##
	LSTALL
IFN FTKI10,<
	CONI	PAG,INTODD##
>
IFN FTKL10,<
	APRID	INTODD##
>
>

;MACRO TO UNLOCK DDB-SCAN
DEFINE DDBSRU<
	SETOM	INTRDD##
	SETOM	INTODD##
IFNDEF DSKPIN,<EXTERNAL DSKPIN>
	CONO	PI,DSKPIN
>
>;END IFN FTMP
IFE FTMP,<
DEFINE DDBSRL<>
DEFINE DDBSRU<>
>;END IFN FTMP

IFN FTMP,<
;GENERAL UUO-LEVEL LOCK
DEFINE	UUOLOK<
	AOSE	INTRUU##
	LSTALL
IFN FTKI10,<
	CONI	PAG,INTOUU##
>
IFN FTKL10,<
	APRID	INTOUU##
>
>
DEFINE	UUONLK<
	SETOM	INTRUU##
	SETOM	INTOUU##
>
>
IFE FTMP,<
DEFINE	UUOLOK<>
DEFINE	UUONLK<>
>
IFN FTMP,<
;INTERLOCK ON CLOCK QUEUE PROCESSING
DEFINE	CLKLOK<
	AOSE	INTRCL##
	LSTALL
IFN FTKI10,<
	CONI	PAG,INTOCL##
>
IFN FTKL10,<
	APRID	INTOCL##
>
>
DEFINE	CLKNLK<
	SETOM	INTRCL##
	SETOM	INTOCL##
>
>
IFE FTMP,<
DEFINE	CLKLOK<>
DEFINE	CLKNLK<>
>
;INTERLOCK ON EMERGENCY PROCESSING
DEFINE	DIELOK<
	AOSE	INTDIE##
	LSTALL
IFN FTKI10,<
	CONI	PAG,INODIE##
>
IFN FTKL10,<
	APRID	INODIE##
>
>
DEFINE	DIENLK<
	SETOM	INTDIE##
	SETOM	INODIE##
>
IFE FTMP,<
DEFINE	DIELOK<>
DEFINE	DIENLK<>
>
	SUBTTL	SYSTEM MACROS -- AIDS TO EXTENDED ADDRESSING

;THESE MACROS ARE DEFINED TO PRODUCE CODE THAT CAN RUN UNDER BOTH
;KL PAGING AND KI PAGING. UNDER KI PAGING THEY WILL PRODUCE CODE
;WHICH WILL RUN IN SECTION 0, AND UNDER KL PAGING THEY WILL PRODUCE
;CODE WHICH RUNS IN AN EXTENDED SECTION. NOTE THAT IF KL PAGING IS
;ON, THE CODE MUST BE EXECUTED IN AN EXTENDED SECTION.

	SOPDEF	IFIW	[1B0]		;INSTRUCTION FORMATTED INDIRECT WORD
	OPDEF	XMOVEI	[SETMI]		;MOVEI WITH PC SECTION NUMBER

;MACRO TO DEFINE AN INDIRECT WORD. IN KI PAGING, IT GENERATES AN ORDINARY
;STANDARD INSTRUCTION FORMATTED INDIRECT WORD, AND IN KL PAGING IT GENERATES
;A FULL GLOBAL INDIRECT WORD.
;	SECTION CAN BE ANY SECTION NUMBER (LH) BETWEEN 0 AND 37
;	ADDR CAN BE ANY 18 BIT ADDRESS PLUS INDIRECTION AND INDEXING.

IFE FTKLP,<DEFINE IW(SECTION,ADDR),<Z ADDR>>
IFN FTKLP,<DEFINE IW(SECTION,ADDR),<SALL
	EA==<Z ADDR>
	IFN <SECTION&<777740,,777777>>!<EA&<777740,,0>>,<
		PRINTX ?INVALID INDIRECT WORD SECTION,ADDR
		EXP 0,,0 ;;GENERATE Q ERROR
		>
	IDX==<<EA&<37,,0>>_-22>
	OFS==<EA&777777>
	IFN <OFS&400000>,<OFS==777777,,OFS>
	EXP <<IDX>B5!<SECTION+<OFS>B35>>
	PURGE EA,OFS,IDX
	>;END DEFINE IW
>; END IFN FTKLP


;MACRO TO CALL A SUBROUTINE IN SECTION 0, RETURNING TO THE CURRENT
;SECTION WHEN DONE. IN KI PAGING THIS RESOLVES TO A PUSHJ.

IFE FTKLP,<DEFINE S0PSHJ(ADDR),<PUSHJ P,ADDR>>
IFN FTKLP,<DEFINE S0PSHJ(ADDR),<SALL
	IFNDEF SSEC0,<EXTERN SSEC0>
	PUSHJ	P,[PUSHJ P,SSEC0
		JRST ADDR]
		>;END DEFINE S0PSHJ
>;END IFN FTKLP

;MACRO TO PJRST TO A SUBROUTINE IN SECTION 0. SAME AS S0PSHJ BUT
;DOES A PJRST INSTEAD OF A PUSHJ.

IFE FTKLP,<DEFINE S0JRST(ADDR),<JRST ADDR>>
IFN FTKLP,<DEFINE S0JRST(ADDR),<SALL
	IFNDEF SSEC0,<EXTERN SSEC0>
	JRST	[PUSHJ P,SSEC0
		JRST ADDR]
	>;END DEFINE S0JRST
>;END IFN FTKLP

	SUBTTL	SYSTEM MACROS -- MACSYM FIXUPS (ALLOW US TO USE TOPS-20 MACSYM)

DEFINE TENSYM,<		;;FIXUP KNOWN MACSYM PROBLEMS. SHOULD
			;;OCCUR IN THE SOURCE AFTER THE SEARCH OF MACSYM
	P=1		;;THE STACK POINTER
	R=3		;;MAKE SURE THAT THE "R" WE USE IS TOPS10
	CX==R		;;SUPER-TEMP AC. FOR USE BY MACROS
	.SAC==CX	;;THE SUPER-TEMP AC FOR MACROS TO USE
	.A16==CX	;;THE SUPER-TEMP AC AGAIN, FOR TRVAR
	.FPAC==P1	;;FIRST PRESERVED AC FOR ACVAR		[FOR SAVEAC]
	.NPAC==2	;;NUMBER OF PRESERVED ACS (P1 - P2)	[FOR SAVEAC]
	MACVER==MACVER	;;MAKE THE MACSYM VERSION ACCESIBLE
OPDEF	CALL	[PUSHJ P,0]	;HAS TO BE REDEFINED 'CAUSE P CHANGES
OPDEF	RET	[POPJ  P,0]	;;ALSO HAS TO BE REDEFINED
	.NODDT	CALL,RET

DEFINE JSERR(B,C,D),<PRINTX ?JSERR MACRO NOT SUPPORTED UNDER TOPS10>

>
	SUBTTL	SYSTEM MACROS -- NETSER INTERLOCK MANAGEMENT
;THE FOLLOWING FIVE MACROS ARE USED TO INTERLOCK THE NETSER DATABASE
;
;  NETDBL	THIS MACRO LOCKS THE DATABASE.  IT MUST BE CALLED FROM
;		UUO LEVEL, AND IT MAY NOT BE CALLED RECURSIVLY!
;  NETDBU	THIS MACRO UNLOCKS THE DATABASE.  (COMPLEMENT OF NETDBL)
;  NETDBJ	IF THE CURRENT JOB ALREADY OWNS THE INTERLOCK, THIS
;		OPERATION DOES NOTHING.  OTHERWISE IT LOCKS THE DATABASE
;		AND COROUTINES BACK TO THE CALLING ROUTINE.  WHEN THAT
;		ROUTINE POPJ'S (OR POPJ1'S) IT WILL UNLOCK THE DATABASE.
;  NTDBLI	THIS OPERATION IS USED TO LOCK THE DATABASE FROM INTERRUPT
;		LEVEL.  IT SKIP RETURNS IF THE DATABASE WAS AVAILABLE.
;		ERROR RETURN'S IF IT WAS LOCKED.
;  NTDBUI	THIS OPERATION IS USED TO UNLOCK THE DATABASE FROM INTERRUPT
;		LEVEL.
;  NTSAVE	THIS OPERATION IS USED RETURN THE INTERLOCK FOR THE
;		DURATION OF ONE SUBROUTINE CALL. (DOES NOTHING IF CURRENT
;		JOB DOES NOT OWN THE INTERLOCK)
;  NTGIVE	THIS MACRO IS USED TO GIVE UP THE INTERLOCK CONDITIONAL
;		ON THE PROCESS'S HAVING IT.  USED IN ERROR ROUTINES
;  NTDBUG	THIS MACRO IS USED TO AID IN DEBUGGING THIS MESS.
;		IT TAKES TWO ARGUMENTS.  THE GOVERNS THE CHECK REGARDING
;		WHO HAS THE INTERLOCK.  THE SECOND GOVERNS CHECKING ABOUT
;		INTERRUPT VS UUO LEVEL.
;		FIRST ARG VALUES:
;		  EITHER	MEANS DON'T WORRY ABOUT WHO HAS THE INTERLOCK
;		  YES		SAYS TO STOP IF THE CURRENT PROCESS DOES NOT
;				HAVE THE INTERLOCK.  (THIS IS THE DEFAULT IF NO
;				ARGUMENT IS SPECIFIED)
;		  NO		SAYS TO STOP IF THE CURRENT PROCESS HAS THE
;				INTERLOCK
;		SECOND ARG VALUES:
;		  EITHER	MEANS DON'T WORRY ABOUT WHAT LEVEL THE CURRENT
;				PROCESS IS RUNNING AT.  (THIS IS THE DEFAULT)
;		  INT		SAYS TO STOP IF THE CURRENT PROCESS IS NOT AT
;				EITHER CLOCK (SCHEDULER), OR INTERRUPT LEVEL
;		  UUO		SAYS TO STOP IF THE CURRENT PROCESS IS NOT AT
;				UUO LEVEL. (STACK IN THE .UPMP)
;

DEFINE	NETDBL,<
	IFNDEF NTLCLK,<EXTERNAL NTLCLK>
	PUSHJ	P,NTLCLK
>

DEFINE	NETDBU,<
	IFNDEF NTUNLK,<EXTERNAL NTUNLK>
	PUSHJ	P,NTUNLK
>

DEFINE	NETDBJ,<
	IFNDEF NTLCKJ,<EXTERNAL NTLCKJ>
	PUSHJ	P,NTLCKJ
>
DEFINE	NTDBLI,<
	IFNDEF NTLCKI,<EXTERNAL NTLCKI>
	PUSHJ	P,NTLCKI
>

DEFINE	NTDBUI,<
	IFNDEF NTULKI,<EXTERNAL NTULKI>
	PUSHJ	P,NTULKI
>

DEFINE	NTSAVE,<
	IFNDEF NTSAV,<EXTERNAL NTSAV>
	PUSHJ	P,NTSAV
>

DEFINE	NTGIVE,<		;;ROUTINE TO GIVE UP THE INTERLOCK ON AN ERROR
	IFNDEF NTLERR,<EXTERNAL NTLERR>
	PUSHJ	P,NTLERR>	;;GIVE UP THE INTERLOCK ONLY IF WE OWN IT

DEFINE	NTDBUG(HAVEIT,LEVEL),<
	IFNDEF NTCHCK,<EXTERNAL NTCHCK>
	IFNDEF NTDSTP,<EXTERNAL NTDSTP>
	IFNDEF UUOLVL,<EXTERNAL UUOLVL>
	IFNDEF INTLVL,<EXTERNAL INTLVL>

ZZZ==0				;;FLAG TO HELP CHECK THE ARG'S VALIDITY

IFB <LEVEL>,<ZZZ==1>		;;IF WE WEREN'T ASKED TO, DON'T CHECK LEVEL
IFNB <LEVEL>,<			;;HERE WE MUST VALIDATE THE LEVEL PARAMETER
  IFIDN <LEVEL><EITHER>,<ZZZ==1>;;EITHER MEANS EITHER LEVEL IS OK
  IFIDN <LEVEL><UUO>,<ZZZ==1	;;HERE VERIFY UUO LEVEL
	PUSHJ	P,UUOLVL	;;SEE IF IT'S UUO LEVEL
	 PUSHJ	P,NTDSTP>	;;STOP IF THE LEVEL IS WRONG
  IFIDN <LEVEL><INT>,<ZZZ==1	;;HERE VERIFY INTERRUPT LEVEL
	PUSHJ	P,INTLVL	;;SEE IF IT'S INTERRUPT LEVEL
	 PUSHJ	P,NTDSTP>>	;;STOP IF THE LEVEL IS WRONG

IFE ZZZ,<PRINTX ?BAD SECOND ARG (= LEVEL ) TO NTDBUG MACRO?>

ZZZ==0

IFB <HAVEIT>,<ZZZ==2>		;;DEFAULT IS TO VERIFY THAT WE HAVE IT (2)
IFIDN <HAVEIT><EITHER>,<ZZZ==1>	;;EITHER MEANS WE DON'T CARE
IFIDN <HAVEIT><YES>,<ZZZ==2>	;;YES MEANS WE SHOULD CHECK FOR IT
IFIDN <HAVEIT><NO>,<ZZZ==3>	;;NO MEANS WE SHOULD MAKE SURE WE DON'T HAVE IT

IFE ZZZ,<PRINTX ?BAD FIRST ARG (= HAVEIT ) TO NTDBUG MACRO?>
IFGE ZZZ-2,<			;;IF WE HAVE TO CHECK,
	PUSHJ	P,NTCHCK	;;CALL THE ROUTINE THAT CHECKS
  IFE ZZZ-3,<JRST .+2>		;;IF WE ARE IN A "NO" CLAUSE, INVERT THE CHECK
	 PUSHJ	P,NTDSTP>	;;STOP IF WE DO/DON'T HAVE THE LOCK

ZZZ==0				;;CLEAN UP
>				;;END OF NTDBUG MACRO
;MACRO TO PREVENT CORE SHUFFLING, USED AT UUO LEVEL WHEN
;A ROUTINE SETS UP AN ABSOLUTE USER ADDRESS IN AN AC
;OTHER THAN P,R, OR R. THE MAIN EXAMPLE IS A BLT
;FROM EXEC TO USER OR USER TO EXEC.

DEFINE NOSHUFF
<>

;MACRO TO ALLOW SHUFFLING ONCE MORE

DEFINE	SHUFFLE
<>



;MACRO TO START A DEVICE FROM UUO LEVEL
;T1:=XWD DEVINT FLAGS,CONO ARGUMENTS

DEFINE STARTDV (A)
<
	CONO	PI,PI.OFF
	CONO	A,(T1)
	HLRM	T1,A'CON
	CONO	PI,PI.ON
>
	SUBTTL	SYSTEM MACROS -- STOPCD

;MACRO TO GENERATE CODE FOR FATAL ERROR CONDITIONS
;CALL WITH:
;	STOPCD	CONT,TYPE,NAME,TYPOUT,	;++COMMENT
;WHERE:
;CONT IS THE CONTINUE ADDRESS FOR THIS CONDITION.
;TYPE IS THE TYPE OF ERROR. IT MUST BE ONE OF THE FOLLOWING:
;	HALT  - GENERATE A HALT INSTRUCTION (USE ONLY IN DISPATCH TABLES, ETC.)
;	STOP  - STOP THE SYSTEM (MAJOR ERROR)
;	JOB   - STOP JOB (MAJOR ERROR IN A DEVICE SERVICE ROUTINE OR UUO)
;	DEBUG - GO TO CONTINUE ADDRESS
;	CPU   - SAME AS STOP ON A SINGLE CPU SYSTEM, IF THIS IS THE LAST
;	        CPU RUNNING ON A MULTIPROCESSOR SYSTEM OR IF DF.CP1 IS
;	        SET.  IN ALL OTHER CASES, STOP ONLY THE CPU ON WHICH THE
;	        ERROR WAS DETECTED.
;NAME IS A THREE LETTER NAME FOR THIS ERROR. IT MUST BE UNIQUE.
;TYPOUT IS AN ADDITIONAL ROUTINE TO CALL FOR ADDITIONAL OUTPUT
DEFINE	STOPCD(CONT,TYPE,NAME,TYPOUT),<
	SALL		;;CLEAN LISTING

	CONTYP==^O17	;;TYPE OF CONTINUE

IFIDN <CONT><.><	CONTYP==0>
IFIDN <CONT><.+1><	CONTYP==1>
IFIDN <CONT><CPOPJ><	CONTYP==2>
IFIDN <CONT><CPOPJ##><	CONTYP==2>
IFIDN <CONT><CPOPJ1><	CONTYP==3>
IFIDN <CONT><CPOPJ1##><	CONTYP==3>

;;TYPE OF ACTION TO TAKE ON STOPCD

	ACTTYP==-1

IF2 <
IFB <TYPE><	PRINTX	?MISSING STOPCD ACTION - SEE %%.'NAME IN CREF>>

IFIDN <TYPE><HALT><	ACTTYP==0>	;;GENERATE A HALT
IFIDN <TYPE><STOP><	ACTTYP==1>	;;STOP THE SYSTEM
IFIDN <TYPE><JOB><	ACTTYP==2>	;;STOP THE JOB
IFIDN <TYPE><DEBUG><	ACTTYP==3>	;;CONTINUE
IFIDN <TYPE><CPU><	ACTTYP==4>	;;STOP CPU

IFL	ACTTYP,<
IF2 <
	PRINTX	?STOPCD NAME IS IN ERROR -- SEE %%.'NAME IN CREF
>
%%.'NAME::	;;SO WE CAN FIND THE BAD STOPCD
	ACTTYP==0	;;GENERATE A HALT
>
IFB <NAME><	PRINTX	?STOPCD WITHOUT A NAME. -- SEE S.. IN CREF>

IFE	ACTTYP,<
S..'NAME::!JRST	4,CONT		;ERROR NAME
>
IFN	ACTTYP,<
IFNB <TYPOUT>,<ACTTYP==ACTTYP+10>
IF2 ,<IFNDEF	DIE,< EXTERNAL DIE>>
S..'NAME::!PUSHJ	P,DIE		;****** NAME STOP ******
	SIXNAM==<SIXBIT /NAME/>
	SIXNAM=SIXNAM_<-^D18>
IFN <CONTYP-17>,<
IFB <TYPOUT>,<
	BYTE	(9)^O300(4)ACTTYP(1)0(4)CONTYP(18)SIXNAM
>
IFNB <TYPOUT>,<
	BYTE	(9)^O300(4)ACTTYP(1)0(4)CONTYP(18)[TYPOUT,,SIXNAM]
>
>
IFE <CONTYP-17>,<
IFB <TYPOUT>,<
	BYTE	(9)^O304(4)ACTTYP(1)0(4)CONTYP(18)SIXNAM
>
IFNB <TYPOUT>,<
	BYTE	(9)^O304(4)ACTTYP(1)0(4)CONTYP(18)[TYPOUT,,SIXNAM]
>
	JRST	CONT		;RECOVER FROM NAME STOP
>>
	PURGE	CONTYP,ACTTYP,SIXNAM
>
	SUBTTL	SYSTEM MACROS -- FRAME

;MACRO TO DEFINE A BUNCH OF WORDS ON THE STACK.
;EACH ARGUMENT TO THE FRAME MACRO ALLOCATES 1 WORD ON THE
; STACK AND DEFINES A MACRO WITH THE SAME NAME AS -N(P).
;
;NOTE: THIS MACRO DEFINES THINGS IN TERMS OF (P) AND THEREFOR
; NOTHING ELSE MAY BE PUSHED ON THE STACK!!!

DEFINE	FRAME(LIST,%A),<
	%%%N==0			;ARGUMENT COUNT
IRP LIST,<
	%FRAM1(LIST,\<%%%N+1>)	;DEFINE MACRO
	%%%N==%%%N+1		;BUMP COUNT
>
IFE FTKL10!FTKS10,<
	ADD	P,[%%%N,,%%%N]	;ALLOCATE THE SPACE
	JUMPGE	P,S..EPO##	;SHOULD NEVER HAPPEN
>
IFN FTKL10!FTKS10,<
	ADJSP	P,%%%N
>
	PUSHJ	P,%A		;DO THE SUBROUTINE
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-%%%N(P)	;PASS ON THE SKIP RETURN
	SUB	P,[%%%N,,%%%N]	;DEALLOCATE SPACE
	POPJ	P,0		;RETURN
%A: ;SUBROUTINE WITH LOCAL STORAGE
>

DEFINE	%FRAM1(A,B),<
DEFINE	A,<-B(P)>
IFE FTKL10!FTKS10,<
>>
	SUBTTL	SYSTEM MACROS -- TEXT CONCATENATION

;THESE MACROS PROVIDE A CONVENIENT MECHANISM TO ACCUMULATE TEXT
;(ASCIZ STRINGS, MACRO DEFINITIONS ETC.) DURING THE COURSE OF AN
;ASSEMBLY, THEN TO USE THAT TEXT AS DESIRED LATER ON.
;
;TO INITIALIZE:
;		CCLEAR(NAME)
;
;	WHERE NAME IS 4 CHARACTERS OR LESS.
;
;TO CONCATENATE TEXT ON THE RIGHT:
;		CONCAT(NAME,TEXT)
;
;	WHERE NAME HAS BEEN INITIALIZED BY CCLEAR, AND TEXT IS
;	THE TEXT TO BE CONCATENATED.
;
;AFTER THE CALL TO ANY CONCAT MACRO, NAME WILL BE DEFINED TO BE
;THE TEXT ACCUMULATED SO FAR. USE OF THIS MACRO DOES NOT PREVENT
;ADDITIONAL CALLS TO CONCAT. MULTIPLE STRINGS CAN BE ACCUMULATED
;SIMULTANEOUSLY, USING DIFFERENT NAMES.
;
;EXAMPLE:
;		CCLEAR(MSG)
;		CONCAT(MSG,ASCIZ /)
;		CONCAT(MSG,A )
;		CONCAT(MSG,LINE)
;		CONCAT(MSG,/)
;
;	IS EQUIVALENT TO DEFINE MSG<ASCIZ /A LINE/>


	DEFINE	CCLEAR(NAME)<			;;CLEAR MACRO
	  DEFINE C.'NAME(FTXT)<			;;DEFINE FIRST CALL
	    DEFINE C.'NAME(TEXT)<		;;DEFINE 2ND CALL
	      C%%%ON <NAME>,<FTXT>,<TEXT>	;;APPEND THE TEXT
	    >
	    DEFINE NAME<FTXT>			;;JUST TEXT 1ST TIME
	  >
	  .XCREF C.'NAME			;;DON'T CREF TEMP MACRO
	  DEFINE NAME<>				;;NULL BEFORE CONCAT'S
	>

	DEFINE	C%%%ON(NAME,OTXT,NTXT)<		;;INTERNAL HELPER MACRO
	  DEFINE C.'NAME(TEXT)<			;;DEF C.NAME FOR LATER
	    C%%%ON <NAME>,<OTXT'NTXT>,<TEXT>	;;CALL HELPER MACRO
	  >
	  DEFINE NAME<OTXT'NTXT>		;;PUT NEW TEXT IN NAME
	>

	DEFINE	CONCAT(NAME,TEXT)<C.'NAME <TEXT>>

	.XCREF	C%%%ON
;THE CONC MACRO SIMPLY CONCATENATES ITS PARAMETERS AND MAKES
; A CONVENIENT MECHANISM TO BUILD LABELS WITH NUMERIC STRINGS IN THEM.

DEFINE	CONC(A,B,C,D)<A'B'C'D>
	SUBTTL	SYSTEM MACROS -- SOPDEF, GOPDEF, GSOPDEF

;MACROS TO DO VARIOUS FLAVORS OF OPDEF.
;
;	SOPDEF			OPDEF, SUPRESSED TO DDT
;	GOPDEF			OPDEF, GLOBAL (INTERNAL)
;	GSOPDEF			OPDEF, GLOBAL SUPPRESSED
;
;EXAMPLE:
;	SOPDEF	PJRST[JRST]	;REPLACE PUSHJ/POPJ SEQUENCE


	DEFINE	SOPDEF(STR)<		;;SUPPRESSED OPDEF
	  O%%%PD(.NODDT,STR)
	>

	DEFINE	GOPDEF(STR)<		;;GLOBAL OPDEF
	  O%%%PD(INTERNAL,STR)
	>

	DEFINE	GSOPDEF(STR)<		;;GLOBAL SUPPRESSED OPDEF
	  O%%%PD(<.NODDT,INTERNAL>,STR)
	>


	DEFINE	O%%%PD(OPS,STR)<
	  .XCREF
	  CCLEAR(O%%P)			;;PREPARE TO EXTRACT NAME
	  CONCAT(O%%P,<OP%%%D (>)	;;START STRING WITH OP%%%D CALL
	  IRPC STR,<
	    IFIDN <STR><[>,<
	      STOPI			;;STOP WHEN WE HAVE THE SYMBOL
	    >
	    IFDIF <STR><[>,<
	      CONCAT(O%%P,STR)		;;ACCUMULATE SYMBOL NAME
	    >
	  >
	  CONCAT(O%%P,<)>)		;;FINISH THE OP%%%D CALL
	  O%%P				;;CALL OP%%%D TO DEFINE O%%P%D
	  .CREF				;;CREF THE OPDEF
	  OPDEF	STR			;;ACTUALLY DO THE OPDEF
	  .XCREF			;;BUT NOTHING ELSE
	  IRP OPS,<
	    O%%P%D(OPS)			;;DO THE PSEUDO-OP TO THE SYMBOL
	  >
	  .CREF
	>

	DEFINE	OP%%%D(STR)<
	  DEFINE O%%P%D(OP)<
	    OP	STR
	  >
	>

	.XCREF	O%%%PD,OP%%%D
	SUBTTL	SYSTEM MACROS -- METER POINT

;METER POINT MACRO (METER. UUO)
;  N=METER POINT # (DECIMAL)
;  AC T1=POINT VALUE (IF ANY)
;  RH OF MEQ'N'## IS POINT PARAMETER (IF ANY)
;    (I.E. MAY BE USED TO QUALIFY POINT VALUE)
;  MEP'N IS GLOBAL & MAY BE USED TO FIND
;    POINT 'N' VIA GLOB & CREFS
;  DESTROYS T1 & T2

DEFINE MPOINT (N)
<IFN FTMETR,<
	SKIPGE	T2,MEP'N'##
	PUSHJ	P,(T2)
>>
	SUBTTL	SYSTEM MACROS -- EXECUTIVE EXECUTE

IFN FTKI10,<

DEFINE	EXCTUX(A)<
	SALL
	XCT 1,[A]	;;ALL READS DONE IN USER'S VIRTUAL ADDRESS SPACE
	LIST
>

DEFINE	EXCTXU(A)<
	SALL
	XCT 2,[A]	;;ALL WRITES DONE IN USER'S VIRTUAL ADDRESS SPACE
	LIST
>

DEFINE	EXCTUU(A)<
	SALL
	XCT 3,[A]	;;BOTH READS AND WRITES DONE IN USER'S
	LIST		;; VIRTUAL ADDRESS SPACE
>

DEFINE	UMOVE(AC,ADR)<EXCTUX <MOVE AC,ADR>>	;MOVE FROM USER TO MONITOR
DEFINE	UMOVEM(AC,ADR)<EXCTXU <MOVEM AC,ADR>>	;MOVE FROM MONITOR TO USER

>	;END IFN FTKI10


;BLT TO USER
DEFINE	BLTXU(X),<EXCTXU(<X>)>

;BLT TO MONITOR
DEFINE	BLTUX(X),<EXCTUX(<X>)>

;SPECIAL PXCT MACROS FOR KL10
; MUST BE DEFINED AS CORRESPONDING EXCT IF FTKL10 IS OFF

DEFINE PXCTUX(A,B)<
	EXCTUX(<A>)
>
DEFINE PXCTXU(A,B)<
	EXCTXU(<A>)
>
DEFINE PXCTUU(A,B)<
	EXCTUU(<A>)
>
	SUBTTL	SYSTEM MACROS -- KL10 SPECIFIC

IFN	FTKL10,<

;KL10 INTERNAL DEVICE OPCODES

CCA==14			;CACHE
TIM==20			;INTERVAL TIMER,TIME BASE
MTR==24			;ACCOUNTING METERS, PERFORMANCE METER

;OPDEFS FOR KL10 INSTRUCTIONS
	OPDEF	ADJSP	[105B8]	;ADJUST STACK POINTER
	SOPDEF	PXCT	[XCT]	;PREVIOUS CONTEXT EXECUTE
	OPDEF	DADD	[114B8]	;DOUBLE ADD
	OPDEF	DSUB	[115B8]	;DOUBLE SUB
	OPDEF	DMUL	[116B8]	;DOUBLE MUL
	OPDEF	DDIV	[117B8]	;DOUBLE DIV
	SOPDEF	ADJBP	[IBP]	;ADJUST BYTE POINTER
	OPDEF	APRID	[BLKI APR,]	;READ PROCESSOR SERIAL, UCODE VERSION
	OPDEF	WRFIL	[BLKO APR,]	;WRITE CACHE REFILL ALGORITHM
	OPDEF	RDERA	[BLKI PI,]	;READ ERROR ADDRESS REGISTER
	OPDEF	SBDIAG	[BLKO PI,]	;SBUS DIAGNOSTIC
	OPDEF	CLRPT	[BLKO PAG,]	;CLEAR ONE ENTRY IN HARDWARE
					; PAGE TABLE
	OPDEF	SWPIA	[DATAI CCA,]	;INVALIDATE ALL CACHE DATA,
					; WITHOUT UPDATING CORE
	OPDEF	SWPVA	[BLKO CCA,]	;SWEEP CACHE, VALIDATING CORE
					; FOR ALL PAGES, LEAVING CACHE VALID
	OPDEF	SWPUA	[DATAO CCA,]	;UNLOAD ALL PAGES, UPDATING
					; CORE AND INVALIDATING CACHE
	OPDEF	SWPIO	[CONI CCA,]	;INVALIDATE ONE PAGE
	OPDEF	SWPVO	[CONSZ CCA,]	;VALIDATE ONE PAGE
	OPDEF	SWPUO	[CONSO CCA,]	;UNLOAD ONE PAGE
	OPDEF	RDPERF	[BLKI TIM,]	;READ DOUBLE-WORD PERFORMANCE
					; ANALYSIS COUNTER
	OPDEF	RDTIME	[DATAI TIM,]	;READ DOUBLE-WORD TIME BASE
	OPDEF	WRPAE	[BLKO TIM,]	;WRITE PERFORMANCE ANALYSIS
					; ENABLES
	OPDEF	RDMACT	[BLKI MTR,]	;READ DOUBLE-WORD MBOX
					; ACCOUNTING COUNT
	OPDEF	RDEACT	[DATAI MTR,]	;READ DOUBLE-WORD EBOX
					; ACCOUNTING COUNT


>;END IFN FTKL10 CONDITIONAL
	SUBTTL	SYSTEM MACROS -- KL10/KS10 SPECIFIC

IFN FTKL10!FTKS10,<
;BITS IN PXCT AC FIELD
	PX.EAC==10		;EFFECTIVE ADDRESS OF OBJECT INSTRUCTION
	PX.MEM==4		;MEMORY OPERAND (BOTH FETCH AND STORE)
	PX.BYT==2		;EFFECTIVE ADDRESS OF BYTE POINTER
	PX.SRC==1		;STACK WORD IN PUSH/POP; SOURCE IN BLT

DEFINE	EXCTUU(INST)<
	SALL
	GINST==<PXCT PX.MEM,[INST]>


	PXGEN(<INST>,<DPB,IDPB>,<PX.SRC>)	;;BECAUSE EXCTUU IS USED ON KL10 FOR
					;; READ-MODIFY-WRITE
	PXGEN(<INST>,<BLT,PUSH,POP>,<PX.SRC!PX.MEM>)
	GINST
	PURGE GINST
>;END EXCTUU MACRO DEFINITION

DEFINE	EXCTUX(INST)<
	SALL
	GINST==<PXCT PX.MEM,[INST]>
	PXGEN(<INST>,<LDB,ILDB,POP,BLT>,<PX.SRC>)
	GINST
	PURGE GINST
>;END EXCTUX MACRO DEFINITION

DEFINE	EXCTXU(INST)<
	SALL
	GINST==<PXCT PX.MEM,[INST]>
	PXGEN(<INST>,<IDPB,DPB,PUSH>,<PX.SRC>)
	PXGEN(<INST>,<POP,BLT>,<PX.MEM>)
	GINST
	PURGE GINST
>;END EXCTXU MACRO DEFINITION

IFN	FTKL10,<
DEFINE	UMOVE(AC,ADR)<EXCTUX <MOVE AC,ADR>>	;MOVE FROM USER TO MONITOR
DEFINE	UMOVEM(AC,ADR)<EXCTXU <MOVEM AC,ADR>>	;MOVE FROM MONITOR TO USER
> ;END IFN FTKL10

IFN	FTKS10,<
OPDEF	UMOVE	[704B8]		;MOVE FROM USER TO MONITOR
OPDEF	UMOVEM	[705B8]		;MOVE FROM MONITOR TO USER
> ;END IFN FTKS10
DEFINE	PXGEN(INST,CODES,BITS)<
	ZZ==0
	IRPC INST,<
	ZZ1==0
	IFIDN < > <INST>,<ZZ1==1>
	IFIDN <	> <INST>,<ZZ1==1>
	IFN ZZ1,<STOPI>
	IFE ZZ1,<
	ZZ==ZZ_6
	ZZ==ZZ+''INST''
>;END IFE ZZ1
>;END IRPC INST
	IRP CODES,<
	IFE <ZZ^!''CODES''>,<GINST==<PXCT BITS,[INST]>>
>;END IRP CODES

	PURGE OPCOD,ZZ1
>;END PXGEN MACRO DEFINITION

;MACROS TO SAVE AND RESTORE  AC BLOCKS FOR KL10/KS10 POWER FAIL RESTART

DEFINE	SAVE(X,Y),<
	EXECAC	(X)
	MOVEM	17,Y+17
	MOVEI	17,Y
	BLT	17,Y+16
	MOVE	17,Y+17
>

DEFINE	RESTOR(X,Y),<
	EXECAC	(X)
	MOVSI	17,Y
	BLT	17,17
>
> ;END FTKL10!FTKS10
;MACROS TO CHANGE AC BLOCKS

	DEFINE	EXECAC(A),<
IFN FTKL10,<
	SALL
IFB <A>,<
	DATAO	PAG,[LG.LAB+01B11]
>
IFNB <A>,<
	DATAO	PAG,[LG.LAB+<<A_3>+1>B11]
>
	LIST
>;IFN FTKL10
IFN FTKS10,<
	SALL
IFB <A>,<
	WRUBR	[SG.LAB+01B11]
>
IFNB <A>,<
	WRUBR	[SG.LAB+<<A_3>+1>B11]
>
	LIST
>;IFN FTKS10
>;DEFINE EXECAC

DEFINE 	USERAC,<
IFN FTKL10,<
	SALL
	DATAO	PAG,[LG.LAB+11B11]
	LIST
>;IFN FTKL10
IFN FTKS10,<
	SALL
	WRUBR	[SG.LAB+11B11]
	LIST
>;IFN FTKS10
>;DEFINE USERAC
DEFINE CLRPGT(CP,PG),<
	SALL
	ZZ==0		;SET TO 1 IF A VALID ARG IS SEEN

IFN FTKI10,<
	IFIDN <CP> <P4><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			DATAO	PAG,.CPEBR
			>
	IFIDN <CP> <0><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			DATAO	PAG,.CPEBR
			>
	IFIDN <CP> <1><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			DATAO	PAG,.CPEBR
			>
	>;END IFN FTKI10

IFN FTKL10,<
IFB <PG> <
	IFIDN <CP> <P4><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			CONO	PAG,@.CPEBR
			>
	IFIDN <CP> <0><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			CONO	PAG,@.CPEBR
			>
	IFIDN <CP> <1><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			CONO	PAG,@.CPEBR
			>
	>

IFNB <PG> <
			ZZ==1		;FLAG THAT CPU ARG IS OK
			CLRPT	PG
	>
	>;END IFN FTKL10

IFN FTKS10 <
IFB <PG> <
	IFIDN <CP> <P4><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			WREBR	@.CPEBR
			>
	IFIDN <CP> <0><
			ZZ==1
			IFNDEF .CPEBR,<EXTERN .CPEBR>
			WREBR	@.CPEBR
			>
	>

IFNB <PG> <
			ZZ==1		;FLAG THAT CPU ARG IS OK
			CLRPT	PG
	>
	>;END IFN FTKS10

IFE ZZ,<PRINTX ? BAD CPU ARGUMENT CP TO CLRPGT MACRO>
	PURGE ZZ
>;END CLRPGT MACRO DEFINITION
	SUBTTL	SYSTEM MACROS -- SOFTWARE INTERRUPTS

;MACRO TO CAUSE A NON-DEVICE PROGRAMMED SOFTWARE INTERRUPT

IFN FTPI,<
	DEFINE	SIGNAL(COND),<
	IF2,<IFNDEF PSICND,<EXTERNAL PSICND>>
		IFNDEF COND,<
		  PRINTX  ? COND IS NOT DEFINED IN FILE S.MAC!
		  XP	COND,C$MIN-1	;CONDITION YOU CAN NOT ENABLE
		  >
		IFGE <COND><
		  PRINTX  ? COND IS NO A NEGATIVE NUMBER!
		  XP	COND,C$MIN-1	;CONDITION YOU CAN NOT ENABLE
		  >
	HRROI	T1,COND		;SETUP CONDITION
	XCT	NOPISK##	;SKIP IS USER IS NOT ENABLED
	PUSHJ	P,PSICND	;ENABLED, CALL SIGNALLER
	>
>
	SUBTTL	SYSTEM MACROS -- TWO SEGMENT MONITOR

;MACROS TO PUT CODE IN THE LOW OR HIGH SEGMENT

	DEFINE $RELOC(A)<
	SALL
	TWOSEG	HIORG
	RELOC	HIORG
	LOCFLG==-1		;0=LOW SEG
				;-1=HIGH SEG
				;+1=ABSOLUTE LOW SEGMENT
	HILOC==HIORG
	LOLOC==0
	ABSLOC==0
>;END OF $RELOC

	DEFINE $LOW(A)<
	IFL LOCFLG,<HILOC==.
		LOCFLG==0
		RELOC	LOLOC>
	IFG LOCFLG,<ABSLOC==.
		LOCFLG==0
		RELOC	LOLOC>
>;END OF $LOW
	DEFINE $HIGH(A)<
	IFE LOCFLG,<LOLOC==.
		LOCFLG==-1
		RELOC	HILOC>
	IFG LOCFLG,<ABSLOC==.
		LOCFLG==-1
		RELOC	HILOC>
>;END OF $HIGH

	DEFINE $ABS(A)<
	IFL LOCFLG,<HILOC==.
		LOCFLG==1
		LOC	ABSLOC>
	IFE LOCFLG,<LOLOC==.
		LOCFLG==1
		LOC	ABSLOC>
>;END OF $ABS

	DEFINE	$LIT<
	$HIGH
	LIT
>;END OF $LIT

	SUBTTL	SYSTEM MACROS -- UUO ERROR CODE GENERATOR

;USAGE:
; DEFINE LOCAL ERROR CODES, ERRA%=0, ERRB%=1, ...
; DEFINE LOCAL LABELS WHICH CORRESPOND TO EACH ERROR CODE.
; FOR EACH ERROR CODE, LABEL PAIR, ERCODE(LABEL,CODE)

ECDMAX==33

DEFINE	ERCODE(NAME,CODE)<
	.DIRECTIVE .XTABM
	ERRCOD	(NAME,CODE,\CODE)
	.DIRECTIVE .ITABM>

DEFINE	ERRCOD(NAME,CODE,ACODE)<
	IFG <CODE+1-ECDMAX>,<GENECD(NAME,CODE,ACODE)>
	IFNDEF NAME,<NAME==ECOD'ACODE##>>

DEFINE	GENECD(NAME,CODE,ACODE)<
PRINTX %ECOD'ACODE IS UNDEFINED, DEFINE ECDMAX IN S.MAC TO BE ACODE+1
NAME==[MOVEI	T1,CODE
	JUMPL	M,CPOPJ##
	JRST	STOTAC##]
	IF1,<NAME==0>>		;GET ROUND BUG IN MACRO 50

DEFINE	ERCALC(N)<
.N==0
REPEAT	N,<ERRJSP (\.N)
.N=.N+1>
ECOD:	SUBI	T1,ECOD0+1
	HRRZS	T1
	JUMPL	M,CPOPJ
	JRST	STOTAC##>

DEFINE	ERRJSP(N)<
ECOD'N::JSP	T1,ECOD>

	SUBTTL	SYSTEM MACROS -- MULTI PROCESSING

IFN FTMP,<		;MASTER-SLAVE INTERFACE CODE PRESENT?

;NOTE: NO NEED TO BRACKET CPLOCK,CPUNLK,SBLOK MACRO CALLS WITH
; IFN FTMP,< ... > SINCE THE ARE DEFINED TO BE NULL IF FTMP = 0.

;MACRO TO INTERLOCK CODE AND/OR DATA ON FLAG XXX.
; CPLOCK XXX ENTERS AND LOCKS BEHIND IT UNTIL MATCHING CPUNLK XXX.
; SO FAR "SCD" IS ONLY INTER-LOCK FLAG(FOR SCHEDULER).

	DEFINE	CPLOCK	(XXX)<
	PUSHJ	P,LOK'XXX	;ENTER CPU INTER-LOCKED REGION ON 'XXX'
	EXTERN	LOK'XXX>

;MACRO TO UNLOCK CODE AND/OR DATA ON FLAG XXX.
; GOES WITH CPLOCK MACRO.

	DEFINE	CPUNLK	(XXX)<
	PUSHJ	P,ULK'XXX	;EXIT CPU INTER-LOCKED REGION ON 'XXX'
	EXTERN	ULK'XXX>

;MACRO TO INTERLOCK A SUBROUTINE UNTIL THIS SUB. EXITS ON FLAG XXX.
; JUST LIKE CPLOCK EXCEPT MATCHING CPUNLK IS AUTOMATIC,
; BECAUSE LK'XXX PUTS ULK'XXX ON PD LIST.

	DEFINE	SBLOK	(XXX)<
	PUSHJ	P,SB'XXX	;INTERLOCK THIS SUBROUTINE ON 'XXX'
	EXTERN	SB'XXX>

>	;END FTMP

IFE FTMP,<		;MASTER-SLAVE INTERFACE CODE NOT PRESENT?

	DEFINE	CPLOCK	(XXX)<>
	DEFINE	CPUNLK	(XXX)<>
	DEFINE	SBLOK	(XXX)<>

>	;END FTMP

;MACRO TO TEST FOR WHICH CPU THIS IS (0 OR 1) OR WHICH TYPE THIS IS (A OR I)
; NOTE:  P4 DOES NOT NEED TO BE SETUP
; ALWAYS BRACKET THIS MACRO CALL WITH IFN FTMP,< ... >, SO NESTED
; SKIP CODE WILL BE OBVIOUS THAT SOMETIMES MACRO DOES NOT GENERATE CODE.

	DEFINE	SKPCPU	(N)<
IF2,< IFNDEF .CPSK'N,<EXTERNAL .CPSK'N>>
	XCT	.CPSK'N
>
	SUBTTL	SYSTEM MACROS -- DISK AND TAPE PI CONTROL


;MACROS TO TURN DISK PI CHANNEL ON AND OFF

	DEFINE	DSKON,<
IFE FTMP,<
IF2,<IFNDEF DSKPIN,<EXTERN DSKPIN>>
	CONO	PI,DSKPIN
>
IFN FTMP,<
IF2,<IFNDEF DSKULK,<EXTERN DSKULK>>
	PUSHJ	P,DSKULK
>
>;END DSKON MACRO DEFINITION


	DEFINE	DSKOFF,<
IFE FTMP,<
IF2,<IFNDEF DSKPIF,<EXTERN DSKPIF>>
	CONO	PI,DSKPIF
>
IFN FTMP,<
IF2,<IFNDEF DSKLOK,<EXTERN DSKLOK>>
	PUSHJ	P,DSKLOK
>
>;END DSKOFF MACRO DEF.


;MACROS TO TURN TAPSER PI CHANNEL ON AND OFF

	DEFINE	TAPON,<
IF2,<IFNDEF TPION,<EXTERN TPION>>
	CONO	PI,TPION
>;END TAPON MACRO DEF.

	DEFINE	TAPOFF,<
IF2,<IFNDEF TPIOFF,<EXTERN TPIOFF>>
	CONO	PI,TPIOFF
>;END TAPOFF MACRO DEFINITION

	DEFINE	SCNON,<
IF2,<IFNDEF SCNPIN,<EXTERN SCNPIN>
   IFN FTMP,<IFNDEF UNLSCI,<EXTERN UNLSCI>>
>
IFE FTMP,<CONO PI,SCNPIN>
IFN FTMP,<PUSHJ P,UNLSCI>
>

	DEFINE	SCNOFF,<
IF2,<IFNDEF SCNPIF,<EXTERN SCNPIF>
   IFN FTMP,<IFNDEF LOKSCI,<EXTERN LOKSCI>>
>
IFE FTMP,<CONO PI,SCNPIF>
IFN FTMP,<PUSHJ P,LOKSCI>
>

	DEFINE	NETON,<
IF2,<IFNDEF NETPIN,<EXTERN NETPIN>
   IFN FTMP,<IFNDEF UNLNPI,<EXTERN UNLNPI>>
>
IFE FTMP,<CONO PI,NETPIN>
IFN FTMP,<PUSHJ P,UNLNPI>
>

	DEFINE	NETOFF,<
IF2,<IFNDEF NETPIF,<EXTERN NETPIF>
   IFN FTMP,<IFNDEF LOKNPI,<EXTERN LOKNPI>>
>
IFE FTMP,<CONO PI,NETPIF>
IFN FTMP,<PUSHJ P,LOKNPI>
>

;BYTE DIDDLING INTERLOCK MACROS
DEFINE BYTPIF,<PUSHJ P,LOKSBI>
DEFINE BYTPIN,<PUSHJ P,UNLSBI>

;...DPB - DO A DEPOSIT BYTE TO AN INTERLOCKED WORD.
;	THIS WAS DEFINED FOR A VERSION OF THE MICROCODE WHICH DID NOT HAVE
;	READ-MODIFY-WRITE FOR DEPOSIT BYTE. IT IS STRONGLY SUGGESTED THAT
;	THIS FEATURE TEST (FTDOTD) NOT BE TURNED ON, SINCE PERFORMANCE IS
;	NOTICABLY IMPACTED.
;
;N.B. - THE MICROCODE BUG HAS BEEN FIXED, BUT PLEASE CONTINUE TO USE THE
;	...DPB CONSTRUCT FOR DPB TO UN-INTERLOCKED WORDS, IN CASE THE FIX
;	HAS TO BE REMOVED FOR SOME UNKNOWN REASON.

IFE <FTMP&FTKLP&FTDOTD>,<SOPDEF ...DPB	[DPB]>
IFN <FTMP&FTKLP&FTDOTD>,<
 DEFINE ...DPB(AC,LOCATION),<
  PUSHJ	P,[PUSHJ P,RMWDPB##	;;CALL ROUTINE TO FIGURE OUT BYTE POINTERS
	IFIW AC,LOCATION]	;;DATA WORD FOR RMWDPB - AC TO DEPOSIT, WHERE.
>>

IFE FTKLP,<
	DEFINE	SPUSH(AC),<>
	DEFINE	SPOP(AC),<>
	DEFINE	SSX(AC,SN),<>
	DEFINE	SSXE(AC,SN),<>
	DEFINE	SE1ENT,<>
>
IFN FTKLP,<
	DEFINE	SPUSH(AC),<PUSH P,AC>
	DEFINE	SPOP(AC),<POP P,AC>
	DEFINE	SSX(AC,SN),<HRLI AC,(SN)>
	DEFINE	SSXE(AC,SN),<HRLI AC,SN>
	DEFINE	SE1ENT,<IFNDEF SSEC1,<EXTERNAL SSEC1>
			PUSHJ P,SSEC1>
	OPDEF	XJRST [JRST 15,]
	DEFINE	SE1JRS,<XJRST .+1
			MCSEC1+.+1
		>
>
;MACRO TO CAUSE AN I/O PAGE FAIL ON AN INTERRUPT TO 40+2N+1
; THIS CAPTURES THE I/O PAGE FAIL WORD WHICH CAN BE USEFUL IN DIAGNOSIS
	DEFINE	IOP,<MOVEM MONORG>
	SUBTTL	MACROS TO MANIPULATE TERMINAL BUFFER STREAMS

;NOTE:  THE FOLLOWING MACROS USE T1 AND T2 AS TEMPORARY AC'S.  THEY
;	MAY ** NOT ** BE SKIPPED OVER.  EACH CALLS A SUPPORT SUBROUTINE TO
;	SKIP FROM CHUNK TO CHUNK, BUT HANDLES THE NORMAL CASE IN LINE.
;	IN CASE OF ERROR RECOVERY (FROM RCC STOPCD) THE SCNSER INTERLOCK
;	MUST BE OWNED.

;MACRO TO TAKE A CHARACTER OUT OF A TERMINAL BUFFER STREAM, ADVANCE
;THE POINTER SPECIFIED BY "LOC", BUT NOT TO GIVE BACK ANY CHUNKS
;THAT ARE PASSED OVER.  USES T1, T2 AND T3.  CHARACTER MAY BE
;RETURNED IN T3 IF DESIRED.

DEFINE LDCHK(AC,LOC,ABO),<
	IFNDEF	CK.BDY,<EXTERNAL CK.BDY>
	IFNDEF	NEWCKS,<EXTERNAL NEWCKS>
	IFB	<ABO>,<PRINTX ? LDCHK INVOKED WITHOUT ABORT ADDRESS>
	SKIPE	T1,LOC		;;COPY OF BYTE POINTER
	TDNN	T1,[770000,,CK.BDY]  ;;POINTER AT END OF CHUNK?
	JRST	[PUSHJ	P,NEWCKS;;YES, ADVANCE TO NEXT CHUNK, KEEPING THIS ONE
		  JRST	ABO	;;ABORT - CHUNKS MESSED UP
		MOVEM	T2,LOC	;;STORE NEW CHUNK BYTE POINTER
		JRST	.+1]	;;DO THE ILDB
	ILDB	AC,LOC		;;GET NEXT BYTE
>

;MACRO TO TAKE A CHARACTER OUT OF A CHUNK AND TO RETURN ANY CHUNKS
;THAT ARE PASSED BY.  USES T1, T2 AND T3.  CHARACTER MAY BE RETURNED
;IN T3 IF DESIRED.

DEFINE LDCHKR(AC,LOC,ABO),<
	IFNDEF	CK.BDY,<EXTERNAL CK.BDY>
	IFNDEF	NEWCKI,<EXTERNAL NEWCKI>
	IFB	<ABO>,<PRINTX ? LDCHKR INVOKED WITHOUT ABORT ADDRESS>
	SKIPE	T1,LOC		;;COPY OF BYTE POINTER
	TDNN	T1,[770000,,CK.BDY]  ;;POINTER AT END OF CHUNK?
	JRST	[PUSHJ	P,NEWCKI;;YES, ADVANCE TO NEXT CHUNK, RELEASING THIS ONE
		  JRST	ABO	;;ABORT - CHUNKS MESSED UP
		MOVEM	T2,LOC	;;STORE NEW CHUNK BYTE POINTER
		JRST	.+1]	;;DO THE ILDB
	ILDB	AC,LOC		;;FETCH THE NEXT BYTE

>
;MACRO TO STORE A CHARACTER IN A TERMINAL OUTPUT STREAM.  DEPOSITS
;CHARACTER FROM "AC" USING THE BYTE POINTER SPECIFIED BY "LOC".
;CHUNKS ARE ALLOCATED FROM THE FREELIST AS NEEDED.  USES T1 AND T2.

DEFINE STCHK(AC,LOC,ABO),<
	IFNDEF	CK.BDY,<EXTERNAL CK.BDY>
	IFNDEF	NEWCKO,<EXTERNAL NEWCKO>
	IFB	<ABO>,<PRINTX ? STCHK INVOKED WITHOUT ABORT ADDRESS>
	SKIPE	T1,LOC		;;COPY OF BYTE POINTER
	TDNN	T1,[770000,,CK.BDY]  ;;POINTER AT END OF CHUNK?
	JRST	[PUSHJ	P,NEWCKO;;YES, ALLOCATE A NEW CHUNK
		  JRST	ABO	;;ABORT - CHUNKS MESSED UP
		MOVEM	T2,LOC	;;STORE NEW CHUNK BYTE POINTER
		JRST	.+1]	;;DO THE IDPB
	IDPB	AC,LOC		;;STUFF THIS CHARACTER INTO THE CHUNK STREAM

>


	SUBTTL	SYSTEM MACROS -- QUEUE DEFINITIONS

;DEFINE THE QUEUES, QUANTUM RUNNING TIME IN JIFFIES, AND PRIORITY
;PRIORITY GOES BACKWARD FROM LOW TO HIGH
;THE QUEUE NUMBERS START AT 0 AND GO UP BY ONE READING DOWN THE PAGE
;THE THIRD ARG CAN BE "DJ" FOR DELAY JOB IF CONTOL C TYPED
; OR "SJ," FOR STOP JOB (WHEN IN EXEC MODE)


DEFINE QUEUES
<	X	RN,7,DJ,	;;STRAIGHT RUN (LOWEST PRIORITY) (Q=0)
	X	WS,6,SJ,	;;I/O WAIT SATISFIED
	X	TS,6,SJ,	;;TTY I/O WAIT SATISFIED
IFN FTCIMP,<			;;[arpa]
	X	IS,6,SJ		;;[arpa] IMP I/O WAIT SATISFIED
>				;;[arpa]
	X	DS,6,DJ,	;;DISK I/O WAIT SATISFIED
	X	PS,6,DJ,	;;PAGING I/O WAIT SATISFIED
>
DEFINE RWAITS
<
	X	AU,4,DJ,	;;ALTER DISK UFD QUEUE
	X	DA,4,DJ,	;;DISK STORAGE ALLOCATION WAIT
	X	CB,4,DJ,	;;DISK CORE-BLOCK SCAN WAIT
	X	D1,4,SJ,	;;DTA DECTAPE CONTROL WAIT
	X	D2,4,SJ,	;;DTB DECTAPE CONTROL WAIT
	X	D3,4,SJ,	;;DTC DECTAPE CONTROL WAIT
	X	D4,4,SJ,	;;DTD DECTAPE CONTROL WAIT
	X	D5,4,SJ,	;;DTE DECTAPE CONTROL WAIT
	X	D6,4,SJ,	;;DTF DECTAPE CONTROL WAIT
	X	D7,4,SJ,	;;DTG DECTAPE CONTROL WAIT
	X	D8,4,SJ,	;;DTH DECTAPE CONTROL WAIT
	X	DC,4,SJ,	;;DATA CONTROL (DC) WAIT - MAGTAPE AND DECTAPE
IFN FTLOCK,<
	X	CA,4,SJ,	;;SEMI-PERMANENT CORE ALLOCATION WAIT>
IFN FTMP,<
	X	MM,4,DJ,	;;MEMORY MANAGEMENT WAIT>
	X	EV,4,SJ,	;;EXEC VIRTUAL MEMORY WAIT
IFN FTEQDQ,<
	X	EQ,4,DJ,	;;ENQ/DEQ WAIT
>
IFN FTMP,<
	X	MC,4,DJ,	;;MONITOR I/O DISK CACHE WAIT
>
>


;;JOB STATUS CODES WHICH HAVE NO CORRESPONDING QUEUES
;;JOBS ARE UNRUNABLE WHEN IN THESE STATES

DEFINE CODES
<	X	IOW,,SJ,	;;I/O WAIT
	X	TIOW,,SJ,	;;TTY I/O WAIT
	X	DIOW,,DJ,	;;DISK I/O WAIT

IFN FTCIMP,<			;;[arpa]
	X	IWT,,SJ,	;;[arpa] INDEFINITE SWAPPABLE IO WAIT
>				;;[arpa]

	X	PIOW,,DJ,	;;PAGING I/O WAIT

	X	SLP,,SJ,	;;JOB SLEEPING
	X	EW,,SJ,		;;JOB IN EVENT WAIT
	X	NAP,,SJ,	;;JOB NAPPING (.LT. 1 SEC SLEEP)
	X	NUL,,SJ,	;;JOB NUMBER NOT ASSIGNED
IFN FTDAEM,<
	X	JDC,,SJ,	;;WAITING FOR DAEMON TO BE RUN
>
	X	STOP,,SJ,	;;STOP (CONTROL C)
>
	SUBTTL	OPDEFS

;USEFUL OPCODES TO INDICATE SHORT CODING OF A SUBROUTINE CALL

SOPDEF PJRST [JRST]	;PJRST IS USED IN PLACE OF THE LAST PAIR OF
		; INSTRUCTIONS IN A SUBROUTINE WHEN THEY ARE PUSHJ
		; FOLLOWED BY A POPJ.  PJRST IS USED INSTEAD OF JRST, SO
		; THAT SOMEONE READING THE CODE WILL UNDERSTAND THAT A
		; SUBROUTINE IS BEING CALLED.

SOPDEF PJRSTF	[JRSTF]
SOPDEF PJSP	[JSP]	;PJSP IS USED IN PLACE OF MOVEI .+2, PJRST SUB
SOPDEF PJUMPL	[JUMPL]
SOPDEF PJMPLE	[JUMPLE]
SOPDEF PJUMPE	[JUMPE]
SOPDEF PJUMPG	[JUMPG]
SOPDEF PJMPGE	[JUMPGE]
SOPDEF PJUMPN	[JUMPN]

;OPDEF TO SET AN AC NON-ZERO AND JUMP (RATHER THAN CALL A SUB)

SOPDEF	SJSP	[JSP]

;OPDEF TO FIND HALTS WHICH SHOULD BE STOPCD'S

OPDEF	HALT	[JRST 4,0]

;INSTRUCTION TO DISPATCH ON ERROR (ILL MEM REF, EXCT?? ASSUMED,
; BUT MAY BE USED ANYWHERE IN MONITOR AFTER PAGE FAULT PROCESSOR
; IS SET UP).

OPDEF	ERJMP	[JUMP 16,]	;JRST TO "E" ON IME (ILL MEM REF)
;OPDEF	ERCAL	[JUMP 17,]	;PUSHJ P, TO "E" ON IME
;OPDEFS TO INDICATE REFERENCING REORGANIZED DATA BASE ENTRIES

SOPDEF .ADDM	[ADDM]
SOPDEF .AOS	[AOS]
SOPDEF .EXCH	[EXCH]
SOPDEF .MOVE	[MOVE]
SOPDEF .MOVN	[MOVN]
SOPDEF .SKIPA	[SKIPA]
SOPDEF	.MOVEM	[MOVEM]
SOPDEF	.ADD	[ADD]
SOPDEF	.SOS	[SOS]
SOPDEF	.CAML	[CAML]
SOPDEF	.CAMG	[CAMG]
SOPDEF	.SETZM	[SETZM]
SOPDEF	.DPB	[DPB]
SOPDEF	.LDB	[LDB]
SOPDEF	.SKIPE	[SKIPE]
SOPDEF	.HRRM	[HRRM]
SOPDEF	.HLLZ	[HLLZ]
SOPDEF	.HLLM	[HLLM]
SOPDEF	.HRRZS	[HRRZS]
SOPDEF	.HRROS	[HRROS]
SOPDEF	.SKIPL	[SKIPL]
SOPDEF	.SKPLE	[SKIPLE]
SOPDEF	.SKIPG	[SKIPG]
SOPDEF	.SKPGE	[SKIPGE]
SOPDEF	.IORM	[IORM]
SOPDEF	.ANCAM	[ANDCAM]
SOPDEF	.SOSLE	[SOSLE]
	SUBTTL	JBTLCL -- Local Status word bit definitions

; Bits in left half of JBTLCL

IFN FTCIMP,<			;[arpa]
	XP	JS.NIO,1B1	;[arpa] If on, indicates non-blocking
				;[arpa] output to an IMP is in progress
>				;[arpa]
	SUBTTL	MONITOR/USER SYMBOL PREFIXES

REPEAT	0,<
MONITOR/USER SYMBOLS PREFIXES:

SYMBOLS FOR MONITOR DATA BLOCKS WILL HAVE PERIODS IN THEM
SO THAT AS MANY OF THEM AS DESIRED CAN BE MADE
USER SYMBOLS AS THE NEED ARISES WITHOUT CONFLICTING
WITH ALREADY CODED PROGRAMS.
IT IS POSSIBLE TO DIVIDE DATA SYMBOLS INTO TWO CLASSES:

    A)  NUMBERS
    B)  MASKS

NUMBERS INCLUDE CORE ADDRESSES, FUNCTION CODES, AND ERROR CODES.

MASKS INCLUDE BITS AND FIELDS.

NUMBERS WILL BE 18 BITS AND MASKS WILL BE 36 BIT QUANTITIES.  USE
THE MACRO FEATURE WHICH SWAPS QUANTITIES INSIDE () TO REFERENCE
THE BITS.  AN ERROR WILL RESULT IF () ARE FORGOTTEN (BITS 0-8 ONLY).
BECAUSE OF PAST PRECEDENT, SYMBOLS DEFINING NUMBERS (I.E. ADDRESS,
FUNCTION CODES, AND ERROR CODES) WILL BEGIN WITH A DOT FOLLOWED BY A
TWO-LETTER PREFIX.  MASKS WILL START WITH A TWO-LETTER PREFIX FOLLOWED
BY A DOT.  UUO OPCODES WILL END WITH DOT.

THE FOLLOWING PREFIXES HAVE BEEN USED.  FILENAMES INDICATE WHERE
THEY ARE DEFINED.

A.	WORD ADDRESSES:

	.JB???	ARE JOB DATA AREA SYMBOLS (JOBDAT.MAC)
	?????.	WILL BE CALLI UUO SYMBOLS IMPLEMENTED AFTER
		5.03 (UUOCON.MAC)
	.PD???	WILL BE SYMBOLS IN THE PROCESS DATA BLOCK
		(PDB), USUALLY INDEXED BY W.
	.RB???	FILE EXTENDED ARGS, (LOOKUP, ENTER, RENAME)
		(S.MAC)
	.CP???	RELATIVE LOCATIONS IN CPU DATA BLOCK (CDB) USUALLY
		INDEXED BY P4 (COMMON.MAC)
	.C0???	ABSOLUTE LOCATIONS IN MASTER CDB (COMMON.MAC)
	.C1???	ABSOLUTE LOCATIONS IN SLAVE CDB (COMMON.MAC)
	.GT???	GETTAB TABLE NUMBERS (UUOCON.MAC)
B.	FUNCTION CODES:

	.FS	STRUUO (FILE STRUCTURE) (PRVUUO.RNO)

C.	ERROR CODES:

	.ER	STRUUO ERROR CODES (PRVUUO.RNO)

D.	BITS:  (FIRST FOUR DO NOT FOLLOW ABOVE CONVENTION.)

	.SP???	SPOOL BITS (S.MAC)
	.TY???	DEVTYP UUO BITS (S.MAC)
	.ERMSG	DON'T TYPE ERROR MESSAGE ON ERROR INTERCEPT
	.OK???	INTERCEPT DEVICE OK ERRORS (S.MAC)

	JB.L??	JOB LIMIT BITS (S.MAC)
	SP.???	SECOND PROCESSOR STATUS BITS (S.MAC)
	AP.???	APR CONI/CONO BITS (S.MAC)
	PC.???	PC WORD FLAGS (S.MAC)
	PI.???	PI CONI/CONO BITS (S.MAC)
	JP.???	JOB PRIVILEGE BITS (S.MAC) IN JBTPRV
	JS.???	JOB STATUS BITS IN JBTSTS (S.MAC)
	JW.???	JOB WATCH RTS IF JBTWCH (S.MAC)

IT IS SUGGESTED THAT ??? BE EITHER A PRONOUNCEABLE "WORD" SUCH AS JOB
OR A TWO OR THREE LETTER ALPHABET SOUP SYMBOL WHERE EACH LETTER IS THE
FIRST LETTER OF EACH WORD IN THE MNEMONIC (E.G. LJR FOR LAST JOB RUN,
RATHER THAN, SAY, LSJ FOR LAST JOB.)
>
SUBTTL DEFINE THE SYMBOLS FOR THE LINK PSEUDO OPERATIONS
	XP	FEKLNK,1	;LINK 1 USED FOR LINKING FEK'S

SUBTTL	KLINIK DEFINITIONS
KPSLEN==26			;LENGTH OF PARAMETER SAVE MESSAGE
	END

