TITLE DATMAN - DATA BASE MANAGER  V125
SUBTTL D BLACK/DAL/JBS  18 OCT 83
	SEARCH	F,S
	$RELOC
	$HIGH

	ENTRY	DATMAN

DATMAN::		;CAUSE DATMAN TO LOAD IF IN LIBRARY FILE

XP LISTSN,1		;CAUSE S.MAC AND F.MAC TO BE LISTED HERE
			; (USED TO BE IN COMMON WHICH IS NOW TOO BIG).


REPEAT 0,<
The DATA BASE MANAGER contains both subroutines to manipulate
monitor's data base and formats of various components of the data base.
The DATA BASE MANAGER should be the only module which modifies the data base;
all other modules should call DATMAN.
This scheme has a number of advantages:

1. It provides a good chance for comments.
2. It provides good conventions for future growth.
3. It provides good locality.
4. It helps reentrancy by having only one module maintain impure code.

DATMAN will also control writing in users' core too.
PROCESS and SEGMENT are important components in the data base
being introduced at this time.
A SEGMENT is one logical collection of data, either program data
or code, and is the building block of a program. Segments are really
the same as previously.
A PROCESS is a virtual machine;
it has a hardware state associated with it: a virtual memory, a processor,
typically one PC, a stack, etc. A process's virtual memory will
contain a number of segments. Several processes may run either
serially or in parallel as one overall program or user.
Monitor data will be organized on a per segment and a per process basis.
Part of per segment and part of per process data must be resident,
other parts could be swappable; the data breaks up
into four components. The following abbreviations and definitions will be used:

PRB	Process Resident Block - the resident process information.
	This will be very small, about 8 or 12 words.

PDB	Process Data Block - the not necessarily resident (swappable) process data.
	This will be most of the process data and may grow to fill a page or more.

SRB	Segment Resident Block - the resident segment information.
	This will be very small, about 8 or 12 words.

SDB	Segment Data Block - the not necessarily resident segment data.
	This may grow to fill a page or more.
Conventions about symbols:

symbols will consist of a three letter prefix and a three letter suffix.
The prefix will determine to what type of data base component the entry belongs,
and the particular usage of the entry.
For example, a word entry in the PDB would be .PDxxx.
The suffix is a three letter mnemonic describing the entry. Thus
the PDB entry SIZ containing the size of the PDB
would be .PDSIZ.
DATMAN is organized in the following manner:

First are the definitions of the various data base components.
These will be in alphabetical order so they can be found easily.

Second are subroutines for manipulating the data base,
grouped by function. Code should go down the page,
as in 5 series monitor conventions, until concern for locality
becomes more important.
>	;END REPEAT 0
	SUBTTL	PDB LOGIC


;SUBROUTINE TO GET A WORD OUT OF A PDB. CALLABLE ONLY FROM UUO LEVEL
;CALLED WITH:
;	J = JOB = CALLERS PROCESS HANDLE
;	T2 = PROCESS NUMBER OF DESIRED PROCESS (POSITIVE NUMBER)
;	T3 = INDEX INTO PDB. (SMALL POSITIVE NUMBER)
;	PUSHJ	P,PDBWRD
;	RETURN HERE WITH WORD IN T1. IF THE PDB DOES NOT EXIST THEN
;	       ZERO IS RETURNED.
	
;CLOBBERS J,U,F,R,T1-T4
PDBWRD::MOVE	T1,T2		;GET POINTER TO PDB
	PUSHJ	P,FPDBT1	; ..
	  JRST	PDBWD1		;NOT IN CORE TRY HARDER
	ADD	T1,T3		;SELECT CORRECT WORD
	MOVE	T1,(T1)		;LOAD INTO T1
	POPJ	P,		;AND RETURN

;HERE IF PDB IS NOT IN CORE

PDBWD1:	SETZM	T1		;IF THE PDB IS NOT IN CORE AND WE
	POPJ	P,		; DO NOT SWAP THEN RETURN ZERO


;SUBROUTINE TO FIND A PDB OR HALT
;CALL WITH:
;	MOVE	J,PROCESS-NUMBER
;	PUSHJ	P,FNPDBS
;	RETURN HERE WITH W POINTING TO A PDB
;
FNDPDS::
FNPDBS::JUMPL	J,NPJSTP
	HRRZ	W,JBTPDB##(J)	;GET PDB
	CAIG	J,JOBMAX##	;LEGAL JOB #
	JUMPN	W,CPOPJ##
NPJSTP::STOPCD CPOPJ##,DEBUG,NPJ, ;++NO PDB FOR JOB


;SUBROUTINE TO FIND PDB FOR PROCESS IN T1
;	PUSHJ 	P,FPDBT1
;	  HERE IF NO PDB
;	HERE WITH T1 POINTING TO PDB
FPDBT1::PUSH	P,J		;SAVE J AND W
	PUSH	P,W		; ..
	HRRZ	J,T1		;COPY PDB HANDLE
	PUSHJ	P,FNDPDB	;FIND THE PDB
	  SOS	-2(P)		;CAUSE NON-SKIP RETURN
	MOVE	T1,W		;COPY CORE ADDRESS
	POP	P,W		;RESTORE AC'S
	JRST	JPOPJ1##	;RETURN
;SUBROUTINE TO FIND A PDB
;CALL WITH:
;	MOVE	J,PROCESS-NUMBER
;	PUSHJ	P,FNDPDB
;	  RETURN HERE IF NO PDB (W = 0)
;	RETURN HERE WITH W POINTING TO PDB

FNDPDB::PUSH	P,T1		;SAVE T1
	PUSHJ	P,LGJPR1	;SEE IF A LEGAL PROCESS (INCLUDING ZERO)
	  JRST	TPOPJ##		;NOT, LOSE
	HRRZ	W,JBTPDB##(J)	;GET PDB ADDRESS
	JUMPN	W,TPOPJ1##	;IF W IS NON-ZERO GIVE THE SKIP RETURN
	JRST	TPOPJ##		; ELSE FAIL
	SUBTTL	ROUTINES TO REFERENCE USER CORE

;GETTAC  --  RE-LOAD AC T1 FROM USER'S AC ON A CALLI OR
;THE LIKE, IN CASES WHERE T1 HAS BEEN DESTROYED.
;CALL:
;
;	MOVE J,JOB NUMBER
;	PUSHJ P,GETTAC
;	RETURN
;
;ON RETURN THE USER'S AC IS IN T1. USES M, PRESERVES ALL OTHER ACS.

GETTAC::LDB	T1,PUUOAC##	;GET USER'S AC NUMBER
	HRR	M,T1		;PROVIDE AS ADDRESS TO READ
	PJRST	GETWDU		;GO READ THE AC



;GETWDU  --  READ 1 WORD FROM USER VIRTUAL ADDRESS SPACE
;GETWD1  --  READ NEXT WORD FROM USER VIRTUAL ADDRESS SPACE
;CALL IS:
;
;	MOVEI	M,<ADR>
;	PUSHJ	P,GETWDU
;	RETURN
;
;WHERE <ADR> IS USER VIRTUAL ADDRESS TO BE READ.
;
;DISPATCHES TO PAGE FAULT HANDLER ON A USER PAGE FAULT, OR PRINTS ILL
;ADR IN UUO IF NO SUCH ADDRESS.
;
;ON SUCCESSFUL RETURN THE USER WORD IS IN T1 AND, IF CALL WAS TO
;GETWD1 M IS UPDATED TO NEW USER VIRTUAL ADDRESS <ADR>+1. J IS SET
;TO THE USER'S JOB NUMBER. ALL OTHER ACS PRESERVED.

GETWD1::HRRI	M,1(M)		;INCREMENT M BEFORE PICKING UP WORD
GTWST2::
GETWDU::MOVE	J,.CPJOB##	;MAKE SURE J CORRECT
	PUSHJ	P,GETWRD	;GET THE WORD AND CHECK IF LEGAL
	  JRST	UADERR##	;ADDRESS NOT ACCESSIBLE, PRINT ERROR
	POPJ	P,		;OK RETURN, T1=WORD
;GETWRD  --  READ 1 WORD FROM USER VIRTUAL ADDRESS SPACE
;GETWR1  --  READ NEXT WORD FROM USER VIRTUAL ADDRESS SPACE
;CALL IS:
;
;	MOVX	J,<JOB>
;	MOVX	M,<ADR>
;	PUSHJ	P,GETWRD
;	  ERROR
;	NORMAL
;
;WHERE <JOB> IS USER JOB NUMBER AND <ADR> IS USER VIRTUAL ADDRESS.
;CAN BE CALLED AT CLOCK OR UUO LEVEL.
;
;DISPATCHES TO PAGE FAULT HANDLER ON A USER PAGE FAULT, OTHERWISE
;RETURNS CPOPJ0 IF USER ADDRESS IS INACCESSIBLE.
;
;SUCCESSFUL RETURN IS CPOPJ1 WITH USER WORD IN T1 AND, IF CALL WAS
;TO GETWR1, WITH M INCREMENTED TO NEW USER VIRTUAL ADDRESS <ADR>+1.
;ALL OTHER ACS ARE PRESERVED.

GETWR1::HRRI	M,1(M)		;INCREMENT M BEFORE PICKING UP WORD
GETWRD::TRNN	M,777760	;REFERENCE TO A USER AC?
	JRST	GETWRA		;YES, HANDLE DIFFERENTLY
GETWRU:
	UMOVE	T1,(M)		;READ THE USER WORD
REPEAT 0,<
	MOVE	T1,M
	TLZ	T1,777740
	PUSHJ	P,SSEC1##	;MAKE ADDRESSABLE
	UMOVE	T1,(T1)
>
	  ERJMP	GETWRY		;IF FAILED CHECK FOR PAGE FAULT ETC.
	JRST	CPOPJ1##	;TAKE SKIP RETURN

GETWRA:	MOVEI	T1,JS.ASA	;THE "ACS-ARE-SHADOW-ACS" BIT
	TDNN	T1,JBTSTS##(J)	;REAL OR FAKE ACS?
	JRST	GETWRU		;REAL, HANDLE NORMALLY AFTER ALL
	HRRZ	T1,M		;CLEAR LEFT HALF JUNK
	MOVE	T1,.JDAT(T1)	;FAKE, READ FROM SHADOW ACS AREA
	JRST	CPOPJ1##	;SUCCESSFUL RETURN

GETWRY:	MOVE	R,.CPADR##	;SET UP RELOCATION FOR VMSER
	PUSHJ	P,FLTSX##	;CHECK FOR PAGE FAULT
	  POPJ	P,		;BAD ADDRESS-ERROR RETURN
	POPJ	P,		;IT'S STILL BAD, FLTSX NOTWITHSTANDING
;STOTAC  --  STORE WORD INTO USER AC
;STOTC1  --  STORE WORD INTO USER AC AND SKIP RETURN
;CALL IS:
;
;	MOVX	T1,<WRD>
;	PUSHJ	P,STOTAC
;	RETURN (STOTAC)
;	RETURN (STOTC1)
;
;WHERE <WRD> IS THE WORD TO BE WRITTEN INTO THE USER AC.
;
;PRESERVES ALL ACS.

STOTC1::AOSA	(P)		;SKIP RETURN
RTM2::	MOVNI	T1,2		;RETURN -2 TO USER
STOTAC::PUSH	P,M		;SAVE M
	LDB	M,PUUOAC##	;GET USER'S AC
	PUSHJ	P,PUTWDU	;STORE T1 IN USER'S AC
	JRST	MPOPJ##		;RESTORE M AND RETURN



;PUTWDU  --  WRITE 1 WORD INTO USER VIRTUAL ADDRESS SPACE
;PUTWD1  --  WRITE NEXT WORD INTO USER VIRTUAL ADDRESS SPACE
;CALL IS:
;
;	MOVX	M,<ADR>
;	MOVX	T1,<WRD>
;	PUSHJ	P,PUTWDU
;	RETURN
;
;WHERE <WRD> IS THE WORD TO BE WRITTEN INTO USER VIRTUAL ADDRESS <ADR>
;
;DISPATCHES TO PAGE FAULT HANDLER ON A USER PAGE FAULT, OR PRINTS ILL
;ADR IN UUO IF NO SUCH ADDRESS.
;
;ON SUCCESSFUL RETURN THE USER WORD IS IN T1 AND, IF CALL WAS TO
;PUTWD1 M IS UPDATED TO NEW USER VIRTUAL ADDRESS <ADR>+1.
;PRESERVES ALL OTHER ACS.

PUTWD1::HRRI	M,1(M)		;INCREMENT M BEFORE STORING WORD
PUTWDU::PUSH	P,J		;SAVE J
	MOVE	J,.CPJOB##	;SET UP J FOR THIS CPU'S JOB
	PUSHJ	P,PUTWRD	;STORE THE WORD
	  JRST	UADERR##	;A LOSER
	JRST	JPOPJ##		;A WINNER, RESTORE J AND RETURN
;PUTWRD  --  WRITE 1 WORD INTO USER VIRTUAL ADDRESS SPACE
;PUTWR1  --  WRITE NEXT WORD INTO USER VIRTUAL ADDRESS SPACE
;CALL IS:
;
;	MOVX	J,<JOB>
;	MOVX	M,<ADR>
;	MOVX	T1,<WRD>
;	PUSHJ	P,GETWRD
;	  ERROR
;	NORMAL
;
;WHERE <JOB> IS USER JOB NUMBER; <ADR> IS USER VIRTUAL ADDRESS;
;AND <WRD> IS THE WORD TO BE WRITTEN INTO THE USER ADDRESS <ADR>.
;CAN BE CALLED AT CLOCK OR UUO LEVEL.
;
;DISPATCHES TO PAGE FAULT HANDLER ON A USER PAGE FAULT, OTHERWISE
;RETURNS CPOPJ0 IF USER ADDRESS IS UNWRITEABLE.
;
;SUCCESSFUL RETURN IS CPOPJ1 WITH USER WORD IN T1 AND, IF CALL WAS
;TO PUTWR1, WITH M INCREMENTED TO NEW USER VIRTUAL ADDRESS <ADR>+1.
;ALL OTHER ACS PRESERVED.

PUTWR1::HRRI	M,1(M)		;INCREMENT BEFORE STORING WORD
PUTWRD::PUSH	P,T1		;NEED A SCRATCH AC MOMENTARILY
	TRNN	M,777760	;REFERENCE TO USER AC?
	JRST	PUTWRA		;YES, HANDLE DIFFERENTLY
	HRRZ	T1,M		;GET USER VIRTUAL ADDRESS
	CAIG	T1,JOBPFI##	;IN PROTECTED JOB DATA AREA?
	JRST	TPOPJ##		;YES, TAKE FAILURE RETURN
PUTWRU:	POP	P,T1		;RESTORE VALUE TO BE DEPOSITED
REPEAT 0,<
	PUSHJ	P,SSEC1##	;ENTER SECTION 1
	PUSH	P,M
	TLZ	M,777740
>
	UMOVEM	T1,(M)		;STORE WORD IN USER ADDRESS SPACE
	  ERJMP	PUTWRY		;CHECK ON FAILURE
REPEAT 0,<
	POP	P,M
>
	JRST	CPOPJ1##	;TAKE SUCCESSFUL RETURN

PUTWRA:	MOVEI	T1,JS.ASA	;THE "ACS-ARE-SHADOW-ACS" BIT
	TDNN	T1,JBTSTS##(J)	;REAL OR FAKE ACS
	JRST	PUTWRU		;REAL, TREAT NORMALLY AFTER ALL
	POP	P,T1		;FAKE ACS, RESTORE T1
	PUSH	P,M
REPEAT 0,<
	TLZ	M,777740	;CLEAR POSSIBLE JUNK
>
	MOVEM	T1,.JDAT(M)	;AND WRITE INTO SHADOW ACS
	POP	P,M
	JRST	CPOPJ1##	;ALWAYS SUCCEEDS

PUTWRY:
REPEAT 0,<
	POP	P,M		;RESTORE ORIGINAL CONTENTS
>
	PUSHJ	P,FLTSX##	;CHECK FOR PAGE FAULT
	  POPJ	P,		;BAD ADDRESS-ERROR RETURN
	PUSH	P,T1		;NEED A SCRATCH AC
	HRRZ	T1,M		;USER VIRTUAL ADDRESS
	CAML	T1,.UPMP+.UPHSS	;ADDRESS WITHIN HIGH SEG?
	CAMLE	T1,.UPMP+.UPHSE	;...
	JRST	TPOPJ##		;NO, WRITE-LOCKED LOWSEG???
	PUSH	P,T2		;PROTECT
	PUSH	P,S		; AGAINST
	PUSH	P,P2		;  HGHDEP
	MOVE	S,-3(P)		;HGHDEP WANTS WORD IN S
	HRRZ	T2,M		;AND ADDRESS IN T2
	PUSHJ	P,HGHDEP##	;TRY STUFFING INTO HIGH SEGMENT
	  SOS	-4(P)		;NOPE
	POP	P,P2		;RESTORE
	POP	P,S		; ACS
	POP	P,T2		;  FROM
	JRST	TPOPJ1##	;   HGHDEP

;WARNING:  ANY CHANGES MADE TO TSTREL SHOULD ALSO BE REFLECTED IN GETWRD & PUTWRD

TSTREL::MOVEI	T1,JS.ASA	;WHAT DOES REFERENCE TO USER 0-17 REALLY MEAN BIT
	TRNN	M,777760	;IS THIS REFERENCE TO USER 0-17?
	TDNN	T1,JBTSTS##(J)	;YES, IS IT TO USER'S ACS OR THE SHADOW ACS?
	AOS	(P)		;USER'S ACS
	POPJ	P,		;GIVE SHADOW ACS OR USER AC SET RETURN
;SUBROUTINE TO CHECK IF SEGMENT # IN J IS A LEGAL SEG #
;ARGS	J=SEG#
;SKIP RETURN IF LEGAL SEGMENT #, NON-SKIP IF NOT

LGJSEG::HRRZ	T1,J
LGLSEG::CAILE	T1,JOBMAX##	;SKIP IF BELOW 1ST LEGAL SEG #
	CAIL	T1,JBTMAX##	;NO, SKIP IF LEGAL SEG #
	POPJ	P,
	JRST	CPOPJ1##

LGJPRC::SKIPA	T1,J		;FROM J, EXCLUDE ZERO
LGJPR1::SKIPA	T1,J		;FROM J, ALLOW ZERO
LGLPRC::JUMPLE	T1,CPOPJ##	;JUMP IF LE 0
LGLPR1::CAIG 	T1,JOBMAX##
	JUMPGE	T1,CPOPJ1##	;0 WAS ALREADY CHECKED
	POPJ	P,		;-N ALWAYS ILLEGAL

;RRNGE AND WRNGE -- CHECK FOR A RANGE OF READABLE OR WRITABLE
; ADDRESSES.
;CALL
;	T1 = FIRST WORD ADDRESS
;	T2 = LAST WORD ADDRESS
;

WRNGE::	CAIG	T1,JOBPFI##	;BLOCK SAFELY ABOVE PROTECTED JOB DATA AREA
	CAILE	T2,17		; OR SAFELY BELOW IT.
	TLOA	T2,(1B0)	;YES, FLAG CALL TO WRNGE
	JRST	UADERR##	;NO, ILLEGAL ADDRESS IN UUO
RRNGE::	PUSH	P,M		;PRESERVE M
	HRRZ	M,T1		;INITIAL ADDRESS TO CHECK
RRNGE1:	PUSHJ	P,GETWDU	;GET A WORD
	JUMPGE	T2,RRNGE2	;IF READ CHECK ONLY
	PUSHJ	P,PUTWDU	;TRY AND WRITE IT BACK
RRNGE2:	TRO	M,PG.BDY##	;LAST WORD IN THIS PAGE
	CAIL	M,(T2)		;CHECKED WHOLE RANGE?
	JRST	MPOPJ##		;YES, ALL OKAY
	ADDI	M,PAGSIZ##	;NO, ADVANCE TO NEXT PAGE
	JRST	RRNGE1		;LOOP OVER WHOLE PAGE

;SUBROUTINE TO CREATE A PDB
;ARG	J=JOB NUMBER


CREPDB::HRRZ	T1,JBTPDB##(J)	;SEE IF ALREADY ONE THERE
	JUMPN	T1,CREPD1	;GO CLEAR IT IF COMCON LEFT ONE
	MOVEI	T2,PDB4WD##	;NUMBER OF 2 WORD BLOCKS NEEDED FOR A PDB
	PUSHJ	P,GET4WD##	;GET BLOCK FOR PDB
	  POPJ	P,		;CAN'T GET THRU
CREPD1:	HRRZ	W,T1
	HRRM	W,JBTPDB##(J)
	SETZM	(W)		;CLEAR ALL PDB
	HRLI	T1,1(W)		;MAKE BIT PTR
	MOVSS	T1
	BLT	T1,.PDLE4##-1(W)
	MOVE	T1,STNPRT##	;INITIALIZE DEAFULT
	MOVEM	T1,.PDDFL##(W)	;TO STANDARD FILE PROTECTION
	MOVSI	T1,(PD.LGN)	;GET THE LOGIN BIT
	IORM	T1,.PDDFL##(W)	;SET IT IN THE WORD
	JRST	CPOPJ1##

;SUBROUTINE TO DEALLOCATE A PDB
;ARGS	J=JOB NUMBER

KILPDB::
IFN FTMP,<
	PUSHJ	P,INTLVL##	;INTERRUPT LEVEL?
	  JRST	[PUSHJ	P,UPMM##;NO, WAIT UUO LEVEL STYLE
		 JRST	KILPD1	]
	PUSHJ	P,GETMM##
	  JRST	.-1		;INTERRUPT LEVEL STYLE
KILPD1:>
	MOVEI	T1,PDB4WD##	;NUMBER OF 4 WORD BLOCKS FOR A PDB
	HRRZ	T2,JBTPDB##(J)	;ADDR OF PDB
	PUSHJ	P,GIV4WD##	;DEALLOCATE PDB
	HLLZS	JBTPDB##(J)	;CLEAR ADDR OF PDB
IFN FTMP,<
	PUSHJ	P,INTLVL##	;INTERRUPT LEVEL?
	  PJRST	DWNMM##		;GIVE IT UP UUO LEVEL STYLE
	PJRST	GIVMM##		;RETURN MM
>
IFE FTMP,<
	POPJ	P,		;RETURN
>

DATEND:	END
