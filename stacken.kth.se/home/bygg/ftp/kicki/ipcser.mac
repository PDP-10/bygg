TITLE IPCSER -- INTER PROCESS COMMUNICATION FACILITY V261
SUBTTL J. SAUTER/T. WACHS/LSS/CDO/JMF   3 JAN 84
	SEARCH	F,S
	$RELOC
	$HIGH


;modified for running galaxy5 860817, pl}thberg

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<
COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
>


;DATE		LOAD	EDIT #
;____		____	______

;12-AUG-80	70111	207
;9349
;19-AUG-80	70112	210
;9368
;02-SEP-80	70114	211
;27-JAN-81	70136	212
;9545-9552
;17-FEB-81	70141	213
;9582-9585
;24-FEB-81	70142	214
;9593
;03-MAR-81	70143	215
;31-MAR-81	70147	216
;9659
;07-APR-81	70150	217
;9665-9676-9679-
;14-APR-81	70151	220
;9687-
;12-MAY-81	70155	221
;21-JUL-81	70167	222
;9834
;22-SEP-81	70175	223
;03-NOV-81	70114	224
;9952-
;17-NOV-81	70116	225
;9969
;22-NOV-81	70117	226
;9981
;15-DEC-81	70122	227
;MCO 10013
;12-JAN-82	70126	230
;9-FEB-82	70132	231
;10085,10088,10096
;02-MAR-82	70135	232
;10123
;09-MAR-82	70136	233
;30-MAR-82	70141	234
;10184
;27-APR-82	70144	235
;22-JUN-82	70154	236
;29-JUN-82	70155	237
;10298
;20-JUL-82	70160	240
;10320
;21-DEC-82	70116	241
;04-JAN-83	70117	242
;11-JAN-83	70120	243
;10-MAY-83	70141	244
;10757
;17-MAY-83	70142	245
;10765
;14-JUN-83	70146	246
;10819
;26-JULY-83	70153	247
;2-AUG-83	70154	250
;10886
;9-aug-83	70155	251
;13-SEP-83	70162	252
;20-SEP-83	70163	253
;27-SEP-83	70164	254
;10978
;11-OCT-83	70166	255
;18-OCT-83	70167	256
;11004
;25-OCT-83	70170	257
;11015
;13-DEC-83	70172	260
;3-JAN-84	70173	261
;19-Sep-84	PCO 10-702-015
;
;XP VIPCSR,262		;VERSION NUMBER FOR GLOB AND MAP

ENTRY IPCSER		;LOAD THIS MODULE IF REQUESTED

IPCSER::

;IPCSER PROVIDES A FACILITY WHICH PERMITS TWO JOBS TO EFFICIENTLY
; EXCHANGE LIMITED AMOUNTS OF DATA.  THE MONITOR MAY ALSO PARTICIPATE
; IN THIS EXCHANGE BY MEANS OF "EXEC PSEUDO-PROCESSES".
;DATA STRUCTURES:
XX=.			;REMEMBER LOCATION
;EXECUTIVE PROCESS CONTROL BLOCK
	PHASE 	0

;NOTE THAT .EPIPC,.EPIPA, .EPIPQ MUST REMAIN IN THIS ORDER
; (SAME ORDER AS .PDIPC,.PDIPA, .PDIPQ)

.EPIPC:!BLOCK	1	;LH=POINTER TO OLDEST PACKET
			;18-26 = PACKETS SENT & NOT RECEIVED
			;27-35 = PACKETS WAITING TO BE REC.
.EPIPA:!BLOCK	1	;LH = COUNT OF SENDS SINCE LOGIN
			;RH = COUNT OF RECEIVES SINCE LOGIN
.EPIPQ:!BLOCK	1	;FLAGS AND QUOTAS
IP.DSB==(1B0)		;RECEIVER IS DISABLED
IP.HBS==(1B1)		;QUOTAS HAVE BEEN SET
IP.DPR==(1B2)		;AT LEAST 1 PID FOR JOB IS TO BE DROPPED ON RESET
IP.DPL==(1B3)		;AT LEAST 1 PID TO BE DROPPED ON LOGOUT
IP.LOK==(1B4)
IP.JOB==:(777B17)	;JOB NUMBER WHOSE QUEUE WE HAVE INTERLOCKED
			;18-26 = SEND QUOTA
			;27-35 = RECEIVE QUOTA
	IP.SBT==1000	;1ST BIT IN SEND QUOTA/COUNT BYTE

;THE .EPXXX WORDS ABOVE HAVE CORRESPONDING .PDXXX WORDS IN
;  THE PDB FOR USER JOBS.

.EPADR:!BLOCK	1	;PUSHJ @ HERE WHEN A PACKET ARRIVES
			;  FOR THIS PROCESS.
	DEPHASE
;DEFINITION OF PACKET DESCRIPTOR BLOCK

	PHASE 	0
.IPCFL::!BLOCK	1	;LINK AND FLAGS
	IP.CFB==(1B0)	;UUO BLOCK: DONT BLOCK READ UUO
	IP.IAS==(1B1)	;UUO BLOCK: INDIRECT ADDRESS FOR SENDER'S PID
	IP.IAR==(1B2)	;UUO BLOCK: INDIRECT ADDRESS FOR RECEIVER'S PID
			;IN PACKET, LH = POINTER TO NEXT
	IP.LPC==(1B3)	;UUO BLOCK: "LAST PHONE CALL" - SEND EVEN THO QUOTA
			; IS OVERDRAWN (ONLY ALLOWS OVERDRAW OF 1)
	IP.TTL==(1B4)	;UUO BLOCK-TRUNCATE PACKET IF TOO LONG
	IP.LPK==(1B5)	;PACKET IS LONGER THAN MAX SYSTEM SIZE (PRIVID)
	IP.RFP==(1B6)	;RECEIVE FOR A PARTICULAR PID
	IP.SIP==1B18	;SENDER IS PRIVILEGED
	IP.CFV==1B19	;VM PAGE MODE
	IP.CFZ==1B20	;DATA LENGTH=0
	IP.AKR==1B21	;SENDER REQUESTS ACKNOWLEGEMENT FROM RECEIVER
	IP.CFE==77B29	;(UNPRIV) ERROR RETURN
	IP.CFM==77B35	;SPECIAL MESSAGE FIELD
	   .IPCMN==1	;MESSAGE 1: MESSAGE WAS UNDELIVERABLE

.IPCFS::!BLOCK	1	;SENDER'S PID
.IPCFR::!BLOCK	1	;RECEIVER'S PID
.IPCFP::!BLOCK	1	;LH = LENGTH  OF PACKET'S DATA
			;IN UUO BLOCK, RH = USER'S PACKET BUFFER
			;IN PACKET, RH = RESERVED FOR VIRTUAL FEATURE
.IPCFM::!BLOCK	0	;MINIMUM LENGTH OF DESCRIPTOR BLOCK
.IPCFU::!BLOCK	1	;SENDER'S PPN.  FILLED IN BY MONITOR ON SEND
			;UUO NEVER FILLED IN BY USER.
.IPCFC::!BLOCK	1	;SENDER'S CAPABILITIES WORD.  FILLED IN SAME
			;FASHION AS .IPCFU.
	IP.JAC==(1B0)	;SENDER HAS JACCT ON
	IP.JLG==(1B1)	;SENDER IS LOGGED-IN
	IP.SXO==(1B2)	;SENDER IS EXECUTE-ONLY
	IP.POK==(1B3)	;SENDER CAN POKE THE MONITOR
	IP.IPC==(1B4)	;SEND HAS IPCF PRIVS
	IP.RIP==1B26	;RECEIVE IN PROGRESS
			;THERE IS A JOB IN THE PROCESS OF RECEIVING THIS
			;PACKET, IT'S TOO LATE TO TURN THE PACKET AROUND.
			;BITS 27:35 = JOB NO OF SENDER
.IPCFD::!BLOCK	0	;IN PACKET ONLY, START OF DATA.
	DEPHASE
	RELOC	XX	;DONT WASTE ANY SPACE
TRNPTR:	POINT	9,.IPCFC(P1),35
TRNPT2:	POINT	9,.IPCFC(P2),35
; SPOOLED PARAMETER BLOCK DEFINITIONS

SPBPCP==0	;NUMBER OF COPIES
SPBPFM==1	;FORMS NAME
SPBPLM==2	;LIMIT
SPBPSF==3	;SPOOLING FLAGS
SPBPDA==4	;DEVICE ATTRIBUTES
SPBPND==5	;NODE
SPBPAF==6	;AFTER PARAMETER
SPBNM1==7	;SIXBIT USER NAME (WORD 1)
SPBNM2==10	;SIXBIT USER NAME (WORD 2)
SPBACT==:11	;START OF ACCOUNT STRING

MAXACS==:^D8	;MAXIMUM LENGTH OF ACCOUNT STRING
		;MUST MATCH ONE IN COMMON

SPBMAX==:SPBACT+MAXACS ;TOTAL LENGTH OF SPB 

;DESCRIPTION OF SPOOL, LOGIN AND LOGOUT MESSAGES
;	ALL MESSAGES FROM IPCC TO QUASAR HAVE A TWO WORD HEADER AS
;	DESCRIBED BELOW.  THE LOGOUT MESSAGE CONSISTS SOLELY OF THESE
;	TWO WORDS, AND THE SPOOL MESSAGE HAS FILE INFORMATION APPENDED,
;	THE LOGIN MESSAGE HAS JOB INFORMATION APPENDED.

	XX=.				;REMEMBER LOCATION

	PHASE	0		;START AT 0

GALMSG:!BLOCK	1			;MESSAGE HEADER
					; XWD LENGTH,,FUNCTION

GALSTS:!BLOCK	1			;STATUS WORD
	GALBSN==177B8			;BATCH STREAM NUMBER (IF GALBAT)
	GALJOB==777B17			;BITS 0-17 IS JOB NUMBER
	GALLOC==777000			;    18-26 IS LOCATION
	GALFLG==777			;    27-35 ARE FLAGS
		GALBAT==1B27		;BATCH JOB
		GALDFR==1B28		;DEFERRED SPOOLING
		GALBSS==1B29		;BATCH STREAM NUMBER SET

	LGMSIZ==.-GALMSG		;SIZE OF LOGOUT MESSAGE

SPMUSR:!BLOCK	2			;USER NAME IN 6BIT
SPMIDV:!BLOCK	1			;INITED DEVICE
SPMSTR:!BLOCK	1			;STRUCTURE NAME
SPMFIL:!BLOCK	1			;FILENAME
SPMEFN:!BLOCK	1			;ENTER'ED FILE NAME (RIBSPL, DEVSPN)
SPMFSZ:!BLOCK	1			;FILE SIZE IN BLOCKS
SPMEXT:!BLOCK	1			;SPOOLED FILE EXTENSION
SPMPRM:!BLOCK	SPBMAX			;SPACE FOR SPOOLING OPTION BLOCK

	SPMSIZ==.-GALMSG		;SIZE OF SPOOL MESSAGE

	PHASE	GALSTS+1
LOMUSR:!BLOCK	2			;USER NAME IN 6BIT
LOMCTL:!BLOCK	1			;CONTROLLERS JOB NUMBER
LOMTTY:!BLOCK	1			;TTY
	LOMSIZ==.-GALMSG

	DEPHASE
	RELOC	XX		;RECLAIM SPACE

;ERROR CODES:

IPCAC%==1		;ADDRESS CHECK (UUO BLOCK OR PACKET BUFFER)
IPCNL%==2		;NOT LONG ENOUGH (UUO BLOCK)
IPCNP%==3		;NO PACKET IN LIST (READ UNBLOCKED)
IPCIU%==4		;(PAGE) IN USE (PART OF VIRTUAL FEATURE)(PAGE IS LOCKED)
IPCTL%==5		;(PACKET) TOO LONG (FOR USER'S BUFFER)
IPCDU%==6		;DESTINATION UNKNOWN (SEND)
IPCDD%==7		;DESTINATION DISABLED (SEND)
IPCRS%==10		;(NO) ROOM (IN) SENDER'S (QUOTA)
IPCRR%==11		;(NO) ROOM (IN) RECEIVER'S (QUOTA)
IPCRY%==12		;(NO) ROOM (IN) SYSTEM (STORAGE)
IPCUP%==13		;UNKNOWN PAGE (SEND) EXISTING PAGE (REC)
IPCIS%==14		;INVALID SEND ADDRESS
IPCPI%==15		;PRIVILEGES INSUFFICIENT
IPCUF%==16		;UNKNOWN FUNCTION
IPCBJ%==17		;BAD JOB NUMBER
IPCPF%==20		;PIDTAB FULL
IPCPR%==21		;PAGED PACKET REQUESTED, REGULAR PACKET IN QUEUE OR VICE VERSA(VM)
IPCIE%==22		;PAGING IO ERROR (VM)
IPCBI%==23		;BAD INDEX SPECIFIED FOR SYSTEM PID TABLE
IPCUI%==24		;UNDEFINED ID IN SYSTEM PID TABLE
IPCRU%==25		;RECEIVER UNKNOWN

;SUBROUTINE TO VALIDATE ARGUMENTS AND FETCH THEM INTO P1-P4.
;  SKIP RETURN ON OK, LEAVES ADDR OF ARG IN M.

VALARG:	HLRZ	T2,T1		;GET USER'S AC LEFT HALF
	CAIGE	T2,.IPCFM	;LONG ENOUGH?
	JRST	ERRNL		;NO.
	MOVE	P4,T1		;YES, COPY USER'S AC
	HRRI	M,.IPCFL(P4)	;FIRST LOCATION OF BLOCK
	PUSHJ	P,GETWRD##	;FETCH .IPCFL
	  JRST	ERRAC		;ADDRESS CHECK
	MOVE	P1,T1		;PUT .IPCFL IN P1
	PUSHJ	P,GETWR1##	;FETCH SENDER'S PID
	  JRST	ERRAC		;ADDRESS CHECK
	TLNN	P1,IP.IAS	;IS SENDER'S PID INDIRECTED?
	JRST	VALAR1		;NO.
	HRR	M,T1		;YES, GET ADDRESS
	TLNN	T1,-1		;LH = 0?
	PUSHJ	P,GETWRD##	;YES, FETCH THAT WORD.
	  JRST	ERRAC		;ADDRESS CHECK
VALAR1:	MOVE	P2,T1		;PUT .IPCFS IN P2
	HRRI	M,.IPCFR(P4)	;THIRD LOCATION OF BLOCK
	PUSHJ	P,GETWRD##	;FETCH RECEIVER'S PID
	  JRST	ERRAC		;ADDRESS CHECK
	TLNN	P1,IP.IAR	;IS RECEIVER'S PID INDIRECTED?
	JRST	VALAR2		;NO.
	HRR	M,T1		;YES, PUT ADDRESS IN M
	TLNN	T1,-1		;IS LH = 0?
	PUSHJ	P,GETWRD##	;YES, GET THE WORD.
	  JRST	ERRAC		;ADDRESS CHECK
VALAR2:	MOVE	P3,T1		;GET RECEIVER PID
	CAMN	P3,%IPCFP##	;PUBLIC VALUE FOR [SYSTEM]IPCF?
	MOVE	P3,PIDTAB##	;YES, CONVERT TO ACTUAL VALUE
	HRRI	M,.IPCFP(P4)	;FOURTH LOCATION OF BLOCK
	PUSHJ	P,GETWRD##	;FETCH PACKET DESCRIPTOR
	  JRST	ERRAC		;ADDRESS CHECK
	HRRI	M,.IPCFL(P4)	;POINT BACK TO FRONT OF BLOCK
	MOVE	P4,T1		;PUT .IPCFP IN P4
	TRNN	P1,IP.CFV	;ASKING FOR A PAGE?
	JRST	VALAR3		;NO
	HLRZ	T1,P4		;YES, EXACTLY 1 PAGE?
	TLNE	P1,IP.TTL	;TRUNCATE IF TOO LONG?
	JUMPE	T1,VALAR3	;YES, LENGTH =0 IS OK
	CAIE	T1,PAGSIZ##
	JRST	ERRTL		;CANT DO MORE THAN 1 PAGE AT A TIME
	HRRZS	P4		;OK, SET LENGTH OF DATA TO 0 (NO DATA WDS IN PACKET)
	MOVSI	T1,NSHF!NSWP	;LOCKED BITS
	SKIPLE	T2,JBTSGN##(J)	;DOES JOB HAVE A HIGH SEG
	TLNE	T2,SHRSEG	;YES, IS IT SHAREABLE
	MOVEI	T2,0		;NO HIGH SEG OR NOT SHAREABLE
	TDNN	T1,JBTSTS##(J)	;LOW SEG LOCKED
	TDNE	T1,JBTSTS##(T2)	;OR HIGH SEG LOCKED
	  PJRST	ERRIU		;YES, GIVE ERROR
	HRLI	P4,-1
	HRRZI	T1,(P4)		;GET PAGE #
	PUSHJ	P,LGLPG##	;LEGAL?
	PJRST	ERRAC		;NO, ADDRESS CHECK.
	JRST	VALAR4
VALAR3:	HRRZ	T1,P4		;START ADR
	PUSHJ	P,CHKADR	;CHECK IT
	  PJRST	ERRAC
	HLRE	T2,P4
	JUMPLE	T2,[JUMPE T2,VALAR4 ;OK IF NO DATA WORDS
		    JRST ERRNL]
	ADDI	T1,-1(T2)	;TOP ADR
	PUSHJ	P,CHKADR	;CHECK
	  PJRST	ERRAC
VALAR4:	MOVSI	T1,JP.IPC	;NO PRIV BIT DEFINED
	TRNN	P1,-1-IP.CFE-IP.CFV-IP.AKR ;PRIV'D FUNCTION?
	TRNA			;NO, DON'T NEED TO CHECK
	PUSHJ	P,PRVBIT##	;YES, GOT PRIVS?
	AOSA	(P)		;EVERYTHING OK
	JRST	ERRPI		;NO PRIVS FOR PRIV'D FUNCTION
	PJRST	FNDPDS##	;SET UP W AND RETURN
;SUBROUTINE TO ADDRESS CHECK
CHKADR:	PUSH	P,T1
	PUSH	P,M		;SAVE M
	HRR	M,T1
	PUSHJ	P,GETWRD##
	  SOS	-2(P)
	POP	P,M
	PJRST	TPOPJ1##
;SUBROUTINE TO LOAD J AND W BASED ON PID IN T1.
;RETURNS CPOPJ ON ERROR, ERROR CODE IN T1
;RETURNS CPOPJ1 IF OK

VALPID:	JUMPE	T1,VALPD4	;ZERO PID IS INVALID
	CAIG	T1,JOBMAX##	;SEE IF JOB NUMBER
	JUMPG	T1,VALPD1	;JOB NO
	MOVE	T2,T1		;COPY OF PID
	AND	T2,%IPCPM##	;MASK TO INDEX
	CAMGE	T2,%IPCMP##	;IN RANGE?
	SKIPN	T2,PIDTAB##(T2)	;YES, PICK UP ENTRY.
	JRST	VALPD4		;NO ENTRY HERE
	MOVE	T3,T2		;SAVE IT FOR LATER
	XOR	T2,T1		;CLEAR BITS IN COMMON
	TDZ	T2,%IPCPM##	;CLEAR UNWANTED BITS
	JUMPN	T2,VALPD4	;SEQ # ARE THE SAME IF 0
	AND	T3,%IPCPM##	;GET JOB NUMBER
	SKIPA	J,T3		;SET J
VALPD1:	MOVE	J,T1
	JUMPE	J,VALPD3	;EXECUTIVE PROCESS
	PUSHJ	P,FNDPDB##	;FIND JOB'S PDB
	  JRST	VALPD4		;NONE - PID IS BAD
VALPD2:	AOS	(P)
	PJRST	SETIPQ		;SET QUOTA IF NOT

VALPD3:	HLRZ	W,T1		;POINT TO EXECUTIVE PROCESS CTL BLK
	HRLS	W		;SAVE LOC OF EXEC CTL BLOCK
	SUBI	W,.PDIPC##	;FIX OFFSET SO .PDXXX POINTS TO .EPXXX
	JRST	VALPD2

;HERE ON ERROR
VALPD4:	MOVEI	T1,IPCIS%	;ERROR CODE
	POPJ	P,
;ERROR ROUTINES.  THESE LOAD IPCXX% INTO T1 FOR EACH ERRXX.
;  ERROR ROUTINES ARE CALLED VIA PUSHJ, BUT THEY NEVER RETURN.
;THE POSITION RELATIVE TO ERRAC DEFINES THE ERROR VALUE.

	ERCODE	ERRAC,IPCAC%	;(1) ADDRESS CHECK
	ERCODE	ERRNL,IPCNL%	;(2) NOT LONG ENOUGH
	ERCODE	ERRNP,IPCNP%	;(3) NO PACKET IN QUEUE
	ERCODE	ERRIU,IPCIU%	;(4) PAGE IN USE (VIRTUAL FEATURE)
	ERCODE	ERRTL,IPCTL%	;(5) PACKET TOO LONG
	ERCODE	ERRDU,IPCDU%	;(6) DESTINATION UNKNOWN
	ERCODE	ERRDD,IPCDD%	;(7) DESTINATION DISABLED
	ERCODE	ERRRS,IPCRS%	;(10) NO ROOM IN SENDER'S QUOTA
	ERCODE	ERRRR,IPCRR%	;(11) NO ROOM IN RECEIVER'S QUOTA
	ERCODE	ERRRY,IPCRY%	;(12) NO ROOM IN SYSTEM FOR PACKET
	ERCODE	ERRUP,IPCUP%	;(13) UNKNOWN PAGE (SEND) OR ALREADY EXISTING (REC)
	ERCODE	ERRIS,IPCIS%	;(14) INVALID SENDER'S ADDRESS
	ERCODE	ERRPI,IPCPI%	;(15) INSUFFICIENT PRIVILEGES
	ERCODE	ERRUF,IPCUF%	;(16) - UNKNOWN FUNCTION
	ERCODE	ERRBJ,IPCBJ%	;(17) - BAD JOB NUMBER
	ERCODE	ERRPF,IPCPF%	;(20) - PIDTAB FULL
	ERCODE	ERRPR,IPCPR%	;(21) - PAGE REQUESTED, NOT-A-PAGE IN QUEUE
	ERCODE	ERRIE,IPCIE%	;(22) - PAGING IO ERROR
	ERCODE	ERRBI,IPCBI%	;(23) - BAD INDEX FOR .GTSID
	ERCODE	ERRUI,IPCUI%	;(24) - UNDEFINED ID  REQUESTED
	ERCODE	ERRRU,IPCRU%	;(25) - RECEIVER UNKNOWN OR DOES NOT BELONG TO JOB

SUBTTL IPCFR - RECEIVE UUO

UIPCFR::PUSHJ	P,SAVE4##	;SAVE P1-P4
	SETZM	JBTPID##(J)	;NOT WAITING FOR A PARTICULAR PID
	PUSH	P,T1		;SAVE USER ARG ON THE STACK
	PUSHJ	P,VALARG	;LOAD ARGS
	  JRST	[POP P,(P)	;BRING STACK INTO PHASE
		 POPJ P,]	;AND RETURN
	TLNN	P1,IP.RFP	;RECEIVE FOR PARTICULAR PID?
	JRST	IPFR1		;NO
	MOVE	T1,P3		;YES, MAKE SURE PID IS OK
	PUSHJ	P,VALPID
	  SETZ	J,
	CAME	J,.CPJOB##
	JRST	[POP P,(P)	;BAD PID OR DOESNT BELONG TO JOB
		 JRST ERRRU]
IPFR1:	POP	P,T4		;RESTORE T1 INTO T4
	HLRZS	T4		;JUST NEED THE LENGTH
IPFR2:	HLRZ	P2,.PDIPC##(W)	;POINTER TO OLDEST PACKET
IPFR3:	JUMPE	P2,IPFR14	;NONE.
	TLNE	P1,IP.RFP	;RECEIVE FOR A PID?
	CAMN	P3,.IPCFR(P2)	;YES, IS THIS A MATCH
	JRST	IPFR4		;WE HAVE A PACKET
	HLRZ	P2,.IPCFL(P2)	;NO MATCH, TRY NEXT PACKET IN QUEUE
	JRST	IPFR3
IPFR4:	HRRZ	T1,.IPCFL(P2)	;GET FLAG WORD
	TRNE	T1,IP.CFV	;PAGED PACKET?
	TRZE	P1,IP.CFV	;MUST HAVE REQUESTED A PAGE
	TRNE	P1,IP.CFV	;ERR IF REQUESTED A PAGE
	JRST	ERRPR		;WRONG MODE
	MOVE	P3,T1
	TRNN	P1,IP.SIP	;IS CALLER PRIV AND ASKING FOR PRIVS?
	TRZ	T1,IP.SIP	;NO, HE DOESNT CARE IF PACKET PRIV
	HLRZ	T2,P4		;SPACE PROVIDED
	HLRZ	T3,.IPCFP(P2)	;LENGTH OF PACKET
	SUB	T3,T2
	SKIPG	T3		;LONG ENOUGH?
	TLZA	P1,IP.TTL	;YES, CLEAR TTL BIT
	TLO	T1,IP.TTL	;NO, SET TTL IN UUO BLOCK
	PUSHJ	P,PUTWDU##	;STORE IN USER'S ARG BLOCK
	MOVE	T1,.IPCFS(P2)	;GET SENDER'S PID
	PUSHJ	P,PUTWD1##	;STORE SENDER'S PID
	MOVE	T1,.IPCFR(P2)	;RECEIVER'S PID
	PUSHJ	P,PUTWD1##	;STORE RECEIVER'S PID
	TLNN	P1,IP.TTL	;TRUNCATE IF TOO LONG?
	JUMPG	T3,ERRTL	;NO, ERROR IF TOO LONG
;COME HERE TO COPY PACKET TO USER'S CORE.

	MOVE	T1,.IPCFP(P2)	;LENGTH IN LH
	HRR	T1,P4		;HDR
	TRNE	P3,IP.CFV
	HRLI	T1,PAGSIZ##	;WHOLE PAGE

	TLNE	P1,IP.TTL	;PACKET TOO LONG?
	HLL	T1,P4		;YES, TELL TRUNCATED LENGTH
	PUSHJ	P,PUTWD1##	;TELL USER THE LENGTH
	MOVE	T1,.IPCFU(P2)	;GET SENDER'S PPN
	CAILE	T4,.IPCFU	;DID HE ASK FOR IT?
	PUSHJ	P,PUTWD1##	;YES, GIVE IT TO HIM
	MOVE	T1,.IPCFC(P2)	;GET CAPABILITIES WORD
	CAILE	T4,.IPCFC	;DID HE ASK FOR IT ALSO?
	PUSHJ	P,PUTWD1##	;YES, GIVE IT TO HIM
	HLRE	T1,.IPCFP(P2)	;LENGTH
	TLNE	P1,IP.TTL	;TOO LONG?
	HLRE	T1,P4		;YES, JUST FILL HIS BLOCK
	JUMPLE	T1,IPFR6	;NOTHING TO STORE IF 0 WDS IN PACKET
	HRRI	M,-1(P4)	;USER'S ADDRESS
	MOVN	T2,T1		;FORM AOBJN WORD
	HRLZS	T2
	HRR	T2,P2		;ADR OF PACKET
IPFR5:	MOVE	T1,.IPCFD(T2)	;FETCH DATA FROM EXEC
	PUSHJ	P,PUTWD1##	;STORE IN USER'S AC
	AOBJN	T2,IPFR5	;COPY WHOLE PACKET

IPFR6:	TRNN	P3,IP.CFV	;WHOLE PAGE?
	JRST	IPFR7		;NO
	TLNE	P1,IP.TTL	;TOO LONG?
IFN	FTDHIA,<
	JRST	[PUSHJ	P,IPCLOK
		 HRRZ T2,.IPCFP(P2)	;YES, DELETE THE PAGE
		 SKIPE	T2		;FORGET IT IF IO ERROR
		 PUSHJ P,IPCDEL##
		 PUSHJ	P,IPCULK
		 JRST IPFR7	     ]
>
IFE	FTDHIA,<
	JRST	[HRRZ	T2,.IPCFP(P2)	;YES, DELETE THE PAGE
		 JUMPE	T2,IPFR7	;FORGET IT IF IO ERROR
		 PUSHJ	P,IPCDEL##
		 JRST	IPFR7	     ]
>
	HRRZ	T1,P4		;NO, GET VIRTUAL PAGE NO
IFN	FTDHIA,<
	PUSHJ	P,IPCLOK
>
	HRRZ	T2,.IPCFP(P2)	;DSK OR CORE ADR
IFE	FTDHIA,<
	JUMPE	T2,ERRIE	;ERROR PAGING OUT THE PAGE
>
IFN	FTDHIA,<
	JUMPE	T2,[PUSHJ	P,IPCULK
		    JRST	ERRIE	]
>
	MOVEI	T3,IP.RIP	;MARK IT IN CASE IPCINS BLOCKS
	IORM	T3,.IPCFC(P2)	
	PUSHJ	P,IPCINS##	;PUT PAGE INTO THIS MAP
	  TDZA	T2,T2		;LOST
	SETO	T2,		;WON
IFN	FTDHIA,<
	PUSHJ	P,IPCULK
>
	MOVEI	T3,IP.RIP	;CLEAR RECEIVE IN PROGREES
	ANDCAM	T3,.IPCFC(P2)	
	JUMPN	T2,IPFR7	;GO IF WON
	JUMPE	T1,ERRUP	;T1=0 IF NO SUCH PAGE
	JRST	ERRIE		;OTHERWISE PAGING IO ERROR
;COME HERE TO DECREMENT RECEIVER'S AND SENDER'S COUNTERS,
;  FREE EXEC COPY OF PACKET, ETC.  NO ERROR EXITS ARE
;  PERMITTED BEYOND THIS POINT SINCE EXEC INFORMATION IS
;  ALTERED.

IPFR7:	MOVEI	T2,.PDIPC##-.IPCFL(W)  ;PRESET PREDECESSOR
IPFR8:	HLRZ	T3,.IPCFL(T2)
	CAIN	T3,(P2)		;THIS PACKET LINK TO OURS?
	JRST	IPFR9		;YES
	MOVE	T2,T3		;NO, TEST NEXT
	JRST	IPFR8
IPFR9:	SYSPIF
	HLRZ	T1,.IPCFL(P2)	;POINTER TO NEXT PACKET
	HRLM	T1,.IPCFL(T2)	;LINK PREDECESSOR TO NEXT
	SKIPN	T1		;END OF QUEUE?
	HRRM	T2,.PDIPN##(W)	;YES, PRED IS NEW END
	SYSPIN
IPFR10:	JUMPE	T1,IPFR12
	MOVE	T2,.IPCFR(P2)	;RECEIVER PID
	TLNE	P1,IP.RFP	;RECEIVE FOR A PID?
	CAMN	T2,.IPCFR(T1)	;YES, IS THIS PACKET A MATCH?
	JRST	IPFR11		;THIS IS NEXT PACKET
	HLRZ	T1,.IPCFL(T1)	;NO MATCH, TRY NEXT
	JRST	IPFR10
IPFR11:	HLL	T1,.IPCFP(T1)	;LENGTH OF NEXT PACKET
	HRR	T1,.IPCFL(T1)	;FLAGS FOR NEXT PACKET
	TRNE	T1,IP.CFV	;PAGE?
	HRLI	T1,PAGSIZ##	;YES, SET LENGTH

IPFR12:	PUSHJ	P,STOTAC##	;RETURN INFO ABOUT NEXT PACKET IN AC
	SOS	.PDIPC##(W)	;DEC COUNT OF PACKETS WAITING
	AOS	T1,.PDIPA##(W)	;INCR RECEIVE COUNT
	TRNN	T1,-1
	SOS	.PDIPA##(W)	;OVERFLOW, COUNT IT DOWN AGAIN

;NOW MOVE TO THE SENDER'S ENVIRONMENT TO DECREMENT THE
;  COUNT OF HIS UNRECEIVED SENDS.  SENDER'S PID HAS BEEN
;  KEPT IN P1 FROM WAY BACK.

	MOVE	T2,.IPCFS(P2)	;IS SENDER A SYSTEM PROCESS?
	AND	T2,%IPCPM##
	CAIGE	T2,%IPCNS##
	TDZA	T2,T2		;YES, DON'T USE .IPCFC
	LDB	T2,TRNPT2	;IF TURNED-AROUND MSG THE PID
	SKIPN	T1,T2		; MAY HAVE BEEN DESTROYED,
	MOVE	T1,.IPCFS(P2)	;SO GET W FROM PID
	PUSH	P,J		;SAVE J
	PUSHJ	P,VALPID	;SET UP J & W
	  JRST	IPFR13		;NO GOOD, SENDER MUST BE GONE.
	MOVNI	T1,IP.SBT	;DECREMENT COUNT OF PACKETS SENT BUT
	MOVE	T2,.PDIPC##(W)	;ANY SEND-COUNT OUTSTANDING?
	TRNE	T2,777000	; (SEND FROM JOB-NO,LOGOUT;NEW JOB SAME SLOT)
	ADDM	T1,.PDIPC##(W)	; NOT YET RECEIVED
IPFR13:	HLRE	T1,.IPCFP(P2)	;GET LENGTH OF THIS BLOCK
	SKIPGE	T1		;PAGE?
	SETZ	T1,		;YES, NO DATA WORDS
	ADDI	T1,.IPCFD	;PLUS OVERHEAD WORDS
	HRRZ	T2,P2		;ADDRESS
	PUSHJ	P,GIVWDS##	;FREE THE PACKET SPACE
	SOSL	%CNIIP##	;DEC COUNT OF PACKETS OUTSTANDING
	PJRST	JPOPJ1##
	STOPCD	.+1,DEBUG,PCN,	;++PACKET COUNT NEGATIVE
	SETZM	%CNIIP##	;CONTINUED - ZERO COUNT SO WONT STOP AGAIN
	PJRST	JPOPJ1##	;RESTORE J AND SKIP-RETURN


;COME HERE IF THERE IS NO PACKET IN THE USER'S LIST.
IPFR14:	JUMPL	P1,ERRNP	;BIT 0 = DONT BLOCK
	TLNE	P1,IP.RFP	;IF A PARTICULAR PID
	MOVEM	P3,JBTPID##(J)	;TELL WORLD WE WANT ONLY THIS
	MOVSI	T1,IPCACE##	;FLAG HIBERNATING FOR IPCF
	IORB	T1,JBTRTD##(J)
	MOVEI	T1,SLPQ##	;PUT JOB IN SLEEP QUEUE
	...DPB	T1,PJBSTS##
	PUSHJ	P,CLRIPT##	;ZAP IN-CORE PROTECT SO JOB CAN BE SWAPPED
	PUSHJ	P,WSCHED##	;WAIT FOR AWAKENING
	SETZM	JBTPID##(J)
IFN FTPI,<
	XCT	NOPISK##	;IF USER IS USING PSI
	SKIPN	@JBTPIA##(J)	;SKIP IF PENDING COUNT IS UP
>
	JRST	IPFR2		;NO PENDING INTERRUPTS, TRY AGAIN
IFN FTPI,<
	SOS	.JDAT+JOBPD1##+IFN FTKLP,<1> ;FORCE UUO TO RESTART
	POPJ	P,		;AFTER INTERRUPT IS GRANTED
>
SUBTTL IPCFS - SEND UUO
UIPCFS::PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSHJ	P,VALARG	;LOAD ARGS
	  POPJ	P,		;WRONG
	PUSHJ	P,SETIPQ	;CHECK FOR QUOTA SET
	LDB	T1,[POINT 9,T2,26] ;SEND QUOTA
	LDB	T2,[POINT 9,.PDIPC##(W),26]	;SEND COUNT
	MOVEI	T3,1		;ASSUME ONE LAST CALL
	TRNE	P1,IP.SIP	;PRIVS?
	MOVEI	T3,777		;YES, LOTS OF CALLS
	TLNE	P1,IP.LPC	;LAST PHONE CALL?
	ADD	T1,T3		;YES, BUMP THE QUOTA
	CAILE	T1,777		;OVERFLOW?
	MOVEI	T1,777		;YES, NOBODY IS ALLOWED TO OVERFLOW
	CAMG	T1,T2		;QUOTA DEPLETED?
	JRST	ERRRS		;YES, DON'T SEND
	JUMPN	P3,IPCS1	;IF REC'R FIELD IS 0,
	SKIPN	P3,.PDIPI##(W)	; SEND MSG TO [SYSTEM]INFO FOR THIS JOB
	MOVE	P3,%SIINF##	; (LOCAL OR GLOBAL)
	JUMPE	P3,ERRDU	;DESTINATION UNKNOWN IF NO [SYSTEM]INFO

;COME HERE TO VALIDATE SENDER'S PID
IPCS1:	JUMPN	P2,IPCS4	;"SENDER'S PID" SPECIFIED?
	MOVN	T1,%IPCMP##	;NO, FIND A DEFAULT PID
	HRLZS	T1
	SKIPN	T2,PIDTAB##(T1)	;SEARCH FOR A VALID PIDTAB ENTRY
IPCS2:	AOBJN	T1,.-1
	JUMPGE	T1,IPCS3	;DONE, NO PIDS FOR THIS JOB
	AND	T2,%IPCPM##	;ISOLATE JOB NO.
	CAME	T2,J		;THIS JOB?
	JRST	IPCS2		;NO.
	MOVE	P2,PIDTAB##(T1)	;PUT ENTRY IN P2
	ANDCM	P2,%IPCPM##	;REMOVE JOB NUMBER
	TROA	P2,(T1)		;INCLUDE PID INDEX
IPCS3:	MOVE	P2,J		;NO PIDS, USE JOB NUMBER
IPCS4:	PUSH	P,J		;SAVE J
	MOVE	T1,P2		;GET SENDER'S PID
	PUSHJ	P,VALPID	;CHECK OUT SENDER
	  JRST	[TRNE	P1,IP.SIP ;PRIV'D?
		JRST	IPCS5     ;YES, OK (TURNING AROUND A MSG CAUSE REC'R DIED)
		POP	P,J       ;NO - INVALID SENDER
		JRST	ERRIS]
	JUMPE	J,[POP P,J	;CANT SEND "FROM" AN EXEC PROCESS
		   JRST ERRIS]
	SUB	J,(P)		;PID IS LEGAL, IS IT HIS?
	TRNN	P1,IP.SIP	;IF SENDER ISN'T PRIV'D,
	JUMPN	J,[POP	P,J
		   PJRST	ERRIS]	; SEND MUST BE FROM HIS JOB
;COME HERE TO VALIDATE RECEIVER
IPCS5:	MOVE	T1,P3		;PUT PID INTO T1
IFN FTMP,<
	PUSHJ	P,UPMM##	;LOCK FOR PDB
>
	PUSHJ	P,VALPID	;SET UP J AND W
	  JRST	[POP P,J	;RESTORE J
IFN FTMP,<
		 PUSHJ	P,DWNMM##	;FAILED
>
		JRST	ERRDU]	;DESTINATION UNKNOWN

;COME HERE TO CHECK THAT THE RECEIVER'S QUOTA IS NOT
;  EXHAUSTED AND THAT THE RECEIVER IS NOT DISABLED.
	LDB	T1,[POINT 9,.PDIPC##(W),35]	;RECEIVE COUNT
	LDB	T2,[POINT 9,.PDIPQ##(W),35]	;RECEIVE QUOTA
	CAMN	P3,JBTPID##(J)	;IF REC'R BLOCKED FOR THIS PID
	AOS	T2		;LET HIM GO 1 OVER QUOTA
	POP	P,J		;RESTORE J (REAL JOB NO. OF SENDER)
	CAML	T1,T2		;QUOTA EXHAUSTED?
IFN FTMP,<
	JRST	[PUSHJ	P,DWNMM##
		 JRST	ERRRR	]
>
IFE FTMP,<
	JRST	ERRRR
>
	SKIPGE	.PDIPQ##(W)	;NO, IS RECEIVER DISABLED?
IFN FTMP,<
	JRST	[PUSHJ	P,DWNMM##
		 JRST	ERRDD	]
>
IFE FTMP,<
	JRST	ERRDD
>
	HLRE	T2,P4		;GET DATA LENGTH
	CAMLE	T2,%CNIPL##	;TOO LONG?
	JRST	[TLNN	P1,IP.LPK ;TRYING TO SEND A LONG MESSAGE?
IFN FTMP,<
		 JRST	[PUSHJ	P,DWNMM##
			 JRST	ERRTL	] ;NO, PACKET IS TOO LONG
>
IFE FTMP<
		 JRST	ERRTL
>
		 MOVSI	T1,JP.IPC  ;YES, REQUIRES PRIVILEGES
		 PUSHJ	P,PRVBT##  ;PRIVILEGED?
		   JRST	IPCS6	;YES, PROCEED
IFN FTMP,<
		 PUSHJ	P,DWNMM##
>
		 JRST	ERRTL]	;NO
	JUMPG	T2,IPCS6
	TRNN	P1,IP.CFV
	TROA	P1,IP.CFZ
	SETZ	T2,
IPCS6:	ADDM	T2,%IPTWT##	;COUNT TOTAL NUMBER OF WORDS XFERRED
	ADDI	T2,.IPCFD	;NO, GET ROOM TO HOLD BLOCK
	PUSHJ	P,GETWDS##	;IN EXEC CORE
IFN FTMP,<
	  JRST	[PUSHJ	P,DWNMM##
		 JRST	ERRRY	]
>
IFE FTMP,<
	JRST	ERRRY
>
	TRNE	P1,70		;SENDER FIELD 0?
	JRST	IPCS7
	CAMN	P2,%SIINF##	;YES, SENDER =[SYSTEM]INFO?
	TRO	P1,20		;YES
	CAMN	P2,.PDIPI##(W)	;SENDER=LOCAL[SYSTEM]INFO?
	TRO	P1,30		;YES
IPCS7:	HRRZM	P1,.IPCFL(T1)	;STORE FLAGS (LH=INTERNAL POINTER)
	MOVEM	P2,.IPCFS(T1)	;STORE SENDER'S PID (FUDGED)
	MOVEM	P3,.IPCFR(T1)	;STORE RECEIVER'S PID
	HLLZM	P4,.IPCFP(T1)	;STORE LENGTH (RH RESERVED)
IFN FTMP,<
	PUSHJ	P,DWNMM##	;DON'T CARE ABOUT PDB ANY MORE
>
	PUSH	P,J		;SAVE CURRENT INFORMATION
	PUSH	P,W
	EXCH	T1,P2		;GET FUDGED SENDERS PID
	PUSHJ	P,VALPID	;AND FIND ITS JOB
	  MOVE	J,-1(P)		;USE CURRENT J IF NOT HERE
	MOVE	T1,P2		;RESTORE T1
	POP	P,W		;AND W
	MOVE	T3,JBTPPN##(J)	;GET FUDGED SENDER PPN
	MOVEM	T3,.IPCFU(T1)	;SAVE IT
	PUSHJ	P,IPCSCA	;STORE CAPABILITIES
	POP	P,J		;AND RESTORE REAL SENDERS J
	HRRI	M,-1(P4)	;POINTER TO BLOCK IN USER CORE
	MOVE	P3,T1		;COPY ADDR OF CORE BLOCK
	HLLZ	P2,P4		;FORM AOBJN WORD
	JUMPLE	P2,IPCS9	;DONT STORE DATA IF LENGTH=0
	HLRZ	T3,P2		;GET TOTAL WORDS IN RH OF AN AC
	MOVNS	P2
	HRR	P2,T1
IPCS8:	PUSHJ	P,GETWD1##	;GET WORD FROM USER CORE
	MOVEM	T1,.IPCFD(P2)	;STORE DATA WORD
	AOBJN	P2,IPCS8	;COPY WHOLE BLOCK
;COME HERE WITH P3 POINTING TO A BLOCK IN EXEC CORE
;  CONTAINING THE UUO ARGS AND THE DATA.  MOVE TO RECEIVER'S
;  ENVIRONMENT AND PUT THE PACKET ON HIS LIST.

IPCS9:
IFN FTMP,<
	TRNE	P1,IP.CFV	;PAGE MODE?
	JRST	IPCS9A		;YES
	PUSHJ	P,UPMM##	;GUARD PDB GOING AWAY AGAIN
	MOVE	T1,.IPCFR(P3)
	PUSHJ	P,VALPID
	  SKIPA	T1,P4		;RECEIVER WENT AWAY
	JRST	IPCS13		;PUT PACKET ON QUEUE
	PUSHJ	P,DWNMM##
	HLRES	T1		;SWAP HALVES
	ADDI	T1,.IPCFD
	MOVEI	T2,(P3)		;ADDRESS
	PUSHJ	P,GIVWDS##	;RETURN THE SPACE
	JRST	ERRDU
IPCS9A:>
IFE FTMP,<
	TRNN	P1,IP.CFV
	JRST	IPCS13		;NOT A PAGE
>
	HRRZ	T1,P4		;PAGE - GET ITS VIRTUAL PAGE NUMBER
	PUSHJ	P,IPCRMV##	;REMOVE FROM SENDERS MAP
	  JRST	[HRRZ	T2,P3	;ERROR - GET ADR OF 4-WD BLOCK
		MOVEI	T1,.IPCFD ;LENGTH OF BLOCK
		PUSHJ	P,GIVWDS## ;RETURN THE SPACE
		JRST	ERRUP]	;AND ERROR RETURN

	AOS	%IPTPT##	;COUNT A PAGE TRANSFERRED
	MOVE	P2,T2		;SAVE CORE ADR
	TRNE	T2,400000	;PAGE ON DSK?
	JRST	IPCS12		;YES
	trne	t2,400000	;Page on dsk?
	jrst	ipcs12		;Yes
	MOVE	T1,.IPCFR(P3)	;RECEIVER
IFN FTMP,<
	PUSHJ	P,UPMM##	;GET THE MM
>
	PUSHJ	P,VALPID	;SET UP J AND W
	  JRST	IPS11a		;SHOULD NEVER HAPPEN
	trne	p2,400000	;Page on dsk?
	jrst	ipcs12		;Yes
	SKIPGE	T1,JBTSTS##(J)	;JOB RUNNING?
	TLNE	T1,SWP		; AND IN CORE?
	JRST	IPCS11		;NO, PAGE THE PAGE OUT
IFN FTLOCK,<
	SKIPN	T1,LOCK##	;ALWAYS PAGE IT IF SOMEONE IS LOCKING
>
	HLRZ	T1,.PDIPC##(W)	;YES
	JUMPN	T1,IPCS11	;PAGE OUT PACKET IF WONT BE FIRST ON 0
	SKIPE	T1,JBTPID##(J)	;IF JOB IS BLOCKED WAITING FOR
	CAME	T1,.IPCFR(P3)	; A PARTICULAR PID
	JUMPN	T1,IPCS11	;PAGE OUT IF NOT RIGHT SENDER
	MOVSI	T1,IPCACE##	;1ST IN QUEUE, IS REC'R HIBERING FOR IPC?
	TDNE	T1,JBTRTD##(J)	
	JRST	IPCS10		;YES, DONT PAGE OUT THE PAGE
IFN FTPI,<
	HRROI	T1,C$IPC	;NO, IS HE PSI'ING FOR IPC?
	PUSHJ	P,PSITST##
	  JRST	IPCS11		;NOT ENABLED, PAGE OUT THE PAGE
>	;END IFN FTPI

;ENABLED OR HIBERING FOR THE PAGE, SEE IF ROOM IN CORE
IPCS10:	MOVE	T1,MAXMAX##	;TOTAL USER CORE ON SYSTEM
	SUB	T1,CORMAX##	;MAX SIZE A JOB CAN BECOME
	LSH	T1,W2PLSH##	;NUMBER OF PAGES AVAILABLE FOR IPCF
	MOVE	T2,%CNPIC##	;NUMBER OF PAGES IN USE BY IPCF
	ADDI	T2,1		;NUMBER WHICH WILL BE IN USE
	CAMLE	T2,T1		;ENOUGH ROOM?
	JRST	IPCS11		;NO, PAGE OUT THE PAGE
	MOVEM	T2,%CNPIC##	;IPCF PAGES IN CORE
	JRST	IPCS12		;LEAVE THE PAGE IN CORE
IPCS11:
IFN FTMP,<
	PUSHJ	P,DWNMM##
>
	MOVE	J,.CPJOB##	;RESTORE J
	MOVE	T2,P2
	PUSHJ	P,IPCPAG##	;PAGE OUT THE PAGE
	  MOVEI	T2,0		;PAGING I/O ERROR
	MOVE	P2,T2
IFN FTMP,<
	PUSHJ	P,UPMM##	;GET THE MM
>
	MOVE	T1,.IPCFR(P3)	;RECEIVER'S PID
	PUSHJ	P,VALPID
	  CAIA
	JRST	IPCS12		;ALL IS WELL
ips11a:	
IFN FTMP,<
	PUSHJ	P,DWNMM##	;RECEIVER IS GONE
>
	TRNE	P1,IP.CFV	;PAGE?
	PUSHJ	P,IPCULK	;YES, FREE HIS INTERLOCK
	MOVEI	T2,(P3)		;DEALLOCATE PACKET
	MOVEI	T1,.IPCFD	;..
	PUSHJ	P,GIVWDS##	;SINCE WON'T BE SENDING
	SKIPN	T2,P2		;GET PAGE BACK
	JRST	ERRIE		;PAGING I/O ERROR
	MOVEI	T1,(P4)		;WHERE TO PUT IT
	PUSHJ	P,IPCINS##	;PUT IT BACK
	  JRST	ERRIE		;PAGING I/O ERROR
	JRST	ERRDU		;RECEIVER WENT AWAY
IPCS12:	HRRM	P2,.IPCFP(P3)	;SAVE DSK ADR IN THE PACKET
IPCS13:	SYSPIF
	SKIPN	T2,.PDIPN##(W)	;PICK UP END OF QUEUE
	MOVEI	T2,.PDIPC##-.IPCFL(W) ;EMPTY QUEUE
	HRLM	P3,.IPCFL(T2)	;SAVE THIS PACKET ON END OF QUEUE
	HRRM	P3,.PDIPN##(W)	;SET UP PNTR TO NEW END-OF-QUEUE
	AOS	%CNIIP##	;INCREMENT OUTSTANDING PACKETS
	AOS	.PDIPC##(W)	;INC COUNT ;C11 pl}th
	SYSPIN
IFN FTMP,<
	PUSHJ	P,DWNMM##	;DONE
>

;COME HERE AFTER THE PACKET IS ON THE RECEIVER'S LIST.

	MOVE	T1,.IPCFS(P3)	;SENDER (MIGHT NOT BE SAME J)
	PUSHJ	P,VALPID	;SET UP (PRIV'D JOB CAN SEND FROM ANOTHER JOB)
	  PJRST	IPCS14		;BAD - TURNING AROUND MSG TO A DROPPED PID
	MOVEI	T1,IP.SBT	;INCREMENT SEND COUNT
	ADDM	T1,.PDIPC##(W)
	HLRZ	T1,.PDIPA##(W)	;COUNT OF SEND UUOS
	ADDI	T1,1
	TRNE	T1,-1		;OVERFLOW?
	HRLM	T1,.PDIPA##(W)	;NO, STORE INCREMENTED COUNT
IPCS14:	AOS	%CNIPS##	;INCREMENT SENT PACKETS

;COME HERE TO AWAKEN A USER JOB OR PUSHJ TO AN EXEC PROCESS
;  THAT HAS JUST HAD A PACKET ARRIVE ON ITS LIST.

IFN	FTDHIA,<
	TRNE	P1,IP.CFV	;ONLY IF PAGED
	PUSHJ	P,IPCULK	;UNLOCK RECEIVER'S QUEUE
>
	MOVE	T1,.IPCFR(P3)	;RECEIVER'S PID
	PUSHJ	P,VALPID	;SET UP J AND W
	  PJRST	CPOPJ1##	;SHOULD NEVER HAPPEN
	JUMPE	J,EXECPR	;SPECIAL HANDLING FOR EXEC PROCESS
	PUSHJ	P,WAKEUP
	PJRST	CPOPJ1##	;AND GIVE SKIP RETURN

;SUBROUTINE TO STORE CAPABILITIES OF THE SENDER
;CALLING SEQUENCE:
;	MOVEI	T1,ADDRESS OF THE PACKET HEADER
;	MOVE	J,JOB NUMBER OF THE SENDER
;	PUSHJ	P,IPCSCA
;ALWAYS RETURN CPOPJ

IPCSCA:	MOVE	T4,J		;CLEAR CAPABILITIES
	MOVE	T3,JBTSTS##(J)	;GET JBTSTS
	TLNE	T3,JACCT	;SENDER HAS JACCT?
	TLO	T4,IP.JAC	;YES
	TLNE	T3,JLOG		;SENDER HAS JLOG?
	TLO	T4,IP.JLG	;YES
	TRNE	T3,JS.XO	;IS SENDER XCT ONLY?
	TLO	T4,IP.SXO	;YUP!
	MOVE	T3,JBTPRV##(J)	;GET JBTPRV WORD
	TLNE	T3,JP.POK	;CAN SENDER POKE MONITOR?
	TLO	T4,IP.POK	;YES,
	TLNE	T3,JP.IPC	;DOES HE HAVE IPCF PRIVS?
	TLO	T4,IP.IPC	;YES
	MOVSI	T3,(UP.IYB)	;IN YOUR BEHALF?
	TDNE	T3,.UPMP+.UPBTS	;TEST
	TLZ	T4,IP.JAC	;AS IF NOT PRIVED
	MOVEM	T4,.IPCFC(T1)	;AND STORE SENDER'S CAPABILITIES
	POPJ	P,		;RETURN
;COME HERE IF EXEC PROCESS.

EXECPR:	HLRZ	T1,W		;NON-OFFSET LOC OF EXEC CTL BLOCK
	PUSHJ	P,@.EPADR(T1)	;CALL THE PACKET HANDLER
	PJRST	CPOPJ1##	;GIVE SKIP-RETURN


IFE FTPI,<
WAKEUP==WAKEJB##		;SAVE SPACE IF NO PSISER
>
IFN FTPI,<
WAKEUP:	SIGNAL	C$IPC		;SIGNAL MESSAGE AVAILABLE
	  JFCL
	PJRST	WAKEJB##	;WAKE JOB IN CASE PSISER COULDN'T

;SUBROUTINE TO SET UP STATUS WORD FOR INTERRUPT
STRSIG::MOVE	T1,JBTPDB##(J)	;PDB LOC
	MOVEI	T2,0		;IN CASE NO PACKETS
	HLRZ	T1,.PDIPC##(T1)	;LOC OF 1ST PACKET
	JUMPE	T1,CPOPJ##	;RETURN T2 = 0 IF NONE
	MOVE	T2,.IPCFP(T1)	;LENGTH OF TOP PACKET TO LH
	HRR	T2,.IPCFL(T1)	;FLAGS
	TRNE	T2,IP.CFV	;PAGE?
	HRLI	T2,PAGSIZ##	;YES, LENGTH = 1 PAGE
	POPJ	P,		; AND RETURN
>
SUBTTL IPCFQ - QUERY UUO

UIPCFQ::PUSHJ	P,SAVE1##
	HRR	M,T1		;ADDRESS OF UUO BLOCK
	HLRZ	T4,T1		;SAVE COUNT
	PUSHJ	P,GETWRD##	;GET WORD 0
	  JRST	ERRAC
	MOVE	P1,T1		;SAVE PRIV BIT
	HLRZ	T2,.PDIPC##(W)	;IS THERE A PACKET?
	JUMPE	T2,ERRNP	;GO IF NONE
	TLNN	P1,IP.RFP	;WANT SPECIFIC PID?
	JRST	IPCFQ4		;NO
	ADDI	M,2
	PUSHJ	P,GETWRD##	;YES, GET THE PID
	  JRST	ERRAC
	TLNN	P1,IP.IAR	;IS RECEIVER'S PID INDIRECTED?
	JRST	IPCFQ0		;NO
	MOVE	T3,M		;PRESERVE M
	HRR	M,T1		;PUT PID ADDRESS IN M
	PUSHJ	P,GETWRD##	;GET THE PID
	  JRST	ERRAC		;ADDRESS CHECK
	MOVE	M,T3		;RESTORE M
IPCFQ0:	SUBI	M,2
IPCFQ1:	CAMN	T1,.IPCFR(T2)	;THIS PACKET FROM THAT PID?
	JRST	IPCFQ4		;YES, INFORM HIM
	HLRZ	T2,.IPCFL(T2)	;NO, TRY NEXT
	JUMPN	T2,IPCFQ1
	JRST	ERRNP
IPCFQ4:	HRRZ	T1,.IPCFL(T2)	;YES, PASS INFO TO CALLER
	TRNN	P1,IP.SIP	;IS HE PRIV?
	TRZ	T1,IP.SIP	;NO, SUPPRESS PRIV BIT IN PACKET
	PUSHJ	P,PUTWRD##	;STORE .IPCFL
	  JRST	ERRAC		;ADDRESS CHECK.
	MOVE	T1,.IPCFS(T2)	;SENDER'S PID
	PUSHJ	P,PUTWR1##	;STORE SENDER'S PID
	  JRST	ERRAC
	MOVE	T1,.IPCFR(T2)	;RECEIVER'S PID
	PUSHJ	P,PUTWR1##	;STORE RECEIVER'S PID
	  JRST	ERRAC		;ADDRESS CHECK
	LDB	T1,[POINT 9,.PDIPC##(W),35]	;COUNT
	MOVE	T3,.IPCFL(T2)	;FLAGS
	TRNE	T3,IP.CFV	;PAGE?
	TLOA	T1,PAGSIZ##	;YES, LENGTH = 1 PAGE
	HLL	T1,.IPCFP(T2)	;LENGTH
	PUSHJ	P,PUTWR1##	;STORE IN USER'S CORE
	  JRST	ERRAC		;ADDRESS CHECK
	MOVE	T1,.IPCFU(T2)	;GET SENDERS PPN
	CAIG	T4,.IPCFU	;DID HE ASK FOR IT?
	PJRST	CPOPJ1##	;NO, JUST RETURN
	PUSHJ	P,PUTWR1##	;YES, GIVE IT TO HIM
	  JRST	ERRAC
	MOVE	T1,.IPCFC(T2)	;GET SENDERS PRIVS
	CAIG	T4,.IPCFC	;DID HE ASK FOR THEM?
	  PJRST	CPOPJ1##	;NO, RETURN
	PUSHJ	P,PUTWR1##	;YES, GIVE THEM TO HIM
	  JRST	ERRAC
	PJRST	CPOPJ1##	;SKIP RETURN TO USER
SUBTTL [SYSTEM]IPCF - THE EXEC PROCESS

IPCFPR::PUSHJ	P,SAVE3##
IFN FTMP,<
	PUSHJ	P,ONCPU0##	;ONLY ONE CPU AT A TIME
>
IPCF1:	TLO	M,400000	;SET SO ERR WONT CALL STOTAC
	PUSHJ	P,GETPAK	;GET OLDEST PACKET
	  POPJ	P,		;NONE, EXIT.
	HRRZ	P1,T1		;PACKET ADDRESS
	HRRE	T4,.IPCFD(P1)	;PICK UP CODE (WORD 0)
	MOVE	T1,.IPCFL(P1)	;PASSING A PAGE TO [SYSTEM] IPCF?
	TRNN	T1,IP.CFV	;YES, THAT ISN'T LEGAL
	CAML	T4,[IPCFCF]	;A CUSTOMER DEFINED FUNCTION?
	CAILE	T4,IPCFM	;VALID?
	SKIPA	T4,BADCOD	;NO, SET FOR ERROR
	MOVE	T4,BADCOD(T4)	;YES, GET DISPATCH ADR
	MOVE	T1,.IPCFS(P1)	;SENDER
	HLRZ	T2,.IPCFP(P1)	;LENGTH
	MOVE	T3,.IPCFL(P1)	;FLAGS
	TRNE	T3,1		;TURNED-AROUND MSG?
	JRST	IPCF3		;YES, JOB MUST HAVE LOGGED OUT
	PUSH	P,W		;PRESERVE W
	TRNN	T3,400000	;JOB HAVE PRIV'S?
	JUMPL	T4,PRVERR	;NO, ERROR IF FUNCTION REQUIORES PRIVS
	LDB	P2,[POINT 3,T4,17] ;GET NEEDED LENGTH OF UUO BLOCK
	CAIGE	T2,(P2)		;UUO BLOCK LONG ENOUGH?
	JRST	SHRTER		;NO, ERROR
	PUSHJ	P,(T4)		;DISPATCH
IPCF2:	  DPB	T1,[POINT 6,.IPCFL(P1),29] ;BAD - STORE ERROR CODE IN FLAG WORD
	PUSHJ	P,DECSND	;DECREMENT SENDER'S COUNTS
	POP	P,W		;RESTORE W

;IN ORDER FOR THE JOB TO RECEIVE THE MSG IT MUST BE ENABLED
;ANSWER WILL THUS ENABLE THE JOB. IN ORDER TO PREVENT THIS
;BIT 0 OF P1 MUST BE LIT BY THE SUBROUTINE (DISABLE FUNCTION)
	PUSHJ	P,ANSWER	;TURN PACKET AROUND TO USER
	JRST	IPCF1		;AND CHECK FOR ANOTHER.

;SUBROUTINE TO GET POINTER TO PACKET INTO T1.

GETPAK:	HLRZ	T1,.PDIPC##(W)	;POINTER OR ZERO
	JUMPE	T1,CPOPJ##	;NONE.
	PJRST	CPOPJ1##	;HAVE ONE - SKIP RETURN
;DISPATCH ERRORS - 
SHRTER:	SKIPA	T1,[IPCNL%]	;UUO BLOCK NOT LONG ENOUGH
PRVERR:	MOVEI	T1,IPCPI%	;PRIV'S INSUFFICIENT
	JRST	IPCF2		;STORE ERROR CODE IN PACKET AND ANSWER

IPCF3:	PUSHJ	P,NXTPAK	;MAKE NEXT PACKET THE OLDEST
	SOS	.PDIPC##(W)	;FIX UP THE COUNTS
	PUSH	P,W
	LDB	T1,TRNPTR	;SENDER JOB NO
	PUSHJ	P,VALPID	;SET W
	  JRST	IPCF4		;OOPS, HE REALLY IS GONE
	MOVNI	T1,IP.SBT
	MOVE	T2,.PDIPC##(W)	;ANY SENDS NOT YET REC'D?
	TRNE	T2,777000
	ADDM	T1,.PDIPC##(W)	;YES, DECREMENT COUNT
IPCF4:	POP	P,W
	PUSHJ	P,REMPAK	;GET RID OF THIS PACKET
	JRST	IPCF1		;AND GO LOOK AT NEXT PACKET

;SUBROUTINE TO DECREMENT COUNT OF PACKETS SENT BUT NOT RECEIVED
DECSND:	MOVE	T1,.IPCFS(P1)	;SENDERS PID
	PUSHJ	P,VALPID	;GET W
	  TDZA	T1,T1		;SHOULDN'T HAPPEN
	MOVNI	T1,IP.SBT	;DEC COUNT OF SENT BUT NOT
	ADDM	T1,.PDIPC##(W)	; REC'D PACKETS FOR SENDER
	POPJ	P,		;RETURN

DECSSW:	PUSH	P,W
	PUSHJ	P,DECSND
	JRST	WPOPJ##

;SUBROUTINE TO MAKE NEXT PACKET THE OLDEST
NXTPAK:	SYSPIF
	HLRZ	T1,.IPCFL(P1)	;NEXT PACKET
	HRLM	T1,.PDIPC##(W)	; IS NOW THE OLDEST
	SKIPN	T1		;EMPTY QUEUE?
	SETZM	.PDIPN##(W)	;YES, CLEAR END POINTER
	JRST	ONPOPJ##	; AND RETURN
;DISPATCH TABLE FOR [SYSTEM]IPCF

;EACH SUBROUTINE IS CALLED WITH P1 POINTING TO THE PACKET
; IN EXEC STORAGE
;P2-P4 ARE AVAILABLE FOR USE
;T1=PID OF SENDER  T2=LENGTH OF DATA  T3=FLAGS
;W AND J ARE SET UP FOR RECEIVER, BUT MAY BE CHANGED
IPCFTL:				;ADD CUSTOMER DEFINED FUNCTIONS HERE
BADCOD:	EXP	ERRUF		;(BAD CODE) - UNKNOWN FNCTN
IPCFTB:	XWD	000000,ENABL	;(1)ENABLE
	XWD	000000,DISAB	;(2)DISABLE
	XWD	000003,WHOIS	;(3)TELL PID OF [SYSTEM]INFO
	XWD	400003,MKINFO	;(4)MAKE [SYSTEM]INFO
	XWD	400002,DESTRY	;(5)DESTROY A PID
	XWD	400003,CREATE	;(6)CREATE A PID
	XWD	400003,QUOTA	;(7) SET QUOTA
	XWD	400003,OWNER	;(10)CHANGE OWNERSHIP OF A PID
	XWD	000003,JOBNO	;(11)FIND JOB NUBER FOR A PID
	XWD	000004,RDPIDS	;(12)FIND PID(S) FOR A JOB
	XWD	000003,RDQTA	;(13)FIND QUOTA FOR A JOB
	XWD	400002,CPOPJ1##	;(14)WAKE UP JOB HIB'ING FROM RESET
IPCFRF:	EXP	ERRUF		;(15)SENT BY IPCF ON RESET
	EXP	ERRUF		;(16)
	EXP	ERRUF		;(17)
	EXP	ERRUF		;(20)
	EXP	ERRUF		;(21)
	EXP	ERRUF		;(22)
	EXP	ERRUF		;(23)
	XWD	400003,SIDSET	;(24)SET SYSTEM PID TABLE
	XWD	000003,SIDRD	;(25)READ SYSTEM PID TABLE
IPCFSM:	EXP	ERRUF		;(26)SPOOL MSG SENT "TO" QUASAR
IPCFLM:	EXP	ERRUF		;(27)LOGOUT MESSAGE SENT "TO" QUASAR
IPCFTM:	EXP	ERRUF		;(30)TAPE LABELING MESSAGE
IPCFUO:	EXP	ERRUF		;(31)MOUNTABLE UNIT ON-LINE
IPCFON:	EXP	ERRUF		;(32)LOGON MESSAGE SENT "TO" QUASAR
	EXP	ERRUF		;(33)ACCOUNTING MESSAGES
IPCFDE:	EXP	ERRUF		;(34)MDA CONTROLLED DEVICE DEASSIGNED OR RELEASED
IPCFME:	EXP	ERRUF		;(35) MOS MEMORY ERROR TO TGHA
IPCFCS:	EXP	ERRUF		;(36)CSHIFT MESSAGE TO ACTDAE
IPCFRL:	EXP	ERRUF		;(37)RESET OF T/S JOB WITH LOCKED STR. TO MDA
IPCFGM:	EXP	ERRUF		;(40)QUEUE. UUO FUNCTION TO A GALAXY COMPONENT
IPCFSC:	EXP	ERRUF		;(41) SEARCH LIST CHANGE TO MDA
IPCFAT:	EXP	ERRUF		;(42) PRIMARY PORT ATTACH (TO MDA)
IPCFDT:	EXP	ERRUF		;(43) PRIMARY PORT DETACH (TO MDA)
IPCFXC:	EXP	ERRUF		;(44) DISK UNIT EXCHANGE (TO MDA)
IPCFRM:	EXP	ERRUF		;(45) STRUCTURE REMOVAL (TO MDA)
IPCFMT:	EXP	ERRUF		;(46)MAGTAPE UNIT ACCESSIBLE (TO MDA)
ipcfst:	exp	erruf		;(47) structure mount (to mda)
.IPCTL==:IPCFTM-IPCFTB+1
.IPCUO==IPCFUO-IPCFTB+1
.IPCDE==:IPCFDE-IPCFTB+1
.IPCME==:IPCFME-IPCFTB+1
.IPCRL==:IPCFRL-IPCFTB+1	;MESSAGE # FOR MDA RESET
.IPCGM==:IPCFGM-IPCFTB+1
.IPCSC==:IPCFSC-IPCFTB+1
.IPCAT==IPCFAT-IPCFTB+1
.IPCDT==IPCFDT-IPCFTB+1
.IPCXC==IPCFXC-IPCFTB+1
.IPCRM==IPCFRM-IPCFTB+1
.IPCMT==IPCFMT-IPCFTB+1
.ipcst==ipcfst-ipcftb+1
IPCFM==.-IPCFTB			;LENGTH OF TABLE
IPCFCF==IPCFTL-BADCOD		;MOST NEGATIVE CUSTOMER FUNCTION
;SUBROUTINE TO GIVE ANSWER TO AN EXEC CALL
ANSWER:	MOVEI	T2,1	
REPEAT 0,<	;NOT NEEDED TILL OTHER EXEC PROCESSES EXIST
	CAMN	T1,PIDTAB##	;SENDER = [SYSTEM]IPCF?
>
;ENTER HERE TO INDICATE MESSAGE SENT BY OTHER THAN IPCC (SENDER'S CODE IN T2)

ANSWE1:	MOVE	T1,.IPCFR(P1)	;SWITCH SENDER & RECEIVER
	DPB	T2,[POINT 3,.IPCFL(P1),32]	;TELL REC'R THAT MSG IS FROM IPCF
	EXCH	T1,.IPCFS(P1)
	MOVEM	T1,.IPCFR(P1)
	MOVE	T1,.IPCFL(P1)	;IF A WHOLE PAGE PASSED,
	TRNN	T1,IP.CFV	; DON'T CLEAR ITS ADDRESS
	HLLZS	.IPCFP(P1)	;ZERO PACKET ADR
	PUSHJ	P,NXTPAK	;MAKE PACKET THE OLDEST
	SETZM	.IPCFC(P1)	;CLEAR FLAG WRDS ON SEND FROM
	SETZM	.IPCFU(P1)	; AN EXEC PROCESS
	PUSHJ	P,SNDMSG	;RETURN PACKET TO SENDER OF ORIGINAL MSG
	  PUSHJ	P,REMPAK	;COULDNT DO IT - REMOVE THE PACKET
	SOS	.PDIPC##(W)
	AOS	T1,.PDIPA##(W)	;COUNT OF RECEIVES SINCE LOGIN
	TRNN	T1,-1		;OVERFLOW?
	SOS	.PDIPA##(W)	;YES, SET IT BACK
	POPJ	P,		;AND RETURN TO CALLER

;SUBROUTINE TO REMOVE THE OLDEST PACKET.

REMPAK::HRRZ	T2,P1		;ADR OF PACKET TO REMOVE
	SOS	%CNIIP##	;DEC COUNT OF OUTSTANDING PACKETS
	HLRE	T1,.IPCFP(T2)	;LENGTH OF DATA
	SKIPGE	T1		;LENGTH = -1(PAGE)
	SETZ	T1,		;YES, NO DATA
	ADDI	T1,.IPCFD	;PLUS OVERHEAD
	HRL	T3,.IPCFP(P1)	;SAVE LOC OF DATA FOR MSG
	HRR	T3,.IPCFL(P1)	;SAVE FLAGS
	PUSH	P,T3
	PUSHJ	P,GIVWDS##	;RETURN THE PACKET (OR HEADER)
	POP	P,T1
	TRNN	T1,IP.CFV	;IS IT A PAGE?
	POPJ	P,		;NO, RETURN
	HLRZ	T2,T1		;YES, GET CORE OR DSK ADR OF THE PAGE
	JUMPE	T2,CPOPJ##	;NOTHING TO RETURN IF PAGING I/O ERROR
	PJRST	IPCDEL##	;AND RETURN IT
;SUBROUTINE TO SEND A PACKET.  ADDRESS OF UUO ARGS AND PACKET
;  DATA IN P1.  SOURCE MUST BE AN EXEC PROCESS, TARGET
;  MAY BE EITHER EXEC OR USER.  TARGET MUST BE USER
;  IF AT INTERRUPT LEVEL.  SKIP RETURN ON OK,
;  NON-SKIP RETURN HAS T1=ERROR CODE.

SNDMSG:	PUSHJ	P,SAVE3##	;SAVE P2 AND 3
	MOVE	P2,J		;SAVE J
	MOVE	P3,W		;SAVE W
	MOVE	T1,.IPCFR(P1)	;CHECK RECEIVER
	PUSHJ	P,VALPID	;SET UP J AND W
	  JRST	SNDERR		;DESTINATION UNKNOWN
	MOVSI	T1,400000	;SET TO ENABLE RECEIVER
	TLNN	P1,400000	;UNLESS BIT 0 ON IN P1
	ANDCAM	T1,.PDIPQ##(W)	;HE IS NOW ENABLED
	LDB	T1,[POINT 9,.PDIPQ##(W),35]	;RECEIVE QUOTA
	LDB	T2,[POINT 9,.PDIPC##(W),35]	;RECEIVE COUNT
	CAMG	T1,T2		;ROOM LEFT?
	JRST	SNDERR
	AOS	.PDIPC##(W)	;INCR COUNT OF REC'D MSGS

;COME HERE TO PUT THE MESSAGE ON THE RECEIVER'S LIST
	SYSPIF			;NO INTERRUPT HERE
	SKIPN	T2,.PDIPN##(W)	;END OF QUEUE
	MOVEI	T2,.PDIPC##-.IPCFL(W) ;EMPTY
	HRRM	P1,.PDIPN##(W)	;NEW END OF QUEUE
	HRLM	P1,.IPCFL(T2)	;SAVE THIS PACKET ON END OF QUEUE
	HRRZS	.IPCFL(P1)	;ZERO LINK OF THE PACKET
	SYSPIN			;ALLOW INTERRUPTS AGAIN
;COME HERE AFTER PUTTING PACKET ON LIST.  UPDATE COUNTERS.

	HLRZ	W,.IPCFS(P1)	;RETURN TO SENDER'S PDB
	HRRZ	T1,.EPIPC(W)	;INCREMENT COUNT OF MSGS SENT
	ADDI	T1,IP.SBT
	MOVEI	T2,IP.SBT
	TLNN	T1,-1
	ADDM	T2,.EPIPC(W)	;MUST USE ADDM TO AVOID SMP RACE
	HLRZ	T1,.EPIPA(W)	;COUNT OF SENDS
	ADDI	T1,1		;INCREMENT IT
	TRNE	T1,-1		;OVERFLOW?
	HRLM	T1,.EPIPA(W)	;NO, STORE INCREMENTED COUNT
	JUMPN	J,SND3		;IS DEST A USER JOB?
	PUSHJ	P,@.EPADR(W)	;NO, GO RUN EXEC PROCESS.
	JRST	SND4		;RETURN TO MAIN LINE.

;COME HERE TO AWAKEN A USER'S JOB.

SND3:	PUSHJ	P,WAKEUP
SND4:	AOS	%CNIPS##	;INC TOTAL PACKETS SENT
	AOS	(P)		;SKIP RETURN
	JRST	SNDER1		;RESTORE AC'S

;HERE ON A SEND ERROR
SNDERR:	HRRZ	T1,.IPCFD(P1)	;CODE
	CAIE	T1,6		;CREATE A PID?
	JRST	SNDER1		;NO
	MOVE	T2,.IPCFL(P1)	;FLAGS WORD
	TRNE	T2,IP.CFE	;IF NO ERROR ON CREATING THE PID,
	JRST	SNDER1
	MOVE	T1,.IPCFD+2(P1)	;GET RID OF IT
	AND	T1,%IPCPM##	;INDEX INTO TABLE
	SETZM	PIDTAB##(T1)
	SOS	%IPCNP##	;DECR CURRENT # OF PIDS
SNDER1:	MOVE	W,P3		;RESTORE W
	MOVE	J,P2		;RESTORE J
	POPJ	P,0		;RETURN
;ENABLE THE OWNER OF THE PID IN WORD 1, OR THE SENDER IF WORD
;  1 IS NOT PROVIDED.  USE OF WORD 1 IS A PRIV. FUNCTION.
ENABL:	CAIGE	T2,2		;WORD 1 SUPPLIED?
	PJRST	CPOPJ1##	;NO, SENDER IS AUTOMATICALLY ENABLED
	TRNN	T3,IP.SIP	;NO, PRIV'D?
	PJRST	ERRPI		;NO, ERROR
	MOVE	T1,.IPCFD+1(P1)	;YES, GET PID SUPPLIED
	PUSHJ	P,VALPID	;SET UP J AND W.
	  POPJ	P,		;BAD PID, FLUSH
	MOVSI	T1,IP.DSB	;CLEAR JOB'S DISABLE BIT
	ANDCAM	T1,.PDIPQ##(W)
	PJRST	CPOPJ1##	;AND GOOD RETURN


;DISABLE THE OWNER OF THE PID IN WORD 1, OR SENDER IF NO WORD 1.
;  USE OF WORD 1 IS A PRIV. FUNCTION.
DISAB:	TRNE	T3,IP.SIP	;PRIV'D?
	CAIGE	T2,2		;YES, WORD 1 SUPPLIED?
	TLOA	P1,400000	;NO, USE SENDER (ALREADY IN T1), DONT ENABLE HIM
	MOVE	T1,.IPCFD+1(P1)	;YES, GET PID SUPPLIED
	CAIL	T2,2		;TRYING TO DISABLE ANOTHER JOB?
	JUMPL	P1,ERRPI	;YES, ERR IF NOT PRIV'D
	PUSHJ	P,VALPID	;SET UP J AND W
	  POPJ	P,		;WRONG, FLUSH
	MOVSI	T1,IP.DSB	;SET JOB'S DISABLE BIT
	IORM	T1,.PDIPQ##(W)
	PJRST	CPOPJ1##	;GOOD RETURN
;MAKE A [SYSTEM]INFO.  ARG IS NOT CHECKED SINCE IT MAY BE
;  DELIBERATELY INVALID (I.E., 0) TO TERMINATE A LOCAL
;  [SYSTEM]INFO OR TO INDICATE THAT THE REAL [SYSTEM]INFO IS LOGGING
;  OUT.
MKINFO:	SKIPN	T1,.IPCFD+2(P1)	;USER OR SYS?
	JRST	MKINF2		;SYS.
	PUSHJ	P,VALPID	;SET UP J AND W FOR TARGET
	  POPJ	P,		;NONE SUCH, FLUSH
	JUMPE	J,CPOPJ##	;NOT VALID FOR EXEC PROCESSES
	SKIPN	%SIINF##	;IF NO GLOBAL OR LOCAL [SYSTEM]INFO
	SKIPE	.PDIPI##(W)	; IS RUNNING THEN MAKING A LOCAL IS OK
	SKIPA	T1,.IPCFS(P1)	;IF SENDER CHECKS OUT
	JRST	MKINF1		;NONE RUNNING NOW - OK
	CAME	T1,%SIINF##	;IS SENDER GLOBAL [SYSTEM]INFO?
	CAMN	T1,.PDIPI##(W)	; OR LOCAL [SYSTEM]INFO?
MKINF1:	SKIPA	T2,.IPCFD+1(P1)	;YES, GET PID TO BECOME THE LOCAL [SYSTEM]INFO
	JRST	ERRPI		;NO, ERROR RETURN
	MOVEM	T2,.PDIPI##(W)	;STORE WITHOUT CHECKING
	PJRST	CPOPJ1##	;GOOD RETURN

;COME HERE TO MAKE SYSTEM'S [SYSTEM]INFO

MKINF2:	MOVE	T1,.IPCFD+1(P1)	;THE PID
	MOVEM	T1,.IPCFD+2(P1)	;MOVE IT OVER
	MOVEI	T1,1		;SYSID INDEX
	MOVEM	T1,.IPCFD+1(P1)	;INTO BLOCK
	PJRST	SIDSET		;USE COMMON CODE


;SEND MESSAGE IDENTIFYING [SYSTEM]INFO

WHOIS:	TRNE	T3,IP.SIP	;PRIV'D?
	SKIPN	T1,.IPCFD+1(P1)	;YES, GET JOB NO WHOSE INFO IS WANTED
	MOVE	T1,.IPCFS(P1)	;NO, TELL HIM HIS OWN [SYSTEM]INFO
	PUSHJ	P,VALPID	;LOAD J AND W
	  POPJ	P,		;BAD PACKET
	SKIPE	J		;EXEC PROCESS HAS NO PDB
	SKIPN	T2,.PDIPI##(W)	;PID OF [SYSTEM]INFO
	MOVE	T2,%SIINF##	;EXEC OR NO LOCAL SPECIFIED
	MOVEM	T2,.IPCFD+1(P1)	;THE ONE WORD OF DATA
	PJRST	CPOPJ1##	;GOOD RETURN
;CREATE A PID. WORD 1 HAS JOB NUMBER, BIT 0=1 IF DROP PID ON RESET
CREATE:	MOVN	P2,%IPCMP##	;SET AOBJN WORD TO SCAN TABLE
	HRLZS	P2
	SKIPE	PIDTAB##(P2)	;FIND AN EMPTY SLOT
	AOBJN	P2,.-1
	JUMPGE	P2,ERRPF	;ERROR IF TABLE FULL
	MOVE	T1,.IPCFD+1(P1)	;USER ARG
	TLZ	T1,400000	;REMOTE TYPE FLAG
	JUMPE	T1,ERRBJ
	TLNN	T1,377777	;ONLY SIGN BIT IS GOOD
	PUSHJ	P,FPDBT1##	;GET ITS PDB (INTO T1)
	  PJRST	ERRBJ		;BAD JOB NUMBER OR NO PDB
	AOS	T2,%IPCTP##	;TOTAL # OF PIDS SINCE RELOAD
	LSH	T2,%IPCLS##	;POSITION PAST JOB #/INDEX SLOT
	IOR	T2,.IPCFD+1(P1)	;ADD JOB NO, (BIT 0 IF DROP ON RESET)
	MOVEM	T2,PIDTAB##(P2)
	ANDCM	T2,%IPCPM##	;REMOVE JOB NUMBER
	IORI	T2,(P2)		;INSERT INDEX INTO TABLE FOR PID AS TOLD
	MOVEM	T2,.IPCFD+2(P1)	; TO USER ("PUBLIC" PID)
	MOVSI	T3,IP.DPR
	SKIPL	T2		;DROP PID ON RESET?
	MOVSI	T3,IP.DPL	;NO, DROP ON LOGOUT
	IORM	T3,.PDIPQ##(T1)	;REMEMBER THAT FACT
	AOS	%IPCNP##	;INCR CURRENT # OF PIDS
	PJRST	CPOPJ1##	;AND GOOD RETURN


;FIND JOB NUMBER ASSOCIATED WITH A PID
JOBNO:	MOVE	T1,.IPCFD+1(P1)	;PID
	PUSHJ	P,VALPID	;LEGAL?
	  PJRST	ERRBJ		;NO
	MOVEM	J,.IPCFD+2(P1)	;YES, RETURN JOB NO TO CALLER
	PJRST	CPOPJ1##	;AND TAKE GOOD RETURN

;TELL QUOTA FOR A JOB
RDQTA:	MOVE	T1,.IPCFD+1(P1)	;JOB NUMBER (OR SOME PID FOR JOB)
	PUSHJ	P,VALPID	;LEGAL?
	  PJRST	ERRBJ		;NO
	MOVE	T1,.PDIPQ##(W)	;YES, GET QUOTA
	HRRZM	T1,.IPCFD+2(P1)	;SAVE IN PACKET
	PJRST	CPOPJ1##	;AND GOOD RETURN

;SET QUOTA FOR PID IN WORD 2.

QUOTA:	MOVE	T1,.IPCFD+1(P1)	;PICK UP JOB NUMBER
	PUSHJ	P,VALPID	;SET UP J + W
	  PJRST	ERRBJ		;ERROR, FLUSH
	MOVE	T2,.IPCFD+2(P1)	;GET QUOTA WORD
	HRRM	T2,.PDIPQ##(W)	;STORE AS NEW QUOTA
	PJRST	CPOPJ1##	;GOOD RETURN
;TELL PID(S) ASSOCIATED WITH A JOB
RDPIDS:	MOVEI	P2,-2(T2)	;NUMBER OF VALUES TO RETURN
	SKIPN	T1,.IPCFD+2(P1)	;STARTING PID
	JRST	RDPID1		;START AT BEGINNING OF TABLE
	PUSHJ	P,VALPID	;CHECK IT OUT
	  PJRST	ERRDU		;CANT START AT AN ILLEGAL PID
	MOVE	T1,.IPCFD+2(P1)	;OK, GET PID AGAIN
	AND	T1,%IPCPM##	;GET START INDEX INTO TABLE
RDPID1:	SKIPLE	T2,.IPCFD+1(P1)	;DESIRED JOB NUMBER
	CAILE	T2,JOBMAX##
	PJRST	ERRBJ		;BAD JOB NUMBER
	MOVNS	P2
	HRLZS	P2		;SET AN AOBJN WORD FOR STORING VALUES
	HRR	P2,P1
	MOVN	T3,%IPCMP##	;MAKE AN AOBJN WORD
	HRLZS	T3		; FOR SCANNING PIDTAB
	ADDI	T1,1
	HRLS	T1
	ADD	T1,T3
RDPID2:	SKIPE	T3,PIDTAB##(T1)	;GET A PID
	AND	T3,%IPCPM##	;JOB NUMBER
	CAIE	T3,(T2)		;TARGET JOB NO?
	JRST	RDPID3		;NO
	MOVE	T3,PIDTAB##(T1)	;YES, GET FULL PID AGAIN
	ANDCM	T3,%IPCPM##	;REMOVE JOB NO
	IORI	T3,(T1)		;ADD INDEX
	MOVEM	T3,.IPCFD+2(P2)	;SAVE IN PACKET
	AOBJP	P2,CPOPJ1##	;DONE IF NO MORE ROOM
RDPID3:	AOBJN	T1,RDPID2	;SCAN WHOLE TABLE
	SETZM	.IPCFD+2(P2)	;TERMINATE WITH A 0
	PJRST	CPOPJ1##	;AND TAKE GOOD RETURN
;DESTROY A PID.

DESTRY:	MOVE	T1,.IPCFD+1(P1)	;PID BEING DESTROYED
	PUSHJ	P,CHKSID	;SEE IF A SYSTEM PID
	  PJRST	ERRPI		;YES, CAN'T DO THAT
	PUSHJ	P,VALPID	;VALIDATE IT
	  PJRST	ERRBJ		;NO GOOD, FLUSH
	MOVE	P3,W		;OLD PDB LOC IN P3
	MOVE	P2,.IPCFD+1(P1)	;PID
	MOVE	T1,.IPCFS(P1)	;SENDER
	PUSHJ	P,VALPID	;SET UP W
	  POPJ	P,		;NO GOOD (SHOULD NEVER HAPPEN)
	CAMN	P2,.IPCFS(P1)	;SENDER DESTROYING HIS OWN PID?
	MOVEM	J,.IPCFS(P1)	;YES, SEND ANSWER BACK TO THE JOB NO.
	MOVE	T2,P2
	AND	T2,%IPCPM##	;MASK TO INDEX
	SETZM	PIDTAB##(T2)
	PUSHJ	P,CHANGE	;PUT ANY MSGS FOR PID INTO SENDER'S QUEUE
	SOS	%IPCNP##	;DECREMENT COUNT OF CURRENT PID'S
	MOVE	J,HIGHJB##	;DO ALL JOBS
DSTRY1:	PUSHJ	P,FNDPDB##	;SET UP W
	JRST	DSTRY2		;NO JOB
	CAMN	P2,.PDIPI##(W)	;DESTROY LOCAL INFO FOR THIS JOB?
	SETZM	.PDIPI##(W)	;CLEAR IT!
DSTRY2:	SOJG	J,DSTRY1	;LOOP FOR ALL JOBS.
	PJRST	CPOPJ1##	;AND GOOD RETURN

;CHANGE THE OWNERSHIP OF A PID.  WORD 1 HAS THE PID, WORD 2 THE NEW
; JOB NUMBER.

OWNER:	MOVE	T1,.IPCFD+1(P1)	;PID TO CHANGE
	PUSHJ	P,CHKSID	;SEE IF A SYSTEM PID
	  PJRST	ERRPI		;YES, CAN'T DO THAT
	PUSHJ	P,VALPID	;SET UP J + W
	  PJRST	ERRDU		;BAD PID
	MOVE	T2,.IPCFD+1(P1)	;GET PID BEING CHANGED
	CAMN	T2,.IPCFS(P1)	;GIVING SELF AWAY?
	MOVEM	J,.IPCFS(P1)	;YES, SEND BACK TO JOB
	JUMPE	J,ERRDU		;CANNOT CHANGE OWNERSHIP OF EXEC PROC.
	MOVE	P3,W		;SOURCE PDB
	SKIPLE	J,.IPCFD+2(P1)
	PUSHJ	P,FNDPDB##	;FIND JOB'S PDB
	  PJRST	ERRBJ		;CANT FIND PDB, BAD JOB NO
	MOVE	P2,.IPCFD+1(P1)	;PID TO CHANGE IN P2
	PUSHJ	P,CHANGE	;CHANGE THE OWNERSHIP OF THE PID
	MOVE	T1,P2		;GET OLD PID
	AND	T1,%IPCPM##	;MASK TO INDEX
	MOVE	T2,PIDTAB##(T1)	;GET OLD PID
	ANDCM	T2,%IPCPM##	;REMOVE OLD JOB
	IOR	T2,.IPCFD+2(P1)	;INCLUDE NEW JOB
	MOVEM	T2,PIDTAB##(T1)	;STORE BACK IN PID TABLE
	PJRST	CPOPJ1##	;AND GOOD RETURN
;SUBROUTINE TO CHANGE THE OWNERSHIP OF A PID
;ENTER W=PDB OF NEW OWNER  P2=PID TO CHANGE  P3=PDB OF OLD OWNER
CHANGE:	MOVEI	T2,.PDIPC##-.IPCFL(P3)	;WHERE TO UNQUEUE FROM

CHNGE3:	HLRZ	T3,.IPCFL(T2)	;NEXT ITEM FROM QUEUE
	JUMPE	T3,CPOPJ##	;DONE IF 0
	MOVE	T1,.IPCFC(T3)	;IGNORE THIS PACKET IF SOMEBODY
	TRNN	T1,IP.RIP	; IS ALREADY RECEIVING IT
	CAME	P2,.IPCFR(T3)	;FOR THE PID BEING CHANGED?
	JRST	CHNGE4		;NO
	CAMN	W,P3		;CHANGING OWNERSHIP TO SAME JOB NO?
	MOVEM	J,.IPCFR(T3)	;YES, MAKE REC'R BE THE JOB ITSELF
				; (OTHERWISE A LOOP MAY RESULT)
	SYSPIF
	SKIPN	T1,.PDIPN##(W)	;END OF QUEUE
	MOVEI	T1,.PDIPC##-.IPCFL(W) ;EMPTY
	HRLM	T3,.IPCFL(T1)	;YES, PUT ON NEW QUEUE
	HLLZ	T4,.IPCFL(T3)	;QUEUE POINTER OF THIS PACKET
	HLLM	T4,.IPCFL(T2)	;REMOVE FROM OLD QUEUE
	HRRZS	.IPCFL(T3)	;LAST ENTRY ON NEW QUEUE
	HRRM	T3,.PDIPN##(W)	;END OF NEW QUEUE
	SKIPN	T4		;IF END OF OLD QUEUE
	HRRM	T2,.PDIPN##(P3)	; MAKE PRED THE END
	SYSPIN
	PUSH	P,T2
	PUSHJ	P,WAKEUP	;PSI OR UNHIBER NEW RECEIVER
	POP	P,T2
	SOS	.PDIPC##(P3)	;UPDATE COUNTS FOR OLD AND NEW OWNERS
	AOSA	.PDIPC##(W)
CHNGE4:	MOVE	T2,T3		;STEP TO NEXT ENTRY IN (OLD) QUEUE
	JRST	CHNGE3		;AND TEST IT
;FUNCTION 24:  SET SYSTEM PID TABLE

SIDSET:	PUSHJ	P,CHKIDX	;GET INDEX AND CHECK IT
	  JRST	ERRBI		;BAD INDEX
	JUMPE	T2,ERRBI	;DON'T LET HIM SET IPCC
	SETZ	J,		;IN CASE CLEARING THE TABLE
	SKIPN	T1,.IPCFD+2(P1)	;GET PID FROM USER
	JRST	SETST1		;ZERO MEANS CLEAR THE ENTRY
	PUSHJ	P,VALPID	;VALIDATE THE PID
	  POPJ	P,		;RETURN ERROR CODE
	MOVE	T2,.IPCFD+1(P1)	;GET INDEX BACK
	MOVE	T1,.IPCFD+2(P1)	;GET THE PID
SETST1:	MOVE	T3,SIDJOB##(T2)	;CHECK OWNER
	CAME	T3,.CPJOB##	;AGAINST CALLER
	JUMPN	T3,ERRPI	;ERROR IF NOT OWNER OF TABLE ENTRY
	MOVEM	T1,.GTSID##(T2)	;STORE IT
	MOVEM	J,SIDJOB##(T2)	;AND IN JOB NUMBER TABLE
	CAIN	T2,1		;[SYSTEM]INFO
	MOVEM	T1,%CNIPI##	;YES, UPDATE OLD GETTAB
	MOVSI	T2,IP.DPL	;GET DROP-ON-LOGOUT BIT
	CAMN	T1,J		;USING JOB NUMBER AS PID?
	IORM	T2,.PDIPQ##(W)	;YES, LIGHT IT FOR THIS JOB
	JRST	CPOPJ1##	;AND RETURN SUCCESS

;FUNCTION 25:  READ SYSTEM PID TABLE

SIDRD:	PUSHJ	P,CHKIDX	;GET INDEX AND CHECK IT
	  JRST	ERRBI		;BAD INDEX
	MOVE	T1,.GTSID##(T2)	;GET THE PID
	MOVEM	T1,.IPCFD+2(P1)	;GIVE IT TO THE USER
	PJRST	CPOPJ1##	;AND RETURN SUCCESSFUL


;CHKIDX  --  ROUTINE TO VALIDATE INDEX AND RETURN IT IN T2.
;	SKIP IF OK, NON-SKIP IF NO GOOD.
CHKIDX:	HRREI	T1,.GTCSD##-.GTSID## ;GET MINIMUM INDEX
	MOVEI	T3,SDTBLN##	; AND MAXIMUM
	MOVE	T2,.IPCFD+1(P1)	;GET INDEX REQUESTED
	CAML	T2,T1		;TOO LOW
	CAMLE	T2,T3		; OR TOO HIGH
	POPJ	P,		;YES
	PJRST	CPOPJ1##	;NO, IN RANGE
;HERE FROM UUOCON ON A LOGOUT UUO
IPCLGO::PUSHJ	P,SAVE2##	;SAVE P1
	PUSHJ	P,QSRLGO	;SEND LOGOUT MESSAGE TO QUASAR
	SETO	P1,		;SETUP MASK TO TEST PIDS
	MOVSI	T1,IP.DPL	;LOAD UP THE LOGOUT FLAG
	JRST	IPCFR1		;SEND MSG TO INFO, DROP PIDS ETC.

;HERE FROM UUOCON ON A RESET UUO.  SEND A MESSAGE TO INFO AND
;	DESTROY THE APPROPRIATE PIDS.
IPCFRC::PUSHJ	P,SAVE2##	;SAVE P1
	MOVSI	P1,(1B0)	;MASK FOR PIDS TO DROP
	MOVSI	T1,IP.DPR	;SET UP CONDITION FOR TEST

;COMMON CODE FOR RESET AND LOGOUT STARTS HERE
IPCFR1:	PUSHJ	P,FNDPDS##	;SET UP W
	PUSHJ	P,TURNQ		;TURN ANY MSGS AROUND FOR THIS JOB
	TDNN	T1,.PDIPQ##(W)	; IF CONDITIONS AREN'T MET
	POPJ	P,		;DONT SEND A MSG TO ANYBODY
	ANDCAM	T1,.PDIPQ##(W)	;AND SAY "NO MORE"
	MOVE	P2,T1		;SAVE IP.DP? BIT
	MOVEI	T2,2		;2 WORD MESSAGE TO INFO
	PUSHJ	P,GTFWDC##	;GET SPACE FOR MESSAGE
	  TDZA	T4,T4		;ISN'T ANY
	MOVE	T4,T1		;REMEMBER WHERE IT IS
	JUMPE	T4,IPCLG0	;WAS THERE ANY
	MOVEI	T2,IPCFRF-IPCFTB+1	;CODE FOR RESET/LOGOUT
	MOVEM	T2,0(T4)	;SAVE IT
	HRR	P2,J		;GET FLAG,,JOB
	MOVEM	P2,1(T4)	;STORE
IPCLG0:	MOVN	P2,%IPCMP##	;SET AN AOBJN WORD FOR LOOKING
	HRLZS	P2		; AT ALL OF PIDTAB
IPCLG1:	MOVE	T2,PIDTAB##(P2)	;PIDTAB ENTRY
	TDNN	P1,T2		;DROP THIS PID?
	JRST	IPCLG2		;NO--KEEP LOOKING
	MOVE	T1,T2		;COPY PID
	AND	T2,%IPCPM##	;JOB NUMBER
	CAIE	T2,(J)		;FOR THIS JOB?
	JRST	IPCLG2		;NO
	SETZM	PIDTAB##(P2)	;YES, CLEAR IT
	SOS	%IPCNP##	;1 LESS PID CURRENTLY ACTIVE
	TDZ	T1,%IPCPM##	;REMOVE JOB NUMBER
	IORI	T1,0(P2)	;INSERT PIDTAB INDEX
	HRREI	T2,.GTCSD##-.GTSID##
IPCLG3:	CAMN	T1,.GTSID##(T2)	;THIS IT
	JRST	[SETZM	.GTSID##(T2)	;YES, CLEAR ENTRY
		 SETZM	SIDJOB##(T2)	;AND THE JOB NUMBER
		 JRST	.+1]	;RETURN A LINE
	CAIGE	T2,SDTBLN##
	AOJA	T2,IPCLG3
	MOVE	T2,%SIINF##	;INFO'S PID
	MOVEM	T2,%CNIPI##	;KEEP THE GETTAB STRAIGHT
IPCLG2:	AOBJN	P2,IPCLG1	;DO FOR ALL ENTRIES IN PIDTAB
	JUMPE	T4,CPOPJ##
	MOVEI	T1,%SIINF##	;LOCATION OF INFO'S PID
	SKIPE	.PDIPI##(W)	;PRIVATE INFO?
	MOVEI	T1,.PDIPI##(W)	;YES, USE IT
	HRLI	T4,2		;INSERT SIZE
	PJRST	SNDFFC		;SEND IT AND RETURN
;SUBROUTINE TO TURN MESSAGES AROUND FOR A JOB ON RESET/LOGOUT
;CALL WITH T1=IP.DPR OR IP.DPL IN T1
;IF IP.DPR, TURNS AROUND ONLY THOSE MESSAGES FOR PIDS TO BE DROPPED ON RESET
;IF IP.DPL, TURNS AROUND ALL MESSAGES
;PRESERVES T1
TURNQ:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSH	P,J		;SAVE J
	MOVE	P3,J
	PUSH	P,T1
	MOVEI	P2,.PDIPC##-.IPCFL(W)	;PRESET PREDECESSOR
	TLNN	T1,IP.DPR
	TLO	P2,-1		;P2 NEGATIVE IF LOGOUT
TURNQ0:	HLRZ	P1,.IPCFL(P2)	;GET NEXT ENTRY IN QUEUE FOR JOB
TURNQ1:	JUMPE	P1,TURNQ7	;DONE IF 0
	SKIPL	T1,.IPCFR(P1)	;IF REC'R IS TO BE DROPPED ON LOGOUT,
	JUMPGE	P2,TURNQ6	; STEP TO NEXT PACKET IF THIS IS RESET
	AOS	T2,.IPCFL(P1)	;SET BIT 35 (UNDELIVERABLE) IN PACKET HEADER
	MOVE	P4,W		;SAVE PDB OF JOB DOING TURNING
	TRNE	T2,2		;ALREADY BEEN THIS WAY?
	JRST	TURNQ4		;YES, MAKE THE PACKET GO AWAY
	EXCH	T1,.IPCFS(P1)
	MOVEM	T1,.IPCFR(P1)
	PUSHJ	P,VALPID	;SET W FOR REC'R (ORIGINAL SENDER)
	  JRST	TURNQ4		;HE'S GONE TOO - REMOVE THE PACKET
	DPB	P3,TRNPTR	;SAVE JOB NUMBER FOR TURN-AROUND RCV.
	MOVNI	T1,IP.SBT	;DECREMENT SEND COUNT
	MOVE	T2,.PDIPC##(W)	
	TRNE	T2,777000
	ADDM	T1,.PDIPC##(W)	
	AOS	.PDIPC##(W)	;INCREMENT RECV COUNT
	EXCH	W,P4		;RESTORE W OF LOGGING-OUT JOB
	MOVEI	T2,777		;ADJUST COUNT OF OLD JOB
	ADDM	T2,.PDIPC##(W)
	SYSPIF
	SKIPN	T1,.PDIPN##(P4)
	MOVEI	T1,.PDIPC##-.IPCFL(P4)
	HRRM	P1,.PDIPN##(P4)
	HRLM	P1,.IPCFL(T1)	;STICK THIS PACKET ON END OF QUEUE
	MOVE	T1,.IPCFL(P1)	;LINK TO NEXT IN OLD JOB'S QUEUE
	HRRZS	.IPCFL(P1)	;THIS IS END IN FORMER SENDER'S QUEUE
	HLRZ	P1,T1		;POINT P1 TO NEXT IN OLD QUEUE
	HRLM	P1,.IPCFL(P2)	;LINK NEXT TO PREDECESSOR IN OLD Q
	SKIPN	P1
	HRRM	P2,.PDIPN##(W)
	SYSPIN
	JUMPN	J,[PUSHJ P,WAKEUP ;WAKE UP ORIGINAL SENDER 
		   JRST  TURNQ1] ;GO TURN AROUND NEXT MSG
	EXCH	W,P4
	HLRZ	T1,W		;LOC OF EXEC PID
	PUSHJ	P,@.EPADR(T1)	;CALL THE EXEC PROCESS
	MOVE	W,P4
	JRST	TURNQ1		;GO TURN AROUND NEXT MSG IN QUEUE

;HERE IF MSG COULDN'T BE TURNED AROUND
TURNQ4:	LDB	T1,TRNPTR	;GET JOB NUMBER
	PUSHJ	P,VALPID	;VALIDATE IT
	 JRST	TURNQ5
	MOVNI	T1,IP.SBT	;DECREMENT HIS SEND COUNT
	MOVE	T2,.PDIPC##(W)
	TRNE	T2,777000
	ADDM	T1,.PDIPC##(W)
TURNQ5:	MOVE	W,P4		;RESTORE PDB OF JOB DOING TURNING
	SYSPIF
	HLRZ	T1,.IPCFL(P1)	;LINK TO NEXT PACKET
	HRLM	T1,.IPCFL(P2)	;MAKE NEXT IN QUEUE
	SKIPN	T1
	HRRM	P2,.PDIPN##(W)
	SOS	.PDIPC##(W)	;DECREMENT USER'S RECEIVE COUNT.
	SYSPIN
	PUSHJ	P,REMPAK	;REURN THIS PACKET TO FREE CORE
	JRST	TURNQ0		;AND TRY NEXT PACKET

;HERE IF PACKET IS FOR A PID TO BE DROPPED ON LOGOUT, THIS IS RESET
TURNQ6:	HRR	P2,P1		;SAVE POINTER TO LAST ON OLD QUEUE
	JRST	TURNQ0		;GO PROCESS NEXT QUEUE ENTRY

;HERE WHEN DONE
TURNQ7:	POP	P,T1		;RESET T1
	PJRST	JPOPJ##		;AND RETURN TO CALLER
SUBTTL	IPCC INTERFACE FOR BATCH AND SPOOLING

IFN FTSPL,<
;HERE ON THE CLOSE OF A SPOOLED FILE FROM FILUUO.  CALLED WITH F
;	CONTAINING THE ADDRESS OF THE SPOOLED DDB.

QSRSPL::PUSHJ	P,SAVT##	;SAVE T1 - T4
	PUSH	P,J		;SAVE J
	LDB	J,PJOBN##	;LOAD UP J
	MOVSI	T1,SPMSIZ	;MESSAGE SIZE
	HRRI	T1,IPCFSM-IPCFTB+1	;SPOOL FUNCTION
	PUSHJ	P,FNPDBS##	;SETUP W
	PUSHJ	P,SETQSR	;SETUP THE PACKET
	SKIPE	T3,DEVSPM##(F)	;GET ADDR OF SPOOLED PARAMETER BLOCK
	SKIPN	T1,SPBNM1(T3)	;HAVE A USER NAME?
	SKIPA	T1,.PDNM1##(W)	;GET NAME FROM USER BLOCK
	SKIPA	T2,SPBNM2(T3)	;SECOND HALF
	MOVE	T2,.PDNM2##(W)	;GET SECOND HALF
	DMOVEM	T1,SPMUSR(T4)	;STORE IT

	MOVE	T1,DEVNAM(F)	;GET INITED DEVICE
	MOVEM	T1,SPMIDV(T4)	;AND SAVE IT
	HLRZ	T1,DEVUNI##(F)	;GET ADR OF UDB
	HRRZ	T1,UNISTR##(T1)	;GET ADR OF SDB
	MOVE	T1,STRNAM##(T1)	;GET STRUCTURE NAME
	MOVEM	T1,SPMSTR(T4)	;STORE IT
	MOVE	T1,DEVFIL(F)	;GET FILENAME
	MOVEM	T1,SPMFIL(T4)	;STORE IT
	HLLZ	T1,DEVEXT(F)	;GET EXTENSION
	HLLM	T1,SPMEXT(T4)	;STORE IT
	SKIPN	T1,DEVSPN##(F)	;GET ENTER'ED NAME IF SETUP
	MOVE	T1,JBTNAM##(J)	;USE PROG NAME IF 0.
	MOVEM	T1,SPMEFN(T4)	;AND SAVE IT
	MOVE	T1,DEVACC##(F)	;GET ADDRESS OF ACCESS TABLE
	MOVE	T1,ACCWRT##(T1)	;GET BLOCKS WRITTEN
	MOVEM	T1,SPMFSZ(T4)	;AND SAVE FILE SIZE
	HRLZ	T1,DEVSPM##(F)	;GET ADDRESS OF SPOOLING OPTION BLOCK
	JUMPE	T1,QSRSP1	;IF NO PARAMETER BLOCK
	HRRI	T1,SPMPRM(T4)	;WHERE TO COPY BLOCK TO
	JRST	QSRSP2		;AND SEND IT ALL
QSRSP1:	HRLI	T1,SPMPRM(T4)	;PREPARE TO CLEAR BLOCK
	HRRI	T1,SPMPRM+1(T4)	;...
	SETZM	SPMPRM(T4)	;CLEAR FIRST WORD
QSRSP2:	BLT	T1,SPMPRM+SPBMAX-1(T4) ;CLEAR OR MOVE ALL PARMS
	SKIPE	DEVUPP##(F)	;IN-YOUR-BEHALF ENTER DONE?
	JRST	QSRSP3		;YES--ACCT STRING ALREADY SETUP
	MOVSI	T1,.PDACS##(W)	;WILL USE ACCT STRING FROM PDB
	HRRI	T1,SPMPRM+SPBACT(T4) ;SET UP BLT
	BLT	T1,SPMPRM+SPBMAX-1(T4) ;COPY ACCT STRING

QSRSP3:	MOVEI	T1,%SIQSR##	;SEND TO QUASAR
	PUSH	P,T4		;SAVE MESSAGE ADDRESS
	SKIPN	T2,DEVUPP##(F)	;GET IN-YOUR-BEHALF PPN
	MOVE	T2,JBTPPN##(J)	;ISN'T ONE SO USE OUR PPN INSTEAD
	EXCH	T2,T4		;SENDS0 WANTS PPN IN T4, AND
	PUSHJ	P,SENDS0	; T2 POINTING TO MESSAGE
	JFCL			;IGNORE PROBLEMS
	POP	P,T2		;GET BACK MESSAGE ADDRESS
	HLRZ	T1,T2		;LENGTH IN T1
	HRRZS	T2		;JUST ADDRESS
	PUSHJ	P,GVFWDS##	;RETURN THE FREECORE

	JRST	JPOPJ##
>	;END IFN FTSPL


	SUBTTL	QUEUE. UUO - UUO TO SEND A MESSAGE TO A GALAXY COMPONENT

;UUO TO SEND A MESSAGE TO A GALAXY COMPONENT AND OPTIONALLY WAIT FOR A RESPONSE
;CALLING SEQUENCE:
;	MOVE	AC,[LENGTH,,ADDRESS]
;	QUEUE.	AC,
;	  ERROR RETURN
;	NORMAL RETURN

;ERROR RETURNS FROM THE QUEUE. UUO
QUIAL%==1
QUILF%==2
QUNFS%==3
QUADC%==4
QUCNR%==5
QUFER%==6
QUSOC%==7
QUNPV%==10

	ERCODE	QUEIAL,QUIAL%	;ILLEGAL ARGUMENT LIST
	ERCODE	QUEILF,QUILF%	;ILLEGAL FUNCTION
	ERCODE	QUENFS,QUNFS%	;NO MONITOR FREE CORE
	ERCODE	QUEADC,QUADC%	;ADDRESS CHECK
	ERCODE	QUECNR,QUCNR%	;COMPONENT NOT RUNNING - NO SYSTEM PID
	ERCODE	QUEFER,QUFER%	;FATAL ERROR RETURNED FROM COMPONENT
	ERCODE	QUESOC,QUSOC%	;SOMEONE IS CONFUSED (INVALID MESSAGE FROM COMPONENT)
	ERCODE	QUENPV,QUNPV%	;ASKING FOR PRIVS BUT ISN'T PRIVILEGED
GLXINF::PUSHJ	P,SAVE4##
	hlrz	p1,t1		;To enable galaxy 5.1 to run under 7.02
	CAIGE	P1,5		;MUST BE AT LEAST ONE REAL ARGUMENT
	JRST	QUEIAL
	HRRI	M,(T1)
	PUSHJ	P,GETWRD##
	  JRST	QUEADC
	TLNE	T1,-1-<(QU.LFB)>;ANY UNDEFINED FLAG BITS ON?
	JRST	QUEIAL		;YES, ILLEGAL ARGUMENT LIST
	TLNE	T1,(QU.PRP)	;PRIVILEGED ASKING FOR PRIVILEGES?
	PUSHJ	P,PRVJC##	;YES, THEN MUST BE PRIVILEGED
	  SKIPA	U,T1		;PRIV'D OR NOT ASKING FOR THEM
	JRST	QUENPV		;NOT PRIV'D
	HRRES	T1		;get function code
	JUMPE	T1,QUEILF	;zero is illegal
	caml	t1,[.gtqft##-.gtqfc##]  ;customer function
	CAILE	T1,QUTBLN##	;dec function
	JRST	QUEILF		;no to either
	HRRZ	T1,.GTQFT##(T1)	;get adress of accos pid
	jumpe	t1,queilf	;ill func if no matching pid
	SKIPN	(T1)
	JRST	QUECNR		;COMPONENT NOT RUNNING

;VALIDATE AND SAVE THE NODE HERE
	PUSHJ	P,GETWR1##
	  JRST	QUEADC
IFE FTNET,<SETZ W,>
IFN FTNET,<
	SKIPN	T2,T1
	MOVE	T1,JBTLOC##
	CAMN	T2,[-1]
	MOVE	T1,JBTLOC##(J)
	PUSHJ	P,[NETDBJ
		   JRST NODE.S##]
	  SKIPA	W,T1		;MAYBE AN OFFLINE NODE
	JRST	[HLRZ W,NDBSNM##(W)
		 MOVE W,(W)
		 JRST .+1]
>	;END FTNET
	PUSHJ	P,INWAT##	;WAIT FOR INPUT TO STOP
;GET LENGTH,,ADDRESS OF RESPONSE BUFFER AND MAKE SURE ITS IN CORE
	PUSHJ	P,GETWR1##
	  JRST	QUEADC
	MOVE	P4,T1
	SKIPGE	U		;DON'T BOTHER IF WE'LL NEVER LOOK AGAIN
	 PUSHJ	P,CHKIC
;HERE TO SCAN THE ARGUMENT LIST MAKING SURE ITS IN CORE AND DETERMINING
; THE NUMBER OF WORDS OF CORE NECESSARY FOR BUILDING THE GALAXY MESSAGE
	MOVEI	P2,-3(P1)	;count of arguments words
	MOVEI	P3,QUESDL	;5 WORDS OF GALAXY HEADER, 2 WORD FUNCTION BLOCK
				; 2 WORDS FOR OPR, 3 WORDS FOR USER'S NAME,
				; ACTSTL + 1 FOR ACCOUNT STRING
GLXIN1:	PUSHJ	P,NXTARG
	  JRST	GLXIN2
	LDB	T2,[POINT 9,T1,17] ;LENGTH OF THE ARGUMENT
	ADDI	P3,1(T2)	;LENGTH OF THE DATA BLOCK + 1 FOR THE HEADER WORD
	JRST	GLXIN1		;loop back
;HERE TO ALLOCATE THE CORE TO BUILD THE MESSAGE
GLXIN2:	MOVE	T2,P3
	CAIG	T2,PAGSIZ##-2
	PUSHJ	P,GTFWDC##
	  JRST	QUENFS
;HERE TO BUILD GALAXY HEADER BLOCK, NODE, AND ACCOUNT STRING BLOCKS
	HRL	P3,T1		;SAVE ADDRESS OF THE FREE CORE
	HRLZ	T2,P3
	HRRI	T2,.IPCGM	;FUNCTION IS GALAXY MESSAGE
	MOVEM	T2,QUELNH(T1)	;LENGTH OF THE ENTIRE BLOCK,,GALAXY FUNCTION
	HRRZ	T2,U		;FUNCTION
	TLNE	U,(QU.PRP)	;PRIVILEGED?
	TLNN	U,(QU.NBR)	;ASKING NOT TO BLOCK?
	CAIA			;NO, BLOCK
	CAIE	T2,%QWTO##-.GTQFT## ;WTO IS THE ONLY NON-BLOCKING FUNCTION NOW
	CAIN	T2,%QWTOR##-.GTQFT## ;WTOR?, IF SO DON'T ASK FOR AN ACK
	TDZA	T2,T2		;YES, DON'T REQUEST AN ACK
	MOVSI	T2,(1B0)	;NO, REQUEST AN ACK
	MOVEM	T2,QUEFLG(T1)
	HRLZ	T2,%CNIPS##	;SEQUENCE NUMBER
	HRR	T2,J		;JOB NUMBER OF REQUESTOR
	MOVEM	T2,QUEJOB(T1)	;STORE FOR ACKNOLEGMENT
	SETZM	QUEMBZ(T1)	;MBZ
	movei	t2,queigl	;set initial argumen t count to
	MOVEM	T2,QUEARC(T1)	;to the number of internal block generated
	MOVE	T2,[QUEFCL,,.WTUFC] ;FUNCTION BLOCK
	MOVEM	T2,QUEFCH(T1)	;STORE THAT
	HRRZM	U,QUEFCN(T1)	;USER SUPPLIED FUNCTION CODE
	MOVE	T2,[QUEONL,,.WTDES] ;OPERATOR BLOCK
	MOVEM	T2,QUEONH(T1)
	MOVEM	W,QUEONN(T1)	;OPERATOR NODE NAME
	PUSHJ	P,FNDPDS##	;FIND THE PDB
	HLRZ	T2,QUEJOB(T1)
	HRRM	T2,.PDQSN##(W)
	MOVE	T2,[QUEUNL,,.WTNAM]
	MOVEM	T2,QUEUNH(T1)
	MOVE	T2,.PDNM1##(W)
	MOVE	T3,.PDNM2##(W)
	DMOVEM	T2,QUEUSN(T1)
	MOVE	T2,[QUEACL,,.WTACT]
	MOVEM	T2,QUEACH(T1)	;ACCOUNT STRING BLOCK
	MOVEI	T2,ACTSTL##
	JUMPE	T2,GLXIN3
	MOVSI	T2,.PDACS##(W)	;ADDRESS OF THE ACCOUNT STRING
	HRRI	T2,QUEACS(T1)	;WHERE TO STORE IT IN THE MESSAGE
	BLT	T2,QUEACS+ACTSTL-1(T1) ;COPY THE ACCOUNT STRING
;HERE TO COPY THE USERS ARGUMENT LIST TO THE GALAXY MESSAGE
GLXIN3:	MOVEI	P2,-3(P1)	;NUMBER OF ARGUMENTS TO COPY
	MOVEI	P1,QUESDL(T1)	;WHERE TO STORE ARGUMENTS
	PUSHJ	P,GETTAC##	;GET BACK THE POINTER TO THE USERS ARGUMENT LIST
	HRRI	M,2(T1)		;ADDRESS - 1 OF FIRST ARGUMENT
GLXIN4:	PUSHJ	P,NXTARG	;NEXT ARGUMENT
	  JRST	GLXIN7		;PROCESSED ALL ARGUMENTS
	hlrz	t3,p3		;get message adres
	aos	quearc(t3)	;count blocks to be added
	LDB	T3,[POINT 9,T1,17] ;LENGTH OF THE DATA BLOCK
	hrrz	t4,t1		;function
	HRLI	T4,1(T3)	;LENGTH,,FUNCTION
	MOVEM	T4,(P1)		;STORE THAT
	AOS	P1		;WHERE TO STORE DATA

GLXIN5:	EXCTUX	<MOVE T4,(T2)>	;GET DATA
	MOVEM	T4,(P1)		;STORE DATA IN THE MESSAGE
	hrri	t2,1(t2)	;advance argument pointer
	SOSLE	T3		;MOVED ALL DATA ITEMS?
	AOJA	P1,GLXIN5	;NO, GET THE NEXT ONE
	AOJA	P1,GLXIN4	;GET NEXT ARGUMENT
;HERE TO SEND THE MESSAGE TO THE APPROPRIATE GALAXY COMPONENT
GLXIN7:	MOVSI	T1,40		;FROM [SYSTEM] GOPHER
	HRR	T1,.GTQFT##(U)	;COMPONENT TO SEND THE MESSAGE TO
	MOVS	T2,P3		;LENGTH,,ADDRESS OF MESSAGE
	PUSH	P,T2
	MOVE	T3,PIDTAB##+1
	ADDI	T3,1
	MOVE	T4,JBTPPN##(J)
	TLNE	U,(QU.NBR)	;WANT NON-BLOCKING?
	JRST	[PUSHJ P,SENDS0	;YES, SEND AND DON'T WAIT FOR A RESPONSE
		   JRST	[PUSHJ P,QUECNR
			 JRST SNDFFR]
		 AOS -1(P)
		 JRST SNDFFR]
	PUSHJ	P,SENDSP
	  JRST	[PUSHJ P,QUECNR
		 JRST SNDFFR]
;HERE TO GIVE THE USER THE RESPONSE IF HE WANTS ONE
	HLRZ	T2,.PDEPA(W)
	MOVE	T1,.IPCFD+1(T2)
	TLNE	T1,100000
	JRST	[PUSHJ P,QUEFER
		 JRST .+2] 	;ERROR RETURN BUT GIVE USER RESPONSE
	AOS	-1(P)
	SKIPL	U		;USER WANT A RESPONSE?
	JRST	GLXI12		;NO, TOSS THE ACK OR RESPONSE
	TLNE	T1,200000	;ACK OR RESPONSE?
	JRST	[SETZB P2,P3	;ACK, SO INDICATE ZERO LENGTH RESPONSE
		 JRST GLXI10]
	HRRZ	T1,.IPCFD+4(T2)
	MOVEI	T2,.IPCFD+5(T2)
GLXIN8:	HRRZ	T3,(T2)
	CAIN	T3,.CMTXT
	JRST	GLXIN9
	HLRZ	T3,(T2)
	ADD	T2,T3
	SOJG	T1,GLXIN8
	PUSHJ	P,QUESOC
	JRST	GLXI12
GLXIN9:	MOVEI	P1,1(T2)
	HLRZ	P2,(T2)
	HLRZ	P3,P4
GLXI10:	MOVE	T1,P2		;LENGTH OF THE RESPONSE
	CAMLE	P2,P3
	TRO	T1,WT.RWT
	TRO	T1,WT.RBR	;INDICATE RESPONSE BLOCK
	PUSHJ	P,STOTAC##	;STORE RESPONSE LENGTH PLUS POSSIBLE TRUNCATED BIT
	JUMPE	P2,GLXI12
	HRRI	M,-1(P4)
GLXI11:	MOVE	T1,(P1)
	PUSHJ	P,PUTWD1##
	AOS	P1
	SOSLE	P2
	SOJG	P3,GLXI11
GLXI12:	HLRZ	T2,.PDEPA(W)
	HLRZ	T1,.IPCFP(T2)
	ADDI	T1,.IPCFD
	PUSHJ	P,GIVWDS##
	PJRST	SNDFFR
;RETURNS T1 = ARGUMENT <I>B0+<LENGTH>B17+<TYPE>B35, T2 = ADDRESS OF DATA
; UNDEFINED BITS MUST BE ZERO

NXTARG:	SOJL	P2,CPOPJ##
	PUSHJ	P,GETWR1##
	  JRST	NXTAD1		;QUEADC, BUT POP STACK BY ONE.
	tlnn	t1,777		;word count specified?
	tlo	t1,1		;no default to one
	hlrz	t2,t1		;number of words in argument is in left half
	andi	t2,777		;strip of flags there might be
	tlnn	t1,377000	;any illegal bits turned on
	caige	t2,1		;resonable lenght?
	jrst	nxtial		;go fetch if not immeadte
	push	p,t1		;save on stack
	jumpge	t1,nxtar1	;go fetch if not immediate
	hrri	m,1(m)		;advance argument pointer
	move	t1,m		;adress of sub block
	push	p,m		;blance stack
	jrst	nxtar2		;re-join common code
nxtar1:	pushj	p,getwr1##	;
 	 jrst	nxtad2		;queadc, but pop t1 and call off
	tlne	t1,(17777b12)	;allow only @(17)777777
	jrst	nxtia2		;spurius bits are on,queal
	hlrz	t2,(p)		;get lenght of of sub block
	PUSH	P,M
	PUSHJ	P,CHKIND##	;RESOLVE ADDRESS AS IF INDIRECTED.
	 JRST	NXTAD3		;ADDR CHECK. THROW AWAY M, T1, AND CALL
				;  BEFORE CALLING QUEADC
nxtar2:	PUSH	P,T1		;SAVE ADDRESS OF THE DATA BLOCK
	HRRZS	T1,(P)		;ADDRESS OF DATA BLOCK, CLEAR LEFT HALF BITS
	HLL	T1,-2(P)	;WHERE CHKIC WANTS LENGTH
	tlz	t1,400000	;ignore imeadeate-mode bit
	PUSHJ	P,CHKIC
	pop	p,m		;restore block adress
	exch	m,(p)		;save and restore m
	hlrz	t2,-1(p)	;get sub-block lenght plus flag
	trzn	p2,400000	;immeadiete mode ?
	movei	t2,1		;no only one word used by point
	subi	p2,(t2)		;account for args in uuo block
	jumpl	p2,nxtia2	;illegal arg list if counts don't match
	add	t2,m		;point past curent argument
	hrri	m,-1(t2)	;ofset for getwr1
	POP	P,T2		;ADDRESS OF THE DATA BLOCK
	JRST	TPOPJ1##	;RESTORE ARGUMENT AND RETURN

CHKIC:	HLRZ	T2,T1
	HRRZS	T1
	ADDI	T2,-1(T1)
	PJRST	TRNGE##

nxtia2:	pop	p,(p)		;pop t1,
NXTIAL:	POP 	P,(P)		; AND CALL TO NXTARG
	PJRST 	QUEIAL		;  AND THEN GIVE AN "ILLEGAL ARG" ERROR

NXTAD3:	POP	P,(P)		;ENTRY TO POP 3 ACS
NXTAD2:	POP	P,(P)		;... 2 ACS
NXTAD1:	POP	P,(P)		;... 1 AC
	PJRST	QUEADC		;AND GIVE AN ADDRESS CHECK ERROR RETURN.

;HERE ON LOGOUT UUO.  LOGOUT MESSAGE IS SENT TO QUASAR IF %SIQSR
;	CONTAINS A VALID PID.

QSRLGO:	PUSHJ	P,SETLMG	;SETUP THE MESSAGE
	MOVEI	T1,%SIOPR##
	PUSHJ	P,SNDFFC
	PUSHJ	P,SETLMG
	PUSHJ	P,SNDQSR
	MOVE	T1,JBTPRG##(J)
	CAMN	T1,LGONAM##
	CAMN	J,ACTJOB##
	POPJ	P,
	PUSHJ	P,SETLMG
	MOVE	T1,[40,,%SIACT##]
	MOVE	T2,T4
	MOVE	T3,PIDTAB##+1
	ADDI	T3,1
	MOVE	T4,JBTPPN##(J)
	PUSH	P,T2
	PUSHJ	P,SENDSP
	  JRST	SNDFFR
	HLRZ	T2,.PDEPA##(W)
	HLRZ	T1,.IPCFP(T2)
	ADDI	T1,.IPCFD
	PUSHJ	P,GIVWDS##
	JRST	SNDFFR


;HERE ON LOGIN UUO TO SEND MESSAGE TO QUASAR

QSRLGI::MOVSI	T1,LOMSIZ	;SIZE OF MESSAGE
	HRRI	T1,IPCFON-IPCFTB+1 ;CODE
	PUSHJ	P,SETQSR	;SETUP THE MESSAGE
	DMOVE	T1,.PDNM1##(W)	;GET USER NAME
	DMOVEM	T1,LOMUSR(T4)	;STORE
	PUSH	P,F
	PUSH	P,T4
	MOVE	F,TTYTAB##(J)
	PUSHJ	P,CTLJBD##
	POP	P,T4
	MOVEM	T1,LOMCTL(T4)
	MOVE	T1,DEVNAM(F)
	MOVEM	T1,LOMTTY(T4)
	POP	P,F
SNDQSR:	MOVEI	T1,%SIQSR##
	PJRST	SNDFFC		;AND SEND MESSAGE TO QUASAR

;SETQSR  --  ROUTINE TO SETUP A PACKET TO SEND TO QUASAR.  CALL
;	WITH T1 CONTAINING SIZE,,CODE, RETURN QSRMSG BLOCK
;	WITH GALMSG AND GALSTS ALL SETUP.
;RETURNS T4=LEN,,ADDR OF MESSAGE

SETCSM::HRRI	T1,IPCFCS-IPCFTB+1 ;CSHIFT CODE
	PJRST	SETQSR		;SET IT UP
SETLMG:	MOVSI	T1,LGMSIZ	;SIZE OF MESSAGE
	HRRI	T1,IPCFLM-IPCFTB+1 ;CODE
;	PJRST	SETQSR		;SETUP THE MESSAGE
SETQSR:	PUSH	P,T1
	HLRZ	T2,T1
	PUSHJ	P,GFWDCD##
	  STOPCD	.,JOB,NCM,	;++NO CORE FOR MESSAGE
	MOVE	T4,T1
	POP	P,GALMSG(T4)
	HLL	T4,GALMSG(T4)
	HRLZ	T1,J		;GET JOB,,0
	LDB	T2,[JBPBSN]	;GET BATCH STREAM NUMBER
	LSH	T2,^D27		;SHIFT OVER
	IOR	T1,T2		; OR IT IN
	MOVSI	T2,(JB.BSS)	;GET BATCH STREAM SET BIT
	TDNE	T2,.PDOBI##(W)	;IS IT ON?
	TRO	T1,GALBSS	;YES-TELL QUASAR
IFN FTNET,<
	HRRZ	T2,JBTLOC##(J)	;GET HIS LOCATION
	LSH	T2,^D9		;SHIFT OVER 9 BITS
	IOR	T1,T2		;OR IT IN
>  ;END IFN FTNET
	MOVSI	T2,(JB.LBT)	;GET BATCH BIT
	TDNE	T2,JBTLIM##(J)	;IS HE A BATCH JOB?
	TRO	T1,GALBAT	;YES, SET THE FLAG
	MOVEI	T2,JB.DFR	;GET DEFERED BIT
	TDNE	T2,JBTSPL##(J)	;TEST IT
	TRO	T1,GALDFR	;ITS ON
	MOVEM	T1,GALSTS(T4)	;AND STORE 2ND DATA WORD
	POPJ	P,		;AND RETURN

IFN FTMDA,<
;SUBROUTINE TO SEND THE CONTENTS OF T1 AND T2 TO [SYSTEM]MDC
;CALLING SEQUENCE:  (MAY BE CALLED AT INTERRUPT LEVEL)
;	MOVE	T1,UNIT NAME
;	MOVEI	T2,DEVICE TYPE
;	PUSHJ	P,SNDMDC
;RETURNS CPOPJ IF THE MESSAGE COULDN'T BE SENT, CPOPJ1 IF OK

LEN.UO==3			;LENGTH OF MSG
SNDMDC::PUSH	P,T1		;SAVE ARGUMENTS
	PUSH	P,T2
	MOVEI	T2,LEN.UO	;GET THREE WORDS OF FREE STORAGE
	PUSHJ	P,GETWDS##
	  JRST	[POP	P,T2	;FAIL
		 JRST	TPOPJ##]
	MOVE	T2,[XWD LEN.UO,.IPCUO]
	MOVEM	T2,(T1)
	POP	P,2(T1)		;DEVICE TYPE
	POP	P,1(T1)		;UNIT NAME
	HRLI	T1,LEN.UO	;LENGTH OF BLOCK
	PUSH	P,T1		;SAVE LEN,,ADDR
	MOVE	T2,2(T1)	;GET BACK DEVICE TYPE
	MOVEI	T1,%SIDOL##	;ASSUME DISK
	CAIE	T2,.TYDSK/.TYEST ;TRUE?
	MOVEI	T1,%SITOL##	;NO, SEND IT TO PULSAR
>
IFN FTMDA!FTMOS,<
;HERE WITH ADDR OF RECVR PID IN T1
;LEN,,MSG ADDRS IN 0(P)
;ALWAYS RETURNS
;LEN WORDS AT ADDR
SNDMDX::MOVE	T2,(P)		;GET ADDR OF MESSAGE AGAIN
	PUSH	P,J		;SAVE J
	PUSH	P,W		;SAVE W
	SETZB	J,T4		;JOB NUMBER AND PPN OF SENDER ARE ZERO
	PUSHJ	P,SENDS0	;SEND THE MESSAGE
	  SOS	-3(P)		;FAILED
	POP	P,W		;RESTORE W
	POP	P,J		;RESTORE J
	POP	P,T2		;AND FREE CORE ADDRESS
	HLRZ	T1,T2		;GET # OF WORDS TO RETURN
	HRRZS	T2		;CLEAR LH OF GIVWDS
	AOS	(P)		;SKIP RETURN IF SUCCESSFUL
	PJRST	GIVWDS##	;RETURN FREE CORE
>
IFN FTMDA,<
;ROUTINE TO SEND A MESSAGE TO MDA WHEN A CONTROLLED DEVICE
; HAS BEEN REASSIGNED
;CALL:	F-DDB ADDRESS
;	J-JOB NUMBER
;RETURNS-CPOPJ IF MESSAGE NOT SENT
;	CPOPJ1 IF OK

LEN.DE==4			;MINIMUM LENGTH OF DEASSIGN MESSAGE
SNDFIN::TDZA	T1,T1		;NO FLAG FOR DEASSIGN
SNDVSS::MOVSI	T1,400000	;GET FLAG INDICATING VOL SWITCH
	MOVEI	T2,LEN.DE	;ASSUME UNINTERESTING DEVICE
	MOVEI	T3,0		;AND NO DATA
	LDB	T4,PDVTYP##	;GET DEVICE TYPE
	CAIE	T4,.TYDTA/.TYEST;DECTAPE?
	JRST	SNDFI1		;NO
	MOVEI	T2,LEN.DE+2	;STANDARD LENGTH PLUS DATA WORDS
	MOVE	T3,[-2,,[EXP 0,0]] ;AOBJN POINTER TO DATA (ZEROS FOR DTA)
	JRST	SNDFI2		;JOIN COMMON CODE

SNDFI1:	CAIE	T4,.TYMTA/.TYEST;MAGTAPE?
	JRST	SNDFI2		;NO
	MOVEI	T2,LEN.DE+6	;STANDARD LENGTH PLUS DATA WORDS
	HLRZ	T3,TDVUDB##(F)	;GET TUB ADDRESS
	MOVEI	T3,TUBCRD##(T3)	;POINT TO START OF UDB DATA QUASAR NEEDS
	HRLI	T3,-6		;SIX WORDS LONG
				;c11 pl}th
	HLL	T4,T1		;GET FLAG SO MDA KNOWS WHAT TO DO WITH STATS
SNDFI2:	PUSH	P,T2		;SAVE LENGTH
	PUSH	P,T3		;SAVE AOBJN POINTER
	PUSH	P,T4		;SAVE DEVICE TYPE
	PUSHJ	P,GETWDS##	;GET CORE
	  JRST	[POP	P,T4
		 POP	P,T3
		 JRST	T2POPJ##]
	LDB	T2,PJOBN##	;GET JOB NUMBER
	MOVEM	T2,3(T1)	;SAVE IT
	POP	P,2(T1)		;DEVICE TYPE
	MOVE	T2,DEVNAM(F)	;GET DEVICE NAME
	MOVEM	T2,1(T1)	;SAVE IT
	POP	P,T3		;GET AOBJN POINTER
	POP	P,T2		;GET MESSAGE LENGTH
	HRLZS	T2		;LH=LENGTH
	HRRI	T2,.IPCDE	;RH=IPCF FUNCTION
	MOVEM	T2,0(T1)	;MESSAGE CODE
	JUMPGE	T3,SNDFI4	;JUMP IF NO DATA TO STORE
	MOVE	T4,T1		;COPY MESSAGE ADDRESS

SNDFI3:	MOVE	T2,(T3)		;GET A WORD
	MOVEM	T2,4(T4)	;PUT A WORD
	ADDI	T4,1		;POINT TO NEXT LOC
	AOBJN	T3,SNDFI3	;LOOP

SNDFI4:	HLL	T1,(T1)		;GET LENGTH FROM MESSAGE


;HERE WITH LEN,,ADRS OF MESSAGE IN T1
;TO SEND MESSAGE TO MDA, AND RETURN FREE
;CORE USED BY THE MESSAGE
SNDF.1:	PUSH	P,T1		;SAVE SO WE CAN RETURN IT
	MOVEI	T1,%SIMDA##	;WHO TO SEND TO
	PJRST	SNDMDX		;SEND IT OFF, RETURN THE CORE
>;END IFN FTMDA

;HERE WHEN A T/S JOB WHICH OWNS LOCKED FILE
;STRUCTURES DOES A RESET. MDA WILL GET MESSAGE
;WITH RESET'S JOB NUMBER.
;CALL - J - JOB #
;RETURNS-
;	POPJ	- NO MDA
;	CPOPJ1  - SENT

IFN FTMDA,<
LEN.RS==2			;LENGTH OF RESET MESSAGE
SNDMDR::
	MOVEI	T2,LEN.RS	;GET MESSAGE LENGTH
	PUSHJ	P,GETWDS##	;GET THAT MUCH SPACE
	 POPJ	P,		;CAN'T, GIVE UP
	MOVE	T2,[XWD LEN.RS,.IPCRL] ;HEADER WORD
	MOVEM	T2,0(T1)	;MARK THE MESSAGE
	MOVEM	J,1(T1)		;SAY WHO'S RESETTING
	HRLI	T1,LEN.RS	;COUNT THE FREE SPACE
	PJRST	SNDF.1		;SEND IT OFF!
> ;END IFN FTMDA

IFN FTMDA,<
;HERE WHEN A JOB CHANGES ITS SEARCH LIST
;MDA WILL GET A COPY OF THE NEW LIST
;CALL -
;	T1,	ADDR OF MESSAGE (IN FREE CORE)
;	T2,	LEN OF MESSAGE SPACE
;RETURNS
;	POPJ	NO MDA
;	CPOPJ1	SENT
;NOTE: THE SPACE OCCUPIED BY THE MESSAGE IS ALWAYS RETURNED

SNDMDN::HRLI	T1,(T2)		;COUNT THE BLOCK
	PJRST	SNDF.1		;SEND IT
>;END IFN FTMDA

IFN FTMDA,<
	LEN.AT==4	;LENGTH OF ATTACH MSG
	LEN.DT==4	;LENGTH OF DETACH MSG
;ATTMPA - NOTIFY MDA OF PORT ATTACHMENT
;	U/ UDB JUST ATTACHED
;	RETURNS - CPOPJ	(ALWAYS)

ATTMPA::MOVEI	T2,LEN.AT	;LENGTH OF ATT/DET MSG
	PUSHJ	P,GETWDS##	;GET SOME SPACE
	  POPJ	P,
	MOVE	T2,[XWD LEN.AT,.IPCAT] ;LEN,,MSG TYPE
	MOVEM	T2,0(T1)	;MARK THE HEADER
	MOVE	T2,UNINAM##(U)	;GET DRIVE NAME
	MOVEM	T2,1(T1)	;PUT IN MESSAGE
	MOVE	T2,U		;COPY ATTACHED UDB ADDRESS
IFE FTDUAL,<
	SETZ	T3,		;NO DUAL PORT IF FTDUAL IS OFF
>
IFN FTDUAL,<
	SKIPE	T3,UNI2ND##(U)	;UNIT DUAL PORTED?
	TLNN	T3,1		;YES, THIS THE PRIMARY PORT?
	CAIA			;YES, OR NOT DUAL PORTED
	EXCH	T2,T3		;T2:=PRIMARY UDB, T3:=SECONDARY UDB
>
	MOVE	T2,UNINAM##(T2)	;GET NAME OF PRIMARY PORT
	MOVEM	T2,2(T1)	;PUT IN MESSAGE
	SKIPE	T3		;HAVE A SECONDARY PORT UDB?
	MOVE	T3,UNINAM##(T3)	;YES, GET THE NAME
	MOVEM	T3,3(T1)	;PUT IN MESSAGE
	HRLI	T1,LEN.AT	;COUNT THE BLOCK
ATTMP1:	PUSHJ	P,SNDF.1	;SEND IT OFF
	  JFCL			;CAN'T? OH WELL
	POPJ	P,

;DETMPA - NOTIFY MDA OF PORT DETACH
;	U/ UDB JUST DETACHED
;	T1/SIXBIT NEW PRIMARY UNIT (PERHAPS 0)
;	RETURN CPOPJ	ALWAYS

DETMPA::PUSH	P,T1		;SAVE NEW PRIMARY
	MOVEI	T2,LEN.DT	;LENGTH OF MSG
	PUSHJ	P,GETWDS##	;GET A MESSAGE BLOCK
	  JRST	TPOPJ##		;OH WELL
	MOVE	T2,[XWD LEN.DT,.IPCDT] ;LEN,,MSG TYPE
	MOVEM	T2,0(T1)	;MARK HEADER
	MOVE	T2,UNINAM##(U)	;DETACHED UNIT NAME
	MOVEM	T2,1(T1)	;THAT'S 1ST ITEM
	POP	P,2(T1)		;NEW PRIMARY OR ZERO
	SETZM	3(T1)		;NO SECONDARY PORT NOW
	HRLI	T1,LEN.DT	;COUNT THE MSG
	PJRST	ATTMP1		;SEND IT

IFN FTDHIA,<

;XCHMPA - NOTIFY MDA OF DISK UNIT EXCHANGE
;	P1 / FIRST UDB ADDRESS
;	U  / SECOND UDB ADDRESS
;	RETURN	CPOPJ	ALWAYS

	LEN.XC==3

XCHMPA::MOVEI	T2,LEN.XC	;GET MSG LENGTH
	PUSHJ	P,GETWDS##	;GET SOME CORE
	  POPJ	P,		;CANT
	MOVE	T2,[LEN.XC,,.IPCXC] ;LEN,,MSG TYPE
	MOVEM	T2,0(T1)	;STORE IT
	MOVE	T2,UNINAM##(P1)	;GET FIRST UNIT NAME
	MOVEM	T2,1(T1)	;STORE IT
	MOVE	T2,UNINAM##(U)	;GET SECOND UNIT NAME
	MOVEM	T2,2(T1)	;STORE IT
	HRLI	T1,LEN.XC	;COUNT THE MSG
	PJRST	ATTMP1		;SEND MSG AND RETURN
> ;END OF IFN FTDHIA & FTATTACH
;REMMPA - NOTIFY MDA OF A STRUCTURE REMOVAL
;	F / STR D.B.
;	RETURN 	CPOPJ	ALWAYS

	LEN.RM==2

REMMPA::MOVEI	T2,LEN.RM	;GET MSG LENGTH
	PUSHJ	P,GETWDS##	;GET SOME CORE
	  POPJ	P,		;CAN'T
	MOVE	T2,[LEN.RM,,.IPCRM] ;LEN,,MSGTYPE
	MOVEM	T2,0(T1)	;STORE IT
	MOVE	T2,STRNAM##(F)	;GET STR NAME
	MOVEM	T2,1(T1)	;STORE IT
	HRLI	T1,LEN.RM	;COUNT THE MSG
	PJRST	ATTMP1		;SEND MSG AND RETURN

	;STRMPA - NOTIFY MDA OF A STRUCTURE MOUNT
	;	F / STR D.B.
	;	RETURN 	CPOPJ	ALWAYS

	STRMPA::PUSHJ	P,SAVE1##	;NEED A PRESERVED AC
		MOVEI	P1,1+1+1	;NEED ONE OVERHEAD WORD + 1 FOR STR NAME + 1 FOR UNIT
		HLRZ	T1,STRUNI##(F)	;PICK UP FIRST UNIT IN STR
	STRMP1:	HLRZ	T1,UNISTR##(T1)	;FIND NEXT UNIT
		SKIPE	T1		;END OF CHAIN?
		AOJA	P1,STRMP1	;NOT YET
		MOVE	T2,P1		;GET NUMBER OF WORDS NEEDED
		PUSHJ	P,GETWDS##	;GET SOME CORE
		  POPJ	P,		;CAN'T
		MOVEI	T3,.IPCST	;FUNCTION CODE
		HRLI	T3,(P1)		;LENGTH
		MOVEM	T3,0(T1)	;STORE IT
		MOVE	T3,STRNAM##(F)	;GET STR NAME
		MOVEM	T3,1(T1)	;STORE IT
		MOVSI	P1,(P1)		;SAVE [LENGTH,,MESSAGE ADDRESS]
		HRR	P1,T1
		HLRZ	T3,STRUNI##(F)	;GET FIRST UDB ADDR
	STRMP2:	MOVE	T2,UNINAM##(T3)	;GET UNIT NAME
		MOVEM	T2,2(T1)	;SAVE
		HLRZ	T3,UNISTR##(T3)	;GET LINK TO NEXT UDB
		SKIPE	T3		;END OF CHAIN?
		AOJA	T1,STRMP2	;NOT YET
		MOVE	T1,P1		;GET MESSAGE ADDRESS BACK
		PJRST	ATTMP1		;SEND IT AND RETURN
>;IFN FTMDA

IFN	FTMDA,<
;MTAMPA- NOTIFY MDA OF A NEW MAGTAP UNIT BEING ACCESSIBLE
;	F/ MAGTAPE DDB ADDRESS
;	RETURN CPOPJ ALWAYS
	LEN.MT==2
MTAMPA::MOVEI	T2,LEN.MT		;GET MSG LENGTH
	PUSHJ	P,GETWDS##		;GET CORE
	  POPJ	P,			;CANT
	MOVE	T2,[LEN.MT,,.IPCMT]	;LEN,,TYPE
	MOVEM	T2,0(T1)		;SAVE IT
	MOVE	T2,DEVNAM(F)		;GET DRIVE NAME
	MOVEM	T2,1(T1)		;SAVE IT
	HRLI	T1,LEN.MT		;SET LENGTH
	PJRST	ATTMP1			;SEND MSG AND RETURN
>;END IFN FTMDA
;SUBROUTINE TO SEND A PACKET TO A PID AND WAIT FOR A RESPONSE
; FROM THE RECEIVER
;CALLING SEQUENCE:
;	MOVE	T1,["SENT BY",,%SIDXXX]
; OR	MOVE	T1,RECEIVER'S PID
;	MOVE	T2,[LENGTH,,ADDRESS]
;	MOVE	T3,SENDER'S PID
;	MOVE	T4,SENDER'S PPN
;	PUSHJ	P,SENDSP	;IF SENDING TO A SPECIAL SYSTEM PROCESS
; OR	PUSHJ	P,SENDAP	;IF SENDING TO AN ARBITRARY PID
;RETURNS CPOPJ IF THE MESSAGE COULLD NOT BE DELIVERED
; RETURNS CPOPJ1 IF THE MESSAGE WAS SUCCESSFULLLY SENT AND A REPLY
; HAS BEEN RECEIVED. THE POINTER TO THE PACKET RECEIVED IS IN .PDEPA.
; IT IS THE CALLLER'S RESPONSIBILLITY TO RETURN THE PACKET TO MONITOR
; FREE CORE AFTER PROCESSING ITS CONTENTS

SENDAP::PUSHJ	P,SAVE4##
	MOVE	P4,T3
	MOVE	P3,T1
	MOVE	P2,T2
	PUSHJ	P,VALPID
	  POPJ	P,
	AND	P3,%IPCPM##
	ADDI	P3,PIDTAB##	;ADDRESS OF THE PID IN PIDTAB
	MOVE	J,.CPJOB##
	PUSHJ	P,SENDS1
	  POPJ	P,
	JRST	SENDP1
SENDSP::MOVE	J,.CPJOB##
	PUSHJ	P,SENDS0
	  POPJ	P,
SENDP1:	MOVEI	T1,EV.IPC
	PUSHJ	P,ESLEEP##
	HRRZ	T1,.PDEPA##(W)
	JUMPN	T1,SENDP1	;THIS DEPENDS ON A SYSTEM PROCESS NOT SENDING TO
				;[SYSTEM]IPCC
	PJRST	CPOPJ1##
;HERE ON RECEIPT OF A MESSAGE SENT TO THE EXEC PSUEDO-PROCESS
; [SYSTEM]GOPHER  IF THE INTENDED RECEIVING PROCESS IS BLOCKED WAITING
; FOR A RESPONSE, STORE THE ADDRESS OF THE PACKET IN THE RECEIVER'S
; PDB AND WAKEUP THE RECEIVER. OTHERWISE, RETURN THE PACKET AS
; UNDELIVERABLE.

IPCSPR::PUSHJ	P,SAVE1##
IFN FTMP,<
	PUSHJ	P,ONCPU0##	;ONLY ONE CPU AT A TIME
>
IPCSP1:	PUSHJ	P,GETPAK
	  POPJ	P,
	HRRZ	P1,T1
	HRRZ	T1,.IPCFD(P1)
	CAIE	T1,.WTORR	;WTOR RESPONSE?
	CAIN	T1,.OMACK	;OR AN ACK?
	JRST	[HRRZ	T1,.IPCFD+2(P1) ;YES, JOB NUMBER IS HERE
		MOVE	J,T1
		PUSHJ	P,FPDBT1##
		  JRST	IPCSP2
		HLRZ	T2,.IPCFD+2(P1)	;GET SEQUENCE NUMBER
		HRRZ	T3,.PDQSN##(T1)	; AND VALUE AT SEND
		CAME	T2,T3		;ONE WE'RE WAITING FOR
		JRST	IPCSP2		;NO, PITCH IT
		JRST	IPCSP3]		;NOW PROCESS IT
IFN FTFDAE,<			;VALIDATE FILDAE SEQUENCE NUMBERS
	MOVE	T2,.IPCFS(P1)	;FIND OUT WHO SENT THIS MESSAGE
	CAME	T2,%SIFDA##
	JRST	IPCSP4		;NOT THE FILE DAEMON? CONTINUE ONWARD
	HRRZ	J,.IPCFD(P1)	;GET JOB # FROM FIRST WORD OF MESSAGE
	PUSHJ	P,FPDBT1##	;FIND HIS PDB
	  JRST	IPCSP2		;HE MUST HAVE LOGGED OUT
	HLRZ	T2,.IPCFD(P1)	;GET THE SEQUENCE NUMBER FROM FILDAE
	JUMPE	T2,IPCSP4	;ZERO?  MUST BE OLD VERSION OF FILDAE
	HLRZ	T3,.PDQSN##(T1)	;GET THE NUMBER WE SAVED BEFORE
	CAME	T2,T3		;DO THEY MATCH?
	JRST	IPCSP2		;NO, BIT-BUCKET THIS MESSAGE
IPCSP4:
>	;END IFN FTFDAE
	MOVE	T1,.IPCFD(P1)
	HRRZ	J,T1
	PUSHJ	P,FPDBT1##	;VALIDATE JOB NUMBER AND GET OBJECT JOB'S PDB
	  JRST	IPCSP2
IPCSP3:	MOVE	T2,.IPCFS(P1)
	LDB	T3,JBYEWT##
	CAMN	T2,.PDEPA##(T1)
	CAIE	T3,EV.IPC
	JRST	IPCSP2
	HRLZM	P1,.PDEPA##(T1)
	SOS	.PDIPC##(W)
	PUSHJ	P,NXTPAK
	MOVE	T1,J
	PUSHJ	P,EWAKE##
	PUSHJ	P,DECSSW
	SOS	%CNIIP##
	JRST	IPCSP1
IPCSP2:	MOVEI	T1,IPCDU%
	DPB	T1,[POINT 6,.IPCFL(P1),29]
	PUSHJ	P,DECSSW
	MOVEI	T2,4
	PUSHJ	P,ANSWE1
	JRST	IPCSP1

SUBTTL	MONITOR INTERFACE ROUTINES

;SENDSI -- ROUTINE TO SEND A MESSAGE TO ANY SPECIAL SYSTEM PROCESS 
;
;CALL:
;	MOVEI	T1,%SIXXX
;	HRLI	T1,"SENT BY [SYSTEM]?", 0 IF IPCC
;	MOVE	T2,[XWD LEN,ADR]
;	MOVE	T3,SYSTEM PID, IGNORED IF IPCC
;	PUSHJ	P,SENDSI
;
;	ALWAYS RETURN HERE
;
;USES T1-T4
;
;NOTE: THE BLOCK SPECIFIED BY THE CALLER BELONGS "TO THE CALLER".
;	IT IS COPIED AND RETURNED TO THE CALLER INTACT.  SPECIFICALLY,
;	IF THE CALLER GOT THE BLOCK FROM THE SYSTEM FREE SPACE, "HE"
;	MUST RETURN IT.
;
SNDFFC::PUSH	P,T4
	MOVE	T2,T4
	PUSHJ	P,SENDSN
SNDFFR:	POP	P,T2
	HLRZ	T1,T2
	HRRZS	T2
	PJRST	GVFWDS##

SENDSN::PUSHJ	P,SENDSI
	  POPJ	P,
	POPJ	P,

SENDSI::MOVE	T4,JBTPPN##(J)	;SENDER'S PPN
;ENTER HERE WITH (T4) = SENDER'S PPN
SENDS0:	SKIPN	0(T1)
	POPJ	P,
	PUSHJ	P,SAVE4##	;SAVE P1-P4
	MOVE	P4,T3
	MOVE	P3,T1		;SAVE T1
	MOVE	P2,T2		; AND T2
	MOVE	P1,T4
	TLNE	P3,-1
	JRST	SENDS1
	HRLI	P3,10
	MOVE	P4,PIDTAB##

;FALL INTO SENDS1
SENDS1:	HLRZ	T2,P2		;GET LENGTH
	ADDI	T2,.IPCFD	;ADD HEADER
	PUSHJ	P,GETPKT	;GET FREE SPACE
	  POPJ	P,
	MOVEM	P1,.IPCFU(T1)
	HLRZM	P3,.IPCFL(T1)
	MOVEM	P4,.IPCFS(T1)
	HRL	P1,P2		;GET SOURCE,,0
	HRRI	P1,.IPCFD(T1)	;GET SOURCE,,DEST
	HLRZ	P4,P2		;GET LEN
	MOVSI	T2,IP.LPK	;GET "LARGE PACKET"
	CAMLE	P4,%CNIPL##	;IS IT LARGE?
	IORM	T2,.IPCFL(T1)	;YES, SET IT
	ADDI	P4,.IPCFD-1(T1)	;GET END OF MSG
	BLT	P1,(P4)		;MOVE THE MSG OVER
	MOVE	T2,(P3)		;GET RECEIVER'S PID
	MOVEM	T2,.IPCFR(T1)	;SAVE IT
	PUSHJ	P,FNDPDS##	;SENDER'S PDB
	MOVEM	T2,.PDEPA##(W)	;STORE THE PID OF WHO CAN ANSWER
	HLLZM	P2,.IPCFP(T1)	;STORE LENGTH
	PUSHJ	P,IPCSCA	;SET CAPABILITIES OF THE JOB PACKET IS BEING SENT FOR
	MOVE	P1,T1		;PUT ADDRESS IN P1
	AOS	%CNIIP##	;ONE MORE IN
	PUSHJ	P,SNDMSG	;SEND IT
	  JRST	SENDS2		;LOSE!
	JRST	CPOPJ1##

SENDS2:	HLRZ	T1,P2		;GET MSG LENGTH
	ADDI	T1,.IPCFD	;ADD HDR SIZE
	HRRZ	T2,P1		;GET ADR
	SOS	%CNIIP##	;1 LESS MESSAGE
	PJRST	GIVWDS##	;RETURN SPACE AND RETURN
;GETPKT  --  GET A PACKET OF FREE CORE.  CALL WITH T2 CONTAINING
;	NUMBER OF WORDS NEEDED.  RETURNS WITH ADDRESS OF PACKET
;	IN T1.  GETPKT "WAITS" IF NO FREE SPACE IS AVAILABLE.  ALWAYS
;	RETURNS CPOPJ.

GETPKT:	PUSH	P,T2
	PUSHJ	P,GETWDS##	;GET THE FREE SPACE
	  JRST	GETPK1		;LOSE, WAIT
	JRST	T2POJ1##	;WIN!!

GETPK1:	JUMPE	J,T2POPJ##	;LOSE IF AT INTERRUPT LEVEL
	MOVEI	T1,1		;ONE SECOND
	PUSHJ	P,SLEEPF##	;SLEEP
	POP	P,T2
	JRST	GETPKT		;AND TRY AGAIN


;CHKSID  --  CHECK IF PID IS ONE OF THE "FRIENDS OF THE MONITOR"
;CALLED WITH T1=THE PID
;DESTROYS T2
;RETURNS CPOPJ IF TRUE, CPOPJ1 OTHERWISE

CHKSID:	MOVEI	T2,SDTBLN##+<.GTSID##-.GTCSD##> ;NUMBER OF PIDS
CHKS.1:	CAMN	T1,.GTCSD##(T2)	;THIS IT
	POPJ	P,		;YES, RETURN
	SOJGE	T2,CHKS.1	;NO, TRY THE NEXT
	JRST	CPOPJ1##	;NOT A SYSTEM

IFN FTLOCK,<
;SUBROUTINE TO FIND AN INCORE IPCF PAGE IN SOME JOB'S IPCF QUEUE
;CALL WITH T2=PHYSICAL PAGE NUMBER, U=DISK ADDRESS TO REPLACE IT WITH
;RETURNS CPOPJ IF NOT FOUND, RETURNS CPOPJ1 IF FOUND, DISK ADDRESS STORED

LOKIPC::MOVE	J,HIGHJB##	;SCAN ALL JOBS
LOKIP1:	PUSHJ	P,FNDPDB##	;FIND THIS JOB'S PDB
	  JRST	LOKIP3		;NO PAGES IN ITS QUEUE IF NO PDB
	MOVEI	T1,.PDIPC##-.IPCFL(W) ; SET PREDESESSOR
LOKIP2:	HLRZ	T1,.IPCFL(T1)	;NEXT ENTRY IN THE QUEUE
	JUMPE	T1,LOKIP3	;GO IF THE LAST
	HRRZ	T3,.IPCFP(T1)	;ADDRESS OF THE PAGE IF IT IS ONE
	CAME	T2,T3		;SAME PHYSICAL PAGE?
	JRST	LOKIP2		;NO, LOOK ON
	HRRM	U,.IPCFP(T1)	;STORE DISK ADDRESS WHER IT WILL BE ON THE SWAPPING SPACE
	JRST	CPOPJ1##	;FOUND RETURN
LOKIP3:	SOJG	J,LOKIP1	;LOOK AT THE NEXT JOB'S QUEUE
	POPJ	P,		;PAGE NOT IN ANY QUEUE
>
IFN FTDHIA,<

;SUBROUTINE TO FIND SWAPPED-OUT IPCF PAGES ON A UNIT BEING REMOVED FROM THE ASL
;RETURNS CPOPJ1 IF A PAGE IS FOUND, T4 = DISK ADDRESS OF PAGE,
; T1 = THE ADDRESS IN THE IPCF PACKET CONTAINING THE DISK ADDRESS
; CPOPJ IF NO MORE IPCF PAGES ON THE UNIT BEING REMOVED

FNDIPC::MOVE	J,HIGHJB##	;SCAN ALL JOBS
FNDIP1:	PUSHJ	P,FNDPDB##	;FIND THIS JOB'S PDB
	  JRST	FNDIP4		;NO PAGES IN ITS QUEUE IF NO PDB
	PUSHJ	P,IPCLOK
	MOVN	T1,MIGRAT##	;GET CURRENT MIGRATE IPCF JOB
	CAILE	T1,(J)		;IF NEW JOB LESS THAN OLD JOB THEN
	MOVNM	J,MIGRAT##	;FLAG LOOKING AT THIS JOB
	MOVEI	T1,.PDIPC##-.IPCFL(W) ;SET PREDESESSOR
FNDIP2:	HLRZ	T1,.IPCFL(T1)	;NEXT ENTRY IN THE QUEUE
	JUMPE	T1,FNDIP3	;GO IF THE LAST
	HRRZ	T4,.IPCFP(T1)	;ADDRESS OF THE PAGE IF IT IS ONE
	TRZN	T4,400000	;A DISK ADDRESS?
	JRST	FNDIP2		;NO, LOOK ON
	PUSHJ	P,TSTUN##	;ON THE UNIT BEING REMOVED FROM THE ASL?
	  JRST	[HRRZ T4,.IPCFP(T1)
		 TRZ T4,400000	;RESTORE DISK ADDRESS
		 MOVEI T1,.IPCFP(T1) ;WHERE TO STORE NEW DSK ADDR WHEN MIGRATED
		 JRST CPOPJ1##]	;GIVE PAGE FOUND RETURN
	JRST	FNDIP2
FNDIP3:	PUSHJ	P,IPCULK
FNDIP4:	SOJG	J,FNDIP1	;LOOK AT THE NEXT JOB'S QUEUE
	POPJ	P,		;NO PAGES REMAINING ON UNIT BEING REMOVED
;ROUTINE TO LOCK THE JOB'S IPCF QUEUE
;REQUIRES J SET UP.
IPCLOK::
	PUSH	P,T1
	PUSH	P,T2
	MOVE	T1,.CPJOB	;SAY WHO WE OWN
	HRRZ	T1,JBTPDB##(T1)	;GET PDB ADDR
	MOVSI	T2,(J)		;JOB WHOSE QUEUE WE HAVE
	IORM	T2,.PDIPQ(T1)	;SET JOB NUMBER
IPLOK1:	MOVSI	T1,IP.LOK
IFN FTMP,<
	PUSHJ	P,UPMM##
>
	HRRZ	T2,JBTPDB##(J)
	JUMPE	T2,[MOVE	T1,.CPJOB
		    HRRZ	T1,JBTPDB(T1)
		    MOVSI	T2,IP.JOB
		    ANDCAM	T2,.PDIPQ(T1)
		    JRST	IPLOK3		]
	SYSPIF
	TDNE	T1,.PDIPQ(T2)
	  JRST	IPLOK4
	IORM	T1,.PDIPQ(T2)
	SYSPIN
IPLOK3:
IFN FTMP,<
	PUSHJ	P,DWNMM##
>
	JRST	TTPOPJ##
IPLOK4:	SYSPIN
IFN FTMP,<
	PUSHJ	P,DWNMM##
>
	MOVEI	T1,1
	PUSH	P,J
	MOVE	J,.CPJOB		;GET RIGHT JOB # BACK
	PUSHJ	P,SLEEPF##
	POP	P,J
	JRST	IPLOK1
IPCULK::
	PUSH	P,T1
	PUSH	P,T2
	HRRZ	T2,.CPJOB
	HRRZ	T2,JBTPDB##(T2)
	MOVSI	T1,IP.JOB
	AND	T1,.PDIPQ(T2)	;TRANSFER JOB# TO T1
	ANDCAM	T1,.PDIPQ(T2)	;CLEAR THAT WE OWN A JOB
	HLRZS	T1
	JUMPE	T1,TTPOPJ##	;HMMM....
IFN FTMP,<
	PUSHJ	P,UPMM##	;GUARD AGAINST PDB DISAPPEARING
>
	HRRZ	T2,JBTPDB##(T1)	;GET PDB ADDR
	MOVSI	T1,IP.LOK
	SKIPE	T2		;NO PDB
	ANDCAM	T1,.PDIPQ(T2)
IFN FTMP,<
	PUSHJ	P,DWNMM##
>
	JRST	TTPOPJ##

;ROUTINE CALLED ON IPCF SEND FROM VMSER (IPCRMV) TO GET INTERLOCK
;FOR RECEIVING JOB AND WAIT UNTIL SAFE WRT SWAP MIGRATION.
;CALL WITH P3=ADDRESS OF PACKET, T1=PAGE NUMBER
;ALL ACS PRESERVED
IPMCHK::
	PUSHJ	P,SAVT##	;BE SAFE NOW
	PUSH	P,J
	PUSH	P,W		;SAVE J,W
	MOVE	T1,.IPCFR(P3)	;RECEIVER
	PUSHJ	P,VALPID
	  JRST	IPCSOK		;SHOULDN'T HAPPEN
IPMCK1:	MOVE	T1,-3(P)	;RESTORE PAGE NUMBER
	PUSHJ	P,IPCLOK	;LOCK RECIEVER'S IPCF QUEUE
	PUSHJ	P,GTPME##	;GET PAGE MAP SLOT
	MOVE	T3,T2		;SAVE MAP CONTENTS
	PUSHJ	P,TSWST##	;IS IT IN THE WORKING SET?
	  CAIA			;NO, CHECK MORE
	JRST	IPCSOK		;IN WORKING SET, DON'T WORRY ABOUT MIGRATION
	MOVE	T4,T3		;GET MAP CONTENTS
	PUSHJ	P,TSTUN##	;IS IT ON THE BAD UNIT?
	  CAIA			;YES, MUST WAIT
	JRST	IPCSOK		;NO, CAN JUST RETURN WITH INTERLOCK
	MOVN	T1,MIGRAT##	;SEE IF ANYTHING BEING MIGRATED
	JUMPE	T1,IPCSOK	;"0" IS A SPECIAL CASE
	CAILE	T1,(J)		;HAS THE IPCF STUFF ALREADY PASSED US?
	  JRST	IPCSOK		;NO, RETURN
	PUSHJ	P,IPCULK	;UNLOCK QUEUE
	PUSHJ	P,IPMWAT##	;YES, MUST WAIT ON PAGE
	JRST	IPMCK1		;GET INTERLOCK AND TRY AGAIN
IPCSOK:	POP	P,W		;RESTORE OLD J,W
	POP	P,J
	POPJ	P,
>;END IFN FTDHIA

;SUBROUTINE TO SET IPCF QUOTA IF NOT SET.  USES T2.  W POINTS TO PDB
;TO SET QUOTA IN
;NOTE THAT THIS CAN BE DONE FASTER WITH MOVE/MOVEM OF .PDIPQ, THAT
;IS A RACE WITH THE CLEARING OF THE JOB IN .PDIPQ IN ROUTINE IPCULK
;RETURNS WITH .PDIPQ(W) IN T2

SETIPQ:	MOVE	T2,.PDIPQ##(W)		;GET QUOTA WORD
	TLNE	T2,IP.HBS		;BEEN SET?
	POPJ	P,			;YES, DO NOTHING
	HRLOI	T2,IP.HBS		;SAVE ALL LH BITS
	ANDCAM	T2,.PDIPQ##(W)		;CLEARING ANY QUOTA THERE
	HRR	T2,%CNIPQ##		;VALUE
	IORB	T2,.PDIPQ##(W)		;SET IT
	POPJ	P,
	LIT
IPCEND:	END
